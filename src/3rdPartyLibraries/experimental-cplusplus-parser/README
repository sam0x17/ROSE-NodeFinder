README for C++11/GNU SDF Grammar V1.2 (2013)

1) Overview

The C++11/GNU SDF grammar is provided as a set of sdf-files:
Main.sdf
CppLayout.sdf  
Literal.sdf  
FloatingLiteral.sdf
Identifier.sdf

The grammar follows the syntax description in the C++ ISO/IEC JTC1
SC22 WG21 N3690 working draft (2013-05-15).
It has been extended with GNU extensions. This allows that C/C++
files be pre-processed with the C-preprocessor cpp and parsed as
complete C/C++ translation units.

The parsers currently used for testing are:

sglri:
http://strategoxt.org/Stratego/StrategoDownload

SDF 2.6.3. in the linux binary distribution
sglr:
http://www.program-transformation.org/Sdf/SdfSoftware

The parser-generator "sglri" is used with the option
"--heuristic-filters on" whereas "sglr" does not have such an option
(but actually seems to have it on by default, because I get identical
time-measurements when using sglri with the above option and sglr for
several files).

2) Running the tests

The tests can be run with ./checkall or with ./checkparser.

i) The script 'checkall' assumes that the parsers 'sglr' and 'sglri' are
installed.

ii) The script 'checkparser' takes several arguments and can be used
with any SDF parser-generator.

Example: "checkparser sglr" reads, preprocesses and parses all tests
in the ROSE distribution which are available in the directory
'Cxx_tests' (1600+ test files). For sglri heuristic ambiguity filters 
are activated.

As 2nd argument a path to test files can be provided. As option the
preprocessing can also be turned off (option --without-cpp). In this
case only test files that do not require preprocessing are used for
testing.

Use "./checkparser -h" for a description of the options.

Information about failed tests is also written to the file
'error-log.txt'. Every invocation of checkparser overwrites this file.
Each line of the file contains the name of the failed test. The number
of lines of this file matches the number of failed tests.

Example output (of summary at end of a checkparser test):

-----------------------------------------------------------------------------
SUCCESS: 1607, FAIL: 2, IGNORED: 0, XFAIL: 3, TOTAL: 1609 (excluding SKIPPED)
SUCCESS RATE: 99.87%
-----------------------------------------------------------------------------

3) Scripts

A few scripts are provided that can make experimentation easier.
./myparse <file>  // uses sglr
./myparsei <file> // uses sglri with option "--heuristic-filters on"

Both scripts work similar to the checkparser script. A temporary file
is generated after preprocessing the original C++ file. The scripts
generate a file "check.cpp". This file is the preprocessed file that
was parsed and can be used for investigating parser errors.  As
include path the same directory as where <file> is found is used.
E.g. "./myparse mytests/test1.C" will use 'mytests' as include path.

The scripts are only a few lines of code and can be easily adapted to
use additional include paths, etc.

./checkclean
removes all files that can be generated by any of the scripts.

3) How the test works

All the *.C test files are harvested from the specified
test-directory. By default a test directory inside in the ROSE
distribution is selected. Optionally, the test directory can be
specified as 2nd argument to 'checkparser'.  The script reads each *.C
file in the test directory, preprocesses it with "cpp -P <file>.C
-I<testdir>", and checks that the generated output can be parsed with
'g++'. If successful, this file is passed to the SDF parser. This
filters all files that can be sucessfully parsed with g++ for parser
tests.  The output is passed to the SDF parser. The option "-P"
ensures that no #line directives are generated by the preprocessor.

The testscript shows for each test file a line:
<testnr> of <totalnr>: LOC=   <loc>: <testresult>: <file>

The <testnr> is number of the test file, starting with 1 up to the
number of total tests <totalnr> found in the specified test directory.
The <loc> is the number of lines of code after preprocessing the
original file. It is the LOC of the pre-processed translation unit.

The <testresult> can be "PASS", "FAIL", "SKIP".

The test succeeds ("PASS") if the used parser can successfully parse
the translation unit without error.

The test fails ("FAIL") if the used parser reports a parser error,
seg-faults, or cannot parse the file within 6 minutes. The testscript
uses a timeout.sh script to ensure that a process running longer than
6 minutes is killed. Since the SDF parsers use a heuristics to cope
with a high number of ambiguities, the results can vary.  The full
path and name of all files for which FAIL is reported are also written
to file 'error-log.txt'.


Filtered tests, those which do not compile with g++ because of being
negative tests, or missing header files, or for any other reason, are
marked as "SKIP".

Finally an overall statistics is provided. XFAIL are those files which
are excluded right at the beginning of the test because they are
supposed to fail, although GNU g++ does accept them. See 6) for an
example and further details.

The files listed as IGNORED are (currently) those that are larger than
150K. There are no tests (i.e. translation units after preprocessing)
in Cxx_tests that are larger than 150K LOC. These settings can be
adapted with the variables MIN_LOC and MAX_LOC. MIN_LOC is currently
set to 0, but can be used to only select files of a minimum size as
well.


4) Purpose, properties, and performance of generated parsers

The purpose of the grammar is *not* to build a full-fledged C++ front
end (we use the EDG and CLANG front ends in ROSE). It is used for
SDF-based experiments at the syntax level for language extensions.
Furthermore it can be used to investigate the C++ working draft
grammars to reveal any bugs that there may exist. For example, in
N3690 a few issues are fixed that existed in N3337 (e.g. ::x refering
to the global namespace was not properly represented in N3337).

The SDF grammar follows closely the latest C++ working draft and
therefore contains the ambiguities of the C++ grammar. An SDF parser
generates a forest of parse trees.

Performance is reasonable considering the high number of ambiguities
of the informative C++ grammar from the working draft. For a 100K LOC
translation unit it takes about 1 minute to parse.


5) GNU-extensions

The GNU-extensions have been added to the C++ grammar and are a
super-set of the GNU-extensions. The specification of the GNU
extensions can be further refined, to meet an exact set of GNU
extensions.  In its present form the grammar allows for some generic
forms of GNU extensions.

The extensions include all those extensions that can be found in GNU
header files. This is necessary as we parse pre-processed translation
units. 

6) Examples of excluded tests (which g++ parses):

i) Example of a syntax error, not detected by GNU:

In test case, test2013_233.C, the parser finds a syntax error in line 81897 which the GNU compiler does not detect:
./myparse Cxx_tests/test2013_233.C
parser:error: parse error, 'i' unexpected
--- input string [file: check.cpp line: 81897 col: 5]

FRAGMENT START:
    token_id id = token_id(t);
    stream << setw(16)
/*line 81897 */        << left << boost::wave::get_token_name(id) << " ("

    if (ExtTokenTypeMask & id) {
FRAGMENT END:

At the end of line 81897 there is indeed a semicolon missing. It may
be the case that GNU does not detect this because this code is inside
a template code which is not instantiated, but it definitely is a
syntax error (which GNU does not report when compiling this file).
Therefore this test is excluded from the tests (expected fail) because
it should actually fail.  The file parses without error, once the
semicolon is added.

ii) Other examples include #pragmas at locations which are allowed by
GNU, but are not supported in the grammar (e.g. inside
expressions). The C++ standard does not restrict the use of
#pragma. The use of "#pragma" in the grammar resembles uses of this
extension mechanism such as in OpenMP. All OpenMP programs are
supposed to be accepted by the parser.
This may be changed in future, allowing more positions #pragma.
Testfiles with an artificial placement of #pragmas (for test purposes) 
are: test2004_15.C test2012_259.C
Those two files are currently excluded (and listed as XFAIL).

