// tps (01/14/2010) : Switching from rose.h to sage3
// test cases are put into tests/roseTests/astInterfaceTests
// Last modified, by Liao, Jan 10, 2008
#include "sage3basic.h"

// We need this so that ROSE_USE_NEW_EDG_INTERFACE will be seen (set via configure).
#include <rose_config.h>

#if 0
// DQ (6/1/2012): Note that to use the std::remove_if() STL algorithm, we have to define it before including some of these header files.
// I worry that this code might be a problem to maintain since it is sensitive to these header file orderings.

// These header files are required.
#include <string>
#include <algorithm>
#include <iostream>
#include <cctype>

// bool isspace (char* c);

// DQ (6/7/2012): Moved this to before the use of SageInterface::hasTemplateSyntax().
#include "sageBuilder.h"

SgName
SageBuilder::generateTemplateNameFromTemplateNameWithTemplateArguments(SgName inputNameWithTemplateArguments)
   {
#if 1
   // DQ (7/27/2012): The new sematics are that template arguments are added to non template argument names 
   // instead of removed from the name with template arguments, this is because it is a problem to remove 
   // the template arguments from examples such as: "X<Y<Z>> operator>()" and others.
      printf ("ERROR: This function SageBuilder::generateTemplateNameFromTemplateNameWithTemplateArguments() should not be called. \n");
      ROSE_ASSERT(false);

      return "";
#else
  // DQ (6/1/2012): 
     std::string nameWithTemplateArguments = inputNameWithTemplateArguments;

  // ROSE_ASSERT(nameWithTemplateArguments.find('<') != std::string::npos);
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithTemplateArguments) == true);

     printf ("In generateTemplateNameFromTemplateNameWithTemplateArguments(): nameWithTemplateArguments = %s \n",nameWithTemplateArguments.c_str());
     size_t positionOfTemplateSyntax = nameWithTemplateArguments.find('<');
     printf ("In generateTemplateNameFromTemplateNameWithTemplateArguments(): positionOfTemplateSyntax = %zu \n",positionOfTemplateSyntax);

  // We might want to strip off trailing white space.
     std::string templateName = nameWithTemplateArguments.substr(0,positionOfTemplateSyntax);

     std::cout << "In generateTemplateNameFromTemplateNameWithTemplateArguments(): Before:" << templateName << ":End" << std::endl;
  // std::string::iterator newEnd = std::remove_if( templateName.begin(), templateName.end(), isspace );
  // std::string::iterator newEnd = std::remove_if( templateName.begin(), templateName.end(), isspace );
     std::string::iterator newEnd = std::remove_if( templateName.begin(), templateName.end(), isspace );
     std::cout << "In generateTemplateNameFromTemplateNameWithTemplateArguments(): After:" << std::string(templateName.begin(), newEnd) << ":End" << std::endl;

     templateName = std::string(templateName.begin(), newEnd);

  // ROSE_ASSERT(templateName.find('<') == std::string::npos);
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(templateName) == false);

  // DQ (6/1/2012): Make sure there is no whitespace (trailing). 
  // This will cause different mangled names to be generated.
     ROSE_ASSERT(templateName.find(' ') == std::string::npos);

     return templateName;
#endif
   }
#endif




#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
   #include "roseAdapter.h"
   #include "markLhsValues.h"
// #include "sageBuilder.h"
   #include <fstream>
   #include <boost/algorithm/string/trim.hpp>
   #include <boost/foreach.hpp>
   #include "Outliner.hh"
#else
// #include "sageBuilder.h"
   #include <fstream>
   #include <boost/algorithm/string/trim.hpp>
   #include <boost/foreach.hpp>

   #include "transformationSupport.h"
#endif

// DQ (4/3/2012): Addes so that I can enforce some rules as the AST is constructed.
#include "AstConsistencyTests.h"

#ifndef USE_CMAKE
// DQ (3/8/2014): Make this conditionally compiled based on when CMake is not used because the libraries are not configured yet.
// DQ (2/27/2014): We need this feature to support the function: fixupCopyOfAstFromSeperateFileInNewTargetAst()
#include "RoseAst.h"
#endif

// DQ (3/31/2012): Is this going to be an issue for C++11 use with ROSE?
#define foreach BOOST_FOREACH

// DQ (2/17/2013): This is a operation on the global AST that we don't need to do too often
// depending on the grainularity sought for the debugging information.  It is done on the
// whole AST once after construction (in edgRose.C), but is not needed more than that
// since it is a performance issue.
#define BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS 0
#define BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP 0

using namespace std;
using namespace SageInterface;
//---------------------------------------------
// scope stack interfaces
//   hide actual implementation of the stack
//---------------------------------------------

// DQ (1/18/2008): Added declaration in source file with Liao.
// std::list<SgScopeStatement*> SageBuilder::ScopeStack;
std::list<SgScopeStatement*> SageBuilder::ScopeStack(0);


// DQ (11/30/2010): Added support for building Fortran case insensitive symbol table handling.
//! Support for construction of case sensitive/insensitive symbol table handling in scopes.
bool SageBuilder::symbol_table_case_insensitive_semantics = false;


//! C++ SageBuilder namespace specific state for storage of the source code position state 
// (used to control how the source code positon is defined for IR nodes built within the SageBuilder interface).
// Set the default to be to mark everything as a transformation.
// SageBuilder::SourcePositionClassification SageBuilder::SourcePositionClassificationMode = SageBuilder::e_sourcePositionError;
SageBuilder::SourcePositionClassification SageBuilder::SourcePositionClassificationMode = SageBuilder::e_sourcePositionTransformation;


//! Get the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).
SageBuilder::SourcePositionClassification
SageBuilder::getSourcePositionClassificationMode()
   {
#if 0
     printf ("In getSourcePositionClassificationMode(): returning mode = %s \n",display(SourcePositionClassificationMode).c_str());
#endif

     return SourcePositionClassificationMode;
   }

//! Set the current source position classification (defines how IR nodes built by the SageBuilder interface will be classified).
void
SageBuilder::setSourcePositionClassificationMode(SageBuilder::SourcePositionClassification X)
   {
     SourcePositionClassificationMode = X;
   }

string
SageBuilder::display(SourcePositionClassification & scp)
   {
  // DQ (11/19/2012): This function is build to support debugging the value of the statically defined mode.

     string s;
     switch(scp)
        {
          case e_sourcePositionError:                s = "e_sourcePositionError";                break; 
          case e_sourcePositionDefault:              s = "e_sourcePositionDefault";              break;
          case e_sourcePositionTransformation:       s = "e_sourcePositionTransformation";       break;
          case e_sourcePositionCompilerGenerated:    s = "e_sourcePositionCompilerGenerated";    break;
          case e_sourcePositionNullPointers:         s = "e_sourcePositionNullPointers";         break;
          case e_sourcePositionFrontendConstruction: s = "e_sourcePositionFrontendConstruction"; break;
          case e_sourcePosition_last:                s = "e_sourcePosition_last";                break;

          default:
             {
               printf ("Error: default reached in SageBuilder::display(SourcePositionClassification & scp): scp = %d \n",scp);
               ROSE_ASSERT(false);
             }
           
        }

     return s;
   }


// DQ (5/21/2013): Added function to support hidding the implementation in the SgScopeStatement API.
// template <class T> SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function (const SgName & name, const SgType* func_type)
template <class T>
SgFunctionSymbol*
SgScopeStatement::find_symbol_by_type_of_function (const SgName & name, const SgType* func_type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // DQ (3/13/2012): This is to address the fact that there are 6 different types of functions in ROSE:
  //    1) SgFunctionDeclaration
  //    2) SgMemberFunctionDeclaration
  //    3) SgTemplateFunctionDeclaration
  //    4) SgTemplateMemberFunctionDeclaration
  //    5) SgTemplateFunctionInstntiationDeclaration
  //    6) SgTemplateMemberFunctionInstntiationDeclaration
  // And 4 different types of function symbols:
  //    1) SgFunctionSymbol
  //    2) SgMemberFunctionSymbol
  //    3) SgTemplateFunctionSymbol
  //    4) SgTemplateMemberFunctionSymbol
  // Note that both:
  //    SgTemplateFunctionInstntiationDeclaration
  //    SgTemplateMemberFunctionInstntiationDeclaration
  // map to 
  //    SgFunctionSymbol
  //    SgMemberFunctionSymbol
  // respectively.

  // Check if there is a function symbol of any kind, then narrow the selection.
  // SgFunctionSymbol* func_symbol = lookup_function_symbol(name,func_type);
     SgFunctionSymbol* func_symbol = NULL;

  // if (func_symbol == NULL)
        {
       // Use the static variant as a selector.
          switch((VariantT)T::static_variant)
             {
               case V_SgFunctionDeclaration:
               case V_SgProcedureHeaderStatement:
               case V_SgTemplateInstantiationFunctionDecl:
                  {
#if 0
                    printf ("In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgFunctionDeclaration or SgTemplateInstantiationFunctionDecl function \n");
#endif
                 // DQ (8/11/2013): Verify that the template arguments are provided for the correct cases and not for the incorrect cases.
                    if ((VariantT)T::static_variant == V_SgTemplateInstantiationFunctionDecl)
                       {
                         ROSE_ASSERT(templateArgumentsList != NULL);
                       }
                      else
                       {
                         ROSE_ASSERT(templateArgumentsList == NULL);
                       }

                 // DQ (5/21/2013): Calling the SgScopeStatement API.
                 // func_symbol = find_nontemplate_function(name,func_type);
                 // func_symbol = lookup_nontemplate_function_symbol(name,func_type);
                    func_symbol = lookup_nontemplate_function_symbol(name,func_type,templateArgumentsList);

                 // DQ (5/22/2013): This function symbol should not be a SgTemplateFunctionSymbol (associated with a template function.  It should be an instantiated template.
                    ROSE_ASSERT(isSgTemplateFunctionSymbol(func_symbol) == NULL);
                    
                    break;
                  }

               case V_SgMemberFunctionDeclaration:
               case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
#if 0
                    printf ("In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgMemberFunctionDeclaration or SgTemplateInstantiationMemberFunctionDecl function \n");
#endif
                 // DQ (5/21/2013): there is no SgScopeStatement API that calls this function.
                 // printf ("WARNING: There is no SgScopeStatement API that calls this function: find_nontemplate_member_function(). \n");

                 // DQ (8/11/2013): Verify that the template arguments are provided for the correct cases and not for the incorrect cases.
                    if ((VariantT)T::static_variant == V_SgTemplateInstantiationMemberFunctionDecl)
                       {
                         ROSE_ASSERT(templateArgumentsList != NULL);
                       }
                      else
                       {
                         ROSE_ASSERT(templateArgumentsList == NULL);
                       }
#if 0
                 // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList 
                 // to the lookup_nontemplate_member_function_symbol() function.
                    ROSE_ASSERT(templateArgumentsList == NULL);
#endif
                 // func_symbol = find_nontemplate_member_function(name,func_type);
                 // ROSE_ASSERT(isSgNamespaceDefinitionStatement(this) == NULL);
                 // func_symbol = get_symbol_table()->find_nontemplate_member_function(name,func_type);
                 // func_symbol = lookup_nontemplate_member_function_symbol(name,func_type);
                    func_symbol = lookup_nontemplate_member_function_symbol(name,func_type,templateArgumentsList);
                    break;
                  }

               case V_SgTemplateFunctionDeclaration:
                  {
#if 0
                    printf ("In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgTemplateFunctionDeclaration function \n");
#endif
                 // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList 
                 // to the lookup_template_function_symbol() function.
                    ROSE_ASSERT(templateArgumentsList == NULL);

                 // DQ (8/11/2013): I think this sould always be non-null.
                    ROSE_ASSERT(templateParameterList != NULL);

                 // DQ (8/7/2013): Adding support to permit template function overloading on template parameters.
                 // Note that the template arguments are being handed in as templateSpecializationArgumentList since this is the matching list.
                 // However, we might expect template parameter.

                 // DQ (8/7/2013): Adding support for template function overloading using template parameters (info passed as template arguments for specialization).
                 // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
                 // In this case these are unavailable from this point.
                 // DQ (5/21/2013): Calling the SgScopeStatement API.
                 // func_symbol = find_template_function(name,func_type);
                 // func_symbol = lookup_template_function_symbol(name,func_type);
                 // func_symbol = lookup_template_function_symbol(name,func_type,NULL,NULL);
                 // func_symbol = lookup_template_function_symbol(name,func_type,NULL,templateArgumentsList);
                    func_symbol = lookup_template_function_symbol(name,func_type,templateParameterList);

                    break;
                  }

               case V_SgTemplateMemberFunctionDeclaration:
                  {
#if 0
                    printf ("In SgScopeStatement::find_symbol_by_type_of_function(): This is a SgTemplateMemberFunctionDeclaration function \n");
#endif
                 // DQ (8/11/2013): I think this should fail in cases were we should be handing the templateArgumentsList 
                 // to the lookup_template_member_function_symbol() function.
                    ROSE_ASSERT(templateArgumentsList == NULL);

                 // DQ (8/11/2013): I think this sould always be non-null.
                    ROSE_ASSERT(templateParameterList != NULL);

                 // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
                 // In this case these are unavailable from this point.
                 // DQ (5/21/2013): Calling the SgScopeStatement API.
                 // func_symbol = find_template_member_function(name,func_type);
                 // func_symbol = lookup_template_member_function_symbol(name,func_type);
                    func_symbol = lookup_template_member_function_symbol(name,func_type,templateParameterList);
                    break;
                  }

               default:
                  {
                    printf ("In SgScopeStatement::find_symbol_by_type_of_function(): default reached --- variantT(T::static_variant) = %d \n",T::static_variant);
                    ROSE_ASSERT(false);
                  }
             }
        }

#if 0
     if (func_symbol != NULL)
          printf ("In SgScopeStatement::find_symbol_by_type_of_function(): func_symbol = %p = %s \n",func_symbol,func_symbol->class_name().c_str());
       else
          printf ("In SgScopeStatement::find_symbol_by_type_of_function(): func_symbol = %p \n",func_symbol);
#endif

  // return isSgFunctionSymbol(func_symbol);
     return func_symbol;
   }


// explicit instantiation of find_symbol_by_type_of_function
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgTemplateFunctionDeclaration>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgTemplateInstantiationMemberFunctionDecl>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgTemplateInstantiationFunctionDecl>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgMemberFunctionDeclaration>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgTemplateMemberFunctionDeclaration>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);
template SgFunctionSymbol* SgScopeStatement::find_symbol_by_type_of_function<SgFunctionDeclaration>(SgName const&, SgType const*, SgTemplateParameterPtrList*, SgTemplateArgumentPtrList*);

void 
SageBuilder::pushScopeStack (SgScopeStatement* stmt)
   {
     ROSE_ASSERT(stmt != NULL);

#if 0
  // DQ (9/28/2009): This is part of testing for GNU 4.0.x (other versions of g++ work fine).
     ROSE_ASSERT(stmt != NULL);
     if (stmt != NULL)
        {
       // Calling any member function is a way to test the pointer.
          stmt->class_name();
        }
#endif

     ScopeStack.push_back(stmt);

#if 0
  // Debugging code to output the scope stack.
     printf ("SageBuilder::pushScopeStack(): Scope stack: \n");
     int counter = 0;
     for (std::list<SgScopeStatement*>::iterator i = ScopeStack.begin(); i != ScopeStack.end(); i++)
        {
          printf ("   --- i = %d: %p = %s \n",counter,*i,(*i)->class_name().c_str());
          counter++;
        }
#endif
   }

void SageBuilder::pushScopeStack (SgNode* node)
   {
     SgScopeStatement* stmt = isSgScopeStatement(node);

  // DQ (9/26/2012): Added assertion.
     ROSE_ASSERT(stmt != NULL);

#if 0
     printf ("Inside of SageBuilder::pushScopeStack(scope = %p = %s) \n",stmt,stmt->class_name().c_str());
#endif

     pushScopeStack(stmt);
   }


void SageBuilder::popScopeStack()
   {
  // we want to warning users  double freeing happens
  // if (!ScopeStack.empty())

  // DQ (7/30/2013): Added assertion.
     ROSE_ASSERT(ScopeStack.empty() == false);

#if 0
     printf ("Inside of SageBuilder::popScopeStack(): ScopeStack.back() = %p = %s \n",ScopeStack.back(),ScopeStack.back()->class_name().c_str());
#endif

     ScopeStack.pop_back();

#if 0
  // Debugging code to output the scope stack.
     printf ("SageBuilder::popScopeStack(): Scope stack: \n");
     int counter = 0;
     for (std::list<SgScopeStatement*>::iterator i = ScopeStack.begin(); i != ScopeStack.end(); i++)
        {
          printf ("   --- i = %d: %p = %s \n",counter,*i,(*i)->class_name().c_str());
          counter++;
        }
#endif
   }

SgScopeStatement* SageBuilder::topScopeStack()
   {
  // DQ (9/28/2009): Test if this is an empty stack, and if so return NULL (ScopeStack.back() should be undefined for this case).
     if (ScopeStack.empty() == true)
         return NULL;

  // DQ (9/28/2009): This is part of testing for GNU 4.0.x (other versions of g++ work fine).
     SgScopeStatement* tempScope = ScopeStack.back();
     if (tempScope != NULL)
        {
          tempScope->class_name();
        }

  // return ScopeStack.back();
     return tempScope;
   }


SgScopeStatement*
SageBuilder::getGlobalScopeFromScopeStack()
   {
  // This function adds new support within the internal scope stack mechanism.
  // DQ (3/11/2012): Test if this is an empty stack, and if so return NULL (ScopeStack.back() should be undefined for this case).
     if (ScopeStack.empty() == true)
          return NULL;

  // The SgGlobal scope should be the first (front) element in the list (the current scope at the end (back) of the list).
     SgScopeStatement* tempScope = ScopeStack.front();
     ROSE_ASSERT(isSgGlobal(tempScope) != NULL);

     return tempScope;
   }

bool SageBuilder::emptyScopeStack()
   {
     return ScopeStack.empty();
   }

void SageBuilder::clearScopeStack()
   {
     ScopeStack.clear();
   }

bool SageBuilder::inSwitchScope()
   {
  // DQ (11/26/2012): This is used to turn off some pragma processing which is a problem in switch statements.
     bool returnVar = false;
     std::list<SgScopeStatement*>::iterator i;
     for (i = ScopeStack.begin(); i != ScopeStack.end(); i++)
        {
          if (isSgSwitchStatement(*i) != NULL)
               returnVar = true;
        }

     return returnVar;
   }


// *******************************************************************************
// *******************************  Build Functions  *****************************
// *******************************************************************************
SgName
SageBuilder::appendTemplateArgumentsToName( const SgName & name, const SgTemplateArgumentPtrList & templateArgumentsList)
   {
  // DQ (7/23/2012): This function is somewhat redundant with the SgDeclarationStatement::resetTemplateNameSupport() in that
  // they both have to generate identical names.  this was a problem and thus this code is seneitive to " ," instead of ","
  // below.

  // DQ (7/23/2012): This is one of three locations where the template arguments are assembled and where 
  // the name generated identically (in each case) is critical.  Not clear how to best refactor this code.
  // The other two are:
  //      Unparse_ExprStmt::unparseTemplateArgumentList()
  // and in:
  //      void SgDeclarationStatement::resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name )
  // It is less clear how to refactor this code.

#if 0
     printf ("In SageBuilder::appendTemplateArgumentsToName(): CRITICAL FUNCTION TO BE REFACTORED (name = %s) \n",name.str());
#endif

     SgUnparse_Info *info = new SgUnparse_Info();
     ROSE_ASSERT(info != NULL);

     info->set_language(SgFile::e_Cxx_output_language);

     bool emptyArgumentList = templateArgumentsList.empty();

  // DQ (9/24/2012): Don't add "< >" if there are no template arguments (see test2012_221.C).
  // SgName returnName = name + " < ";
     SgName returnName = name;
     if (emptyArgumentList == false)
          returnName += " < ";

     SgTemplateArgumentPtrList::const_iterator i = templateArgumentsList.begin();
     while (i != templateArgumentsList.end())
        {
#if 0
          printf ("In SageBuilder::appendTemplateArgumentsToName(): (top of loop) templateArgumentsList element *i = %p = %s returnName = %s \n",*i,(*i)->class_name().c_str(),returnName.str());
#endif
#if 0
          string s = string("/* templateArgument is explicitlySpecified = ") + (((*i)->get_explicitlySpecified() == true) ? "true" : "false") + " */";
#endif

       // DQ (9/15/2012): We need to communicate that the language so that SgBoolVal will not be unparsed to "1" instead of "true" (see test2012_215.C).
       // Calling the unparseToString (SgUnparse_Info *info) function instead of the version not taking an argument.
       // unparseTemplateArgument(*i,info);
       // returnName += (*i)->unparseToString();
          returnName += (*i)->unparseToString(info);

#if 0
          printf ("In SageBuilder::appendTemplateArgumentsToName(): (after appending template name) *i = %p returnName = %s \n",*i,returnName.str());
#endif
          i++;

       // If there are more arguments then we need a "," to seperate them.
          if (i != templateArgumentsList.end())
             {
            // Since we have a few places were these names are generated the code is sensative to names being 
            // generated exactly the same.  So the space on both sides of the "," is critical. This will be fixed
            // and all locations where this is done are marked with "CRITICAL FUNCTION TO BE REFACTORED".
            // returnName += ",";
               returnName += " , ";
             }

#if 0
          printf ("In SageBuilder::appendTemplateArgumentsToName(): (bottom of loop) returnName = %s \n",returnName.str());
#endif
        }

  // DQ (9/24/2012): Don't add "< >" if there are no templte arguments.
  // returnName += " > ";
     if (emptyArgumentList == false)
          returnName += " > ";

#if 0
     printf ("Leaving SageBuilder::appendTemplateArgumentsToName(): returnName = %s \n",returnName.str());
#endif

     delete info;
     info = NULL;

     return returnName;
   }


SgTemplateArgumentPtrList*
SageBuilder::getTemplateArgumentList( SgDeclarationStatement* decl )
   {
  // DQ (9/13/2012): This function returns the SgTemplateArgumentPtrList. Both template declarations and template instanatiations have them.
  // In a template instantiation it is the templateArguments field and from template declarations it is the templateSpecializationArguments field.

     ROSE_ASSERT(decl != NULL);

     SgTemplateArgumentPtrList* templateArgumentsList = NULL;

     switch(decl->variantT())
        {
       // DQ (8/17/2013): These cases do not use templates. 
       // This function has to handle these cases because it is called in a general context
       // on many types of declarations as part of the name qualification support.
          case V_SgNamespaceDeclarationStatement:
          case V_SgEnumDeclaration:
          case V_SgVariableDeclaration:
          case V_SgTypedefDeclaration:
             {
               templateArgumentsList = NULL;
               break;
             }

       // PC (10/11/13):  Added case of SgJavaPackageDeclaration
       // DQ (8/11/2013): Added cases for SgFunctionDeclaration and SgMemberFunctionDeclaration
       // I forget why we needed this case...
          case V_SgJavaPackageDeclaration:
          case V_SgFunctionDeclaration:
          case V_SgMemberFunctionDeclaration:
          case V_SgClassDeclaration:
             {
               templateArgumentsList = NULL;
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               templateArgumentsList = &(isSgTemplateInstantiationDecl(decl)->get_templateArguments());
               break;
             }

          case V_SgTemplateClassDeclaration:
             {
               templateArgumentsList = &(isSgTemplateClassDeclaration(decl)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateInstantiationFunctionDecl:
             {
               templateArgumentsList = &(isSgTemplateInstantiationFunctionDecl(decl)->get_templateArguments());
               break;
             }

          case V_SgTemplateFunctionDeclaration:
             {
               templateArgumentsList = &(isSgTemplateFunctionDeclaration(decl)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               templateArgumentsList = &(isSgTemplateInstantiationMemberFunctionDecl(decl)->get_templateArguments());
               break;
             }

          case V_SgTemplateMemberFunctionDeclaration:
             {
               templateArgumentsList = &(isSgTemplateMemberFunctionDeclaration(decl)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateVariableDeclaration:
             {
               templateArgumentsList = &(isSgTemplateVariableDeclaration(decl)->get_templateSpecializationArguments());
               break;
             }

          default:
             {
               printf ("setTemplateArgumentParents(): Default reched in switch: decl = %p = %s \n",decl,decl->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

  // DQ (9/16/2012): We would like to support this test, if possible.
  // ROSE_ASSERT(templateParameterList != NULL);

     return templateArgumentsList;
   }



SgTemplateParameterPtrList*
SageBuilder::getTemplateParameterList( SgDeclarationStatement* decl )
   {
  // DQ (9/16/2012): This function returns the SgTemplateParameterPtrList that is associated with template declarations.
  // For all other cases it returns NULL (or is an error).

     ROSE_ASSERT(decl != NULL);

     SgTemplateParameterPtrList* templateParameterList = NULL;

     switch(decl->variantT())
        {
       // DQ (8/17/2013): These cases do not use templates.
       // This function has to handle these cases because it is called in a general context
       // on many types of declarations as part of the name qualification support.
          case V_SgNamespaceDeclarationStatement:
          case V_SgEnumDeclaration:
          case V_SgVariableDeclaration:
          case V_SgTypedefDeclaration:
             {
               templateParameterList = NULL;
               break;
             }

       // PC (10/11/13):  Added case of SgJavaPackageDeclaration
       // DQ (8/12/2013): This function has to be supported when called using any kind of declaration (at least SgFunctionDeclaration and SgClassDeclaration).
       // DQ (9/16/2012): I think it should be an error to call this function for a SgClassDeclaration.
          case V_SgJavaPackageDeclaration:
          case V_SgFunctionDeclaration:
          case V_SgMemberFunctionDeclaration:
          case V_SgClassDeclaration:
             {
               templateParameterList = NULL;
               break;
             }

       // DQ (8/12/2013): This function has to be supported when called using any kind of declaration (at least SgFunctionDeclaration and SgClassDeclaration).
       // DQ (9/16/2012): I think it should be an error to call this function for these types of declarations.
          case V_SgTemplateInstantiationDecl:
          case V_SgTemplateInstantiationFunctionDecl:
          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               templateParameterList = NULL;
               break;
             }

          case V_SgTemplateClassDeclaration:
             {
               templateParameterList = &(isSgTemplateClassDeclaration(decl)->get_templateParameters());
               break;
             }

          case V_SgTemplateFunctionDeclaration:
             {
               templateParameterList = &(isSgTemplateFunctionDeclaration(decl)->get_templateParameters());
               break;
             }

          case V_SgTemplateMemberFunctionDeclaration:
             {
               templateParameterList = &(isSgTemplateMemberFunctionDeclaration(decl)->get_templateParameters());
               break;
             }

          case V_SgTemplateVariableDeclaration:
             {
               templateParameterList = &(isSgTemplateVariableDeclaration(decl)->get_templateParameters());
               break;
             }

          default:
             {
               printf ("setTemplateArgumentParents(): Default reched in switch: decl = %p = %s \n",decl,decl->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

  // DQ (9/16/2012): We would like to support this test, if possible.
  // ROSE_ASSERT(templateParameterList != NULL);

     return templateParameterList;
   }



void
SageBuilder::setTemplateArgumentParents( SgDeclarationStatement* decl )
   {
  // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).

     ROSE_ASSERT(decl != NULL);

#if 0
     printf ("In setTemplateArgumentParents(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     SgTemplateArgumentPtrList* templateArgumentsList = getTemplateArgumentList(decl);

     if (templateArgumentsList != NULL)
        {
          SgDeclarationStatement* first_decl = decl->get_firstNondefiningDeclaration();
          ROSE_ASSERT(first_decl != NULL);

          SgTemplateArgumentPtrList::iterator i = templateArgumentsList->begin();
          while (i != templateArgumentsList->end())
             {
               SgNode* parent = (*i)->get_parent();
               if (parent== NULL)
                  {
                 // (*i)->set_parent(decl);
                    (*i)->set_parent(first_decl);
                  }
                 else
                  {
                    SgScopeStatement* scope = isSgScopeStatement(parent);
                    if (scope != NULL)
                       {
                      // Template Arguments should have had there parents set to a scope when they were build, we want
                      // to refine that now that the declaration which we want them to be specified in has been build.
#if 0
                         printf ("In setTemplateArgumentParents(): Reset the template argument parent from scope = %p = %s to decl = %p = %s \n",scope,scope->class_name().c_str(),decl,decl->class_name().c_str());
#endif
                      // (*i)->set_parent(decl);
                         (*i)->set_parent(first_decl);
                       }
                      else
                       {
                         SgDeclarationStatement* declaration = isSgDeclarationStatement(parent);
                         if (declaration != NULL)
                            {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                              printf ("In setTemplateArgumentParents(): Template argument already set to declaration = %p = %s \n",declaration,declaration->class_name().c_str());
#endif
                            }
                           else
                            {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                              printf ("Error: In setTemplateArgumentParents(): I think it is an error for the template argument parent to be set to %p = %s \n",parent,parent->class_name().c_str());
#endif
                            }
                       }
                  }

               i++;
             }
        }

     testTemplateArgumentParents(decl);
   }


void
SageBuilder::setTemplateParameterParents( SgDeclarationStatement* decl )
   {
  // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).

     ROSE_ASSERT(decl != NULL);

#if 0
     printf ("In setTemplateParameterParents(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     SgTemplateParameterPtrList* templateParameterList = getTemplateParameterList(decl);

     if (templateParameterList != NULL)
        {
          SgDeclarationStatement* first_decl = decl->get_firstNondefiningDeclaration();
          ROSE_ASSERT(first_decl != NULL);

          SgTemplateParameterPtrList::iterator i = templateParameterList->begin();
          while (i != templateParameterList->end())
             {
               SgNode* parent = (*i)->get_parent();
               if (parent== NULL)
                  {
                 // (*i)->set_parent(decl);
                    (*i)->set_parent(first_decl);
                  }
                 else
                  {
                    SgScopeStatement* scope = isSgScopeStatement(parent);
                    if (scope != NULL)
                       {
                      // Template Arguments should have had there parents set to a scope when they were build, we want
                      // to refine that now that the declaration which we want them to be specified in has been build.
#if 0
                         printf ("Reset the template parameter parent from scope = %p = %s to decl = %p = %s \n",scope,scope->class_name().c_str(),decl,decl->class_name().c_str());
#endif
                      // (*i)->set_parent(decl);
                         (*i)->set_parent(first_decl);
                       }
                      else
                       {
#if 0
                         SgDeclarationStatement* declaration = isSgDeclarationStatement(parent);
                         if (declaration != NULL)
                            {
                              printf ("Template argument already set to declaration = %p = %s \n",declaration,declaration->class_name().c_str());
                            }
                           else
                            {
                              printf ("Error: I think it is an error for the template argument parent to be set to %p = %s \n",parent,parent->class_name().c_str());
                            }
#endif
                       }
                  }

               i++;
             }
        }

     testTemplateParameterParents(decl);
   }


void
SageBuilder::testTemplateArgumentParents( SgDeclarationStatement* decl )
   {
  // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).

     ROSE_ASSERT(decl != NULL);

#if 0
     printf ("In testTemplateArgumentParents(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     SgTemplateArgumentPtrList* templateArgumentsList = getTemplateArgumentList(decl);
  // ROSE_ASSERT(templateArgumentsList != NULL);
     
     if (templateArgumentsList != NULL)
        {
          SgTemplateArgumentPtrList::iterator i = templateArgumentsList->begin();
          while (i != templateArgumentsList->end())
             {
               SgNode* parent = (*i)->get_parent();
               if (parent == NULL)
                  {
                    printf ("Error: In testTemplateArgumentParents(): decl = %p = %s has template argument = %p with null parent \n",decl,decl->class_name().c_str(),*i);
                  }
               ROSE_ASSERT(parent != NULL);

            // DQ (9/16/2012): Adding new test.
               ROSE_ASSERT(decl->get_firstNondefiningDeclaration() != NULL);
#if 0
            // DQ (2/16/2014): This happens because the templates arguments are shared across multiple template instantiations and there parent pointers can only match a single template instantiation.
               if (parent != decl->get_firstNondefiningDeclaration())
                  {
                    printf ("Error: In testTemplateArgumentParents(): decl = %p = %s has template argument = %p with parent = %p = %s \n",decl,decl->class_name().c_str(),*i,parent,parent->class_name().c_str());
                    printf ("  --- decl                                    = %p = %s \n",decl,decl->class_name().c_str());
                    printf ("  --- decl->get_firstNondefiningDeclaration() = %p = %s \n",decl->get_firstNondefiningDeclaration(),decl->get_firstNondefiningDeclaration()->class_name().c_str());
                  }
#endif
            // DQ (1/30/2013): Commented this test out so that we could reuse SgTemplateArguments and
            // assure that the mapping from EDG a_template_arg_ptr's to SgTemplateArgument's was 1-to-1.
            // It is not clear if we can relax this constraint in the future.
            // ROSE_ASSERT(parent == decl->get_firstNondefiningDeclaration());

               i++;
             }
        }
   }


void
SageBuilder::testTemplateParameterParents( SgDeclarationStatement* decl )
   {
  // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).

     ROSE_ASSERT(decl != NULL);

#if 0
     printf ("In testTemplateParameterParents(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     SgTemplateParameterPtrList* templateParameterList = getTemplateParameterList(decl);

     if (templateParameterList != NULL)
        {
          SgTemplateParameterPtrList::iterator i = templateParameterList->begin();
          while (i != templateParameterList->end())
             {
               SgNode* parent = (*i)->get_parent();
               if (parent == NULL)
                  {
                    printf ("Error: In testTemplateParameterParents(): decl = %p = %s has template argument = %p with null parent \n",decl,decl->class_name().c_str(),*i);
                  }
               ROSE_ASSERT(parent != NULL);

            // DQ (9/16/2012): Adding new test.
               ROSE_ASSERT(decl->get_firstNondefiningDeclaration() != NULL);
               if (parent != decl->get_firstNondefiningDeclaration())
                  {
                     printf ("Error: In testTemplateParameterParents(): decl = %p = %s has template argument = %p with parent = %p = %s \n",decl,decl->class_name().c_str(),*i,parent,parent->class_name().c_str());
                  }

            // DQ (8/22/2013): Since these are now shared, it makes less sense to expect these to have such simple parent relationships.
            // This commit of work on ROSE added caching to template parameters so that we could support pointer equality for tests
            // of template parameter equality in the symbol table handling (this was a technique previously used for template arguments).
            // This test fails in the mergeTest_04.C test , but only on the GNU 4.4.x compiler (passes on the GNU 4.2.4 compiler).
            // ROSE_ASSERT(parent == decl->get_firstNondefiningDeclaration());

               i++;
             }
        }
   }


void
SageBuilder::setTemplateArgumentsInDeclaration( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateArgumentsList_input )
   {
  // DQ (9/16/2012): Setup the template arguments for any type of template instantiation.

#if 0
     printf ("In setTemplateArgumentsInDeclaration(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     ROSE_ASSERT(templateArgumentsList_input != NULL);

     ROSE_ASSERT(decl->variantT() == V_SgTemplateInstantiationDecl || 
                 decl->variantT() == V_SgTemplateInstantiationFunctionDecl || 
                 decl->variantT() == V_SgTemplateInstantiationMemberFunctionDecl);

     SgTemplateArgumentPtrList* templateArgumentsList_from_declaration = getTemplateArgumentList(decl);

     if (templateArgumentsList_from_declaration != NULL)
        {
          *templateArgumentsList_from_declaration = *templateArgumentsList_input;

       // Set the parents.
          setTemplateArgumentParents(decl);
        }
       else
        {
#if 1
          printf ("In setTemplateArgumentsInDeclaration(): Setup of template arguments not supported for decl = %p = %s \n",decl,decl->class_name().c_str());
#endif
        }

     testTemplateArgumentParents(decl);
   }


void
SageBuilder::setTemplateSpecializationArgumentsInDeclaration( SgDeclarationStatement* decl, SgTemplateArgumentPtrList* templateSpecializationArgumentsList_input )
   {
  // DQ (9/16/2012): Setup the template arguments for any type of template declaration

#if 0
     printf ("In setTemplateSpecializationArgumentsInDeclaration(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     ROSE_ASSERT(templateSpecializationArgumentsList_input != NULL);

     ROSE_ASSERT(decl->variantT() == V_SgTemplateClassDeclaration          || decl->variantT() == V_SgTemplateFunctionDeclaration || 
                 decl->variantT() == V_SgTemplateMemberFunctionDeclaration || decl->variantT() == V_SgTemplateVariableDeclaration );

     SgTemplateArgumentPtrList* templateSpecializationArgumentsList_from_declaration = getTemplateArgumentList(decl);

     if (templateSpecializationArgumentsList_from_declaration != NULL)
        {
          *templateSpecializationArgumentsList_from_declaration = *templateSpecializationArgumentsList_input;

       // Set the parents.
          setTemplateArgumentParents(decl);
        }
       else
        {
#if 1
          printf ("In setTemplateSpecializationArgumentsInDeclaration(): Setup of template arguments not supported for decl = %p = %s \n",decl,decl->class_name().c_str());
#endif
        }

     testTemplateArgumentParents(decl);
   }


void
SageBuilder::setTemplateParametersInDeclaration( SgDeclarationStatement* decl, SgTemplateParameterPtrList* templateParameterList_input )
   {
  // DQ (9/16/2012): Setup the template parameters for any type of template declaration.

#if 0
     printf ("In setTemplateParametersInDeclaration(): decl = %p = %s \n",decl,decl->class_name().c_str());
#endif

     ROSE_ASSERT(templateParameterList_input != NULL);

     ROSE_ASSERT(decl->variantT() == V_SgTemplateClassDeclaration          || decl->variantT() == V_SgTemplateFunctionDeclaration || 
                 decl->variantT() == V_SgTemplateMemberFunctionDeclaration || decl->variantT() == V_SgTemplateVariableDeclaration );

     SgTemplateParameterPtrList* templateParameterList_from_declaration = getTemplateParameterList(decl);

     if (templateParameterList_from_declaration != NULL)
        {
          ROSE_ASSERT(templateParameterList_from_declaration->empty() == true);
          *templateParameterList_from_declaration = *templateParameterList_input;

       // Set the parents.
          setTemplateParameterParents(decl);
        }
       else
        {
#if 1
          printf ("In setTemplateParameterInDeclaration(): Setup of template parameters not supported for decl = %p = %s \n",decl,decl->class_name().c_str());
#endif
        }

     testTemplateParameterParents(decl);
   }



// Only used to build parameter arguments for function ??
// should be transparently generated for most variable declaration builder
// deferred symbol insertion, scope setting , etc
// do them when it is actually used with the  parameterList!!
SgInitializedName *
SageBuilder::buildInitializedName ( const SgName & name, SgType* type, SgInitializer* init /* = NULL */)
{
#if 0
  // If the scope was not specified, then get it from the scope stack.
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();
//     ROSE_ASSERT(scope != NULL);
#endif 
     //foo(int);  empty name is possible here!!
     //ROSE_ASSERT(name.is_null() == false);
     ROSE_ASSERT(type != NULL);

     SgInitializedName* initializedName = new SgInitializedName(name,type,init);
     ROSE_ASSERT(initializedName);
#if 0
    //TODO prototype parameter has no symbol associated!!
    //TODO  scope is also different: SgFunctionDefinition or scope of SgFunctionDeclaration
    SgVariableSymbol * symbol_1 = new SgVariableSymbol(initializedName);
    ROSE_ASSERT(symbol_1);
    scope->insert_symbol(name, symbol_1);
    initializedName->set_scope(scope);
#endif 
    setSourcePositionAtRootAndAllChildren(initializedName);
    return initializedName;
}

SgInitializedName *
SageBuilder::buildInitializedName ( const std::string & name, SgType* type)
{
  SgName var_name(name);  
  return buildInitializedName(var_name,type);
}

SgInitializedName *
SageBuilder::buildInitializedName ( const char* name, SgType* type)
{
  SgName var_name(name);  
  return buildInitializedName(var_name,type);
}

SgInitializedName *
SageBuilder::buildInitializedName_nfi ( const SgName & name, SgType* type, SgInitializer* init)
   {
     ROSE_ASSERT(type != NULL);

     SgInitializedName* initializedName = new SgInitializedName(name,type,init);
     ROSE_ASSERT(initializedName != NULL);

  // DQ (9/4/2013): Added test.
     ROSE_ASSERT(init == NULL || init->get_parent() == initializedName);

     setOneSourcePositionNull(initializedName);

     return initializedName;
   }

//-----------------------------------------------
// could have two declarations for a same variable
// extern int i;
//  int i;
SgVariableDeclaration* 
SageBuilder::buildVariableDeclaration (const SgName & name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)
 //(const SgName & name, SgType* type, SgInitializer * varInit= NULL, SgScopeStatement* scope = NULL)
{
  if (scope == NULL)
    scope = SageBuilder::topScopeStack();
//   ROSE_ASSERT(scope != NULL); // enable bottomup construction: scope can be unknown
   ROSE_ASSERT(name.is_null() == false);
   ROSE_ASSERT(type != NULL);

  SgVariableDeclaration * varDecl = new SgVariableDeclaration(name, type, varInit);
  ROSE_ASSERT(varDecl);

// DQ (8/21/2011): Note that the default is to set the declaration modifier's access modifier to be 
// default (which is the same as public).  So the effect it to set it to be public.  This is ignored
// by the unparser for most languguages in ROSE.

// DQ (8/21/2011): Debugging declarations should have default settings (should not be marked as public).
// ROSE_ASSERT(varDecl->get_declarationModifier().get_accessModifier().isPublic() == false);

  varDecl->set_firstNondefiningDeclaration(varDecl);

  if (scope!=NULL) 
  {
    // Liao 12/13/2010
    // Fortran subroutine/function parameters have corresponding variable declarations in the body
    // For this declaration, it should use the initialized names of the parameters instead of creating new ones
    // The symbol of the init name should be under SgFunctionDefinition, instead of the function body block
    bool isFortranParameter = false; 
    if (SageInterface::is_Fortran_language())
    {
      SgFunctionDefinition * f_def = getEnclosingProcedure (scope);
      if (f_def != NULL)
      {
     // DQ (5/21/2013): Removed direct reference to symbol table (namespace handling is only supported at the SgScopeStatement level).
     // SgSymbolTable * st = f_def->get_symbol_table();
     // ROSE_ASSERT (st != NULL);
     // SgVariableSymbol * v_symbol = st->find_variable(name); 
        SgVariableSymbol * v_symbol = f_def->lookup_variable_symbol(name); 
        if (v_symbol != NULL) // find a function parameter with the same name
        {
          // replace the default one with the one from parameter
          SgInitializedName *default_initName = varDecl->get_decl_item (name);
          ROSE_ASSERT (default_initName != NULL);
          SgInitializedName * new_initName = v_symbol->get_declaration();
          ROSE_ASSERT (new_initName != NULL);
          ROSE_ASSERT (default_initName != new_initName);

          SgInitializedNamePtrList&  n_list= varDecl->get_variables();
          std::replace (n_list.begin(), n_list.end(),default_initName, new_initName );
          ROSE_ASSERT (varDecl->get_decl_item (name)==new_initName); //ensure the new one can be found  

          // change the function argument's old parent to the variable declaration
          SgNode * old_parent = new_initName->get_parent();
          ROSE_ASSERT  (old_parent != NULL);
          ROSE_ASSERT  (isSgFunctionParameterList(old_parent) != NULL);
          new_initName->set_parent(varDecl); // adjust parent from SgFunctionParameterList to SgVariableDeclaration

       // DQ (1/25/2011): Deleting these causes problems if I use this function in the Fortran support...
       // delete (default_initName->get_declptr()); // delete the var definition
       // delete (default_initName->get_declptr()); // relink the var definition

          SgVariableDefinition * var_def = isSgVariableDefinition(default_initName->get_declptr()) ;
          ROSE_ASSERT (var_def != NULL);
          var_def->set_parent(new_initName);
          var_def->set_vardefn(new_initName);
          new_initName->set_declptr(var_def); // it was set to SgProcedureHeaderStatement as a function argument

          delete (default_initName); // must delete the old one to pass AST consistency test

       // DQ (12/13/2011): Is this executed...
          //printf ("Is this executed \n");
          //ROSE_ASSERT(false);

          isFortranParameter = true;
        }
      }
    }
    if (! isFortranParameter) // No need to add symbol to the function body if it is a Fortran parameter
                              // The symbol should already exist under function definition for the parameter
      fixVariableDeclaration(varDecl,scope);
  }

  SgInitializedName *initName = varDecl->get_decl_item (name);   
  ROSE_ASSERT(initName != NULL);
  ROSE_ASSERT((initName->get_declptr())!=NULL);

  //bug 119, SgVariableDefintion's File_info is needed for deep copy to work
  // AstQuery based setSourcePositionForTransformation() cannot access all child nodes
  // have to set SgVariableDefintion explicitly
  SgDeclarationStatement* variableDefinition_original = initName->get_declptr();
  setOneSourcePositionForTransformation(variableDefinition_original);
  ROSE_ASSERT((variableDefinition_original->get_startOfConstruct()) !=NULL);
  ROSE_ASSERT((variableDefinition_original->get_endOfConstruct())!=NULL);

  setSourcePositionAtRootAndAllChildren(varDecl);
  //ROSE_ASSERT (isSgVariableDefinition(initName->get_declptr())->get_startOfConstruct()!=NULL);
  return varDecl;
}

//-----------------------------------------------
// could have two declarations for a same variable
// extern int i;
//  int i;
SgVariableDeclaration* 
SageBuilder::buildVariableDeclaration_nfi (const SgName & name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)
 //(const SgName & name, SgType* type, SgInitializer * varInit= NULL, SgScopeStatement* scope = NULL)
   {
     if (scope == NULL) 
        {
          scope = SageBuilder::topScopeStack();
        }

     ROSE_ASSERT (scope != NULL);
     ROSE_ASSERT(type != NULL);

#if 0
     SgVariableDeclaration * varDecl = new SgVariableDeclaration(name, type, varInit);
#else
  // DQ (7/18/2012): Added debugging code (should fail for test2011_75.C).
     SgVariableSymbol* variableSymbol = scope->lookup_variable_symbol(name);
  // ROSE_ASSERT(variableSymbol == NULL);

  // If there was a previous use of the variable, then there will be an existing symbol with it's declaration pointing to the SgInitializedName object.
     SgVariableDeclaration * varDecl = NULL;
     if (variableSymbol == NULL)
        {
          varDecl = new SgVariableDeclaration(name, type, varInit);
        }
       else
        {
          SgInitializedName* initializedName = variableSymbol->get_declaration();
          ROSE_ASSERT(initializedName != NULL);
          SgVariableDeclaration* associatedVariableDeclaration = isSgVariableDeclaration(initializedName->get_parent());
          if (associatedVariableDeclaration != NULL)
             {
            // Build a seperate SgVariableDeclaration so that we can avoid sharing the SgInitializedName 
            // (and it's possible initializer which would be an error for the secondary declaration 
            // (the declaration in the class for the case of a static declaration))
               varDecl = new SgVariableDeclaration(name, type, varInit);
             }
            else
             {
            // If there is not an associated SgVariableDeclaration then reuse the existing SgInitializedName.
               varDecl = new SgVariableDeclaration(initializedName);
             }
        }
#endif

  // DQ (11/3/2012): The SgInitializedName inside the SgVariableDeclaration must have valid source position object (even if default initialized).
     SgInitializedName* variable = getFirstInitializedName(varDecl);
     ROSE_ASSERT(variable != NULL);
     setSourcePosition(variable);

     ROSE_ASSERT(varDecl != NULL);

     varDecl->set_firstNondefiningDeclaration(varDecl);

  // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).
     ROSE_ASSERT(varDecl->get_parent() == NULL);

     if (name != "")
        {
       // Anonymous bit fields should not have symbols
          fixVariableDeclaration(varDecl,scope);

       // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).
       // ROSE_ASSERT(varDecl->get_parent() == NULL);
        }
       else
        {
       // DQ (7/12/2012): This is not correct for C++ (to use the input scope), so don't set it here (unless we use the current scope instead of scope).
       // Yes, let's set it to the current top of the scope stack.  This might be a problem if the scope stack is not being used...
          varDecl->set_parent(topScopeStack());
          ROSE_ASSERT(varDecl->get_parent() != NULL);
        }

     SgInitializedName *initName = varDecl->get_decl_item (name);   
     ROSE_ASSERT(initName);
     ROSE_ASSERT(initName->get_declptr() != NULL);

  // DQ (5/17/2013): Added test.
     if (initName->get_scope() == NULL)
        {
       // Make this a warning for the few places where this fails.
#if 0
          printf ("WARNING: Note in buildVariableDeclaration_nfi(): initName->get_scope() == NULL \n");
#endif
        }
  // ROSE_ASSERT(initName->get_scope() != NULL);

  // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).
  // ROSE_ASSERT(varDecl->get_parent() == NULL);

#if 1
  // bug 119, SgVariableDefintion's File_info is needed for deep copy to work
  // AstQuery based setSourcePositionForTransformation() cannot access all child nodes
  // have to set SgVariableDefintion explicitly
     SgVariableDefinition* variableDefinition_original = isSgVariableDefinition(initName->get_declptr());
     ROSE_ASSERT(variableDefinition_original != NULL);
     setOneSourcePositionNull(variableDefinition_original);
#endif
     setOneSourcePositionNull(varDecl);

#if 0
  // DQ (1/2/2010): Set the defining declaration to itself.
     if (varDecl->get_definingDeclaration() == NULL)
          varDecl->set_definingDeclaration(varDecl);
#endif

  // DQ (7/12/2012): The parent should be set to the current scope (not the same as that specified 
  // in the scope (since that applies to the variable (SgInitializedName) not the SgVariableDeclaration).
  // DQ (7/9/2012): Added test (parent should not be set yet; set in parse_statement).
  // ROSE_ASSERT(varDecl->get_parent() == NULL);
  // Liao, 1/23/2013, quick fix for now, this condition is a mirror to the code setting parent in SageInterface::fixVariableDeclaration()
     if (topScopeStack() != NULL)
        {
          ROSE_ASSERT(varDecl->get_parent() != NULL);
        }

  // ROSE_ASSERT (varDecl->get_declarationModifier().get_accessModifier().isPublic() == false);
     return varDecl;
   }


// #ifdef TEMPLATE_DECLARATIONS_DERIVED_FROM_NON_TEMPLATE_DECLARATIONS
#ifdef ROSE_USE_NEW_EDG_INTERFACE
// DQ (12/6/2011): Adding support for template declarations into the AST.
// SgTemplateDeclaration*
// SgVariableDeclaration*
// SgTemplateVariableDeclaration* buildTemplateVariableDeclaration_nfi(const SgName & name, SgType *type, SgInitializer *varInit, SgScopeStatement* scope);
SgTemplateVariableDeclaration*
SageBuilder::buildTemplateVariableDeclaration_nfi (const SgName & name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)
   {
     ROSE_ASSERT (scope != NULL);
     ROSE_ASSERT(type != NULL);

  // At present we don't have a SgTemplateVariableDeclaration IR node, so use the base class SgTemplateDeclaration for now!
  // printf ("ROSE maybe needs a SgTemplateVariableDeclaration IR node \n");

  // SgTemplateDeclaration * varDecl = new SgTemplateDeclaration(name, type, varInit);
  // SgTemplateDeclaration * varDecl = new SgTemplateDeclaration(name);

  // DQ (12/21/2011): The new design for SgTemplateVariableDeclaration derives from the SgVariableDeclaration instead of SgTemplateDeclaration.
  // SgTemplateDeclaration * varDecl = new SgTemplateVariableDeclaration(name);
  // SgVariableDeclaration * varDecl = new SgTemplateVariableDeclaration();
  // SgTemplateVariableDeclaration * varDecl = new SgTemplateVariableDeclaration();
     SgTemplateVariableDeclaration * varDecl = new SgTemplateVariableDeclaration(name, type, varInit);
     ROSE_ASSERT(varDecl);

     varDecl->set_firstNondefiningDeclaration(varDecl);

  // DQ (11/3/2012): The SgInitializedName inside the SgVariableDeclaration must have valid source position object (even if default initialized).
     SgInitializedName* variable = getFirstInitializedName(varDecl);
     ROSE_ASSERT(variable != NULL);
     setSourcePosition(variable);

#if 1
     if (name != "")
        {
       // Anonymous bit fields should not have symbols
          fixVariableDeclaration(varDecl,scope);
        }

     SgInitializedName *initName = varDecl->get_decl_item (name);   
     ROSE_ASSERT(initName); 
     ROSE_ASSERT((initName->get_declptr())!=NULL);

#if 1
  // bug 119, SgVariableDefintion's File_info is needed for deep copy to work
  // AstQuery based setSourcePositionForTransformation() cannot access all child nodes
  // have to set SgVariableDefintion explicitly
     SgVariableDefinition* variableDefinition_original = isSgVariableDefinition(initName->get_declptr());
     ROSE_ASSERT(variableDefinition_original != NULL);
     setOneSourcePositionNull(variableDefinition_original);
#endif
#else
     printf ("In buildTemplateVariableDeclaration_nfi(): Support for template variable declarations is not yet implemented into AST. \n");
#endif

     setOneSourcePositionNull(varDecl);

#if 0
// DQ (1/2/2010): Set the defining declaration to itself.
     if (varDecl->get_definingDeclaration() == NULL)
          varDecl->set_definingDeclaration(varDecl);
#endif

  // ROSE_ASSERT (varDecl->get_declarationModifier().get_accessModifier().isPublic() == false);
     return varDecl;
   }
#endif

SgVariableDeclaration*
SageBuilder::buildVariableDeclaration(const std::string & name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)
{
  SgName name2(name);
  return buildVariableDeclaration(name2,type, varInit,scope);
}

SgVariableDeclaration*
SageBuilder::buildVariableDeclaration(const char* name, SgType* type, SgInitializer * varInit, SgScopeStatement* scope)
{
  SgName name2(name);
  return buildVariableDeclaration(name2,type, varInit,scope);
}

//!Build a typedef declaration, such as: typedef int myint; 
SgTypedefDeclaration* 
SageBuilder::buildTypedefDeclaration(const std::string& name, SgType* base_type, SgScopeStatement* scope /*= NULL*/, bool has_defining_base/*= false*/)
{
  SgTypedefDeclaration* type_decl = buildTypedefDeclaration_nfi(name, base_type, scope, has_defining_base);
  setOneSourcePositionForTransformation(type_decl);

// DQ (1/2/2010): Set the defining declaration to itself.
// type_decl->set_definingDeclaration(type_decl);

  return type_decl;
}

//!Build a typedef declaration, such as: typedef int myint; 
// The side effects include: creating SgTypedefType, SgTypedefSymbol, and add SgTypedefType to the base type
SgTypedefDeclaration* 
SageBuilder::buildTypedefDeclaration_nfi(const std::string& name, SgType* base_type,  SgScopeStatement* scope /*= NULL*/, bool has_defining_base/*=false*/)
   {
     ROSE_ASSERT (base_type != NULL);
#if 0
     printf ("In buildTypedefDeclaration_nfi(): base_type = %p = %s \n",base_type,base_type->class_name().c_str());
#endif

     if (scope == NULL )
        {
          scope = SageBuilder::topScopeStack();
        }

  // We don't yet support bottom up construction for this node yet    
     ROSE_ASSERT(scope!=NULL);

     SgDeclarationStatement* base_decl = NULL;

  // Handle the case where this is a pointer, reference, or typedef to another type.
  // if (isSgNamedType(base_type))
     SgNamedType* namedType = isSgNamedType(base_type->stripType());
     if (namedType != NULL)
        {
       // DQ (3/20/2012): Use this to set the value of base_decl (which was previously unset).
       // isSgNamedType(base_type)->get_declaration();
       // base_decl = isSgNamedType(base_type)->get_declaration();
          base_decl = namedType->get_declaration();

       // DQ (3/20/2012): All named types should have a valid declaration!
          ROSE_ASSERT(base_decl != NULL);
#if 0
          printf ("In buildTypedefDeclaration_nfi(): base_decl = %p = %s \n",base_decl,base_decl->class_name().c_str());
          if (base_decl->get_definingDeclaration() != NULL)
             {
               printf ("base_decl->get_definingDeclaration() = %p parent = %p \n",base_decl->get_definingDeclaration(),base_decl->get_definingDeclaration()->get_parent());
             }
          if (base_decl == base_decl->get_definingDeclaration())
             {
               printf ("base_decl matches the defining declaration = %p parent = %p \n",base_decl,base_decl->get_parent());
             }

          if (base_decl->get_firstNondefiningDeclaration() != NULL)
             {
               printf ("base_decl->get_firstNondefiningDeclaration() = %p parent = %p \n",base_decl->get_firstNondefiningDeclaration(),base_decl->get_firstNondefiningDeclaration()->get_parent());
             }
          if (base_decl == base_decl->get_firstNondefiningDeclaration())
             {
               printf ("base_decl matches the firstNondefining declaration = %p parent = %p \n",base_decl,base_decl->get_parent());
             }
#endif
        }

#if 0
     printf ("In buildTypedefDeclaration_nfi(): base_decl = %p \n",base_decl);
#endif

  // DQ (3/20/2012): I don't remember why we need to provide the symbol for the scope of the 
  // parent rather then the scope. But as I recall there was a special corner of C++ that 
  // required this sort of support.
     SgSymbol* parent_scope = NULL;
     if (scope != NULL)
        {
#if 0
          printf ("In buildTypedefDeclaration_nfi(): scope = %p = %s calling get_symbol_from_symbol_table() \n",scope,scope->class_name().c_str());
#endif
          ROSE_ASSERT(scope->get_parent() != NULL);
          SgDeclarationStatement* declaration = isSgDeclarationStatement(scope->get_parent());
#if 0
          printf ("declaration = %p \n",declaration);
#endif
          if (declaration != NULL)
             {
#if 0
               printf ("Found a valid declaration = %p = %s \n",declaration,declaration->class_name().c_str());
#endif
               ROSE_ASSERT(declaration->get_firstNondefiningDeclaration() != NULL);
            // parent_scope = declaration->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table();
               parent_scope = declaration->search_for_symbol_from_symbol_table();

               ROSE_ASSERT(parent_scope != NULL);
             }
        }

#if 0
     printf ("In buildTypedefDeclaration_nfi(): parent_scope = %p \n",parent_scope);
#endif

  // SgTypedefDeclaration (Sg_File_Info *startOfConstruct, SgName name="", SgType *base_type=NULL, SgTypedefType *type=NULL, SgDeclarationStatement *declaration=NULL, SgSymbol *parent_scope=NULL)
  // SgTypedefDeclaration (SgName name="", SgType *base_type=NULL, SgTypedefType *type=NULL, SgDeclarationStatement *declaration=NULL, SgSymbol *parent_scope=NULL)
  //
  // Create the first nondefining declaration (note that the typedef type is always a NULL input value).
  // SgTypedefDeclaration* type_decl = new SgTypedefDeclaration(SgName(name),base_type,NULL, NULL, NULL);
     SgTypedefDeclaration* type_decl = new SgTypedefDeclaration(SgName(name), base_type, NULL, base_decl, parent_scope);
     ROSE_ASSERT(type_decl != NULL);

#if 0
     printf ("In buildTypedefDeclaration_nfi(): After SgTypedefDeclaration constructor: type_decl->get_scope() = %p \n",type_decl->get_scope());
#endif

  // DQ (3/20/2012): Comment ouly, these are always set this way. first defining is a self reference, and defining is always NULL (required for AST consistancy)).
     type_decl->set_firstNondefiningDeclaration (type_decl);
     type_decl->set_definingDeclaration(NULL);

  // Set the source code position information.
     setOneSourcePositionNull(type_decl);

  // Liao 11/29/2012, for typedef struct Frame {int x;} st_frame; We have to set parent for the struct.
  // AstPostProcessing() has resetParentPointers(). But it is kind of too late.
  if (SgClassDeclaration* base_class = isSgClassDeclaration(base_decl))
  {
    SgClassDeclaration* def_class = isSgClassDeclaration(base_class->get_definingDeclaration());
    SgClassDeclaration* nondef_class = isSgClassDeclaration(base_class->get_firstNondefiningDeclaration());
    // Dan and Liao, 12/3/2012, handle test2003_08.C nested typedef
    if (has_defining_base)  
    {
      if (def_class != NULL)
        if (def_class->get_parent() == NULL)
          def_class->set_parent(type_decl);
    }
    else
    {
    if (nondef_class != NULL)
      if (nondef_class->get_parent() == NULL)
      {
        nondef_class->set_parent(type_decl);
      }
    }
  }

  // Symbol and SgTypedefType should be associated with the first nondefining declaration
  // Create SgTypedefType
  // This is already included in the constructor
  // SgTypedefType::createType (type_decl);
     if (scope != NULL)
        {
          SgTypedefSymbol* typedef_symbol = new SgTypedefSymbol(type_decl);
          ROSE_ASSERT(typedef_symbol);

#if 1
       // DQ (5/16/2013): This is the code we want now that we have implemented the namespace support behind the scope symbol bable interface.
          scope->insert_symbol(SgName(name),typedef_symbol);
          type_decl->set_scope(scope);
#else
       // DQ (5/9/2013): If this is a namespace scope then we need so handle that case there there can be many since it is reentrant.
          SgScopeStatement* associatedScope = NULL;
          SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);
          if (namespaceDefinition != NULL)
             {
               associatedScope = namespaceDefinition->get_global_definition();
               if (namespaceDefinition->get_global_definition() == NULL)
                  {
                    printf ("ERROR: namespaceDefinition->get_global_definition() == NULL: namespaceDefinition = %p \n",namespaceDefinition);
                  }
               ROSE_ASSERT(associatedScope != NULL);
             }
            else
             {
               associatedScope = scope;
             }
          ROSE_ASSERT(associatedScope != NULL);

          associatedScope->insert_symbol(SgName(name),typedef_symbol);
          type_decl->set_scope(associatedScope);
#endif

       // DQ (3/20/2012): Commented added only: The parent is always the scope in this case, I think.
          type_decl->set_parent(scope);
        }

#if 0
  // DQ (3/20/2012): This is always false...since base_decl is never reset from NULL (above).

  // TODO double check when to create defining declaration
  // I tried two cases so far and the simplest typedef int MYINT will not have defining typedef declaration
  // the complex typedef struct frame {} frame; has a defining typedef declaration
  // base declaration should be associated with defining typedef declaration
     if (base_decl != NULL) 
        {
          SgTypedefDeclaration* def_type_decl = new SgTypedefDeclaration(SgName(name),base_type,type_decl->get_type(), base_decl, NULL);
          def_type_decl->set_firstNondefiningDeclaration(type_decl);
          type_decl->set_definingDeclaration(def_type_decl);
          setOneSourcePositionNull(def_type_decl);
        }
#endif

#if 0
  // DQ (3/20/2012): Test the base_decl.
     if (base_decl != NULL)
        {
          printf ("In buildTypedefDeclaration_nfi(): base_decl->get_definingDeclaration()         = %p \n",base_decl->get_definingDeclaration());
          if (base_decl->get_definingDeclaration() != NULL)
             {
               printf ("In buildTypedefDeclaration_nfi(): base_decl->get_definingDeclaration()->get_parent()         = %p \n",base_decl->get_definingDeclaration()->get_parent());
             }
          printf ("In buildTypedefDeclaration_nfi(): base_decl->get_firstNondefiningDeclaration() = %p \n",base_decl->get_firstNondefiningDeclaration());
          if (base_decl->get_firstNondefiningDeclaration() != NULL)
             {
               printf ("In buildTypedefDeclaration_nfi(): base_decl->get_firstNondefiningDeclaration()->get_parent() = %p \n",base_decl->get_firstNondefiningDeclaration()->get_parent());
             }
        }
#endif

#if 0
  // DQ (1/2/2010): Set the defining declaration to itself. (BAD IDEA).
     if (type_decl->get_definingDeclaration() == NULL)
          type_decl->set_definingDeclaration(type_decl);
#endif

     return type_decl;
   }

//-----------------------------------------------
// Assertion `definingDeclaration != NULL || firstNondefiningDeclaration != NULL' 
SgFunctionParameterList * 
SageBuilder::buildFunctionParameterList(SgInitializedName* in1, SgInitializedName* in2, SgInitializedName* in3, SgInitializedName* in4, SgInitializedName* in5, SgInitializedName* in6, SgInitializedName* in7, SgInitializedName* in8, SgInitializedName* in9, SgInitializedName* in10)
{
  SgFunctionParameterList *parameterList = new SgFunctionParameterList();
  ROSE_ASSERT (parameterList);

  parameterList->set_definingDeclaration (NULL);
  parameterList->set_firstNondefiningDeclaration (parameterList);

  setOneSourcePositionForTransformation(parameterList);

  if (in1) appendArg(parameterList, in1);
  if (in2) appendArg(parameterList, in2);
  if (in3) appendArg(parameterList, in3);
  if (in4) appendArg(parameterList, in4);
  if (in5) appendArg(parameterList, in5);
  if (in6) appendArg(parameterList, in6);
  if (in7) appendArg(parameterList, in7);
  if (in8) appendArg(parameterList, in8);
  if (in9) appendArg(parameterList, in9);
  if (in10) appendArg(parameterList, in10);

  return parameterList;
}

SgFunctionParameterList * 
SageBuilder::buildFunctionParameterList_nfi() {
  SgFunctionParameterList *parameterList = new SgFunctionParameterList();
  ROSE_ASSERT (parameterList);
  parameterList->set_definingDeclaration (NULL);
  parameterList->set_firstNondefiningDeclaration (parameterList);

  setOneSourcePositionNull(parameterList);

  return parameterList;
}

//-----------------------------------------------
// no type vs. void type ?
SgFunctionParameterTypeList * 
SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList* paralist)
   {
  // DQ (8/19/2012): I am not a fan of this sort of codeing style either (NULL pointers as inputs should be an error).
     if (paralist == NULL)
        {
          printf ("WARNING: In buildFunctionParameterTypeList(): Accepting NULL input and returning NULL pointer. \n");

          return NULL;
        }

  // DQ (8/18/2012): This is a problem, any valid list (even zero length) should result in a valid return list of types (even zero length).
  // if (paralist->get_args().size()==0)
  //      return NULL;

     SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;
     ROSE_ASSERT(typePtrList != NULL);

#if 0
     printf ("In SageBuilder::buildFunctionParameterTypeList(SgFunctionParameterList*): SgFunctionParameterTypeList* typePtrList = %p \n",typePtrList);
#endif

     SgInitializedNamePtrList args = paralist->get_args();
     SgInitializedNamePtrList::const_iterator i;
     for(i = args.begin(); i != args.end(); i++)
          (typePtrList->get_arguments()).push_back( (*i)->get_type() );

     setSourcePositionAtRootAndAllChildren(typePtrList);

     return typePtrList;
   }


SgFunctionParameterTypeList *
SageBuilder::buildFunctionParameterTypeList (SgExprListExp * expList)
   {
     if (expList ==NULL) return NULL;
     SgExpressionPtrList expPtrList = expList->get_expressions();

     SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;
     ROSE_ASSERT(typePtrList);

#if 0
     printf ("In SageBuilder::buildFunctionParameterTypeList(SgExprListExp*): SgFunctionParameterTypeList* typePtrList = %p \n",typePtrList);
#endif

     SgExpressionPtrList::const_iterator i;
     for (i=expPtrList.begin();i!=expPtrList.end();i++)
        {
          typePtrList->get_arguments().push_back( (*i)->get_type() );
        }

     setSourcePositionAtRootAndAllChildren(typePtrList);

     return typePtrList;
   }

SgFunctionParameterTypeList * 
SageBuilder::buildFunctionParameterTypeList(SgType* type0, SgType* type1, SgType* type2, SgType* type3,
                                            SgType* type4, SgType* type5, SgType* type6, SgType* type7)
   {
     SgFunctionParameterTypeList* typePtrList = new SgFunctionParameterTypeList;
     ROSE_ASSERT(typePtrList);

#if 0
     printf ("In SageBuilder::buildFunctionParameterTypeList(SgType*,SgType*,...): SgFunctionParameterTypeList* typePtrList = %p \n",typePtrList);
#endif

     SgTypePtrList & types = typePtrList->get_arguments();

     if (type0 != NULL) types.push_back(type0);
     if (type1 != NULL) types.push_back(type1);
     if (type2 != NULL) types.push_back(type2);
     if (type3 != NULL) types.push_back(type3);
     if (type4 != NULL) types.push_back(type4);
     if (type5 != NULL) types.push_back(type5);
     if (type6 != NULL) types.push_back(type6);
     if (type7 != NULL) types.push_back(type7);

     return typePtrList;
   }

//-----------------------------------------------
// build function type, 
// 
// insert into symbol table when not duplicated
SgFunctionType * 
SageBuilder::buildFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList)
   {
     ROSE_ASSERT(return_type != NULL);

  // DQ (8/19/2012): Can we enforce this?
     ROSE_ASSERT(typeList != NULL);

#if 0
     printf ("Inside of SageBuilder::buildFunctionType(SgType,SgFunctionParameterTypeList) \n");
     printf ("Inside of SageBuilder::buildFunctionType() return_type = %s \n",return_type->get_mangled().str());
     printf ("Inside of SageBuilder::buildFunctionType() typeList->get_arguments().size() = %zu \n",typeList->get_arguments().size());
#endif
#if 0
  // DQ (1/21/2014): Activate this test to see how we are building SgFunctionType with return type as SgFunctionType (see test2014_53.c).
     printf ("Inside of SageBuilder::buildFunctionType() (activate test for return_type): return_type = %p = %s \n",return_type,return_type->class_name().c_str());
#endif
#if 0
  // DQ (1/21/2014): Activate this test to see how we are building SgFunctionType with return type as SgFunctionType (see test2014_53.c).
     if (isSgFunctionType(return_type) != NULL)
        { 
       // Liao 12/14/2012. This is not true for some functions (e.g. findFunctionUsingDlopen() on top of dlopen()) returning a function type
          printf ("ERROR: Inside of SageBuilder::buildFunctionType(): function type can't be return type of function type (at least for debugging) \n");
          ROSE_ASSERT(false);
        }
#endif

     SgFunctionTypeTable * fTable = SgNode::get_globalFunctionTypeTable();
     ROSE_ASSERT(fTable);

  // This function make clever use of a static member function which can't be built
  // for the case of a SgMemberFunctionType (or at least not without more work).
     SgName typeName = SgFunctionType::get_mangled(return_type, typeList);

#if 0
     printf("[SageBuilder::buildFunctionType] return_type = %p (%s), mangled name = %s\n", return_type, return_type->class_name().c_str(), typeName.getString().c_str());
#endif

     SgFunctionType* funcType = isSgFunctionType(fTable->lookup_function_type(typeName));

#if 0
     printf ("In SageBuilder::buildFunctionType(): typeName = %s funcType = %p \n",typeName.str(),funcType);
     if (funcType != NULL)
        {
          printf ("In SageBuilder::buildFunctionType(): funcType->get_mangled_type() = %s \n",funcType->get_mangled_type().str());
        }
#endif

     if (funcType == NULL) 
        {
       // Only build the new type if it can't be found in the global type table.
          funcType = new SgFunctionType(return_type, false);
          ROSE_ASSERT(funcType);

          if (typeList != NULL)
             {
            // DQ (12/5/2012): We want to avoid overwriting an existing SgFunctionParameterTypeList. Could be related to failing tests for AST File I/O.
               if (funcType->get_argument_list() != NULL)
                  {
                    delete funcType->get_argument_list();
                    funcType->set_argument_list(NULL);
                  }
               ROSE_ASSERT(funcType->get_argument_list() == NULL);

               funcType->set_argument_list(typeList);
               typeList->set_parent(funcType);
             }

#if 0
          printf ("Inserting function type = %s into function type table with type = %p \n",typeName.str(),funcType);
#endif

          fTable->insert_function_type(typeName,funcType);
        }
       else
        {
       // DQ (12/6/2012): Tracking down orphaned SgFunctionParameterTypeList objects.
#if 0
          printf ("In SageBuilder::buildFunctionType(): Note that the SgFunctionParameterTypeList* typeList = %p was not used (so should be deleted by which ever calling function allocated it) \n",typeList);
#endif
        }

#if 0
     printf ("Leaving buildFunctionType(): Returning function type = %p \n",funcType); 
#endif

     return funcType;
   }



SgMemberFunctionType*
SageBuilder::buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList, SgClassType *classType, unsigned int mfunc_specifier)
   {
  // DQ (8/19/2012): This is a refactored version of the buildMemberFunctionType() below so that we can 
  // isolate out the part that uses a SgClassType from the version that uses the SgClassDefinition.

#if 0
  // DQ (12/3/2011): We need to FIRST look into the global function type table to reuse types.
  // SgMemberFunctionType * funcType = new SgMemberFunctionType(return_type, false, classType, mfunc_specifier);
  // SgMemberFunctionType * funcType = SgMemberFunctionType::createType(return_type, false, classType, mfunc_specifier);
  // SgPartialFunctionType* partialFunctionType = SgPartialFunctionType::createType(return_type, false, classType, mfunc_specifier);
  // SgPartialFunctionType* partialFunctionType = new SgPartialFunctionType(return_type, false, classType, mfunc_specifier);
     bool has_ellipses = false;
     SgPartialFunctionType* partialFunctionType = new SgPartialFunctionType(return_type, has_ellipses, classType, mfunc_specifier);

     ROSE_ASSERT(partialFunctionType != NULL);

#error "DEAD CODE!"

  // printf ("In buildMemberFunctionType(): partialFunctionType = %p = %s \n",partialFunctionType,partialFunctionType->class_name().c_str());

  // DQ (3/8/2012): If this is non-zero then the SgPartialFunctionType should have somethin set internally.
     if (mfunc_specifier != 0)
        {
#if 0
          printf ("In buildMemberFunctionType(): partialFunctionType->isConstFunc()    = %s \n",partialFunctionType->isConstFunc()    ? "true" : "false");
          printf ("In buildMemberFunctionType(): partialFunctionType->isVolatileFunc() = %s \n",partialFunctionType->isVolatileFunc() ? "true" : "false");
          printf ("In buildMemberFunctionType(): partialFunctionType->isRestrictFunc() = %s \n",partialFunctionType->isRestrictFunc() ? "true" : "false");
#endif
       // ROSE_ASSERT(partialFunctionType->isConstFunc() == true || partialFunctionType->isVolatileFunc() == true);
          ROSE_ASSERT(partialFunctionType->isConstFunc() == true || partialFunctionType->isVolatileFunc() == true || partialFunctionType->isRestrictFunc() == true);
        }

#error "DEAD CODE!"

  // SgMemberFunctionType* funcType = SgMemberFunctionType::createType(partialFunctionType, NULL);
     SgMemberFunctionType* funcType = SgMemberFunctionType::createType(partialFunctionType, NULL);
     ROSE_ASSERT(funcType != NULL);

  // printf ("In buildMemberFunctionType(): funcType = %p = %s \n",funcType,funcType->class_name().c_str());

     if (typeList != NULL)
        {
       // DQ (12/5/2012): We want to avoid overwriting an existing SgFunctionParameterTypeList. Could be related to failing tests for AST File I/O.
          if (funcType->get_argument_list() != NULL)
             {
               delete funcType->get_argument_list();
               funcType->set_argument_list(NULL);
             }
          ROSE_ASSERT(funcType->get_argument_list() == NULL);

          funcType->set_argument_list(typeList);
          typeList->set_parent(funcType);
        }

     SgName typeName = funcType->get_mangled_type();

#error "DEAD CODE!"

  // Maintain the global type table 
     SgFunctionTypeTable* fTable = SgNode::get_globalFunctionTypeTable();
     ROSE_ASSERT(fTable != NULL);

  // fTable->get_function_type_table()->print("In buildMemberFunctionType(): globalFunctionTypeTable BEFORE");

     SgType* typeInTable = fTable->lookup_function_type(typeName);

  // DQ (12/5/2012): I want to test that we are not building the SgMemberFunctionType correctly since we are not including the SgFunctionParameterTypeList in the lookup.
        {
#if 0
          printf ("########### In buildMemberFunctionType(): Looking in global function type table for member function type = %p name = %s \n",funcType,typeName.str());
#endif

#error "DEAD CODE!"

          SgName                alt_typeName    = SgMemberFunctionType::get_mangled(return_type,typeList,classType,mfunc_specifier);
          SgType*               alt_typeInTable = fTable->lookup_function_type(alt_typeName);
          SgMemberFunctionType* alt_funcType    = isSgMemberFunctionType(fTable->lookup_function_type(typeName));
#if 0
          printf ("########### In buildMemberFunctionType(): Looking in global function type table for alt member function type = %p alt name = %s alt typeInTable = %p \n",alt_funcType,alt_typeName.str(),alt_typeInTable);
#endif
        }
#else
  // Maintain the global type table 
     SgFunctionTypeTable* fTable = SgNode::get_globalFunctionTypeTable();
     ROSE_ASSERT(fTable != NULL);

  // DQ (12/6/2012): Added assertion.
     ROSE_ASSERT(classType != NULL);

  // DQ (12/13/2012): Added assertion.
     ROSE_ASSERT(typeList != NULL);

  // DQ (12/6/2012): Newer simpler code (using static function SgMemberFunctionType::get_mangled()).
     SgName                typeName    = SgMemberFunctionType::get_mangled(return_type,typeList,classType,mfunc_specifier);
     SgType*               typeInTable = fTable->lookup_function_type(typeName);

#if 0
     printf ("In buildMemberFunctionType(): fTable->lookup_function_type(typeName = %s) = %p \n",typeName.str(),typeInTable);
#endif

     SgMemberFunctionType* funcType = NULL;
     if (typeInTable == NULL)
        {
          bool has_ellipses = false;
          SgPartialFunctionType* partialFunctionType = new SgPartialFunctionType(return_type, has_ellipses, classType, mfunc_specifier);
          ROSE_ASSERT(partialFunctionType != NULL);
#if 0
          printf ("Building a SgPartialFunctionType: partialFunctionType = %p \n",partialFunctionType);
#endif
       // DQ (12/5/2012): We want to avoid overwriting an existing SgFunctionParameterTypeList. Could be related to failing tests for AST File I/O.
          if (partialFunctionType->get_argument_list() != NULL)
             {
               delete partialFunctionType->get_argument_list();
               partialFunctionType->set_argument_list(NULL);
             }
          ROSE_ASSERT(partialFunctionType->get_argument_list() == NULL);

          typeList->set_parent(partialFunctionType);

       // DQ (12/6/2012): Set the SgFunctionParameterTypeList in the SgPartialFunctionType before trying 
       // to build a SgMemberFunctionType (not critical that it be set before, but might be in the future, 
       // but it is important that it be set).
          partialFunctionType->set_argument_list(typeList);

          ROSE_ASSERT(partialFunctionType->get_argument_list() != NULL);

       // The optional_fortran_type_kind is only required for Fortran support.
          SgExpression* optional_fortran_type_kind = NULL;
          funcType = SgMemberFunctionType::createType(partialFunctionType, optional_fortran_type_kind);

       // DQ (12/13/2012): Remove the SgPartialFunctionType after it has been used to build the SgMemberFunctionType.
       // I would rather modify the SgMemberFunctionType::createType() API so that we didn't use the SgPartialFunctionType IR nodes.
       // First we have to reset the pointer to the type argument list to NULL since it is shared with the SgMemberFunctionType.
          partialFunctionType->set_argument_list(NULL);

       // Then we can delete the SgPartialFunctionType.
          delete partialFunctionType;
          partialFunctionType = NULL;

       // This is perhaps redundant since it was set to a derived class (but might be an important distiction).
          typeList->set_parent(funcType);

          ROSE_ASSERT(funcType->get_argument_list() != NULL);
        }
  // SgMemberFunctionType* funcType    = isSgMemberFunctionType(fTable->lookup_function_type(typeName));
#endif

#if 0
     printf ("########### In buildMemberFunctionType(): Looking in global function type table for member function type = %p name = %s typeInTable = %p \n",funcType,typeName.str(),typeInTable);
#endif

     if (typeInTable == NULL)
        {
#if 0
          printf ("########### In buildMemberFunctionType(): Adding funcType = %p = %s to global function type table \n",funcType,typeName.str());
#endif
          ROSE_ASSERT(funcType != NULL);
          fTable->insert_function_type(typeName,funcType);
        }
       else
        {
       // DQ (12/3/2011): Added this case to support reuse of function types (not handled by the createType functions).
       // Delete the one generated so that we could form the mangled name.

       // printf ("Deleting funcType = %p = %s \n",funcType,funcType->class_name().c_str());

       // DQ (3/22/2012): Added assertion.
          ROSE_ASSERT(typeInTable != funcType);

#if 0

#error "DEAD CODE!"

       // DQ (4/25/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) Skipping delete of funcType = %p = %s \n",funcType,funcType->class_name().c_str());
#else
          delete funcType;
#endif
          funcType = NULL;
#if 0

#error "DEAD CODE!"

       // DQ (12/13/2011): Is this executed!
          printf ("Is this executed! \n");
          ROSE_ASSERT(false);
#endif
       // Return the one from the global type table.
          funcType = isSgMemberFunctionType(typeInTable);
          ROSE_ASSERT(funcType != NULL);
        }
#if 0

#error "DEAD CODE!"

        }
       else
        {
       // DQ (12/4/2011): Templates should not really generate types, but we need just such a concept.
          ROSE_ASSERT(templateClassDeclaration != NULL);

          printf ("Not clear how to handle case of SgTemplateClassDeclaration \n");
          ROSE_ASSERT(false);
        }
#endif

  // fTable->get_function_type_table()->print("In buildMemberFunctionType(): globalFunctionTypeTable AFTER");

  // DQ (1/21/2009): TODO: Need to mark the function type as const, volatile, 
  // or restrict (assert that none are set for now).
  // ROSE_ASSERT(mfunc_specifier == 0);
  // funcType->set_mfunc_specifier(mfunc_specifier);
#if 0
     printf ("Leaving buildMemberFunctionType(): returning funcType = %p = %s mfunc_specifier = %u \n",funcType,funcType->class_name().c_str(),mfunc_specifier);
     printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
#endif

  // DQ (3/8/2012): This should be non-zero for a const member function type.
  // ROSE_ASSERT(mfunc_specifier == 0);

     return funcType;
   }


// DQ (1/4/2009): Need to finish this!!!
//-----------------------------------------------
// build member function type, 
// 
// insert into symbol table when not duplicated
SgMemberFunctionType*
SageBuilder::buildMemberFunctionType(SgType* return_type, SgFunctionParameterTypeList* typeList, SgClassDefinition *struct_name, /* const, volatile, restrict support */ unsigned int mfunc_specifier)
   {
  // This function has to first build a version of the SgMemberFunctionType so that it can generate a mangled name.
  // If the mangled name can be use to lookup a SgMemberFunctionType then the "just built" SgMemberFunctionType
  // is deleted and the one from the global function type table is returned.  This fixes a lot of subtle C++
  // specific issues with the build interface and it's use with the newer EDG 4.3 connection to ROSE.

     ROSE_ASSERT(return_type != NULL);

  // SgMemberFunctionType (SgType *return_type=NULL, bool has_ellipses=true, SgClassDefinition *struct_name=NULL, unsigned int mfunc_specifier=0)
  // SgMemberFunctionType * funcType = new SgMemberFunctionType(return_type, false);

     ROSE_ASSERT(struct_name != NULL);
  // ROSE_ASSERT(isSgTemplateClassDefinition(struct_name) == NULL);

     ROSE_ASSERT(struct_name->get_parent() != NULL);
  // ROSE_ASSERT(struct_name->get_declaration() != NULL);

#if 0
     printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
     printf ("In buildMemberFunctionType() return_type = %p typeList = %p struct_name = %p = %s = %s mfunc_specifier = %u \n",return_type,typeList,struct_name,struct_name->class_name().c_str(),struct_name->get_declaration()->get_name().str(),mfunc_specifier);
#endif

  // SgDeclarationStatement* declaration = struct_name->get_declaration();
     SgTemplateClassDefinition* templateClassDefinition = isSgTemplateClassDefinition(struct_name);
     
     SgDeclarationStatement* declaration = NULL;
     if (templateClassDefinition != NULL)
        {
          declaration = templateClassDefinition->get_declaration();
          ROSE_ASSERT(declaration != NULL);
        }
       else
        {
          declaration = struct_name->get_declaration();
          ROSE_ASSERT(declaration != NULL);
        }

     ROSE_ASSERT(declaration != NULL);

     if (typeList != NULL)
        {
#if 0
          SgTypePtrList & typeListArgs = typeList->get_arguments();
          for (SgTypePtrList::iterator i = typeListArgs.begin(); i != typeListArgs.end(); i++)
             {
               printf ("   --- type argument = %p = %s \n",*i,(*i)->class_name().c_str());
             }
#endif
        }
       else
        {
          printf ("WARNING: typeList == NULL \n");
        }

#if 0
  // DQ (8/15/2013): I think that the function type is computed the same for templates as non-templates, and template 
  // instantiations.  The difference is now template arguments or templae parameters are used to distinquish the 
  // different symbols in the symbol table lookup.
     if (isSgTemplateClassDeclaration(declaration) != NULL)
        {
          printf ("In buildMemberFunctionType(): Not clear how to handle case of SgTemplateClassDeclaration \n");
        }
#endif
#if 0
     if (isSgTemplateClassDeclaration(declaration) != NULL)
        {
          printf ("Not clear how to handle case of SgTemplateClassDeclaration \n");
          ROSE_ASSERT(false);
        }
#endif

     SgClassDeclaration*         classDeclaration         = isSgClassDeclaration(declaration);
     SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(declaration);

     SgMemberFunctionType* funcType = NULL;
  // ROSE_ASSERT(classDeclaration != NULL);

  // DQ (8/15/2013): I think we can asert this under the new design where 
  // SgTemplateClassDeclaration is derived from SgClassDeclaration.
     ROSE_ASSERT(classDeclaration != NULL);

  // DQ (12/4/2011): Modified SgClassType to support template declarations (SgTemplateClassDeclaration now contains a type set to SgClassType.
  // The SgClassType has been modified (browdened) to support a SgDeclarationStatement instead of a SgClassDeclaration.
  // SgClassType* classType = classDeclaration->get_type();
     SgClassType* classType = NULL;
     if (classDeclaration != NULL)
        {
          classType = classDeclaration->get_type();
          ROSE_ASSERT(classType != NULL);
        }
       else
        {
          ROSE_ASSERT(templateClassDeclaration != NULL);
          SgType* type = templateClassDeclaration->get_type();
          ROSE_ASSERT(type != NULL);

          classType = isSgClassType(type);
          ROSE_ASSERT(classType != NULL);
        }

     ROSE_ASSERT(classType != NULL);

#if 0
     printf ("In buildMemberFunctionType(): Calling refactored function: buildMemberFunctionType(...,classType = %p,...) \n",classType);
#endif

  // DQ (8/19/2012): This code has been refactored.
     funcType = buildMemberFunctionType(return_type,typeList,classType,mfunc_specifier);

#if 0
     printf ("In buildMemberFunctionType(): DONE: Calling refactored function: buildMemberFunctionType(...,classType = %p,...) \n",classType);
#endif

     return funcType;
   }


//----------------------------------------------------
//! Build an opaque type with a name, useful when a type's details are unknown during transformation, especially for a runtime library's internal type.
SgType * SageBuilder::buildOpaqueType(std::string const name, SgScopeStatement * scope)
{
  // we require users to specify a target scope
  ROSE_ASSERT(scope);
  SgTypedefDeclaration* type_decl = NULL;
  SgTypedefType* result = NULL;

  // Liao and Greg Bronevetsky , 8/27/2009
  // patch up the symbol  
  // and avoid duplicated creation
  // TODO  a function like fixTypeDeclaration() (similar to SageInterface::fixVariableDeclaration()) for this
  SgTypedefSymbol* type_symbol = scope->lookup_typedef_symbol(name);
  if (type_symbol == NULL)
  {
    type_decl =  new SgTypedefDeclaration(name,buildIntType(),NULL, NULL, NULL);
    ROSE_ASSERT(type_decl);
    type_symbol = new SgTypedefSymbol(type_decl);
    ROSE_ASSERT(type_symbol);
    SgName n = name;

 // DQ (5/21/2013): The symbol table should only be accessed through the SgScopeStatement interface.
 // scope->get_symbol_table()->insert(n, type_symbol); 
    scope->insert_symbol(n,type_symbol); 

    type_decl->set_firstNondefiningDeclaration (type_decl);
    setOneSourcePositionForTransformation(type_decl);
    prependStatement(type_decl,scope);
    // Hide it from unparser
    Sg_File_Info* file_info = type_decl->get_file_info();
    file_info->unsetOutputInCodeGeneration ();
    result = new SgTypedefType(type_decl);
  } 
  else
  {
    type_decl = type_symbol->get_declaration();
    result = type_decl->get_type();
  }
  ROSE_ASSERT(result);
  return result;
}


//----------------- function type------------
// same function declarations (defining or nondefining) should share the same function type!
SgFunctionType*
SageBuilder::buildFunctionType(SgType* return_type, SgFunctionParameterList * argList)
   {
#if 0
     printf ("Inside of SageBuilder::buildFunctionType(SgType,SgFunctionParameterList) \n");
#endif

  // DQ (8/19/2012): Can we assert this?
     ROSE_ASSERT(argList != NULL);

     SgFunctionParameterTypeList* typeList  = buildFunctionParameterTypeList(argList);

  // DQ (8/19/2012): Can we assert this?
     ROSE_ASSERT(typeList != NULL);

     SgFunctionType* func_type = buildFunctionType(return_type, typeList);

     if (func_type->get_argument_list() != typeList)
        {
#if 0
          printf ("WARNING: the generated SgFunctionParameterTypeList* typeList = %p was not used and should be deleted \n",typeList);
#endif
          delete typeList;
          typeList = NULL;
        }

     return func_type;
   }


// DQ (12/1/2011): Added similar function for SgMemberFunctionType as for SgFunctionType 
// (required for use in template function buildNondefiningFunctionDeclaration_T<T>()).
SgMemberFunctionType*
SageBuilder::buildMemberFunctionType(SgType* return_type, SgFunctionParameterList* argList, SgClassDefinition* classDefinition, /* const, volatile, restrict support */ unsigned int mfunc_specifier)
   {
#if 0
     printf ("Inside of SageBuilder::buildMemberFunctionType(SgType*,SgFunctionParameterList*,SgClassDefinition*,unsigned int) \n");
#endif

     SgFunctionParameterTypeList* typeList  = buildFunctionParameterTypeList(argList);
     SgMemberFunctionType*        func_type = buildMemberFunctionType(return_type, typeList, classDefinition, mfunc_specifier);

     return func_type;
   }


void
checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope ( SgDeclarationStatement* func, SgScopeStatement* scope )
   {
  // DQ (12/14/2011): We need the parent to be set so that we can call some of the test functions 
  // (e.g assert that get_class_scope() for member functions).  So we set the parent to the scope
  // by default and see if this will work, else we could disable to assertion that the parent is 
  // non-null in the get_class_scope() member function.

     if (isSgMemberFunctionDeclaration(func) != NULL)
        {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("WARNING: setting parent of function to match scope by default \n");
#endif
          func->set_parent(scope);

          ROSE_ASSERT(scope != NULL);

          if (isSgTemplateInstantiationMemberFunctionDecl(func) != NULL)
             {
            // DQ (12/14/2011): We should not have a member function template instantiation in a template class definition.
               ROSE_ASSERT(isSgTemplateClassDefinition(scope) == NULL);
             }
        }
       else
        {
          if (isSgTemplateFunctionDeclaration(func) != NULL)
             {
               if (isSgTemplateInstantiationMemberFunctionDecl(func) != NULL)
                  {
                    ROSE_ASSERT(isSgTemplateClassDefinition(scope) != NULL);
                  }
             }
        }
   }

//----------------- function declaration------------
// considering
// 1. fresh building
// 2. secondary building after another nondefining functiondeclaration
// 3. secondary building after another defining function declaration
// 4. fortran ?
template <class actualFunction>
actualFunction*
SageBuilder::buildNondefiningFunctionDeclaration_T (const SgName & XXX_name, SgType* return_type, SgFunctionParameterList * paralist, bool isMemberFunction, 
   SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateArgumentPtrList* templateArgumentsList, SgTemplateParameterPtrList* templateParameterList)
   {
  // DQ (11/25/2011): This function has been modified to work when used with a SgTemplateFunctionDeclaration as a template argument.
  // It was originally designed to work with only SgFunctionDeclaration and SgMemberFunctionDeclaration, it now works with these
  // plus SgTemplateFunctionDeclaration and SgTemplateMemberonDeclaration IR nodes. This is part of providing new support for template 
  // declarations in the AST and a general update of this function to support this expanded use.

  // DQ (11/27/2011) Note: it is not clear if we need the newly added input paramter: buildTemplateInstantiation; since this is represented in the template parameter.

#if 0
  // FMZ (3/23/2009): We need this for the  coarray translator
     if (SageInterface::is_Fortran_language() == true)
        {
       // We don't expect this is being called for Fortran
          cerr<<"Building nondefining function in Fortran is not allowed!"<<endl;
          ROSE_ASSERT(false);
        }
#endif

  // argument verification
     if (scope == NULL)
        {
          scope = SageBuilder::topScopeStack();
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): isMemberFunction = %s scope == NULL resetting the scope = %p = %s \n",isMemberFunction ? "true" : "false",scope,scope->class_name().c_str());
#endif
        }

#if 0
     printf ("In buildNondefiningFunctionDeclaration_T(): scope = %p = %s templateArgumentsList = %p templateParameterList = %p \n",scope,scope != NULL ? scope->class_name().c_str() : "NULL",templateArgumentsList,templateParameterList);
#endif

  // ROSE_ASSERT(XXX_name.is_null() == false);
     if (XXX_name.is_null() == true)
        {
       // DQ (4/2/2013): This case is generated for test2013_86.C.
          printf ("NOTE: In buildNondefiningFunctionDeclaration_T(): XXX_name.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n");
        }

     SgName nameWithoutTemplateArguments = XXX_name;
     SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;

     bool buildTemplateInstantiation = ((VariantT)actualFunction::static_variant == V_SgTemplateInstantiationFunctionDecl || (VariantT)actualFunction::static_variant == V_SgTemplateInstantiationMemberFunctionDecl);

  // DQ (8/7/2013): Added support for template declarations.
     bool buildTemplateDeclaration   = ((VariantT)actualFunction::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration);

#if 0
     printf ("In buildNondefiningFunctionDeclaration_T(): buildTemplateInstantiation = %s \n",buildTemplateInstantiation ? "true" : "false");
#endif

  // DQ (8/7/2013): Added support for template declarations (need to handle template names overloaded on template parameters).
  // We want to use the template arguments in the symbol table lookup, but not in the name generation.
  // if (buildTemplateInstantiation == true)
  // if (buildTemplateInstantiation == true || buildTemplateDeclaration == true)
     if (buildTemplateInstantiation == true)
        {
          ROSE_ASSERT(templateArgumentsList != NULL);
          nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);
#if 0
          printf ("Building a non-defining function: buildNondefiningFunctionDeclaration_T() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n",nameWithTemplateArguments.str(),buildTemplateInstantiation ? "true:" : "false");
#endif
#if 0
          if (nameWithTemplateArguments == "insert < __normal_iterator< SgInitializedName ** , __type  >  > ")
             {
               printf ("In buildNondefiningFunctionDeclaration_T(): Found function nameWithTemplateArguments = %s \n",nameWithTemplateArguments.str());
             }
#endif
        }

#if 0
     printf ("In buildNondefiningFunctionDeclaration_T(): nameWithTemplateArguments = |%s| \n",nameWithTemplateArguments.str());
#endif

  // printf ("Building non-defining function for scope = %p in file = %s \n",scope,TransformationSupport::getSourceFile(scope)->getFileName().c_str());

  // DQ (2/25/2009): I think I added this recently but it is overly restrictive.
  // ROSE_ASSERT(scope != NULL);

  // ROSE_ASSERT(scope->containsOnlyDeclarations()); 
  // this function is also called when building a function reference before the function declaration exists.  So, skip the check
  // ROSE_ASSERT(nameWithTemplateArguments.is_null() == false);
     if (nameWithTemplateArguments.is_null() == true)
        {
       // DQ (4/2/2013): This case is generated for test2013_86.C.
          printf ("NOTE: In buildNondefiningFunctionDeclaration_T(): nameWithTemplateArguments.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n");
        }

  // ROSE_ASSERT(nameWithoutTemplateArguments.is_null() == false);
     if (nameWithoutTemplateArguments.is_null() == true)
        {
       // DQ (4/2/2013): This case is generated for test2013_86.C.
          printf ("NOTE: In buildNondefiningFunctionDeclaration_T(): nameWithoutTemplateArguments.is_null() == true: This is a function with an empty name (allowed as compiler generated initializing constructors to un-named classes, structs, and unions in C++ \n");
        }

     ROSE_ASSERT(return_type != NULL);
     ROSE_ASSERT(paralist != NULL);

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
  // ROSE_ASSERT(SageInterface::hasTemplateSyntax(XXX_name) == false);
     if (SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == true)
        {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("Warning: In buildNondefiningFunctionDeclaration_T(): nameWithoutTemplateArguments = %s nameWithTemplateArguments = %s \n",nameWithoutTemplateArguments.str(),nameWithTemplateArguments.str());
#endif
        }
  // DQ (7/27/2012): There are reasons why this can fail: e.g. for functions with names such as:
  // "operator std::auto_ptr_ref<_Tp1>" which is a user defined conversion operator to one class from another.
  // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);

  // tentatively build a function type, since it is shared
  // by all prototypes and defining declarations of a same function!
  // SgFunctionType * func_type = buildFunctionType(return_type,paralist);

#if 0
     printf ("In buildNondefiningFunctionDeclaration_T(): isMemberFunction = %s scope = %p = %s \n",isMemberFunction ? "true" : "false",scope,scope->class_name().c_str());
#endif

     SgFunctionType* func_type = NULL;
     if (isMemberFunction == true)
        {
       // func_type = buildMemberFunctionType(return_type,paralist,NULL,0);
       // func_type = buildFunctionType(return_type,paralist);
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): scope = %p = %s build SgFunctionParameterTypeList \n",scope,scope->class_name().c_str());
#endif
          SgClassDefinition *struct_name = isSgClassDefinition(scope);
          ROSE_ASSERT(struct_name != NULL);
          SgFunctionParameterTypeList * typeList = buildFunctionParameterTypeList(paralist);

       // DQ (11/6/2011): Modified function interfaces to support defining const and vaolatile functions (part of function type, but be built before types are shared).
       // func_type = buildMemberFunctionType(return_type,typeList,struct_name,/* const, volatile, restrict support */ 0);
          func_type = buildMemberFunctionType(return_type,typeList,struct_name,/* const, volatile, restrict support */ functionConstVolatileFlags);

       // printf ("Error: SgFunctionType built instead of SgMemberFunctionType \n");
       // ROSE_ASSERT(false);
        }
       else
        {
          func_type = buildFunctionType(return_type,paralist);
        }

     ROSE_ASSERT(func_type != NULL);

#if 0
     printf ("In buildNondefiningFunctionDeclaration_T(): func_type = %p = %s \n",func_type,func_type->class_name().c_str());
#endif

  // function declaration
     actualFunction* func = NULL;

  // search before using the function type to create the function declaration 
  // TODO only search current scope or all ancestor scope?? (DQ: Only current scope!)
  // We don't have lookup_member_function_symbol  yet
  // SgFunctionSymbol *func_symbol = scope->lookup_function_symbol(name,func_type);

  // DQ (12/27/2011): Under the new design we can make the symbol type SgFunctionSymbol instead of the less specific SgSymbol.
  // DQ (11/25/2011): We want to add the support for template function declarations, 
  // so this should be a SgSymbol so that we can have it be either a SgFunctionSymbol 
  // or a SgTemplateSymbol.
  // SgFunctionSymbol *func_symbol = NULL;
  // SgSymbol *func_symbol = NULL;
     SgFunctionSymbol* func_symbol = NULL;

     if (scope != NULL)
        {
       // DQ (3/13/2012): Experiment with new function to support only associating the right type of symbol with the 
       // function being built.  I don't think I like the design of this interface, but we might change that later.
       // func_symbol = scope->lookup_function_symbol(name,func_type);
       // SgSymbol* symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(name,func_type);
       // func_symbol = symbol;
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): name = %s func_type = %p = %s templateParameterList->size() = %zu templateArgumentsList->size() = %zu \n",
               nameWithTemplateArguments.str(),func_type,func_type->get_mangled().str(),
               templateParameterList != NULL ? templateParameterList->size() : 999,
               templateArgumentsList != NULL ? templateArgumentsList->size() : 999);
#endif

       // DQ (8/7/2013): We need to use the template arguments in the symbol table lookup for template functions to permit template function overloading on template perameters.
       // func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(name,func_type);
       // func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,templateArgumentsList);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);
          func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);

#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): func_symbol from scope->find_symbol_by_type_of_function<actualFunction>(name = %s) = %p \n",nameWithTemplateArguments.str(),func_symbol);
#endif
       // If not a proper function (or instantiated template function), then check for a template function declaration.
          if (func_symbol == NULL)
             {
            // Note that a template function does not have a function type (just a name).
#if 0
               printf ("NOTE: Maybe template symbols for template function declarations should use the function type \n");
#endif
               ROSE_ASSERT(func_type != NULL);

#if 0
            // DQ (12/12/2011): Because this is an just using the name, it could return the wrong symbol in the case of overloaded functions.
            // func_symbol = scope->lookup_template_symbol(name);

#error "DEAD CODE!"

               func_symbol = scope->lookup_template_function_symbol(name,func_type);
               printf ("In buildNondefiningFunctionDeclaration_T(): func_symbol from scope->lookup_template_symbol(name = %s) = %p \n",name.str(),func_symbol);
               if (func_symbol != NULL)
                  {
                 // Check that this is a SgTemplateFunctionDeclaration (could be a SgTemplateMemberFunctionDeclaration).
                    ROSE_ASSERT(isSgTemplateFunctionDeclaration(func_symbol->get_symbol_basis()) != NULL);
                  }
#endif
             }
            else
             {
#if 0
               printf ("In buildNondefiningFunctionDeclaration_T(): func_symbol = %p was found using name = %s \n",func_symbol,nameWithTemplateArguments.str());
#endif
             }
        }

#if 1
  // DQ (3/13/2012): I want to introduce error checking on the symbol matching the template parameter.
     if (func_symbol != NULL)
        {
#if 0
          printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p = %s \n",scope,func_symbol,func_symbol->class_name().c_str());
#endif
#if 0
          if ((VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration)
               printf ("This is a SgTemplateMemberFunctionDeclaration function \n");
            else
               printf ("variantT(actualFunction::static_variant) = %d \n",actualFunction::static_variant);
#endif
          switch((VariantT)actualFunction::static_variant)
             {
               case V_SgFunctionDeclaration:
               case V_SgProcedureHeaderStatement:
               case V_SgTemplateInstantiationFunctionDecl:
                  {
#if 0
                    printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgFunctionDeclaration function \n");
#endif
                    ROSE_ASSERT(isSgFunctionSymbol(func_symbol) != NULL);
                    break;
                  }
               case V_SgMemberFunctionDeclaration:
               case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
#if 0
                    printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgMemberFunctionDeclaration function \n");
#endif
                    ROSE_ASSERT(isSgMemberFunctionSymbol(func_symbol) != NULL);
                    break;
                  }
               case V_SgTemplateFunctionDeclaration:
                  {
#if 0
                    printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgTemplateFunctionDeclaration function \n");
#endif
                    ROSE_ASSERT(isSgTemplateFunctionSymbol(func_symbol) != NULL);
                    break;
                  }
               case V_SgTemplateMemberFunctionDeclaration:
                  {
#if 0
                    printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): This is a SgTemplateMemberFunctionDeclaration function \n");
#endif
                    ROSE_ASSERT(isSgTemplateMemberFunctionSymbol(func_symbol) != NULL);
                    break;
                  }

               default:
                  {
                    printf ("default reach in buildNondefiningFunctionDeclaration_T(): variantT(actualFunction::static_variant) = %d \n",actualFunction::static_variant);
                    ROSE_ASSERT(false);
                  }
             }
        }
#endif

     if (func_symbol == NULL)
        {
       // first prototype declaration
       // func = new actualFunction (name,func_type,NULL);
          func = new actualFunction (nameWithTemplateArguments,func_type,NULL);

          ROSE_ASSERT(func != NULL);

       // DQ (5/1/2012): This should always be true.
          ROSE_ASSERT(func->get_file_info() == NULL);

#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): constructor called to build func = %p = %s \n",func,func->class_name().c_str());
#endif
#if 0
          if (isSgMemberFunctionDeclaration(func) != NULL)
             {
               printf ("In buildNondefiningFunctionDeclaration_T(): SgCtorInitializerList = %p \n",isSgMemberFunctionDeclaration(func)->get_CtorInitializerList());
             }
#endif
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif
       // DQ (12/14/2011): Moved this from lower in this function.
          func->set_scope(scope);

       // DQ (12/15/2011): Added test.
          checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(func,scope);

       // This fails below for a SgTemplateFunctionDeclaration, so test it here.
          ROSE_ASSERT(func->get_parameterList() != NULL);

       // NOTE: we want to allow the input scope to be NULL (and even the SageBuilder::topScopeStack() == NULL)
       // so that function can be built bottom up style.  However this means that the symbol tables in the 
       // scope of the returned function declaration will have to be setup separately.
          if (scope != NULL)
             {
            // function symbol table
               if (isSgMemberFunctionDeclaration(func))
                  {
                 // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used. I have
                 // not decided if template declarations should cause symbols to be generated for functions and member functions.
                 // func_symbol = new SgMemberFunctionSymbol(func);
                    if (isSgTemplateMemberFunctionDeclaration(func) != NULL)
                       func_symbol = new SgTemplateMemberFunctionSymbol(isSgTemplateMemberFunctionDeclaration(func));
                    else
                     {
                       SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(func);
                       ROSE_ASSERT(memberFunctionDeclaration != NULL);
                       func_symbol = new SgMemberFunctionSymbol(memberFunctionDeclaration);
                     }

                    ROSE_ASSERT(func_symbol != NULL);
                    ROSE_ASSERT(func_symbol->get_symbol_basis() != NULL);
                  }
                 else
                  {
#if 0
                 // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used.
                 // func_symbol = new SgFunctionSymbol(func);
                    func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(func));
                    ROSE_ASSERT(func_symbol->get_symbol_basis() != NULL);
#else
                 // if (isSgFunctionDeclaration(func))
                    if (isSgTemplateFunctionDeclaration(func))
                       {
#if 0
                         printf ("THIS IS A TEMPLATE FUNCTION DECLARATION (MEMBER OR NON-MEMBER (build a SgTemplateFunctionSymbol) \n");
#endif
                      // How should we handled template functions in the symbol table???
                      // DQ (11/24/2011): After some thought, I think that template declarations for function are more template declarations 
                      // than functions.  So all template function declarations will be handled as SgTemplateSymbols and not SgFunctionSymbols.
#if 0
                         SgTemplateDeclaration* templatedeclaration = isSgTemplateDeclaration(func);
                         ROSE_ASSERT(templatedeclaration != NULL);
                         SgTemplateSymbol* template_symbol = new SgTemplateSymbol(templatedeclaration);
                         ROSE_ASSERT(template_symbol != NULL);
                         ROSE_ASSERT(template_symbol->get_symbol_basis() != NULL);
#else
                      // DQ (12/27/2011): New design for symbols for template function declarations.
                         SgTemplateFunctionDeclaration* templatedeclaration = isSgTemplateFunctionDeclaration(func);
                         ROSE_ASSERT(templatedeclaration != NULL);
#ifdef TEMPLATE_DECLARATIONS_DERIVED_FROM_NON_TEMPLATE_DECLARATIONS
                         SgTemplateFunctionSymbol* template_symbol = new SgTemplateFunctionSymbol(templatedeclaration);
#else
                         printf ("Error: This functionality is not yet been made backwardly compatable to EDG 3.3 template design \n");
                         SgFunctionSymbol* template_symbol = new SgFunctionSymbol(NULL);
#error "DEAD CODE!"
                         printf ("Exiting to avoid further errors \n");
                         ROSE_ASSERT(false);
#endif
                         ROSE_ASSERT(template_symbol != NULL);
                         ROSE_ASSERT(template_symbol->get_symbol_basis() != NULL);
#endif
                         func_symbol = template_symbol;
                       }
                      else
                       {
                         func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(func));
                         ROSE_ASSERT(func_symbol->get_symbol_basis() != NULL);
                       }
#endif
                  }
               ROSE_ASSERT(func_symbol != NULL);
               ROSE_ASSERT(func_symbol->get_symbol_basis() != NULL);
#if 0
               printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p = %s nameWithTemplateArguments = %s func_symbol = %p = %s = %s \n",
                    scope,scope->class_name().c_str(),nameWithTemplateArguments.str(),func_symbol,func_symbol->class_name().c_str(),SageInterface::get_name(func_symbol).c_str());
#endif
            // scope->insert_symbol(name, func_symbol);
               scope->insert_symbol(nameWithTemplateArguments, func_symbol);

            // DQ (3/8/2012): Added assertion.
               ROSE_ASSERT(func->get_symbol_from_symbol_table() != NULL);

            // ROSE_ASSERT(scope->lookup_template_member_function_symbol(name,result->get_type()) != NULL);

               if (isSgFunctionDeclaration(func) == NULL)
                  {
                 // DQ (12/18/2011): If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.
#if 0
                    printf ("In buildNondefiningFunctionDeclaration_T(): Looking up nameWithTemplateArguments = %s in scope = %p = %s \n",nameWithTemplateArguments.str(),scope,scope->class_name().c_str());
#endif
                 // DQ (8/12/2013): Added template parameter list.
                 // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
                 // In this case these are unavailable from this point.
                 // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
                 // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments) != NULL);
                 // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);
                 // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);
                    ROSE_ASSERT(scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);
                  }

            // ROSE_ASSERT(scope->lookup_function_symbol(name,func_type) != NULL);

            // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
            // In this case these are unavailable from this point.
            // DQ (11/25/2011): Added support for template functions.
            // DQ (2/26/2009): uncommented assertion.
            // ROSE_ASSERT(scope->lookup_function_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?
            // ROSE_ASSERT(scope->lookup_function_symbol(name) != NULL || scope->lookup_template_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?
            // ROSE_ASSERT(scope->lookup_function_symbol(nameWithTemplateArguments) != NULL || scope->lookup_template_symbol(nameWithTemplateArguments) != NULL); // Did not pass for member function? Should we have used the mangled name?
            // Did not pass for member function? Should we have used the mangled name?
            // ROSE_ASSERT(scope->lookup_function_symbol(nameWithTemplateArguments) != NULL || scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);
            // ROSE_ASSERT(scope->lookup_function_symbol(nameWithTemplateArguments) != NULL || scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);
#if 0
               printf ("\n ############################### \n");
               printf ("In buildNondefiningFunctionDeclaration_T(): lookup_symbol: templateParameterList = %p \n",templateParameterList);
               printf ("In buildNondefiningFunctionDeclaration_T(): func = %p = %s \n",func,func->class_name().c_str());
#endif
               ROSE_ASSERT(buildTemplateDeclaration == false || templateParameterList != NULL);
#if 0
               SgSymbol* s0 = scope->lookup_template_member_function_symbol(nameWithTemplateArguments,func_type,templateParameterList);

               printf ("In buildNondefiningFunctionDeclaration_T(): lookup_template_member_function_symbol: s0 = %p \n",s0);

               SgSymbol* s1 = scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList);

               printf ("In buildNondefiningFunctionDeclaration_T(): lookup_template_function_symbol: s1 = %p \n",s1);

               SgSymbol* s2 = scope->lookup_function_symbol(nameWithTemplateArguments);

               printf ("In buildNondefiningFunctionDeclaration_T(): lookup_template_function_symbol: s1 = %p lookup_function_symbol: s2 = %p \n",s1,s2);
#endif
            // DQ (8/13/2013): We need to test for function symbols (which will include member function symbols), 
            // template functions and template member functions. Each must be tested for seperately because template 
            // functions and template member functions are not connected to derivation which non-template functions 
            // and non-template member functions are connected through derivation.
            // ROSE_ASSERT(scope->lookup_function_symbol(nameWithTemplateArguments) != NULL || scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);
               ROSE_ASSERT(scope->lookup_function_symbol(nameWithTemplateArguments) != NULL || 
                           scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL ||
                           scope->lookup_template_member_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP
            // if (scope->lookup_function_symbol(name) == NULL || scope->lookup_template_symbol(name) != NULL)
            // if (scope->lookup_function_symbol(nameWithTemplateArguments) == NULL || scope->lookup_template_symbol(nameWithTemplateArguments) != NULL)
            // if (scope->lookup_function_symbol(nameWithTemplateArguments) == NULL || scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL)
               if (scope->lookup_function_symbol(nameWithTemplateArguments,templateArgumentList) == NULL || scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL)
                  {
                 // Make sure this is a template function declaration...
                    printf ("Need to make sure this is a template function declaration... \n");
                  }
#endif
             }

       // DQ (12/14/2011): Added test.
          ROSE_ASSERT(func->get_scope() != NULL);

          if (isSgFunctionDeclaration(func) == NULL)
             {
            // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.
#if 0
               printf ("In buildNondefiningFunctionDeclaration_T(): Looking up name = %s in scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
#endif
            // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
            // In this case these are unavailable from this point.
            // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);
               ROSE_ASSERT(scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);
             }
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_firstNondefiningDeclaration(func = %p) (to itself) \n",func,func);
          printf ("In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(func == NULL)      (to NULL) \n",func);
#endif
          func->set_firstNondefiningDeclaration(func);
          func->set_definingDeclaration(NULL);

          ROSE_ASSERT(func->get_definingDeclaration() == NULL);

       // DQ (12/14/2011): Error checking
          SgTemplateInstantiationMemberFunctionDecl* testMemberDecl = isSgTemplateInstantiationMemberFunctionDecl(func);
          if (testMemberDecl != NULL)
             {
               ROSE_ASSERT(testMemberDecl->get_scope() != NULL);
#if 0
               printf ("testMemberDecl->get_scope() = %s \n",testMemberDecl->get_scope()->class_name().c_str());
#endif
               ROSE_ASSERT(testMemberDecl->get_class_scope() != NULL);
#if 0
               printf ("testMemberDecl->get_class_scope() = %s \n",testMemberDecl->get_class_scope()->class_name().c_str());
#endif
               ROSE_ASSERT(testMemberDecl->get_associatedClassDeclaration() != NULL);
             }
#if 0
            else
             {
               SgTemplateInstantiationFunctionDecl* testNonMemberDecl = isSgTemplateInstantiationFunctionDecl(func);
               if (testNonMemberDecl != NULL)
                  {
                    ROSE_ASSERT(testNonMemberDecl->get_associatedClassDeclaration() != NULL);
                  }
             }
#endif
        }
       else 
        {
          ROSE_ASSERT(func_symbol != NULL);

          ROSE_ASSERT(scope != NULL);

       // 2nd, or 3rd... prototype declaration
       // reuse function type, function symbol of previous declaration

       // std::cout<<"debug:SageBuilder.C: 267: "<<"found func_symbol!"<<std::endl;
       // delete (func_type-> get_argument_list ());
       // delete func_type; // bug 189
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): func_symbol = %p = %s \n",func_symbol,func_symbol->class_name().c_str());
#endif
       // func_type = func_symbol->get_declaration()->get_type();
          SgNode* associatedSymbolBasis = func_symbol->get_symbol_basis();
          ROSE_ASSERT(associatedSymbolBasis != NULL);

          SgDeclarationStatement* associatedDeclaration = isSgDeclarationStatement(associatedSymbolBasis);
          ROSE_ASSERT(associatedDeclaration != NULL);
          SgFunctionDeclaration*         functionDeclaration         = isSgFunctionDeclaration(associatedDeclaration);
          SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(associatedDeclaration);
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): associatedDeclaration = %p functionDeclaration = %p templateFunctionDeclaration = %p \n",associatedDeclaration,functionDeclaration,templateFunctionDeclaration);
#endif
          if (functionDeclaration != NULL)
             {
               func_type = functionDeclaration->get_type();
             }
            else
             {
               if (templateFunctionDeclaration != NULL)
                  {
                    func_type = templateFunctionDeclaration->get_type();
                  }
                 else
                  {
                    printf ("Error: associatedDeclaration = %p = %s \n",associatedDeclaration,associatedDeclaration->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
             }
          ROSE_ASSERT(func_type != NULL);

       // func = new actualFunction(name,func_type,NULL);
          func = new actualFunction(nameWithTemplateArguments,func_type,NULL);
          ROSE_ASSERT(func != NULL);
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): func->get_name() = %s func = %p = %s \n",func->get_name().str(),func,func->class_name().c_str());
#endif

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
       // DQ (5/1/2012): Make sure that we don't have IR nodes marked as translformations.
       // This is too early a point to test since the source position has not been set for func yet.
       // detectTransformations_local(func);
#endif
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T() (part 2): constructor called to build func = %p = %s \n",func,func->class_name().c_str());
          if (isSgMemberFunctionDeclaration(func) != NULL)
             {
               printf ("In buildNondefiningFunctionDeclaration_T() (part 2): SgCtorInitializerList = %p \n",isSgMemberFunctionDeclaration(func)->get_CtorInitializerList());
             }
#endif

       // DQ (12/14/2011): Moved this up from below.
          func->set_scope(scope);

       // DQ (3/8/2012): Added assertion.
          ROSE_ASSERT(func->get_symbol_from_symbol_table() == NULL);

#if 1
       // DQ (12/15/2011): Added test.
          checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(func,scope);
#else
       // DQ (12/14/2011): We need the parent to be set so that we can call some of the test functions 
       // (e.g assert that get_class_scope() for member functions).  So we set the parent to the scope
       // by default and see if this will work, else we could disable to assertion that the parent is 
       // non-null in the get_class_scope() member function.
          if (isSgMemberFunctionDeclaration(func) != NULL)
             {
               printf ("WARNING: setting parent of function to match scope by default \n");
               func->set_parent(scope);

#error "DEAD CODE!"

               ROSE_ASSERT(scope != NULL);
               ROSE_ASSERT(isSgTemplateClassDefinition(scope) == NULL);
             }
            else
             {
               if (isSgTemplateMemberFunctionDeclaration(func) != NULL)
                  {
                    ROSE_ASSERT(isSgTemplateClassDefinition(scope) != NULL);
                  }
             }
#endif
       // we don't care if it is member function or function here for a pointer
       // SgFunctionDeclaration* prevDecl = NULL;
          SgDeclarationStatement* prevDecl = NULL;

       // This does not handle the case of a template function declaration.
       // prevDecl = func_symbol->get_declaration();
          if (functionDeclaration != NULL)
             {
#if 0
               printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): Set prevDecl = functionDeclaration \n");
#endif
               prevDecl = functionDeclaration;
             }
            else
             {
               ROSE_ASSERT(templateFunctionDeclaration != NULL);
#if 0
               printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): Set prevDecl = templateFunctionDeclaration \n");
#endif
               prevDecl = templateFunctionDeclaration;
             }

          ROSE_ASSERT(prevDecl != NULL);
#if 0
          printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): prevDecl = %p = %s \n",prevDecl,prevDecl->class_name().c_str());
#endif
#if 0
          if (prevDecl == prevDecl->get_definingDeclaration())
             {
            // The symbol points to a defining declaration and now that we have added a non-defining 
            // declaration we should have the symbol point to the new non-defining declaration.
            // printf ("Switching declaration in functionSymbol to point to the non-defining declaration \n");

#error "DEAD CODE!"

            // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used.
            // func_symbol->set_declaration(func);
               func_symbol->set_declaration(isSgFunctionDeclaration(func));

            // DQ (11/23/2011): Added this test to support debugging the case where SgTemplateFunctionDeclarations is used.
               ROSE_ASSERT(func_symbol->get_declaration() != NULL);
             }
#else
          SgFunctionSymbol *function_symbol = isSgFunctionSymbol(func_symbol);
          if (prevDecl == prevDecl->get_definingDeclaration())
             {
            // The symbol points to a defining declaration and now that we have added a non-defining 
            // declaration we should have the symbol point to the new non-defining declaration.
               printf ("WARNING: Switching declaration in functionSymbol to point to the non-defining declaration \n");
               function_symbol->set_declaration(isSgFunctionDeclaration(func));
               ROSE_ASSERT(function_symbol->get_declaration() != NULL);
             }
#endif

       // If this is the first non-defining declaration then set the associated data member.
          SgDeclarationStatement* nondefiningDeclaration = prevDecl->get_firstNondefiningDeclaration();
          if (nondefiningDeclaration == NULL)
             {
               nondefiningDeclaration = func;
             }

          ROSE_ASSERT(nondefiningDeclaration != NULL);
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_firstNondefiningDeclaration(nondefiningDeclaration = %p)      (to nondefiningDeclaration) \n",func,nondefiningDeclaration);
          printf ("In buildNondefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl->get_definingDeclaration() = %p) (to prevDecl->get_definingDeclaration()) \n",func,prevDecl->get_definingDeclaration());
#endif
       // func->set_firstNondefiningDeclaration(prevDecl->get_firstNondefiningDeclaration());
          func->set_firstNondefiningDeclaration(nondefiningDeclaration);
          func->set_definingDeclaration(prevDecl->get_definingDeclaration());
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): Setting new function (func = %p) to have firstNondefiningDeclaration = %p definingDeclaration = %p \n",func,func->get_firstNondefiningDeclaration(),func->get_definingDeclaration());
#endif
       // DQ (3/8/2012): Added assertion.
          ROSE_ASSERT(nondefiningDeclaration->get_symbol_from_symbol_table() != NULL);

       // DQ (3/8/2012): If this is the redundant function prototype then we have to look
       // at the first defining declaration since only it will have an associated symbol.
       // ROSE_ASSERT(func->get_symbol_from_symbol_table() != NULL);
          if (func->get_symbol_from_symbol_table() == NULL)
             {
               ROSE_ASSERT(nondefiningDeclaration != NULL);
               ROSE_ASSERT(func->get_firstNondefiningDeclaration() == nondefiningDeclaration);
               ROSE_ASSERT(nondefiningDeclaration->get_symbol_from_symbol_table() != NULL);
             }

       // DQ (12/14/2011): Added test.
          ROSE_ASSERT(scope != NULL);
          ROSE_ASSERT(func->get_scope() != NULL);
          ROSE_ASSERT(func->get_scope() == scope);

       // DQ (12/14/2011): Error checking
          SgTemplateInstantiationMemberFunctionDecl* testMemberDecl = isSgTemplateInstantiationMemberFunctionDecl(func);
          if (testMemberDecl != NULL)
             {
               ROSE_ASSERT(testMemberDecl->get_scope() != NULL);
               ROSE_ASSERT(testMemberDecl->get_associatedClassDeclaration() != NULL);
             }

       // DQ (12/18/2011): Testing to debug generation of wrong kind of declaration (symbol not found in correct scope or ...).
          if (isSgFunctionDeclaration(func) == NULL)
             {
            // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.
#if 0
               printf ("In buildNondefiningFunctionDeclaration_T(): Looking up name = %s in scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
#endif
            // DQ (8/12/2013): Added template parameter list.
            // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
            // In this case these are unavailable from this point.
            // DQ (12/18/2011): This fails because the first use of the function causes a non-defining function declaration 
            // to be built and it is built as a template instantiation instead of a template declaration.  So the symbol for
            // the non-defining declaration is put into the correct scope, but as a SgMemberFunctionSymbol instead of as a 
            // SgTemplateSymbol (if it were built as a SgTemplateMemberFunctionDeclaration).  So of course we can't find it 
            // using lookup_template_symbol().
            // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);
            // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);
               ROSE_ASSERT(scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);
             }
        }

     ROSE_ASSERT(func != NULL);

     ROSE_ASSERT(func->get_file_info() == NULL);

  // DQ (3/8/2012): Added assertion.
     ROSE_ASSERT(func->get_firstNondefiningDeclaration() != NULL);
     assert(func_symbol != NULL);
     assert(func_symbol->get_symbol_basis() == func->get_firstNondefiningDeclaration());
     ROSE_ASSERT(func->get_symbol_from_symbol_table() != NULL || func->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() != NULL);

  // DQ (2/24/2009): Delete the old parameter list build by the actualFunction (template argument) constructor.
     ROSE_ASSERT(func->get_parameterList() != NULL);
     delete func->get_parameterList();
     func->set_parameterList(NULL);

  // DQ (9/16/2012): Setup up the template arguments and the parents of the template arguments.
     if (buildTemplateInstantiation == true)
        {
          setTemplateArgumentsInDeclaration(func,templateArgumentsList);
        }

  // DQ (8/10/2013): Setup the template parameters if this is a template declaration.
     if (buildTemplateDeclaration == true)
        {
          setTemplateParametersInDeclaration(func,templateParameterList);
#if 0
          printf ("Exiting as a test! \n");
          ROSE_ASSERT(false);
#endif

       // DQ (8/13/2013): Adding test of template parameter lists.
          SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(func);
          ROSE_ASSERT(templateFunctionDeclaration == NULL || (templateParameterList != NULL && templateParameterList->size() == templateFunctionDeclaration->get_templateParameters().size()));
          SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(func);
          ROSE_ASSERT(templateMemberFunctionDeclaration == NULL || (templateParameterList != NULL && templateParameterList->size() == templateMemberFunctionDeclaration->get_templateParameters().size()));
        }

  // parameter list
  // DQ (11/23/2011): This change allows this to compile for where SgTemplateFunctionDeclarations are used.
  // setParameterList(func, paralist);
  // setParameterList(isSgFunctionDeclaration(func), paralist);
     setParameterList(func, paralist);

     SgInitializedNamePtrList argList = paralist->get_args();
     Rose_STL_Container<SgInitializedName*>::iterator argi;
     for (argi=argList.begin(); argi!=argList.end(); argi++)
        {
       // std::cout<<"patching argument's scope.... "<<std::endl;
          (*argi)->set_scope(scope);

       // DQ (2/23/2009): Also set the declptr (to NULL)
       // (*argi)->set_declptr(NULL);
        }

  // DQ (5/2/2012): Test this to make sure we have SgInitializedNames set properly.
     SageInterface::setSourcePosition(paralist);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
  // Liao 11/21/2012: we should assert no transformation only when the current model is NOT transformation
     if (SourcePositionClassificationMode != e_sourcePositionTransformation)
        {
          detectTransformations_local(paralist);
        }
#endif

  // DQ (12/14/2011): Moved this closer to top of function.
  // TODO double check if there are exceptions
  // func->set_scope(scope);

  // DQ (12/14/2011): Added test.
     ROSE_ASSERT(scope != NULL);
     ROSE_ASSERT(func->get_scope() != NULL);
     ROSE_ASSERT(func->get_scope() == scope);

  // DQ (1/5/2009): This is not always true (should likely use SageBuilder::topScopeStack() instead)
     if (SageBuilder::topScopeStack() != NULL) // This comparison only makes sense when topScopeStack() returns non-NULL value
        {
       // since  stack scope is totally optional in SageBuilder.
          if (scope != SageBuilder::topScopeStack())
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("Warning: SageBuilder::buildNondefiningFunctionDeclaration_T(): scope parameter may not be the same as the topScopeStack() (e.g. for member functions) \n");
#endif
             }
        }

     func->set_parent(scope);

  // DQ (2/21/2009): We can't assert that this is always NULL or non-NULL.
  // ROSE_ASSERT(func->get_definingDeclaration() == NULL);

  // DQ (2/21/2009): Added assertion
     ROSE_ASSERT(func->get_firstNondefiningDeclaration() != NULL);

  // mark as a forward declartion
     func->setForward();

#ifndef ROSE_USE_NEW_EDG_INTERFACE
  // DQ (11/23/2011): Skip this Python specific feature when working with the NEW C++ support (for now).

  // handle decorators
     if (decoratorList != NULL)
        {
          func->set_decoratorList(decoratorList);
          decoratorList->set_parent(func);
        }
#endif

     ROSE_ASSERT(func->get_file_info() == NULL);

  // set File_Info as transformation generated or front end generated
     setSourcePositionAtRootAndAllChildren(func);

     ROSE_ASSERT(func->get_file_info() != NULL);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
  // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.
     if (SourcePositionClassificationMode != e_sourcePositionTransformation)
        {
          detectTransformations_local(func);
        }
#endif

  // printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): generated function func = %p \n",func);

  // Liao 12/2/2010, special handling for Fortran functions and subroutines
     if (SageInterface::is_Fortran_language() == true)
        {
          SgProcedureHeaderStatement * f_func = isSgProcedureHeaderStatement(func);
          ROSE_ASSERT (f_func != NULL);
          if (return_type == buildVoidType())
               f_func->set_subprogram_kind(SgProcedureHeaderStatement::e_subroutine_subprogram_kind);
            else
               f_func->set_subprogram_kind(SgProcedureHeaderStatement::e_function_subprogram_kind);
       
       // hide it from the unparser since fortran prototype func declaration is internally used by ROSE AST 
          f_func->get_startOfConstruct()->unsetOutputInCodeGeneration();
          f_func->get_endOfConstruct()->unsetOutputInCodeGeneration();
          ROSE_ASSERT(f_func->get_startOfConstruct()->isOutputInCodeGeneration() == false);
          ROSE_ASSERT(f_func->get_endOfConstruct()->isOutputInCodeGeneration() == false);
        }

  // DQ (12/11/2011): Added new test.
     ROSE_ASSERT(func->get_firstNondefiningDeclaration() != NULL);
     SgSymbol* symbol_from_first_nondefining_function = func->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol_from_first_nondefining_function != NULL);

  // DQ (12/11/2011): Note that this may be false when func is not the first nondefining declaration.
     if (func != func->get_firstNondefiningDeclaration())
        {
          SgSymbol* symbol_from_nondefining_function = func->get_symbol_from_symbol_table();
          ROSE_ASSERT(symbol_from_nondefining_function == NULL);
        }

  // DQ (12/18/2011): Testing to debug generation of wrong kind of declaration (symbol not found in correct scope or ...).
     if (isSgFunctionDeclaration(func) == NULL)
        {
       // If this is a SgTemplateDeclaration, then we shuld be able to find the name in the associated scope.
#if 0
          printf ("In buildNondefiningFunctionDeclaration_T(): Looking up nameWithTemplateArguments = %s in scope = %p = %s \n",nameWithTemplateArguments.str(),scope,scope->class_name().c_str());
#endif
       // DQ (8/12/2013): Make sure we use the template parameters and the template arguments that are available.
       // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
       // In this case these are unavailable from this point.
       // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
       // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments) != NULL);
       // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,NULL,NULL) != NULL);
       // ROSE_ASSERT(scope->lookup_template_symbol(nameWithTemplateArguments,templateParameterList,NULL) != NULL);
          ROSE_ASSERT(scope->lookup_template_function_symbol(nameWithTemplateArguments,func_type,templateParameterList) != NULL);
        }

  // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).
  // setTemplateNameInTemplateInstantiations(func,name);
     setTemplateNameInTemplateInstantiations(func,nameWithoutTemplateArguments);

#if 0
     printf ("Leaving buildNondefiningFunctionDeclaration_T(): function nameWithTemplateArguments = %s in scope = %p = %s func = %p func->get_firstNondefiningDeclaration() = %p \n",
          nameWithTemplateArguments.str(),scope,scope->class_name().c_str(),func,func->get_firstNondefiningDeclaration());
#endif

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
  // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.
     if (SourcePositionClassificationMode !=e_sourcePositionTransformation) 
        {
          detectTransformations_local(func);
        }
#endif

  // DQ (12/11/2012): Force the two different ways that this can be set to match (we want consistancy).
     if (functionConstVolatileFlags & SgMemberFunctionType::e_restrict)
        {
          func->get_declarationModifier().get_typeModifier().setRestrict();
        }

#if 0
     printf ("[Build Non-defining Funct Tpl] decl = %p, name = %s, type = %p, scope = %p\n", func, func->get_name().getString().c_str(), func->get_type(), scope);
#endif

  // DQ (8/19/2013): Added assertion that is tested and which fails for test_3 of the RoseExample_tests directory (in edgRose.C).
  // This fails for everything.... not sure why...
  // ROSE_ASSERT(func->get_symbol_from_symbol_table() != NULL);

     return func;  
   }


//! Build a prototype for an existing function declaration (defining or nondefining ) 
SgFunctionDeclaration *
SageBuilder::buildNondefiningFunctionDeclaration (const SgFunctionDeclaration* funcdecl, SgScopeStatement* scope/*=NULL*/, SgExprListExp* decoratorList)
{
  ROSE_ASSERT(funcdecl!=NULL);
  SgName name=funcdecl->get_name(); 
  SgFunctionType * funcType = funcdecl->get_type();
  SgType* return_type = funcType->get_return_type();
  SgFunctionParameterList* paralist = deepCopy<SgFunctionParameterList>(funcdecl->get_parameterList());
 
 // make sure the function has consistent function type based on its return type and parameter list
 ROSE_ASSERT (funcType == buildFunctionType(funcdecl->get_type()->get_return_type(), buildFunctionParameterTypeList(funcdecl->get_parameterList())));
#if 0
  // DQ (2/19/2009): Fixed to handle extern "C" state in input "funcdecl"
  // return buildNondefiningFunctionDeclaration(name,return_type,paralist,scope);
  SgFunctionDeclaration* returnFunction = buildNondefiningFunctionDeclaration(name,return_type,paralist,scope,decoratorList);
#endif
  // buildNondefiningFunctionDeclaration() will check if a same function is created before by looking up function symbols.
  SgFunctionDeclaration* returnFunction  = buildNondefiningFunctionDeclaration (name, return_type, paralist, scope, decoratorList, false, NULL);

  returnFunction->set_linkage(funcdecl->get_linkage());
  if (funcdecl->get_declarationModifier().get_storageModifier().isExtern() == true)
  {
    returnFunction->get_declarationModifier().get_storageModifier().setExtern();
  }

  ROSE_ASSERT (returnFunction->get_linkage() == funcdecl->get_linkage());
  ROSE_ASSERT (returnFunction->get_declarationModifier().get_storageModifier().isExtern() ==
               funcdecl->get_declarationModifier().get_storageModifier().isExtern());

  ROSE_ASSERT(returnFunction->get_firstNondefiningDeclaration() != NULL);
  // Make sure that internal references are to the same file (else the symbol table information will not be consistent).
  if (scope != NULL)
  {
    // ROSE_ASSERT(returnFunction->get_parent() != NULL);
    ROSE_ASSERT(returnFunction->get_firstNondefiningDeclaration() != NULL);
    ROSE_ASSERT(TransformationSupport::getSourceFile(returnFunction) == TransformationSupport::getSourceFile(returnFunction->get_firstNondefiningDeclaration()));
    ROSE_ASSERT(TransformationSupport::getSourceFile(returnFunction->get_scope()) == TransformationSupport::getSourceFile(returnFunction->get_firstNondefiningDeclaration()));
  }

  return returnFunction;
}

SgFunctionDeclaration*
SageBuilder::buildNondefiningFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     SgFunctionDeclaration * result = NULL;
     if (SageInterface::is_Fortran_language())
        {
       // result = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList,0);
          result = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, NULL);
        }
       else
        {
       // DQ (11/27/2011): Added support to generate template declarations in the AST (this is part of a common API to make the build functions support more uniform).
          if (buildTemplateInstantiation == true)
             {
            // result = buildNondefiningFunctionDeclaration_T <SgTemplateInstantiationFunctionDecl> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList,0);
               result = buildNondefiningFunctionDeclaration_T <SgTemplateInstantiationFunctionDecl> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, templateArgumentsList, NULL);
             }
            else
             {
            // result = buildNondefiningFunctionDeclaration_T <SgFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList,0);
               result = buildNondefiningFunctionDeclaration_T <SgFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, NULL);
             }
        }

     return result;
   }


// DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).
// We need to decide if the SageBuilder API should include these sorts of functions.
SgFunctionDeclaration*
SageBuilder::buildNondefiningFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList)
   {
     return buildNondefiningFunctionDeclaration (name,return_type,paralist,scope,decoratorList,false,NULL);
   }


// DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).
// We need to decide if the SageBuilder API should include these sorts of functions.
SgMemberFunctionDeclaration*
SageBuilder::buildNondefiningMemberFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)
   {
     unsigned int memberFunctionModifiers = 0;
     return buildNondefiningMemberFunctionDeclaration (name,return_type,paralist,scope,NULL,memberFunctionModifiers,false,NULL);
   }

// DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficient).
// We need to decide if the SageBuilder API should include these sorts of functions.
SgMemberFunctionDeclaration*
SageBuilder::buildDefiningMemberFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)
   {
     unsigned int memberFunctionModifiers = 0;
  // each defining member function decl must have a non-defining counter part now. 11/27/2012, Liao
     SgMemberFunctionDeclaration* nondefining_decl = buildNondefiningMemberFunctionDeclaration (name, return_type, paralist, scope,NULL, memberFunctionModifiers, false, NULL);
     return buildDefiningMemberFunctionDeclaration (name,return_type,paralist,scope,NULL,false,memberFunctionModifiers,nondefining_decl,NULL);
   }


// SgTemplateFunctionDeclaration* SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList)
// SgTemplateFunctionDeclaration* SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateArgumentPtrList* templateArgumentsList)
SgTemplateFunctionDeclaration*
SageBuilder::buildNondefiningTemplateFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateParameterPtrList* templateParameterList)
   {
  // DQ (8/15/2013): Note that we don't need template arguments because teplate functions can't support partial specialization.

  // DQ (11/25/2011): Adding support for template declarations in the AST.

  // DQ (8/7/2013): Added support for template function overloading using template parameters.
  // SgTemplateFunctionDeclaration* result = buildNondefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList,0);
  // SgTemplateFunctionDeclaration* result = buildNondefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL);
  // SgTemplateFunctionDeclaration* result = buildNondefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, templateArgumentsList);
     SgTemplateFunctionDeclaration* result = buildNondefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ false, scope, decoratorList, false, NULL, templateParameterList);

  // DQ (12/12/2011): Added test.
     ROSE_ASSERT(result != NULL);
     if (result->get_symbol_from_symbol_table() == NULL)
        {
          ROSE_ASSERT(result->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT(result != result->get_firstNondefiningDeclaration());
          ROSE_ASSERT(result->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() != NULL);
        }

  // DQ (12/15/2011): We can't inforce this if it is not the first non-defining declaration (but we test for this above).
  // ROSE_ASSERT(result->get_symbol_from_symbol_table() != NULL);

     return result;
   }

SgTemplateFunctionDeclaration*
SageBuilder::buildDefiningTemplateFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgTemplateFunctionDeclaration* first_nondefining_declaration)
   {
  // DQ (12/1/2011): Adding support for template declarations in the AST.

  // DQ (7/31/2013): Added assertions earlier before calling buildDefiningFunctionDeclaration_T<>().
     ROSE_ASSERT(first_nondefining_declaration != NULL);
     ROSE_ASSERT(first_nondefining_declaration->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(first_nondefining_declaration->get_firstNondefiningDeclaration() == first_nondefining_declaration);

  // template <class actualFunction> actualFunction * buildDefiningFunctionDeclaration_T (const SgName & name, SgType* return_type, SgFunctionParameterList * parlist, SgScopeStatement* scope=NULL, SgExprListExp* decoratorList = NULL);
  // SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList,functionConstVolatileFlags);
  // SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList, 0, first_nondefining_declaration);
     SgTemplateFunctionDeclaration* result = buildDefiningFunctionDeclaration_T <SgTemplateFunctionDeclaration> (name,return_type,paralist,/* isMemberFunction = */ false, scope, decoratorList, 0, first_nondefining_declaration, NULL);

     return result;
   }

#ifdef ROSE_USE_NEW_EDG_INTERFACE
SgTemplateMemberFunctionDeclaration*
SageBuilder::buildDefiningTemplateMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList *paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateMemberFunctionDeclaration* first_nondefining_declaration)
   {
  // DQ (12/1/2011): Adding support for template declarations in the AST.

     assert(first_nondefining_declaration->get_firstNondefiningDeclaration() == first_nondefining_declaration);

     SgTemplateMemberFunctionDeclaration* result = buildDefiningFunctionDeclaration_T <SgTemplateMemberFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ true, scope, decoratorList, functionConstVolatileFlags, first_nondefining_declaration, NULL);
     ROSE_ASSERT(result != NULL);

     ROSE_ASSERT(result->get_definition() != NULL);

#if 0
     printf ("This function is not yet finished being implemented in the build API! \n");
     ROSE_ASSERT(false);
#endif

     return result;
   }
#endif


//! Build a prototype for an existing member function declaration (defining or nondefining ) 
SgMemberFunctionDeclaration *
SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgMemberFunctionDeclaration* funcdecl, SgScopeStatement* scope/*=NULL*/, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags)
   {
     ROSE_ASSERT(funcdecl!=NULL);
     SgName name = funcdecl->get_name(); 

  // DQ (2/19/2009): Fixed to handle extern "C" state in input "funcdecl"
  // return buildNondefiningFunctionDeclaration(name,return_type,paralist,scope);
  // SgMemberFunctionDeclaration* returnFunction = buildNondefiningMemberFunctionDeclaration(name,return_type,paralist,scope,decoratorList);

#if 1
// DQ (7/26/2012): I am at least temporarily removing this function from the API.
// Later if we need it, we can update it to reflect that passing of the new 
// SgTemplateArgumentPtrList function parameter (part of the new API design).

   SgMemberFunctionDeclaration* returnFunction = NULL;
   printf ("Error: buildNondefiningMemberFunctionDeclaration(): This function should not be used! \n");
   ROSE_ASSERT(false);
#else
     SgFunctionType * funcType = funcdecl->get_type();
     SgType* return_type = funcType->get_return_type();
     SgFunctionParameterList* paralist = deepCopy<SgFunctionParameterList>(funcdecl->get_parameterList());
     SgMemberFunctionDeclaration* returnFunction = buildNondefiningMemberFunctionDeclaration(name,return_type,paralist,scope,decoratorList,functionConstVolatileFlags);
#endif

     returnFunction->set_linkage(funcdecl->get_linkage());

     if (funcdecl->get_declarationModifier().get_storageModifier().isExtern() == true)
        {
          returnFunction->get_declarationModifier().get_storageModifier().setExtern();
        }

  // DQ (2/26/2009): Make this consistant with the non-member functions.
  // ROSE_ASSERT(returnFunction->get_definingDeclaration() == NULL);
     ROSE_ASSERT(returnFunction->get_firstNondefiningDeclaration() != NULL);

     return returnFunction;
   }

SgMemberFunctionDeclaration*
SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, 
   SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // This function builds either a SgMemberFunctionDeclaration (non-template; normal member function) or a SgTemplateInstantiationMemberFunctionDecl (template instantiation).

  // DQ (11/27/2011): Added support for instations of template member functions.
  // SgMemberFunctionDeclaration * result = buildNondefiningFunctionDeclaration_T <SgMemberFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags);
     SgMemberFunctionDeclaration * result = NULL;

#if 0
     printf ("In buildNondefiningMemberFunctionDeclaration(): buildTemplateInstantiation = %s \n",buildTemplateInstantiation ? "true" : "false");
#endif

     if (buildTemplateInstantiation == true)
        {
       // This is how we build an instantiation of a template (SgTemplateInstantiationMemberFunctionDecl).
          result = buildNondefiningFunctionDeclaration_T <SgTemplateInstantiationMemberFunctionDecl> (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,templateArgumentsList,NULL);
        }
       else
        {
       // This is a non-template instatiation (normal member function).
          result = buildNondefiningFunctionDeclaration_T <SgMemberFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,NULL,NULL);
        }
     ROSE_ASSERT(result != NULL);

  // set definingdecl for SgCtorInitializerList
     SgCtorInitializerList* ctor = result->get_CtorInitializerList();
     ROSE_ASSERT(ctor != NULL);

  // required in AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()
     ctor->set_definingDeclaration(ctor);
     ctor->set_firstNondefiningDeclaration(ctor);

  // DQ (1/4/2009): Error checking
     ROSE_ASSERT(result->get_associatedClassDeclaration() != NULL);

     if (result->get_associatedClassDeclaration() == NULL)
        {
          printf ("Warning, must set the SgMemberFunctionDeclaration::associatedClassDeclaration \n");

          ROSE_ASSERT(scope != NULL);
          SgClassDefinition* classDefinition = isSgClassDefinition(scope);
          ROSE_ASSERT(classDefinition != NULL);
          SgDeclarationStatement* associatedDeclaration = classDefinition->get_declaration();
          ROSE_ASSERT(associatedDeclaration != NULL);
          SgClassDeclaration* associatedClassDeclaration = isSgClassDeclaration(associatedDeclaration);

       // DQ (1/4/2009): This needs to be set, checked in AstConsistencyTests.C!
          result->set_associatedClassDeclaration(associatedClassDeclaration);
        }

     return result;
   }


// DQ (8/12/2013): This function needs to handle the SgTemplateParameterPtrList (since it is generating a template).
// It need not take a SgTemplateArgumentPtrList because template functions (including template member functions) can not support partial specialization.
// SgTemplateMemberFunctionDeclaration* SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags)
SgTemplateMemberFunctionDeclaration*
SageBuilder::buildNondefiningTemplateMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, SgTemplateParameterPtrList* templateParameterList)
   {
  // This function only builds template member function declarations.

  // SgTemplateMemberFunctionDeclaration * result = buildNondefiningFunctionDeclaration_T <SgTemplateMemberFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,NULL,NULL);
     SgTemplateMemberFunctionDeclaration * result = buildNondefiningFunctionDeclaration_T <SgTemplateMemberFunctionDeclaration> (name,return_type,paralist, /* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,NULL,templateParameterList);

  // set definingdecl for SgCtorInitializerList
     ROSE_ASSERT(result != NULL);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
  // DQ (5/1/2012): Make sure that we don't have IR nodes marked as translformations.
     if (SourcePositionClassificationMode != e_sourcePositionTransformation) 
        {
          detectTransformations_local(result);
        }
#endif

#if 0
     printf ("After calling buildNondefiningFunctionDeclaration_T <SgTemplateMemberFunctionDeclaration>: result = %p = %s \n",result,result->class_name().c_str());
#endif

  // DQ (8/12/2013): Added template paremter list to call to get the function template symbol.
  // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
  // In this case these are unavailable from this point.
  // SgSymbol* associatedSymbol = scope->lookup_template_member_function_symbol(name,result->get_type());
  // SgSymbol* associatedSymbol = scope->lookup_template_member_function_symbol(name,result->get_type(),NULL);
     SgSymbol* associatedSymbol = scope->lookup_template_member_function_symbol(name,result->get_type(),templateParameterList);
     if (associatedSymbol == NULL)
        {
          printf ("ERROR: associatedSymbol == NULL \n");
          printf ("   --- result = %p = %s \n",result,result->class_name().c_str());
          printf ("   --- scope = %p = %s \n",scope,scope->class_name().c_str());
          printf ("   --- name = %s \n",name.str());
          printf ("   --- result->get_type() = %p = %s \n",result->get_type(),result->get_type()->class_name().c_str());
          printf ("   --- result->get_type()->get_mangled() = %s \n",result->get_type()->get_mangled().str());
       }
     ROSE_ASSERT(associatedSymbol != NULL);

#if 1
     SgCtorInitializerList * ctor = result->get_CtorInitializerList();
     ROSE_ASSERT(ctor != NULL);
  // required ty AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()
     ctor->set_definingDeclaration(ctor);
     ctor->set_firstNondefiningDeclaration(ctor);

#if 0
  // DQ (11/25/2011): I don't know if the SgTemplateMemberFunctionDeclaration needs this support!

  // DQ (1/4/2009): Error checking 
     ROSE_ASSERT(result->get_associatedClassDeclaration() != NULL);

     if (result->get_associatedClassDeclaration() == NULL)
        {
          printf ("Warning, must set the SgMemberFunctionDeclaration::associatedClassDeclaration \n");

          ROSE_ASSERT(scope != NULL);
          SgClassDefinition* classDefinition = isSgClassDefinition(scope);
          ROSE_ASSERT(classDefinition != NULL);
          SgDeclarationStatement* associatedDeclaration = classDefinition->get_declaration();
          ROSE_ASSERT(associatedDeclaration != NULL);
          SgClassDeclaration* associatedClassDeclaration = isSgClassDeclaration(associatedDeclaration);

       // DQ (1/4/2009): This needs to be set, checked in AstConsistencyTests.C!
          result->set_associatedClassDeclaration(associatedClassDeclaration);
        }
#endif

#else
     printf ("Error: incomplete implementation of buildNondefiningTemplateMemberFunctionDeclaration() \n");
     ROSE_ASSERT(false);
#endif

  // DQ (12/11/2011): Added new test (also at the base of buildNondefiningFunctionDeclaration_T<>() function).
     ROSE_ASSERT(result->get_firstNondefiningDeclaration() != NULL);
     SgSymbol* symbol_from_first_nondefining_function = result->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol_from_first_nondefining_function != NULL);

  // DQ (12/11/2011): Note that this may be false when func is not the first nondefining declaration.
     if (result != result->get_firstNondefiningDeclaration())
        {
          SgSymbol* symbol_from_nondefining_function = result->get_symbol_from_symbol_table();
          ROSE_ASSERT(symbol_from_nondefining_function == NULL);
        }

#if 0
     printf ("In buildNondefiningTemplateMemberFunctionDeclaration(): Looking up name = %s in scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
#endif

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_SYMBOL_TABLE_LOOKUP
  // DQ (7/31/2013): Fixing API to use functions that now require template parameters and template specialization arguments.
  // In this case these are unavailable from this point.
  // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
  // if (scope->lookup_template_member_function_symbol(name,result->get_type()) == NULL)
  // if (scope->lookup_template_member_function_symbol(name,result->get_type(),NULL,NULL) == NULL)
     if (scope->lookup_template_member_function_symbol(name,result->get_type(),templateParameterList) == NULL)
        {
          printf ("Error: scope->lookup_template_member_function_symbol(name,result->get_type()) == NULL (investigate this) \n");
          printf ("--- function name = %s in scope = %p = %s result->get_type() = %p = %s \n",name.str(),scope,scope->class_name().c_str(),result->get_type(),result->get_type()->class_name().c_str());
          scope->get_symbol_table()->print("Error: scope->lookup_template_member_function_symbol(name,result->get_type()) == NULL (investigate this)");
        }
#endif
  // ROSE_ASSERT(scope->lookup_template_member_function_symbol(name,result->get_type()) != NULL);
  // ROSE_ASSERT(scope->lookup_template_member_function_symbol(name,result->get_type(),NULL) != NULL);
     ROSE_ASSERT(scope->lookup_template_member_function_symbol(name,result->get_type(),templateParameterList) != NULL);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
  // DQ (5/1/2012): Make sure that we don't have IR nodes marked as transformations.
     if (SourcePositionClassificationMode != e_sourcePositionTransformation)
        {
          detectTransformations_local(result);
        }
#endif

     return result;
   }

#if 0
SgMemberFunctionDeclaration*
SageBuilder::buildNondefiningMemberFunctionDeclaration (const SgName & name, SgMemberFunctionType* func_type, SgFunctionParameterList* paralist, SgScopeStatement* scope)
   {
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

     ROSE_ASSERT(name.is_null() == false);
     ROSE_ASSERT(func_type != NULL);

     SgClassDefinition *struct_name = isSgClassDefinition(scope);
     ROSE_ASSERT(struct_name != NULL);


  // function declaration
     SgMemberFunctionDeclaration* func = NULL;

  // search before using the function type to create the function declaration 
  // TODO only search current scope or all ancestor scope??
  // We don't have lookup_member_function_symbol  yet
  // SgFunctionSymbol *func_symbol = scope->lookup_function_symbol(name,func_type);
     SgFunctionSymbol *func_symbol = NULL;
     if (scope != NULL)
          func_symbol = scope->lookup_function_symbol(name,func_type);

  // printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p \n",scope,func_symbol);
     if (func_symbol == NULL)
        {
       // first prototype declaration
          func = new SgMemberFunctionDeclaration (name,func_type,NULL);
          ROSE_ASSERT(func != NULL);

       // NOTE: we want to allow the input scope to be NULL (and even the SageBuilder::topScopeStack() == NULL)
       // so that function can be built bottom up style.  However this means that the symbol tables in the 
       // scope of the returned function declaration will have to be setup separately.
          if (scope != NULL)
             {
            // function symbol table
               func_symbol = new SgMemberFunctionSymbol(func);

            // printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): scope = %p func_symbol = %p = %s = %s \n",scope,func_symbol,func_symbol->class_name().c_str(),SageInterface::get_name(func_symbol).c_str());
               ROSE_ASSERT(func_symbol != NULL);

               scope->insert_symbol(name, func_symbol);

            // ROSE_ASSERT(scope->lookup_function_symbol(name,func_type) != NULL);

            // DQ (2/26/2009): uncommented assertion.
               ROSE_ASSERT(scope->lookup_function_symbol(name) != NULL); // Did not pass for member function? Should we have used the mangled name?
             }

          func->set_firstNondefiningDeclaration(func);
          func->set_definingDeclaration(NULL);

          ROSE_ASSERT(func->get_definingDeclaration() == NULL);
        }
       else 
        {
          ROSE_ASSERT(scope != NULL);

       // 2nd, or 3rd... prototype declaration
       // reuse function type, function symbol of previous declaration

       // std::cout<<"debug:SageBuilder.C: 267: "<<"found func_symbol!"<<std::endl;
       // delete (func_type-> get_argument_list ());
       // delete func_type; // bug 189
   
          func_type = isSgMemberFunctionType(func_symbol->get_declaration()->get_type());
          func = new SgMemberFunctionDeclaration(name,func_type,NULL);
          ROSE_ASSERT(func);
   
       // we don't care if it is member function or function here for a pointer
          SgFunctionDeclaration* prevDecl = NULL;
          prevDecl = func_symbol->get_declaration();
          ROSE_ASSERT(prevDecl != NULL);

       // printf ("In SageBuilder::buildNondefiningFunctionDeclaration_T(): prevDecl = %p \n",prevDecl);

          if (prevDecl == prevDecl->get_definingDeclaration())
             {
            // The symbol points to a defining declaration and now that we have added a non-defining 
            // declaration we should have the symbol point to the new non-defining declaration.
            // printf ("Switching declaration in functionSymbol to point to the non-defining declaration \n");

               func_symbol->set_declaration(func);
             }

       // If this is the first non-defining declaration then set the associated data member.
          SgDeclarationStatement* nondefiningDeclaration = prevDecl->get_firstNondefiningDeclaration();
          if (nondefiningDeclaration == NULL)
             {
               nondefiningDeclaration = func;
             }

          ROSE_ASSERT(nondefiningDeclaration != NULL);

       // func->set_firstNondefiningDeclaration(prevDecl->get_firstNondefiningDeclaration());
          func->set_firstNondefiningDeclaration(nondefiningDeclaration);
          func->set_definingDeclaration(prevDecl->get_definingDeclaration());
        }

  // parameter list
     //SgFunctionParameterList* paralist = buildFunctionParameterList(func_type->get_argument_list());
     setParameterList(func, paralist);

     SgInitializedNamePtrList argList = paralist->get_args();
     Rose_STL_Container<SgInitializedName*>::iterator argi;
     for(argi=argList.begin(); argi!=argList.end(); argi++)
        {
       // std::cout<<"patching argument's scope.... "<<std::endl;
          (*argi)->set_scope(scope);

       // DQ (2/23/2009): Also set the declptr (to NULL)
       // (*argi)->set_declptr(NULL);
        }
  // TODO double check if there are exceptions
     func->set_scope(scope);

     // DQ (1/5/2009): This is not always true (should likely use SageBuilder::topScopeStack() instead)
     if (SageBuilder::topScopeStack()!= NULL) // This comparison only makes sense when topScopeStack() returns non-NULL value
        {
       // Since stack scope is totally optional in SageBuilder.
          if (scope != SageBuilder::topScopeStack())
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("Warning: SageBuilder::buildNondefiningFunctionDeclaration_T(): scope parameter may not be the same as the topScopeStack() (e.g. for member functions) \n");
#endif
             }
        }

     func->set_parent(scope);

  // DQ (2/21/2009): We can't assert that this is always NULL or non-NULL.
  // ROSE_ASSERT(func->get_definingDeclaration() == NULL);

  // DQ (2/21/2009): Added assertion
     ROSE_ASSERT(func->get_firstNondefiningDeclaration() != NULL);

  // mark as a forward declartion
     func->setForward();

  // set File_Info as transformation generated
     setSourcePositionAtRootAndAllChildren(func);

     return func;  
   }
#endif

#if 1
// DQ (8/29/2012): This is re-enabled because the backstroke project is using it.
// DQ (7/26/2012): I would like to remove this from the API (at least for now while debugging the newer API required for template argument handling).
SgMemberFunctionDeclaration*
SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName & name, SgMemberFunctionType* func_type, SgScopeStatement* scope, SgExprListExp* decoratorList, SgMemberFunctionDeclaration* first_nondefining_declaration)
   {
     SgType* return_type = func_type->get_return_type();
     SgFunctionParameterList* paralist = buildFunctionParameterList(func_type->get_argument_list());

     bool buildTemplateInstantiation         = false;
     unsigned int functionConstVolatileFlags = 0;
     SgTemplateArgumentPtrList* templateArgumentsList = NULL;

     return SageBuilder::buildDefiningMemberFunctionDeclaration(name, return_type, paralist, scope, decoratorList, buildTemplateInstantiation, functionConstVolatileFlags, first_nondefining_declaration, templateArgumentsList);
   }
#endif

#if 0
// DQ (7/26/2012): I would like to remove this from the API (at least for now while debugging the newer API required for template argument handling).

// DQ (5/12/2012): This interferes with the other function:
// SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration)
// Once the default arguments are removed.
// Comment this out for now.  this might be one too many API functions anyway.

SgMemberFunctionDeclaration*
SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName & name, SgMemberFunctionType* func_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, SgMemberFunctionDeclaration* first_nondefining_declaration)
{
  if (scope == NULL)
    scope = SageBuilder::topScopeStack();
  ROSE_ASSERT(scope != NULL);
  ROSE_ASSERT(name.is_null() == false);
  ROSE_ASSERT(func_type != NULL);

  SgMemberFunctionDeclaration * func;

 //  symbol table and non-defining 
  SgMemberFunctionSymbol *func_symbol = isSgMemberFunctionSymbol(scope->lookup_function_symbol(name,func_type));
  if (func_symbol == NULL)
  {
    // new defining declaration
//    func = new SgFunctionDeclaration(name,func_type,NULL);
    func = new SgMemberFunctionDeclaration(name,func_type,NULL);
    ROSE_ASSERT(func);
    SgMemberFunctionSymbol *func_symbol = new SgMemberFunctionSymbol(func);
    scope->insert_symbol(name, func_symbol);
    func->set_firstNondefiningDeclaration(NULL);
  } else
  {
    // defining declaration after nondefining declaration
    //reuse function type, function symbol

//    delete func_type;// bug 189

    // Cong (10/25/2010): Make sure in this situation there is no defining declaration for this symbol.
    //ROSE_ASSERT(func_symbol->get_declaration()->get_definingDeclaration() == NULL);

    func_type = isSgMemberFunctionType(func_symbol->get_declaration()->get_type());
    //func = new SgFunctionDeclaration(name,func_type,NULL);
    func = new SgMemberFunctionDeclaration(name,func_type,NULL);
    ROSE_ASSERT(func);

    func->set_firstNondefiningDeclaration(func_symbol->get_declaration()->get_firstNondefiningDeclaration());

    // fix up defining declarations before current statement
    func_symbol->get_declaration()->set_definingDeclaration(func);
    //for the rare case that two or more prototype declaration exist
    // cannot do anything until append/prepend_statment() is invoked
  }

  // handle decorators
  if (decoratorList != NULL)
  {
      func->set_decoratorList(decoratorList);
      decoratorList->set_parent(func);
  }

  // definingDeclaration 
  func->set_definingDeclaration(func);

  // function body and definition are created before setting argument list 
  SgBasicBlock * func_body = new SgBasicBlock();
  ROSE_ASSERT(func_body);
  SgFunctionDefinition * func_def = new SgFunctionDefinition(func,func_body);
  ROSE_ASSERT(func_def);

  // DQ (11/28/2010): Added specification of case insensitivity (e.g. Fortran).
  if (symbol_table_case_insensitive_semantics == true)
     {
       func_def->setCaseInsensitive(true);
       func_body->setCaseInsensitive(true);
     }

  func_def->set_parent(func);
  func_def->set_body(func_body);
  func_body->set_parent(func_def);

   // parameter list,
   //TODO consider the difference between C++ and Fortran
  //SgFunctionParameterList* paralist = buildFunctionParameterList(func_type->get_argument_list());
  setParameterList(func,paralist);
         // fixup the scope and symbol of arguments,
  SgInitializedNamePtrList& argList = paralist->get_args();
  Rose_STL_Container<SgInitializedName*>::iterator argi;
  for(argi=argList.begin(); argi!=argList.end(); argi++)
  {
//    std::cout<<"patching defining function argument's scope and symbol.... "<<std::endl;
    (*argi)->set_scope(func_def);
    func_def->insert_symbol((*argi)->get_name(), new SgVariableSymbol(*argi) );
  }

  func->set_parent(scope);
  func->set_scope(scope);

  // set File_Info as transformation generated
  setSourcePositionAtRootAndAllChildren(func);
  return func;
}
#endif


// SgMemberFunctionDeclaration* SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration)
SgMemberFunctionDeclaration*
SageBuilder::buildDefiningMemberFunctionDeclaration (const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, unsigned int functionConstVolatileFlags, SgMemberFunctionDeclaration* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)
   {

#if 0
     SgMemberFunctionDeclaration * result = buildDefiningFunctionDeclaration_T <SgMemberFunctionDeclaration> (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList);

  // DQ (12/1/2011): This API is not yet supported for member function template instantiations.
  // ROSE_ASSERT(buildTemplateInstantiation == false);
     if (buildTemplateInstantiation == true)
        {
       // DQ (12/18/2011): I can't think of what more might be required here, but there may be something missing.
          printf ("WARNING: In buildDefiningMemberFunctionDeclaration(): Case of buildTemplateInstantiation == true may be incomplete \n");

          ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result) != NULL);
        }
#else
  // DQ (12/18/2011): Need to build a SgTemplateInstantiationMemberFunctionDecl when buildTemplateInstantiation == true
     SgMemberFunctionDeclaration * result = NULL;
     if (buildTemplateInstantiation == true)
        {
       // SgTemplateArgumentPtrList emptyList;
       // nondefdecl = new SgTemplateInstantiationMemberFunctionDecl(name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList);
          SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(first_nondefining_declaration);
          ROSE_ASSERT(templateInstantiationMemberFunctionDecl != NULL);

#if 1
       // DQ (1/26/2013): Added test failing in buildDefiningFunctionDeclaration_T().
             {
               ROSE_ASSERT(templateArgumentsList != NULL);
               string nameWithoutTemplateArguments = name;
               string nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);
               SgMemberFunctionType* func_type = isSgMemberFunctionType(first_nondefining_declaration->get_type());
               ROSE_ASSERT(func_type != NULL);

            // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.
            // SgSymbol* func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<SgTemplateInstantiationMemberFunctionDecl>(nameWithTemplateArguments,func_type);
            // SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<SgTemplateInstantiationMemberFunctionDecl>(nameWithTemplateArguments,func_type);
            // SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<SgTemplateInstantiationMemberFunctionDecl>(nameWithTemplateArguments,func_type,NULL);
               SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<SgTemplateInstantiationMemberFunctionDecl>(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);
               if (func_symbol == NULL)
                  {
                    printf ("ERROR caught in SageBuilder::buildDefiningMemberFunctionDeclaration(): nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n",nameWithTemplateArguments.c_str(),buildTemplateInstantiation ? "true:" : "false");
                    printf ("ERROR caught in SageBuilder::buildDefiningMemberFunctionDeclaration(): func_symbol == NULL for first_nondefining_declaration = %p = %s and func_type = %p = %s \n",
                         templateInstantiationMemberFunctionDecl,templateInstantiationMemberFunctionDecl->class_name().c_str(),func_type,func_type->class_name().c_str());
                  }
            // ROSE_ASSERT(func_symbol != NULL);
             }
#endif

       // result = buildDefiningFunctionDeclaration_T <SgTemplateInstantiationMemberFunctionDecl> (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,templateInstantiationMemberFunctionDecl);
          result = buildDefiningFunctionDeclaration_T <SgTemplateInstantiationMemberFunctionDecl> (name, return_type, paralist, /* isMemberFunction = */ true, scope, decoratorList, functionConstVolatileFlags, templateInstantiationMemberFunctionDecl, templateArgumentsList);
#if 0
          printf ("In SageBuilder::buildDefiningMemberFunctionDeclaration(): isSgTemplateInstantiationMemberFunctionDecl(result)->get_templateName() = %s \n",isSgTemplateInstantiationMemberFunctionDecl(result)->get_templateName().str());
#endif
          ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result) != NULL);
          ROSE_ASSERT(isSgTemplateInstantiationMemberFunctionDecl(result)->get_templateName().is_null() == false);
        }
       else
        {
          ROSE_ASSERT(first_nondefining_declaration != NULL);

       // DQ (12/27/20134): Added these to permit testing earlier than in the buildDefiningFunctionDeclaration_T() function.
          ROSE_ASSERT(first_nondefining_declaration->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT(first_nondefining_declaration->get_firstNondefiningDeclaration() == first_nondefining_declaration);

          result = buildDefiningFunctionDeclaration_T <SgMemberFunctionDeclaration> (name,return_type,paralist,/* isMemberFunction = */ true,scope,decoratorList,functionConstVolatileFlags,first_nondefining_declaration, NULL);
        }
#endif

     ROSE_ASSERT(result != NULL);

  // set definingdecl for SgCtorInitializerList
     SgCtorInitializerList* ctor = result->get_CtorInitializerList();
     ROSE_ASSERT(ctor != NULL);

  // required ty AstConsistencyTests.C:TestAstForProperlySetDefiningAndNondefiningDeclarations()
     ctor->set_definingDeclaration(ctor);
     ctor->set_firstNondefiningDeclaration(ctor);

  // DQ (1/4/2009): Error checking
     ROSE_ASSERT(result->get_associatedClassDeclaration() != NULL);
#if 0
     printf ("Looking up name = %s in scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
  // ROSE_ASSERT(scope->lookup_template_symbol(name) != NULL);
     ROSE_ASSERT(scope->lookup_template_symbol(name,templateParameterList) != NULL);
#endif

     return result;
   }


//----------------- defining function declaration------------
// a template builder for all kinds of defining SgFunctionDeclaration
// handle common chores for function type, symbol, paramter etc.

template <class actualFunction>
actualFunction*
SageBuilder::buildDefiningFunctionDeclaration_T(const SgName & XXX_name, SgType* return_type, SgFunctionParameterList* paralist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, unsigned int functionConstVolatileFlags, actualFunction* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // Note that the semantics of this function now differs from that of the buildDefiningClassDeclaration().
  // We want to have the non-defining declaration already exist before calling this function.
  // We could still build a higher level function that built both together.  Or we could provide two versions
  // named differently (from this one) and depricate this function...which I like much better.

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
     printf ("WARNING: This function for building defining function declarations has different semantics from that of the function to build defining class declarations. \n");
#endif

     assert(first_nondefining_declaration != NULL);
     assert(first_nondefining_declaration->get_firstNondefiningDeclaration() != NULL);
     assert(first_nondefining_declaration->get_firstNondefiningDeclaration() == first_nondefining_declaration);

     if (scope == NULL)
        {
          scope = SageBuilder::topScopeStack();
        }

     ROSE_ASSERT(XXX_name.is_null() == false);
     ROSE_ASSERT(scope != NULL);
     ROSE_ASSERT(return_type != NULL);

     SgName nameWithoutTemplateArguments = XXX_name;
     SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;

     bool buildTemplateInstantiation = ((VariantT)actualFunction::static_variant == V_SgTemplateInstantiationFunctionDecl || (VariantT)actualFunction::static_variant == V_SgTemplateInstantiationMemberFunctionDecl);

  // DQ (8/7/2013): Added support for template declarations.
     bool buildTemplateDeclaration   = ((VariantT)actualFunction::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)actualFunction::static_variant == V_SgTemplateMemberFunctionDeclaration);

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): buildTemplateInstantiation = %s \n",buildTemplateInstantiation ? "true" : "false");
#endif

  // DQ (8/11/2013): Check that the template argument lists are consistant.  The templateArgumentsList can then be considered redundant if this works.
     if (buildTemplateInstantiation == true)
        {
          ROSE_ASSERT(templateArgumentsList != NULL);

          SgTemplateArgumentPtrList & templateArgumentsList_from_first_nondefining_declaration = (isMemberFunction == false) ? 
               isSgTemplateInstantiationFunctionDecl(first_nondefining_declaration)->get_templateArguments() :
               isSgTemplateInstantiationMemberFunctionDecl(first_nondefining_declaration)->get_templateArguments();

          ROSE_ASSERT(*templateArgumentsList == templateArgumentsList_from_first_nondefining_declaration);
        }

     SgTemplateParameterPtrList* templateParameterList = NULL;
     if (buildTemplateDeclaration == true)
        {
       // DQ (8/11/2013): Since this is not passed in so we can access it but not assert its equivalence with a redundant input parameter.
          templateParameterList = (isMemberFunction == false) ?
               &(isSgTemplateFunctionDeclaration(first_nondefining_declaration)->get_templateParameters()) :
               &(isSgTemplateMemberFunctionDeclaration(first_nondefining_declaration)->get_templateParameters());

          ROSE_ASSERT(templateArgumentsList == NULL);
          ROSE_ASSERT(templateParameterList != NULL);
#if 0
          if (templateParameterList != NULL)
             {
                ROSE_ASSERT(templateArgumentsList == NULL);
             }
          ROSE_ASSERT(templateParameterList == NULL || templateParameterList->size() == templateArgumentsList->size());
#endif
        }

     if (buildTemplateInstantiation == true)
        {
          ROSE_ASSERT(templateArgumentsList != NULL);
          nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);
#if 0
          printf ("Building a defining function: buildDefiningFunctionDeclaration_nfi() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n",nameWithTemplateArguments.str(),buildTemplateInstantiation ? "true:" : "false");
#endif

          if (nameWithTemplateArguments == "insert < __normal_iterator< SgInitializedName ** , __type  >  > ")
             {
               printf ("In buildDefiningFunctionDeclaration_T(): Found function nameWithTemplateArguments = %s \n",nameWithTemplateArguments.str());
             }
        }

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): nameWithTemplateArguments = %s \n",nameWithTemplateArguments.str());
#endif

     ROSE_ASSERT(nameWithoutTemplateArguments.is_null() == false);
     ROSE_ASSERT(nameWithTemplateArguments.is_null() == false);

  // DQ (12/3/2011): Added more checking.
     ROSE_ASSERT(paralist != NULL);

     if (SageInterface::is_Python_language() == false)
        {
          ROSE_ASSERT(scope->containsOnlyDeclarations());
        }

  // actualFunction* firstNondefiningFunctionDeclaration = NULL;
     actualFunction* defining_func = NULL;

  // build function type, manage function type symbol internally
  // SgFunctionType* func_type = buildFunctionType(return_type,paralist);
     SgFunctionType* func_type = NULL;

  // DQ (5/11/2012): Enforce this so that we can avoid building the function type (be reusing the function type of the first non-defining declaration).
  // This is a special problem for templates because the function parameters will evaluate different for different builds of the same template.
  // This is a problem for test2012_74.C (and a dozen other test codes that make use of STL).
     ROSE_ASSERT(first_nondefining_declaration != NULL);

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): isMemberFunction = %s \n",isMemberFunction ? "true" : "false");
#endif

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
  // DQ (7/27/2012): There are reasons why this can fail: e.g. for functions with names such as:
  // "operator std::auto_ptr_ref<_Tp1>" which is a user defined conversion operator to one class from another.
  // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);

#if 1
  // DQ (5/12/2012): Use the newly added parameter to get the exact SgFunctionType used to build the symbol.
  // This should make the template handling more robust since we were sometimes using types that had different
  // levels of template instantiation between the non-definng and defining function declarations and this 
  // caused symbols build to support the non-defining declaration to not be found when we searched for them
  // using the function type built for the defining declaration.  We want the function types for all defining
  // and non-defining declarations to be identical.  This define also means that we don't have to build a 
  // SgFunctionType just to look up a symbol in the symbol table (which was always silly).  However, only 
  // the defining function declaration can use the existing function type because it is required that a
  // non-defining declaration exist prior to the construction of the defining declaration (built by this 
  // function).
     func_type = first_nondefining_declaration->get_type();
#else
     if (isMemberFunction == true)
        {
#if 0
          printf ("return_type = %p = %s \n",return_type,return_type->class_name().c_str());
#endif
          ROSE_ASSERT(isSgClassDefinition(scope) != NULL);
       // func_type = buildMemberFunctionType(return_type,paralist,isSgClassDefinition(scope),0);
          func_type = buildMemberFunctionType(return_type,paralist,isSgClassDefinition(scope),functionConstVolatileFlags);
        }
       else
        {
          func_type = buildFunctionType(return_type,paralist);
        }
#endif
     ROSE_ASSERT(func_type != NULL);

  // Make sure these are the same (this will fail until we generate the func_type directly from first_nondefining_declaration).
     ROSE_ASSERT(func_type == first_nondefining_declaration->get_type());

     SgDeclarationStatement* firstNondefiningFunctionDeclaration = NULL;

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): scope     = %p = %s \n",scope,scope->class_name().c_str());
     printf ("In buildDefiningFunctionDeclaration_T(): func_type = %p = %s \n",func_type,func_type->class_name().c_str());
     printf ("In buildDefiningFunctionDeclaration_T(): Looking for function in symbol table with nameWithTemplateArguments = %s \n",nameWithTemplateArguments.str());
#endif

  // symbol table and non-defining 
  // SgFunctionSymbol *func_symbol = scope->lookup_function_symbol(name,func_type);
  // SgSymbol* func_symbol = scope->lookup_function_symbol(name,func_type);

     ROSE_ASSERT(scope != NULL);
  // ROSE_ASSERT(scope->get_symbol_table() != NULL);

  // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.
  // SgSymbol* func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(name,func_type);
  // SgSymbol* func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
  // SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
  // SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);
     SgSymbol* func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);

#if 0
     if (func_symbol == NULL)
        {
          printf ("In buildDefiningFunctionDeclaration_T(): could not find function symbol for name = %s \n",name.str());

       // Look for the template function
       // func_symbol = scope->lookup_template_symbol(name,func_type);
       // func_symbol = scope->lookup_template_symbol(name);

#error "DEAD CODE!"

       // DQ (3/10/2012): Fix this to call lookup_template_function_symbol() instead.
       // func_symbol = scope->lookup_template_symbol(name);
          func_symbol = scope->lookup_template_function_symbol(name,func_type);

          if (func_symbol == NULL)
             {
               printf ("In buildDefiningFunctionDeclaration_T(): could not find template symbol for name = %s \n",name.str());
             }
          ROSE_ASSERT(func_symbol != NULL);
        }
#else
  // DQ (5/10/2012): This is a failing assertion, I'm not sure that we can enforce this in general (see test2004_149.C).
  // DQ (3/13/2012): Note that this function building a defining declaration can enforce that the non-defining declaration has already build a proper symbol.
     if (func_symbol == NULL)
        {
          printf ("In buildDefiningFunctionDeclaration_T(): func_symbol == NULL We can't assume that the symbol already exists. \n");

          printf ("In buildDefiningFunctionDeclaration_T(): nameWithTemplateArguments = %s \n",nameWithTemplateArguments.str());
          printf ("In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration = %p = %s \n",
               first_nondefining_declaration,first_nondefining_declaration->class_name().c_str());

          printf ("In buildDefiningFunctionDeclaration_T(): scope                    = %p = %s \n",scope,scope->class_name().c_str());
          printf ("In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration->get_scope() = %p = %s \n",
               first_nondefining_declaration->get_scope(),first_nondefining_declaration->get_scope()->class_name().c_str());

          printf ("In buildDefiningFunctionDeclaration_T(): func_type                = %p = %s \n",func_type,func_type->class_name().c_str());
          printf ("In buildDefiningFunctionDeclaration_T(): first_nondefining_declaration->get_type() = %p = %s \n",
               first_nondefining_declaration->get_type(),first_nondefining_declaration->get_type()->class_name().c_str());

          printf ("In buildDefiningFunctionDeclaration_T(): func_type->get_mangled() = %s \n",func_type->get_mangled().str());
          printf ("In buildDefiningFunctionDeclaration_T(): Looking for function in symbol table with name = %s \n",nameWithTemplateArguments.str());

#if 0
          scope->get_symbol_table()->print("In SageBuilder::buildDefiningFunctionDeclaration_T()");
#endif

       // DQ (1/29/2013): Retry using the name from the non-definging function declaration.
          SgFunctionDeclaration* nondefiningFunctionDeclaration = isSgFunctionDeclaration(first_nondefining_declaration);
          ROSE_ASSERT(nondefiningFunctionDeclaration != NULL);

          nameWithTemplateArguments = nondefiningFunctionDeclaration->get_name();

       // DQ (8/7/2013): API change due to added support for template function overloading using template parameters.
       // func_symbol = scope->get_symbol_table()->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,templateArgumentsList);
       // func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,NULL,templateArgumentsList);
          func_symbol = scope->find_symbol_by_type_of_function<actualFunction>(nameWithTemplateArguments,func_type,templateParameterList,templateArgumentsList);

          printf ("In buildDefiningFunctionDeclaration_T(): func_symbol = %p reset using lookup with reset nameWithTemplateArguments = %s \n",func_symbol,nameWithTemplateArguments.str());

          ROSE_ASSERT(func_symbol != NULL);

          printf ("In buildDefiningFunctionDeclaration_T(): func_symbol = %p = %s reset using lookup with reset nameWithTemplateArguments = %s \n",func_symbol,func_symbol->class_name().c_str(),nameWithTemplateArguments.str());
#if 0
          printf ("Exiting as a test! \n");
          ROSE_ASSERT(false);
#endif
        }

  // DQ (1/26/2013): This fails for ROSE compiling ROSE.
     ROSE_ASSERT(func_symbol != NULL);
#endif

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): func_symbol = %p \n",func_symbol);
#endif

#if 0
  // Not ready for member functions yet, need to generate SgMemberFucntionType instead of SgFunctionType.
     printf ("Not ready for member functions yet, need to generate SgMemberFucntionType instead of SgFunctionType. \n");
     ROSE_ASSERT(isMemberFunction == false);
#endif

     if (func_symbol == NULL)
        {
          printf ("Could not find an existing symbol for this function! \n");
       // scope->get_symbol_table()->print("Could not find an existing symbol for this function!");

       // DQ (12/2/2011): After discussion with Liao, we think this should be an error.
       // The defining declaration requires that the associated non-defining declaration should already exist.
       // If required, a higher level build function could build both of these and connect them as required.
          printf ("Error: building a defining declaration requires that the associated non-defining declaration already exists and it's symbol found the the same scope's symbol table! \n");
          ROSE_ASSERT(false);
#if 0
       // new defining declaration
       // func = new SgFunctionDeclaration(name,func_type,NULL);
          defining_func = new actualFunction(name,func_type,NULL);
          ROSE_ASSERT(defining_func != NULL);

          firstNondefiningFunctionDeclaration = defining_func;
          ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
#if 0
          SgFunctionSymbol *func_symbol = new SgFunctionSymbol(defining_func);
          scope->insert_symbol(name, func_symbol);
          defining_func->set_firstNondefiningDeclaration(NULL);
#else
          printf ("This code may still have to be debugged! \n");

          if (isSgFunctionDeclaration(defining_func) != NULL)
             {
               func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(defining_func));
               if (isMemberFunction == true)
                  {
                    ROSE_ASSERT(isSgMemberFunctionDeclaration(defining_func) != NULL);
                    func_symbol = new SgMemberFunctionSymbol(isSgMemberFunctionDeclaration(defining_func));
                  }
                 else
                  {
                    ROSE_ASSERT(isSgFunctionDeclaration(defining_func) != NULL);
                    func_symbol = new SgFunctionSymbol(isSgFunctionDeclaration(defining_func));
                  }

               ROSE_ASSERT(func_symbol != NULL);
               ROSE_ASSERT(func_symbol->get_symbol_basis() != NULL);
             }
            else
             {
            // How should we handled template functions in the symbol table???
            // DQ (11/24/2011): After some thought, I think that template declarations for function are more template declarations 
            // than functions.  So all template function declarations will be handled as SgTemplateSymbols and not SgFunctionSymbols.
               SgTemplateDeclaration* templatedeclaration = isSgTemplateDeclaration(defining_func);
               ROSE_ASSERT(templatedeclaration != NULL);
               SgTemplateSymbol* template_symbol = new SgTemplateSymbol(templatedeclaration);
               ROSE_ASSERT(template_symbol != NULL);
               ROSE_ASSERT(template_symbol->get_symbol_basis() != NULL);

               func_symbol = template_symbol;
             }

          ROSE_ASSERT(func_symbol != NULL);
          scope->insert_symbol(name, func_symbol);
#if 0
          printf ("In buildDefiningFunctionDeclaration_T(): Setting the defining_func = %p set_firstNondefiningDeclaration(NULL) (to NULL) \n",defining_func);
       // printf ("In buildDefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl->get_definingDeclaration() = %p) (to prevDecl->get_definingDeclaration()) \n",func,prevDecl->get_definingDeclaration());
#endif
          defining_func->set_firstNondefiningDeclaration(NULL);

          printf ("In buildDefiningFunctionDeclaration_T(): func_symbol = %p = %s \n",func_symbol,func_symbol->class_name().c_str());
#endif
#endif
        }
       else
        {
       // We will now build a reference to the non-defining declaration found in the symbol.

       // defining declaration after nondefining declaration
       // reuse function type, function symbol

       // delete func_type;// bug 189

       // Cong (10/25/2010): Make sure in this situation there is no defining declaration for this symbol.
       // ROSE_ASSERT(func_symbol->get_declaration()->get_definingDeclaration() == NULL);
#if 0
          func_type = func_symbol->get_declaration()->get_type();
#else
          SgFunctionSymbol* temp_function_sym = isSgFunctionSymbol(func_symbol);
          SgTemplateSymbol* temp_template_sym = isSgTemplateSymbol(func_symbol);
          if (temp_function_sym != NULL)
             {
               func_type = temp_function_sym->get_declaration()->get_type();

            // firstNondefiningFunctionDeclaration = temp_function_sym->get_declaration()->get_firstNondefiningDeclaration();
            // firstNondefiningFunctionDeclaration = isSgFunctionDeclaration(temp_function_sym->get_declaration()->get_firstNondefiningDeclaration());
            // firstNondefiningFunctionDeclaration = dynamic_cast<SgFunctionDeclaration*>(temp_function_sym->get_declaration()->get_firstNondefiningDeclaration());
               firstNondefiningFunctionDeclaration = temp_function_sym->get_declaration()->get_firstNondefiningDeclaration();
               ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
             }
            else
             {
            // There is no type for a template function declaration.
            // func_type = temp_template_sym->get_declaration()->get_type();
               ROSE_ASSERT(temp_template_sym != NULL);
            // firstNondefiningFunctionDeclaration = temp_template_sym->get_declaration()->get_firstNondefiningDeclaration();
            // firstNondefiningFunctionDeclaration = isSgTemplateFunctionDeclaration(temp_template_sym->get_declaration()->get_firstNondefiningDeclaration());
            // firstNondefiningFunctionDeclaration = dynamic_cast<SgTemplateFunctionDeclaration*>(temp_template_sym->get_declaration()->get_firstNondefiningDeclaration());
               firstNondefiningFunctionDeclaration = temp_template_sym->get_declaration()->get_firstNondefiningDeclaration();
               ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
             }
#endif
#if 0
       // func = new SgFunctionDeclaration(name,func_type,NULL);
          defining_func = new actualFunction(name,func_type,NULL);
          ROSE_ASSERT(defining_func);

       // func->set_firstNondefiningDeclaration(func_symbol->get_declaration()->get_firstNondefiningDeclaration());
          ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
          defining_func->set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration);

       // fix up defining declarations before current statement
       // func_symbol->get_declaration()->set_definingDeclaration(func);
          firstNondefiningFunctionDeclaration->set_definingDeclaration(defining_func);

       // for the rare case that two or more prototype declaration exist
       // cannot do anything until append/prepend_statment() is invoked
#else
          ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
#endif
        }

  // defining_func = new actualFunction(name,func_type,NULL);
     defining_func = new actualFunction(nameWithTemplateArguments,func_type,NULL);

     ROSE_ASSERT(defining_func != NULL);

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): constructor called to build func = %p = %s \n",defining_func,defining_func->class_name().c_str());
     if (isSgMemberFunctionDeclaration(defining_func) != NULL)
        {
          printf ("In buildDefiningFunctionDeclaration_T(): SgCtorInitializerList = %p \n",isSgMemberFunctionDeclaration(defining_func)->get_CtorInitializerList());
        }
#endif

#if 0
     printf ("In buildDefiningFunctionDeclaration_T(): Setting the defining_func = %p set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration = %p) (to valid pointer) \n",defining_func,firstNondefiningFunctionDeclaration);
  // printf ("In buildDefiningFunctionDeclaration_T(): Setting the func = %p set_definingDeclaration(prevDecl->get_definingDeclaration() = %p) (to prevDecl->get_definingDeclaration()) \n",func,prevDecl->get_definingDeclaration());
#endif

  // func->set_firstNondefiningDeclaration(func_symbol->get_declaration()->get_firstNondefiningDeclaration());
     ROSE_ASSERT(firstNondefiningFunctionDeclaration != NULL);
     defining_func->set_firstNondefiningDeclaration(firstNondefiningFunctionDeclaration);

  // fix up defining declarations before current statement
     firstNondefiningFunctionDeclaration->set_definingDeclaration(defining_func);

  // Handle decorators (Python specific)
     if (decoratorList != NULL)
        {
          defining_func->set_decoratorList(decoratorList);
          decoratorList->set_parent(defining_func);
        }

  // definingDeclaration 
     defining_func->set_definingDeclaration(defining_func);

  // function body and definition are created before setting argument list 
     SgBasicBlock * func_body = new SgBasicBlock();
     ROSE_ASSERT(func_body != NULL);

#if 0
     SgFunctionDefinition* func_def = new SgFunctionDefinition(defining_func,func_body);
#else
     SgFunctionDefinition*          func_def                    = NULL;
     SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(defining_func);

  // Build either a definition for a template or non-template function definition.
  // DQ (2/11/2012): Swapped the order to test templateFunctionDeclaration, since functionDeclaration is always a valid pointer.
  // if (functionDeclaration != NULL)
     if (templateFunctionDeclaration == NULL)
        {
       // DQ (2/11/2012): If we can't assert this then I fear we may have the test in the wrong 
       // order (for if test above should be on templateFunctionDeclaration instead).  The new 
       // design for templates makes the SgFunctionDeclaration a base class of SgTemplateFunctionDeclaration.
       // Might not make a difference if it is OK to use SgFunctionDefinition interchangibly with 
       // SgTemplateFunctionDefinition, but we would never want that.
          ROSE_ASSERT(templateFunctionDeclaration == NULL);

          SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(defining_func);
          ROSE_ASSERT(functionDeclaration != NULL);
          func_def = new SgFunctionDefinition(functionDeclaration,func_body);
        }
       else
        {
          ROSE_ASSERT(templateFunctionDeclaration != NULL);
          func_def = new SgTemplateFunctionDefinition(templateFunctionDeclaration,func_body);
        }
#endif
     ROSE_ASSERT(func_def);

  // DQ (11/28/2010): Added specification of case insensitivity (e.g. Fortran).
     if (symbol_table_case_insensitive_semantics == true)
        {
          func_def->setCaseInsensitive(true);
          func_body->setCaseInsensitive(true);
        }

     func_def->set_parent(defining_func);
     func_def->set_body(func_body);
     func_body->set_parent(func_def);

  // parameter list,
  // TODO consider the difference between C++ and Fortran
     setParameterList(defining_func,paralist);
  // fixup the scope and symbol of arguments,
     SgInitializedNamePtrList& argList = paralist->get_args();
     Rose_STL_Container<SgInitializedName*>::iterator argi;
     for (argi = argList.begin(); argi!=argList.end(); argi++)
        {
        // std::cout<<"patching defining function argument's scope and symbol.... "<<std::endl;
          (*argi)->set_scope(func_def);
          func_def->insert_symbol((*argi)->get_name(), new SgVariableSymbol(*argi) );
        }

     defining_func->set_parent(scope);
     defining_func->set_scope(scope);

  // DQ (12/14/2011): Added test.
     ROSE_ASSERT(defining_func->get_scope() != NULL);

  // DQ (12/15/2011): Added test.
     checkThatNoTemplateInstantiationIsDeclaredInTemplateDefinitionScope(defining_func,scope);

  // set File_Info as transformation generated
     setSourcePositionAtRootAndAllChildren(defining_func);

  // DQ (2/11/2012): Enforce that the return type matches the specification to build a member function.
     if (isMemberFunction == true)
        {
          ROSE_ASSERT(isSgMemberFunctionDeclaration(defining_func) != NULL);
        }

  // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).
  // setTemplateNameInTemplateInstantiations(defining_func,name);
     setTemplateNameInTemplateInstantiations(defining_func,nameWithoutTemplateArguments);

  // DQ (9/16/2012): Setup up the template arguments and the parents of the template arguments.
     if (buildTemplateInstantiation == true)
        {
          setTemplateArgumentsInDeclaration(defining_func,templateArgumentsList);
        }

  // DQ (8/13/2013): Added code to set the template parameters in the defining declaration (if it is a template declaration).
     if (buildTemplateDeclaration == true)
        {
          setTemplateParametersInDeclaration(defining_func,templateParameterList);

       // DQ (8/13/2013): Adding test of template parameter lists.
          SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(defining_func);
          ROSE_ASSERT(templateFunctionDeclaration == NULL || (templateParameterList != NULL && templateParameterList->size() == templateFunctionDeclaration->get_templateParameters().size()));
          SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(defining_func);
          ROSE_ASSERT(templateMemberFunctionDeclaration == NULL || (templateParameterList != NULL && templateParameterList->size() == templateMemberFunctionDeclaration->get_templateParameters().size()));
        }

  // DQ (12/12/2012): Force the two different ways that this can be set to match (we want consistancy).
     if (functionConstVolatileFlags & SgMemberFunctionType::e_restrict)
        {
          defining_func->get_declarationModifier().get_typeModifier().setRestrict();
        }

#if 0
     printf ("[Build Defining Funct Tpl] decl = %p, name = %s, type = %p, scope = %p\n", defining_func, defining_func->get_name().getString().c_str(), defining_func->get_type(), scope);
#endif

     return defining_func;
   }


void
SageBuilder::setTemplateNameInTemplateInstantiations( SgFunctionDeclaration* func, const SgName & name )
   {
  // DQ (2/11/2012): If this is a template instantiation then we have to set the template name (seperate from the name of the function which can include template parameters)).

#if 0
     printf ("In setTemplateNameInTemplateInstantiations(): name = %s func->get_name() = %s \n",name.str(),func->get_name().str());
#endif

     SgTemplateInstantiationFunctionDecl*       templateInstantiationFunctionDecl       = isSgTemplateInstantiationFunctionDecl(func);
     SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunctionDecl = isSgTemplateInstantiationMemberFunctionDecl(func);
     bool isTemplateInstantition = (templateInstantiationFunctionDecl != NULL) || (templateInstantiationMemberFunctionDecl != NULL);
     if (isTemplateInstantition == true)
        {
       // If this is a template instantiation then we need to take care of a few more issues.

          SgName templateNameWithoutArguments = name;

#if 1
       // DQ (7/27/2012): New semantics is that we want to have the input name be without template arguments and 
       // we will add the template arguments instead of trying to remove then (which was problematic for examples 
       // such as "X<Y<Z>> operator X&()" and "X<Y<Z>> operator>()".
          if (hasTemplateSyntax(templateNameWithoutArguments) == true)
             {
               printf ("WARNING: new semantics is that the input name has no template syntax. templateNameWithoutArguments = %s \n",templateNameWithoutArguments.str());
            // ROSE_ASSERT(false);
             }
#else
          XXX SageBuilder::appendTemplateArgumentsToName( const SgName & name, const SgTemplateArgumentPtrList & templateArgumentsList)

       // if (templateNameWithoutArguments.getString().find('<') != string::npos)
          if (hasTemplateSyntax(templateNameWithoutArguments) == true)
             {
               templateNameWithoutArguments = generateTemplateNameFromTemplateNameWithTemplateArguments(name);
             }
            else
             {
               printf ("WARNING: In setTemplateNameInTemplateInstantiations(): name = %s (does not have any template argument syntax) \n",name.str());

            // DQ (7/22/2012): Test exiting where we don't detect template syntax.
               printf ("Exiting as a test \n");
               ROSE_ASSERT(false);
             }
#endif
#if 0
          printf ("In setTemplateNameInTemplateInstantiations(): detected construction of template instantiation func->get_name() = %s \n",func->get_name().str());
          printf ("In setTemplateNameInTemplateInstantiations(): templateNameWithoutArguments            = %s \n",templateNameWithoutArguments.str());
          printf ("In setTemplateNameInTemplateInstantiations(): templateInstantiationFunctionDecl       = %p \n",templateInstantiationFunctionDecl);
          printf ("In setTemplateNameInTemplateInstantiations(): templateInstantiationMemberFunctionDecl = %p \n",templateInstantiationMemberFunctionDecl);
#endif

          bool isMemberFunction = (templateInstantiationMemberFunctionDecl != NULL);
          if (isMemberFunction == true)
             {
               ROSE_ASSERT(templateInstantiationMemberFunctionDecl != NULL);
               ROSE_ASSERT(templateInstantiationFunctionDecl == NULL);

               if (templateInstantiationMemberFunctionDecl->get_templateName().is_null() == true)
                  {
                 // Set the template name for the member function template instantiation.
                 // templateInstantiationMemberFunctionDecl->set_templateName(name);
                    templateInstantiationMemberFunctionDecl->set_templateName(templateNameWithoutArguments);

                 // DQ (5/31/2012): Find locations where this is set and include template syntax.
                 // ROSE_ASSERT(name.getString().find('<') == string::npos);
                 // ROSE_ASSERT(templateNameWithoutArguments.getString().find('<') == string::npos);
                 // ROSE_ASSERT(hasTemplateSyntax(templateNameWithoutArguments) == false);
                  }
#if 0
               printf ("templateInstantiationMemberFunctionDecl->get_templateName() = %s \n",templateInstantiationMemberFunctionDecl->get_templateName().str());
#endif
               ROSE_ASSERT(templateInstantiationMemberFunctionDecl->get_templateName().is_null() == false);
             }
            else
             {
               ROSE_ASSERT(templateInstantiationFunctionDecl != NULL);
               ROSE_ASSERT(templateInstantiationMemberFunctionDecl == NULL);

               if (templateInstantiationFunctionDecl->get_templateName().is_null() == true)
                  {
                 // Set the template name for the function template instantiation.
                 // templateInstantiationFunctionDecl->set_templateName(name);
                    templateInstantiationFunctionDecl->set_templateName(templateNameWithoutArguments);

                 // DQ (5/31/2012): Find locations where this is set and include template syntax.
                 // ROSE_ASSERT(name.getString().find('<') == string::npos);
                 // ROSE_ASSERT(templateNameWithoutArguments.getString().find('<') == string::npos);
                    ROSE_ASSERT(hasTemplateSyntax(templateNameWithoutArguments) == false);
                  }
#if 0
               printf ("templateInstantiationFunctionDecl->get_templateName() = %s \n",templateInstantiationFunctionDecl->get_templateName().str());
#endif
               ROSE_ASSERT(templateInstantiationFunctionDecl->get_templateName().is_null() == false);
             }
#if 0
          printf ("Exiting as a test! \n");
          ROSE_ASSERT(false);
#endif
        }
   }


// SgFunctionDeclaration* SageBuilder::buildDefiningFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgFunctionDeclaration* first_nondefining_declaration)
SgFunctionDeclaration*
SageBuilder::buildDefiningFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* paralist, SgScopeStatement* scope, SgExprListExp* decoratorList, bool buildTemplateInstantiation, SgFunctionDeclaration* first_nondefining_declaration, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // DQ (2/10/2012): This is not correct, we have to build template instantiations depending on the value of buildTemplateInstantiation.
  // SgFunctionDeclaration* func = buildDefiningFunctionDeclaration_T<SgFunctionDeclaration>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList);

  // DQ (2/10/2012): Fixed to build either SgTemplateInstantiationFunctionDecl or SgFunctionDeclaration.
     SgFunctionDeclaration* func = NULL;
     if (buildTemplateInstantiation == true)
        {
          SgTemplateInstantiationFunctionDecl* templateInstantiationFunctionDecl = isSgTemplateInstantiationFunctionDecl(first_nondefining_declaration);

          ROSE_ASSERT(first_nondefining_declaration != NULL);
#if 0
          printf ("In buildDefiningFunctionDeclaration(): first_nondefining_declaration->get_declarationModifier().isFriend() = %s \n",first_nondefining_declaration->get_declarationModifier().isFriend() ? "true" : "false");
#endif
       // func = buildDefiningFunctionDeclaration_T<SgTemplateInstantiationFunctionDecl>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl);
       // func = buildDefiningFunctionDeclaration_T<SgTemplateInstantiationFunctionDecl>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl, templateArgumentsList);
          func = buildDefiningFunctionDeclaration_T<SgTemplateInstantiationFunctionDecl>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,templateInstantiationFunctionDecl, templateArgumentsList);

          ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func) != NULL);
#if 0
          printf ("In SageBuilder::buildDefiningFunctionDeclaration(): isSgTemplateInstantiationFunctionDecl(func)->get_templateName() = %s \n",isSgTemplateInstantiationFunctionDecl(func)->get_templateName().str());
#endif
          ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func) != NULL);
          ROSE_ASSERT(isSgTemplateInstantiationFunctionDecl(func)->get_templateName().is_null() == false);
        }
       else
        {
          ROSE_ASSERT(first_nondefining_declaration != NULL);

       // func = buildDefiningFunctionDeclaration_T<SgFunctionDeclaration>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,first_nondefining_declaration);
          func = buildDefiningFunctionDeclaration_T<SgFunctionDeclaration>(name,return_type,paralist,/* isMemberFunction = */ false,scope,decoratorList,0,first_nondefining_declaration, NULL);

          ROSE_ASSERT(isSgFunctionDeclaration(func) != NULL);
        }

     return func;
   }


// DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).
// We need to decide if the SageBuilder API should include these sorts of functions.
SgFunctionDeclaration*
SageBuilder::buildDefiningFunctionDeclaration(const SgName& name, SgType* return_type, SgFunctionParameterList* parameter_list, SgScopeStatement* scope)
   {
  // DQ (11/12/2012): Note that this function is not used in the AST construction in the EDG/ROSE interface.

  // DQ (8/23/2013): Added assertions.
     ROSE_ASSERT(return_type != NULL);
     ROSE_ASSERT(parameter_list != NULL);

  // DQ (8/23/2013): We need to provide the buildDefiningFunctionDeclaration() function with a pointer to the first non-defining declaration.
  // So we need to find it, and if it does not exist we need to build one so that we have a simple API for building defining declarations.
  // DQ (11/12/2012): Building a defining declaration from scratch now requires a non-defining declaration to exist.
  // SgFunctionDeclaration* nondefininfDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);

     if (scope == NULL)
        {
          scope = SageBuilder::topScopeStack();
        }

     SgFunctionDeclaration* nondefiningDeclaration = NULL;

     SgFunctionType* func_type = buildFunctionType(return_type,parameter_list);
     SgFunctionSymbol* func_symbol = scope->find_symbol_by_type_of_function<SgFunctionDeclaration>(name,func_type,NULL,NULL);
     if (func_symbol != NULL)
        {
          nondefiningDeclaration = func_symbol->get_declaration();
        }
       else
        {
          nondefiningDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);
#if 0
       // DQ (11/20/2013): We should not be appending the nondefiningDeclaration to the scope.  This was added a few months ago.
       // This was a mistake/misunderstanding with Laio about the semantics of the buildDefiningFunctionDeclaration() 
       // function.  Building a function should not have a side-effect on the AST (though clearly it can build new 
       // subtrees, the AST is not modified until the result of the buildDefiningFunctionDeclaration() is explicitly 
       // added (it should also not add the nondefiningDeclaration).  Additionally this code was not consistant with
       // the associated fortran function to build defining function declaration.
          if (scope != NULL)
               appendStatement(nondefiningDeclaration, scope);
#endif
        }

  // DQ (8/23/2013): Added assertions.
     assert(nondefiningDeclaration != NULL);
     assert(nondefiningDeclaration->get_firstNondefiningDeclaration() != NULL);
     assert(nondefiningDeclaration->get_firstNondefiningDeclaration() == nondefiningDeclaration);

  // return buildDefiningFunctionDeclaration (name,return_type,parameter_list,scope,NULL,false,NULL,NULL);
     return buildDefiningFunctionDeclaration (name,return_type,parameter_list,scope,NULL,false,nondefiningDeclaration,NULL);
   }


// DQ (8/28/2012): This preserves the original API with a simpler function (however for C++ at least, it is frequently not sufficent).
// We need to decide if the SageBuilder API should include these sorts of functions.
SgProcedureHeaderStatement*
SageBuilder::buildProcedureHeaderStatement(const SgName& name, SgType* return_type, SgFunctionParameterList* parameter_list, SgProcedureHeaderStatement::subprogram_kind_enum kind, SgScopeStatement* scope)
   {
  // DQ (8/23/2013): Added assertions.
     ROSE_ASSERT(return_type != NULL);
     ROSE_ASSERT(parameter_list != NULL);

  // DQ (8/23/2013): We need to provide the buildDefiningFunctionDeclaration() function with a pointer to the first non-defining declaration.
  // So we need to find it, and if it does not exist we need to build one so that we have a simple API for building defining declarations.
  // DQ (11/12/2012): Building a defining declaration from scratch now requires a non-defining declaration to exist.
  // SgFunctionDeclaration* nondefininfDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);

     if (scope == NULL)
        {
          scope = SageBuilder::topScopeStack();
        }

  // SgProcedureHeaderStatement* nondefiningDeclaration = NULL;
     SgFunctionDeclaration* nondefiningDeclaration = NULL;

     SgFunctionType* func_type = buildFunctionType(return_type,parameter_list);
     SgFunctionSymbol* func_symbol = scope->find_symbol_by_type_of_function<SgProcedureHeaderStatement>(name,func_type,NULL,NULL);
     if (func_symbol != NULL)
        {
          nondefiningDeclaration = func_symbol->get_declaration();
        }
       else
        {
          nondefiningDeclaration = buildNondefiningFunctionDeclaration(name,return_type,parameter_list,scope,NULL);
        }

  // DQ (8/23/2013): Added assertions.
     assert(nondefiningDeclaration != NULL);
     assert(nondefiningDeclaration->get_firstNondefiningDeclaration() != NULL);
     assert(nondefiningDeclaration->get_firstNondefiningDeclaration() == nondefiningDeclaration);

#if 0
  // Function prototype: buildNondefiningFunctionDeclaration_T (
  //      const SgName & name, SgType* return_type, SgFunctionParameterList * paralist, bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, 
  //      unsigned int functionConstVolatileFlags, SgTemplateArgumentPtrList* templateArgumentsList, SgTemplateParameterPtrList* templateParameterList);

  // DQ (8/21/2013): Fixed number of parameters in buildNondefiningFunctionDeclaration_T() function call.
  // SgProcedureHeaderStatement* non_def_decl = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement> (name,return_type,parameter_list, /* isMemberFunction = */ false, scope, NULL, false, NULL);
     SgProcedureHeaderStatement* non_def_decl = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement> (name,return_type,parameter_list, /* isMemberFunction = */ false, scope, NULL, 0, NULL, NULL);
#endif

  // return buildProcedureHeaderStatement(name.str(),return_type,parameter_list,kind,scope,NULL);
  // return buildProcedureHeaderStatement(name.str(),return_type,parameter_list,kind,scope, non_def_decl);
     return buildProcedureHeaderStatement(name.str(),return_type,parameter_list,kind,scope, isSgProcedureHeaderStatement(nondefiningDeclaration));
   }


//! Build a Fortran subroutine or procedure
SgProcedureHeaderStatement*
SageBuilder::buildProcedureHeaderStatement( const char* name, SgType* return_type, SgFunctionParameterList * paralist, 
                                            SgProcedureHeaderStatement::subprogram_kind_enum kind, SgScopeStatement* scope/*=NULL*/,
                                            SgProcedureHeaderStatement* first_nondefining_declaration)
   {
  // DQ (7/14/2013): We would like to insist that a nondefining declaration has been built at this point.
     ROSE_ASSERT(first_nondefining_declaration != NULL);

  // We will want to call: SageBuilder::buildNondefiningFunctionDeclaration_T (const SgName & XXX_name, SgType* return_type, SgFunctionParameterList * paralist, 
  //                                                                           bool isMemberFunction, SgScopeStatement* scope, SgExprListExp* decoratorList, 
  //                                                                           unsigned int functionConstVolatileFlags, SgTemplateArgumentPtrList* templateArgumentsList)

     if (kind == SgProcedureHeaderStatement::e_subroutine_subprogram_kind)
        {
          ROSE_ASSERT(return_type == buildVoidType());
        }
       else
        {
          if (kind != SgProcedureHeaderStatement::e_function_subprogram_kind)
             {
               cerr << "unhandled subprogram kind for Fortran function unit:" << kind << endl;
               ROSE_ASSERT(false);
             }
        }

     SgName rose_name = name;
  // SgProcedureHeaderStatement* func = buildDefiningFunctionDeclaration_T<SgProcedureHeaderStatement> (rose_name,return_type,paralist,/* isMemberFunction = */ false,scope,NULL,0U,first_nondefining_declaration);
     SgProcedureHeaderStatement* func = buildDefiningFunctionDeclaration_T<SgProcedureHeaderStatement> (rose_name,return_type,paralist,/* isMemberFunction = */ false,scope,NULL,0U,first_nondefining_declaration, NULL);
     ROSE_ASSERT(func != NULL);

     func->set_subprogram_kind(kind) ;

     return func;
   }

#if 0
// DQ (7/26/2012): I would like to remove these from the API (if possible).
SgFunctionDeclaration*
SageBuilder::buildDefiningFunctionDeclaration(const std::string & name, SgType* return_type, SgFunctionParameterList * paralist,SgScopeStatement* scope, SgExprListExp* decoratorList, SgFunctionDeclaration* first_nondefining_declaration)
   {
     SgName sg_name(name);

     bool buildTemplateInstantiation = false;

  // DQ (5/11/2012): This is a compile time error (use if SgFunctionDeclaration* first_nondefining_declaration results in ambigous function type for g++). 
  // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,first_nondefining_declaration);
  // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList);
     return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,buildTemplateInstantiation,first_nondefining_declaration);
   }
#endif

#if 0
// DQ (7/26/2012): I would like to remove these from the API (if possible).
SgFunctionDeclaration *
SageBuilder::buildDefiningFunctionDeclaration(const char* name, SgType* return_type, SgFunctionParameterList * paralist,SgScopeStatement* scope, SgExprListExp* decoratorList, SgFunctionDeclaration* first_nondefining_declaration)
   {
     SgName sg_name(name);

     bool buildTemplateInstantiation = false;

  // DQ (5/11/2012): This is a compile time error (use if SgFunctionDeclaration* first_nondefining_declaration results in ambigous function type for g++). 
  // return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,first_nondefining_declaration);
     return buildDefiningFunctionDeclaration(sg_name,return_type, paralist,scope,decoratorList,buildTemplateInstantiation,first_nondefining_declaration);
   }
#endif


//------------------build value expressions -------------------
//-------------------------------------------------------------
SgBoolValExp* SageBuilder::buildBoolValExp(int value /*=0*/)
{
  //TODO does valueString matter here?
  SgBoolValExp* boolValue= new SgBoolValExp(value);
  ROSE_ASSERT(boolValue);
  setOneSourcePositionForTransformation(boolValue);
  return boolValue;
}
SgBoolValExp* SageBuilder::buildBoolValExp(bool value /*=0*/)
{
  return buildBoolValExp(int(value));
}
SgBoolValExp* SageBuilder::buildBoolValExp_nfi(int value)
{
  SgBoolValExp* boolValue= new SgBoolValExp(value);
  ROSE_ASSERT(boolValue);
  setOneSourcePositionNull(boolValue);
  return boolValue;
}

SgCharVal* SageBuilder::buildCharVal(char value /*= 0*/)
{
  SgCharVal* result = new SgCharVal(value, "");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgCharVal* SageBuilder::buildCharVal_nfi(char value, const string& str)
{
  SgCharVal* result = new SgCharVal(value, str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgWcharVal* SageBuilder::buildWcharVal(wchar_t value /*= 0*/)
{
  SgWcharVal* result = new SgWcharVal(value, "");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgWcharVal* SageBuilder::buildWcharVal_nfi(wchar_t value, const string& str)
{
  SgWcharVal* result = new SgWcharVal(value, str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgComplexVal* SageBuilder::buildComplexVal(SgValueExp* real_value, SgValueExp* imaginary_value)
{
  SgComplexVal* result = new SgComplexVal(real_value,imaginary_value,imaginary_value->get_type(),"");
  ROSE_ASSERT(result);

// DQ (12/31/2008): set and test the parents
  if (real_value != NULL)
       real_value->set_parent(result);

  if (imaginary_value != NULL)
       imaginary_value->set_parent(result);

  ROSE_ASSERT(real_value == NULL || real_value->get_parent() != NULL);
  ROSE_ASSERT(imaginary_value == NULL || imaginary_value->get_parent() != NULL);

  setOneSourcePositionForTransformation(result);
  return result;
}

SgComplexVal* SageBuilder::buildComplexVal_nfi(SgValueExp* real_value, SgValueExp* imaginary_value, const std::string& str)
{
  SgComplexVal* result = new SgComplexVal(real_value,imaginary_value,imaginary_value->get_type(),str);
  ROSE_ASSERT(result);

// DQ (12/31/2008): set and test the parents
  if (real_value != NULL)
       real_value->set_parent(result);

  if (imaginary_value != NULL)
       imaginary_value->set_parent(result);

  ROSE_ASSERT(real_value == NULL || real_value->get_parent() != NULL);
  ROSE_ASSERT(imaginary_value == NULL || imaginary_value->get_parent() != NULL);

  setOneSourcePositionNull(result);
  return result;
}

SgComplexVal* SageBuilder::buildImaginaryVal(long double imaginary_value /*= 0.0*/ )
{
  SgComplexVal* result = new SgComplexVal(NULL,buildLongDoubleVal(imaginary_value),SgTypeLongDouble::createType(),"");
  ROSE_ASSERT(result);

// DQ (12/31/2008): set and test the parents
  result->get_imaginary_value()->set_parent(result);
  ROSE_ASSERT(result->get_imaginary_value()->get_parent() != NULL);

  setOneSourcePositionForTransformation(result);
  return result;
}

SgComplexVal* SageBuilder::buildImaginaryVal(SgValueExp* imaginary_value)
{
  ROSE_ASSERT(imaginary_value != NULL);

  SgComplexVal* result = new SgComplexVal(NULL,imaginary_value,imaginary_value->get_type(),"");
  ROSE_ASSERT(result);

// DQ (12/31/2008): set and test the parents
  imaginary_value->set_parent(result);
  ROSE_ASSERT(imaginary_value->get_parent() != NULL);

  setOneSourcePositionForTransformation(result);
  return result;
}

SgComplexVal* SageBuilder::buildImaginaryVal_nfi(SgValueExp* imaginary_value, const std::string& str)
{
  ROSE_ASSERT(imaginary_value != NULL);

  SgComplexVal* result = new SgComplexVal(NULL,imaginary_value,imaginary_value->get_type(),str);
  imaginary_value->set_parent(result);
  ROSE_ASSERT(result);

// DQ (12/31/2008): set and test the parents
  ROSE_ASSERT(imaginary_value->get_parent() != NULL);

  setOneSourcePositionNull(result);
  return result;
}

SgDoubleVal* SageBuilder::buildDoubleVal(double t)
{
  SgDoubleVal* value = new SgDoubleVal(t,"");
  ROSE_ASSERT(value);
  setOneSourcePositionForTransformation(value);
  return value;
}

SgDoubleVal* SageBuilder::buildDoubleVal_nfi(double t, const string& str)
{
  SgDoubleVal* value = new SgDoubleVal(t,str);
  ROSE_ASSERT(value);
  setOneSourcePositionNull(value);
  return value;
}

SgFloatVal* SageBuilder::buildFloatVal(float value /*= 0.0*/)
{
  SgFloatVal* result = new SgFloatVal(value,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgFloatVal* SageBuilder::buildFloatVal_nfi(float value, const string& str)
{
  SgFloatVal* result = new SgFloatVal(value,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgIntVal* SageBuilder::buildIntVal(int value)
   {
     SgIntVal* intValue= new SgIntVal(value,"");
     ROSE_ASSERT(intValue);
     setOneSourcePositionForTransformation(intValue);

#if 0
     printf ("In buildIntVal(value = %d): intValue = %p \n",value,intValue);
#endif

     return intValue;
   }

SgIntVal* SageBuilder::buildIntValHex(int value)
   {
     SgIntVal* intValue= new SgIntVal(value, (value >= 0 ? StringUtility::intToHex((unsigned int)value) : "-" + StringUtility::intToHex((unsigned int)(-value))));
     ROSE_ASSERT(intValue);
     setOneSourcePositionForTransformation(intValue);

#if 0
     printf ("In buildIntValHex(value = %d): intValue = %p \n",value,intValue);
#endif

     return intValue;
   }

SgIntVal* SageBuilder::buildIntVal_nfi(int value, const string& str)
   {
     SgIntVal* intValue = new SgIntVal(value,str);
     ROSE_ASSERT(intValue);
     setOneSourcePositionNull(intValue);

#if 0
     printf ("In buildIntVal_nfi(value = %d,str = %s): intValue = %p \n",value,str.c_str(),intValue);
#endif

     return intValue;
   }

SgLongIntVal* SageBuilder::buildLongIntVal(long value)
{
  SgLongIntVal* intValue= new SgLongIntVal(value,"");
  ROSE_ASSERT(intValue);
  setOneSourcePositionForTransformation(intValue);
  return intValue;
}

SgLongIntVal* SageBuilder::buildLongIntVal_nfi(long value, const string& str)
{
  SgLongIntVal* intValue= new SgLongIntVal(value,str);
  ROSE_ASSERT(intValue);
  setOneSourcePositionNull(intValue);
  return intValue;
}

SgLongLongIntVal* SageBuilder::buildLongLongIntVal(long long value)
{
  SgLongLongIntVal* intValue= new SgLongLongIntVal(value,"");
  ROSE_ASSERT(intValue);
  setOneSourcePositionForTransformation(intValue);
  return intValue;
}

SgLongLongIntVal* SageBuilder::buildLongLongIntVal_nfi(long long value, const string& str)
{
  SgLongLongIntVal* intValue= new SgLongLongIntVal(value,str);
  ROSE_ASSERT(intValue);
  setOneSourcePositionNull(intValue);
  return intValue;
}

SgEnumVal* SageBuilder::buildEnumVal_nfi(int value, SgEnumDeclaration* decl, SgName name)
   {
     SgEnumVal* enumVal= new SgEnumVal(value,decl,name);
     ROSE_ASSERT(enumVal != NULL);

     setOneSourcePositionNull(enumVal);

#if 0
  // DQ (6/10/2012): This is moved, but perhaps it really should be here!
     printf ("In buildEnumVal_nfi(): We need to add the enum value to the symbol table in the scope of the SgEnumDeclaration (name = %s) \n",name.str());

  // DQ (6/10/2012): We need to add the enum field value to the correct symbol table.
     SgScopeStatement* scope = decl->get_scope();
     ROSE_ASSERT(scope != NULL);

#error "DEAD CODE!"

     SgEnumFieldSymbol* enumFieldSymbol = scope->lookup_enum_field_symbol(name);
     ROSE_ASSERT(enumFieldSymbol == NULL);
     if (enumFieldSymbol == NULL)
        {
          SgEnumType* enumType = new SgEnumType(decl);
          ROSE_ASSERT(enumType != NULL);

          printf ("In buildEnumVal_nfi(): Building a SgInitializedName for enum field \n");

          SgInitializedName* initializedName = buildInitializedName(name,enumType);
          ROSE_ASSERT(initializedName != NULL);

          initializedName->set_declptr(decl);
          initializedName->set_scope(scope);

          enumFieldSymbol = new SgEnumFieldSymbol(initializedName);
        }

     ROSE_ASSERT(enumFieldSymbol != NULL);

     scope->insert_symbol(name,enumFieldSymbol);
#endif

     return enumVal;
   }

SgLongDoubleVal* SageBuilder::buildLongDoubleVal(long double value /*= 0.0*/)
{
  SgLongDoubleVal* result = new SgLongDoubleVal(value,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgLongDoubleVal* SageBuilder::buildLongDoubleVal_nfi(long double value, const string& str)
{
  SgLongDoubleVal* result = new SgLongDoubleVal(value,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgStringVal* SageBuilder::buildStringVal(std::string value /*=""*/)
{
  SgStringVal* result = new SgStringVal(value);
  ROSE_ASSERT(result);   
  setOneSourcePositionForTransformation(result);
  return result;
}

SgStringVal* SageBuilder::buildStringVal_nfi(std::string value)
{
  SgStringVal* result = new SgStringVal(value);
  ROSE_ASSERT(result);   
  setOneSourcePositionNull(result);
  return result;
}

SgUnsignedCharVal* SageBuilder::buildUnsignedCharVal(unsigned char v)
{
  SgUnsignedCharVal* result = new SgUnsignedCharVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedCharVal* SageBuilder::buildUnsignedCharValHex(unsigned char v)
{
  SgUnsignedCharVal* result = new SgUnsignedCharVal(v,StringUtility::intToHex(v));
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedCharVal* SageBuilder::buildUnsignedCharVal_nfi(unsigned char v, const string& str)
{
  SgUnsignedCharVal* result = new SgUnsignedCharVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgShortVal* SageBuilder::buildShortVal(short v)
{
  SgShortVal* result = new SgShortVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgShortVal* SageBuilder::buildShortValHex(short v)
{
  SgShortVal* result = new SgShortVal(v, (v >= 0 ? StringUtility::intToHex((unsigned int)v) : "-" + StringUtility::intToHex((unsigned int)(-v))));
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgShortVal* SageBuilder::buildShortVal_nfi(short v, const string& str)
{
  SgShortVal* result = new SgShortVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgUnsignedShortVal* SageBuilder::buildUnsignedShortVal(unsigned short v)
{
  SgUnsignedShortVal* result = new SgUnsignedShortVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedShortVal* SageBuilder::buildUnsignedShortValHex(unsigned short v)
{
  SgUnsignedShortVal* result = new SgUnsignedShortVal(v,StringUtility::intToHex(v));
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedShortVal* SageBuilder::buildUnsignedShortVal_nfi(unsigned short v, const string& str)
{
  SgUnsignedShortVal* result = new SgUnsignedShortVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgUnsignedIntVal* SageBuilder::buildUnsignedIntVal(unsigned int v)
{
  SgUnsignedIntVal* result = new SgUnsignedIntVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedIntVal* SageBuilder::buildUnsignedIntValHex(unsigned int v)
{
  SgUnsignedIntVal* result = new SgUnsignedIntVal(v,StringUtility::intToHex(v) + "U");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedIntVal* SageBuilder::buildUnsignedIntVal_nfi(unsigned int v, const string& str)
{
  SgUnsignedIntVal* result = new SgUnsignedIntVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgUnsignedLongVal* SageBuilder::buildUnsignedLongVal(unsigned long v)
{
  SgUnsignedLongVal* result = new SgUnsignedLongVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedLongVal* SageBuilder::buildUnsignedLongValHex(unsigned long v)
{
  SgUnsignedLongVal* result = new SgUnsignedLongVal(v,StringUtility::intToHex(v) + "UL");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedLongVal* SageBuilder::buildUnsignedLongVal_nfi(unsigned long v, const string& str)
{
  SgUnsignedLongVal* result = new SgUnsignedLongVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntVal(unsigned long long v)
{
  SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntValHex(unsigned long long v)
{
  SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,StringUtility::intToHex(v) + "ULL");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgUnsignedLongLongIntVal* SageBuilder::buildUnsignedLongLongIntVal_nfi(unsigned long long v, const string& str)
{
  SgUnsignedLongLongIntVal* result = new SgUnsignedLongLongIntVal(v,str);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgTemplateParameterVal* SageBuilder::buildTemplateParameterVal(int template_parameter_position)
{
  SgTemplateParameterVal* templateParameterValue = new SgTemplateParameterVal(template_parameter_position,"");
  ROSE_ASSERT(templateParameterValue);
  setOneSourcePositionForTransformation(templateParameterValue);

// DQ (7/25/2012): Assert this (it will be set later).
  ROSE_ASSERT(templateParameterValue->get_parent() == NULL);

  return templateParameterValue;
}

SgTemplateParameterVal* SageBuilder::buildTemplateParameterVal_nfi(int template_parameter_position, const string& str)
{
  SgTemplateParameterVal* templateParameterValue= new SgTemplateParameterVal(template_parameter_position,str);
  ROSE_ASSERT(templateParameterValue);
  setOneSourcePositionNull(templateParameterValue);

// DQ (7/25/2012): Assert this (it will be set later).
  ROSE_ASSERT(templateParameterValue->get_parent() == NULL);

  return templateParameterValue;
}

//! Build UPC THREADS (integer expression)
SgUpcThreads* SageBuilder::buildUpcThreads()
{
  SgUpcThreads* result = new SgUpcThreads(0,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build UPC THREADS (integer expression)
SgUpcThreads* SageBuilder::buildUpcThreads_nfi()
{
  SgUpcThreads* result = new SgUpcThreads(0,"");
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

//! Build UPC  MYTHREAD (integer expression)
SgUpcMythread* SageBuilder::buildUpcMythread()
{
  SgUpcMythread* result = new SgUpcMythread(0,"");
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build UPC  MYTHREAD (integer expression)
SgUpcMythread* SageBuilder::buildUpcMythread_nfi()
{
  SgUpcMythread* result = new SgUpcMythread(0,"");
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgThisExp* SageBuilder::buildThisExp(SgClassSymbol* sym)
{
  SgThisExp* result = new SgThisExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgThisExp* SageBuilder::buildThisExp_nfi(SgClassSymbol* sym)
{
  SgThisExp* result = new SgThisExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgSuperExp* SageBuilder::buildSuperExp(SgClassSymbol* sym)
{
  SgSuperExp* result = new SgSuperExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgSuperExp* SageBuilder::buildSuperExp_nfi(SgClassSymbol* sym)
{
  SgSuperExp* result = new SgSuperExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgClassExp* SageBuilder::buildClassExp(SgClassSymbol* sym)
{
  SgClassExp* result = new SgClassExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgClassExp* SageBuilder::buildClassExp_nfi(SgClassSymbol* sym)
{
  SgClassExp* result = new SgClassExp(sym, 0);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgTupleExp*
SageBuilder::buildTupleExp(SgExpression * elt1, SgExpression* elt2, SgExpression* elt3, SgExpression* elt4, SgExpression* elt5, SgExpression* elt6, SgExpression* elt7, SgExpression* elt8, SgExpression* elt9, SgExpression* elt10)
{
  SgTupleExp* tuple = new SgTupleExp();
  ROSE_ASSERT(tuple);
  if (elt1) appendExpression(tuple, elt1);
  if (elt2) appendExpression(tuple, elt2);
  if (elt3) appendExpression(tuple, elt3);
  if (elt4) appendExpression(tuple, elt4);
  if (elt5) appendExpression(tuple, elt5);
  if (elt6) appendExpression(tuple, elt6);
  if (elt7) appendExpression(tuple, elt7);
  if (elt8) appendExpression(tuple, elt8);
  if (elt9) appendExpression(tuple, elt9);
  if (elt10) appendExpression(tuple, elt10);

  setOneSourcePositionForTransformation(tuple);
  return tuple;
}

SgTupleExp*
SageBuilder::buildTupleExp(const std::vector<SgExpression*>& elts)
{
  SgTupleExp* expList = SageBuilder::buildTupleExp();
  appendExpressionList(expList, elts);
  return expList;
}

SgTupleExp*
SageBuilder::buildTupleExp_nfi()
{
  SgTupleExp* tuple = new SgTupleExp();
  ROSE_ASSERT(tuple);
  setOneSourcePositionNull(tuple);
  return tuple;
}

SgTupleExp*
SageBuilder::buildTupleExp_nfi(const std::vector<SgExpression*>& elts)
{
  SgTupleExp* tuple = SageBuilder::buildTupleExp_nfi();
  appendExpressionList(tuple, elts);
  return tuple;
}

SgListExp*
SageBuilder::buildListExp(SgExpression * elt1, SgExpression* elt2, SgExpression* elt3, SgExpression* elt4, SgExpression* elt5, SgExpression* elt6, SgExpression* elt7, SgExpression* elt8, SgExpression* elt9, SgExpression* elt10)
{
  SgListExp* tuple = new SgListExp();
  ROSE_ASSERT(tuple);
  if (elt1) appendExpression(tuple, elt1);
  if (elt2) appendExpression(tuple, elt2);
  if (elt3) appendExpression(tuple, elt3);
  if (elt4) appendExpression(tuple, elt4);
  if (elt5) appendExpression(tuple, elt5);
  if (elt6) appendExpression(tuple, elt6);
  if (elt7) appendExpression(tuple, elt7);
  if (elt8) appendExpression(tuple, elt8);
  if (elt9) appendExpression(tuple, elt9);
  if (elt10) appendExpression(tuple, elt10);

  setOneSourcePositionForTransformation(tuple);
  return tuple;
}

SgListExp*
SageBuilder::buildListExp(const std::vector<SgExpression*>& elts)
{
  SgListExp* expList = SageBuilder::buildListExp();
  appendExpressionList(expList, elts);
  return expList;
}

SgListExp*
SageBuilder::buildListExp_nfi()
{
  SgListExp* tuple = new SgListExp();
  ROSE_ASSERT(tuple);
  setOneSourcePositionNull(tuple);
  return tuple;
}

SgListExp*
SageBuilder::buildListExp_nfi(const std::vector<SgExpression*>& elts)
{
  SgListExp* tuple = SageBuilder::buildListExp_nfi();
  appendExpressionList(tuple, elts);
  return tuple;
}

//----------------------build unary expressions----------------------
template <class T>
T* SageBuilder::buildUnaryExpression(SgExpression* operand)
{ 
  SgExpression* myoperand=operand;
  
#if 0
 // it is very tempting to reuse expressions during translation,
  // so try to catch such a mistake here
  if (operand!=NULL)
    if (operand->get_parent()!=NULL)
    {
      cout<<"Warning! Found an illegal attempt to reuse operand of type "
          << operand->class_name() << 
        " when building a unary expression . Operand is being copied."<<endl;
     ROSE_ABORT();// remind user the issue
      myoperand = isSgExpression(deepCopy(operand));
    }
#endif
  T* result = new T(myoperand, NULL);
  ROSE_ASSERT(result);   
  if (myoperand!=NULL) 
  { 
    myoperand->set_parent(result);
  // set lvalue, it asserts operand!=NULL 
    markLhsValues(result);
  }
  setOneSourcePositionForTransformation(result);
  return result; 
}

template <class T>
T* SageBuilder::buildUnaryExpression_nfi(SgExpression* operand)
   {
     SgExpression* myoperand = operand;
     T* result = new T(myoperand, NULL);
     ROSE_ASSERT(result);   

     if (myoperand != NULL) 
        {
          myoperand->set_parent(result);
       // set lvalue, it asserts operand!=NULL 
          markLhsValues(result);
        }

  // DQ (11/2/2012): Modified to reflect call to function that defines source position policy.
  // result->set_startOfConstruct(NULL);
  // result->set_endOfConstruct(NULL);
  // result->set_operatorPosition(NULL);
     setSourcePosition(result);

     result->set_need_paren(false);
     return result; 
   }

#define BUILD_UNARY_DEF(suffix) \
  Sg##suffix* SageBuilder::build##suffix##_nfi(SgExpression* op) \
  { \
     return SageBuilder::buildUnaryExpression_nfi<Sg##suffix>(op); \
  } \
  ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix(SgExpression* op) \
  { \
     return SageBuilder::buildUnaryExpression<Sg##suffix>(op); \
  }

BUILD_UNARY_DEF(AddressOfOp)
BUILD_UNARY_DEF(BitComplementOp)
BUILD_UNARY_DEF(MinusOp)
BUILD_UNARY_DEF(NotOp)
BUILD_UNARY_DEF(PointerDerefExp)
BUILD_UNARY_DEF(UnaryAddOp)
BUILD_UNARY_DEF(MinusMinusOp)
BUILD_UNARY_DEF(PlusPlusOp)
BUILD_UNARY_DEF(RealPartOp)
BUILD_UNARY_DEF(ImagPartOp)
BUILD_UNARY_DEF(ConjugateOp)
BUILD_UNARY_DEF(VarArgStartOneOperandOp)
BUILD_UNARY_DEF(VarArgEndOp)

#undef BUILD_UNARY_DEF

SgCastExp * SageBuilder::buildCastExp(SgExpression *  operand_i,
                SgType * expression_type,
                SgCastExp::cast_type_enum cast_type)
{
  SgCastExp* result = new SgCastExp(operand_i, expression_type, cast_type);
  ROSE_ASSERT(result);
  if (operand_i) {operand_i->set_parent(result); markLhsValues(result);}
  setOneSourcePositionForTransformation(result);
  return result;
}

SgNewExp*
SageBuilder::buildNewExp ( SgType* specified_type, 
                           SgExprListExp* placement_args, 
                           SgConstructorInitializer* constructor_args, 
                           SgExpression* builtin_args, 
                        // FIXME: Change this from "short int" to "bool".
                           short int need_global_specifier, 
                           SgFunctionDeclaration* newOperatorDeclaration)
   {
  // DQ (11/18/2012): Modified parameter names to make this function more clear.
     SgNewExp* result = new SgNewExp(specified_type, placement_args, constructor_args, builtin_args, need_global_specifier, newOperatorDeclaration);
     ROSE_ASSERT(result);

     setOneSourcePositionForTransformation(result);
     return result;
   }

SgDeleteExp* SageBuilder::buildDeleteExp(SgExpression* variable,
                                         short is_array,
                                         short need_global_specifier,
                                         SgFunctionDeclaration* deleteOperatorDeclaration)
{
  SgDeleteExp* result = new SgDeleteExp(variable, is_array, 
          need_global_specifier, deleteOperatorDeclaration);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgTypeIdOp*
SageBuilder::buildTypeIdOp(SgExpression *operand_expr, SgType *operand_type)
   {
  // DQ (1/25/2013): Added support for typeId operators.
     SgTypeIdOp* result = new SgTypeIdOp(operand_expr,operand_type);
     ROSE_ASSERT(result != NULL);
     setOneSourcePositionForTransformation(result);
     return result;
   }

SgCastExp * SageBuilder::buildCastExp_nfi(SgExpression *  operand_i, SgType * expression_type, SgCastExp::cast_type_enum cast_type)
{
  SgCastExp* result = new SgCastExp(operand_i, expression_type, cast_type);
  ROSE_ASSERT(result);
  if (operand_i) {operand_i->set_parent(result); markLhsValues(result);}
  setOneSourcePositionNull(result);
  return result;
}

SgVarArgOp * SageBuilder::buildVarArgOp_nfi(SgExpression *  operand_i, SgType * expression_type) {
  SgVarArgOp* result = new SgVarArgOp(operand_i, expression_type);
  ROSE_ASSERT(result);
  if (operand_i) {operand_i->set_parent(result); markLhsValues(result);}
  setOneSourcePositionNull(result);
  return result;
}

SgMinusMinusOp *SageBuilder::buildMinusMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgMinusMinusOp* result = buildUnaryExpression<SgMinusMinusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}

SgMinusMinusOp *SageBuilder::buildMinusMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgMinusMinusOp* result = buildUnaryExpression_nfi<SgMinusMinusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}

SgMinusOp *SageBuilder::buildMinusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgMinusOp* result = buildUnaryExpression<SgMinusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}

SgMinusOp *SageBuilder::buildMinusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgMinusOp* result = buildUnaryExpression_nfi<SgMinusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}

SgPlusPlusOp *SageBuilder::buildPlusPlusOp(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgPlusPlusOp* result = buildUnaryExpression<SgPlusPlusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}


SgPlusPlusOp *SageBuilder::buildPlusPlusOp_nfi(SgExpression* operand_i, SgUnaryOp::Sgop_mode  a_mode)
{
  SgPlusPlusOp* result = buildUnaryExpression_nfi<SgPlusPlusOp>(operand_i);
  ROSE_ASSERT(result);
  result->set_mode(a_mode);
  return result;
}

SgThrowOp *SageBuilder::buildThrowOp(SgExpression *operand_i, SgThrowOp::e_throw_kind throwKind)
   {
  // DQ (11/8/2011): operand_i is allowed to be NULL.

  // SgThrowOp* result = new SgThrowOp(operand_i, operand_i -> get_type(), throwKind);
     SgThrowOp* result = new SgThrowOp(operand_i, (operand_i != NULL) ? operand_i->get_type() : NULL, throwKind);

     if (operand_i != NULL)
        {
          markLhsValues(result);
        }

     setOneSourcePositionForTransformation(result);

     if (operand_i != NULL)
          operand_i -> set_parent(result);

     ROSE_ASSERT(result);

     return result;
   }


//---------------------binary expressions-----------------------

template <class T>
T* SageBuilder::buildBinaryExpression(SgExpression* lhs, SgExpression* rhs)
{
  SgExpression* mylhs, *myrhs;
  mylhs = lhs;
  myrhs = rhs;

#if 0 // Jeremiah complained this, sometimes users just move expressions around
 // it is very tempting to reuse expressions during translation,
  // so try to catch such a mistake here
  if (lhs!=NULL)
    if (lhs->get_parent()!=NULL)
    {
      cout<<"Warning! Found an illegal attempt to reuse lhs of type "
          << lhs->class_name() <<
        " when building a binary expression . lhs is being copied."<<endl;
     ROSE_ABORT();
      mylhs = isSgExpression(deepCopy(lhs));
    }

  if (rhs!=NULL)
    if (rhs->get_parent()!=NULL)
    {
      cout<<"Warning! Found an illegal attempt to reuse rhs of type "
          << rhs->class_name() <<
        " when building a binary expression . rhs is being copied."<<endl;
     ROSE_ABORT();
      myrhs = isSgExpression(deepCopy(rhs));
    }
#endif
  T* result = new T(mylhs,myrhs, NULL);
  ROSE_ASSERT(result);
  if (mylhs!=NULL) 
  {
   mylhs->set_parent(result);
  // set lvalue
    markLhsValues(result);
  }
  if (myrhs!=NULL) myrhs->set_parent(result);
  setOneSourcePositionForTransformation(result);
  return result;

}

template <class T>
T* SageBuilder::buildBinaryExpression_nfi(SgExpression* lhs, SgExpression* rhs)
   {
     SgExpression* mylhs, *myrhs;
     mylhs = lhs;
     myrhs = rhs;
     T* result = new T(mylhs,myrhs, NULL);
     ROSE_ASSERT(result);
     if (mylhs!=NULL) 
        {
          mylhs->set_parent(result);
       // set lvalue
          markLhsValues(result);
        }

     if (myrhs!=NULL) myrhs->set_parent(result);

  // DQ (11/2/2012): Modified to reflect call to function that defines source position policy.
  // result->set_startOfConstruct(NULL);
  // result->set_endOfConstruct(NULL);
  // result->set_operatorPosition(NULL);
     setSourcePosition(result);

     result->set_need_paren(false);

     return result;
   }

#define BUILD_BINARY_DEF(suffix) \
  ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix##_nfi(SgExpression* lhs, SgExpression* rhs) \
  { \
     return buildBinaryExpression_nfi<Sg##suffix>(lhs, rhs); \
  } \
  ROSE_DLL_API Sg##suffix* SageBuilder::build##suffix(SgExpression* lhs, SgExpression* rhs) \
  { \
     return buildBinaryExpression<Sg##suffix>(lhs, rhs); \
  }

BUILD_BINARY_DEF(AddOp)
BUILD_BINARY_DEF(AndAssignOp)
BUILD_BINARY_DEF(AndOp)
BUILD_BINARY_DEF(ArrowExp)
BUILD_BINARY_DEF(ArrowStarOp)
BUILD_BINARY_DEF(AssignOp)
BUILD_BINARY_DEF(BitAndOp)
BUILD_BINARY_DEF(BitOrOp)
BUILD_BINARY_DEF(BitXorOp)

BUILD_BINARY_DEF(CommaOpExp)
BUILD_BINARY_DEF(ConcatenationOp)
BUILD_BINARY_DEF(DivAssignOp)
BUILD_BINARY_DEF(DivideOp)
BUILD_BINARY_DEF(DotExp)
BUILD_BINARY_DEF(DotStarOp)
BUILD_BINARY_DEF(EqualityOp)

BUILD_BINARY_DEF(ExponentiationOp)
BUILD_BINARY_DEF(ExponentiationAssignOp)
BUILD_BINARY_DEF(GreaterOrEqualOp)
BUILD_BINARY_DEF(GreaterThanOp)
BUILD_BINARY_DEF(IntegerDivideOp)
BUILD_BINARY_DEF(IntegerDivideAssignOp)
BUILD_BINARY_DEF(IorAssignOp)
BUILD_BINARY_DEF(IsOp)
BUILD_BINARY_DEF(IsNotOp)

BUILD_BINARY_DEF(LessOrEqualOp)
BUILD_BINARY_DEF(LessThanOp)
BUILD_BINARY_DEF(LshiftAssignOp)
BUILD_BINARY_DEF(LshiftOp)

BUILD_BINARY_DEF(MembershipOp)
BUILD_BINARY_DEF(MinusAssignOp)
BUILD_BINARY_DEF(ModAssignOp)
BUILD_BINARY_DEF(ModOp)
BUILD_BINARY_DEF(MultAssignOp)
BUILD_BINARY_DEF(MultiplyOp)

BUILD_BINARY_DEF(NotEqualOp)
BUILD_BINARY_DEF(NonMembershipOp)
BUILD_BINARY_DEF(OrOp)
BUILD_BINARY_DEF(PlusAssignOp)
BUILD_BINARY_DEF(PntrArrRefExp)
BUILD_BINARY_DEF(RshiftAssignOp)
BUILD_BINARY_DEF(JavaUnsignedRshiftAssignOp)

BUILD_BINARY_DEF(RshiftOp)
BUILD_BINARY_DEF(JavaUnsignedRshiftOp)
BUILD_BINARY_DEF(ScopeOp)
BUILD_BINARY_DEF(SubtractOp)
BUILD_BINARY_DEF(XorAssignOp)

BUILD_BINARY_DEF(VarArgCopyOp)
BUILD_BINARY_DEF(VarArgStartOp)

#undef BUILD_BINARY_DEF



SgArrayType* SageBuilder::buildArrayType(SgType* base_type/*=NULL*/, SgExpression* index/*=NULL*/)
{
  SgArrayType* result = new SgArrayType(base_type,index);
  ROSE_ASSERT(result); 
  if (index!=NULL) index->set_parent(result); // important!
  return result;
}

SgConditionalExp* SageBuilder::buildConditionalExp(SgExpression* test, SgExpression* a, SgExpression* b)
{
  SgConditionalExp* result = new SgConditionalExp(test, a, b, NULL);
  if (test) test->set_parent(result);
  if (a) a->set_parent(result);
  if (b) b->set_parent(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgConditionalExp* SageBuilder::buildConditionalExp_nfi(SgExpression* test, SgExpression* a, SgExpression* b, SgType* t)
{
  SgConditionalExp* result = new SgConditionalExp(test, a, b, t);
  if (test) test->set_parent(result);
  if (a) {a->set_parent(result); markLhsValues(a);}
  if (b) {b->set_parent(result); markLhsValues(b);}
  setOneSourcePositionNull(result);
  return result;
}
SgVariantExpression * SageBuilder::buildVariantExpression()
{
  SgVariantExpression * result =  new SgVariantExpression();
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result; 
}

SgNullExpression* SageBuilder::buildNullExpression_nfi()
{
  SgNullExpression* ne = new SgNullExpression();
  ROSE_ASSERT(ne);
  setOneSourcePositionNull(ne);
  return ne;
}

SgNullExpression* SageBuilder::buildNullExpression() {
  SgNullExpression* e = buildNullExpression_nfi();
  setOneSourcePositionForTransformation(e);
  return e;
}

SgAssignInitializer * SageBuilder::buildAssignInitializer(SgExpression * operand_i /*= NULL*/, SgType * expression_type /* = NULL */)
   {
     SgAssignInitializer* result = new SgAssignInitializer(operand_i, expression_type);
     ROSE_ASSERT(result);
     if (operand_i!=NULL) 
        {
          operand_i->set_parent(result);
       // set lvalue, it asserts operand!=NULL 
          markLhsValues(result);
        }
     setOneSourcePositionForTransformation(result);
     return result; 
   }

SgAssignInitializer * SageBuilder::buildAssignInitializer_nfi(SgExpression * operand_i /*= NULL*/, SgType * expression_type /* = UNLL */)
   {
     SgAssignInitializer* result = new SgAssignInitializer(operand_i, expression_type);
     ROSE_ASSERT(result);   
     if (operand_i!=NULL) 
        {
          operand_i->set_parent(result);
       // set lvalue, it asserts operand!=NULL 
          markLhsValues(result);
        }

  // DQ (11/2/2012): Set the source positon using our standard approach.
  // result->set_startOfConstruct(NULL);
  // result->set_endOfConstruct(NULL);
  // result->set_operatorPosition(NULL);
     setSourcePosition(result);

     result->set_need_paren(false);

     return result; 
   }

//! Build an aggregate initializer
SgAggregateInitializer * SageBuilder::buildAggregateInitializer(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)
{
  SgAggregateInitializer* result = new SgAggregateInitializer(initializers, type);
  ROSE_ASSERT(result);
  if (initializers!=NULL)
  {
    initializers->set_parent(result);
  }
  result->set_need_explicit_braces(true);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build an aggregate initializer
SgAggregateInitializer * SageBuilder::buildAggregateInitializer_nfi(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)
{
  SgAggregateInitializer* result = new SgAggregateInitializer(initializers, type);
  ROSE_ASSERT(result);
  if (initializers!=NULL)
  {
    initializers->set_parent(result);
  }
  result->set_need_explicit_braces(true);
  setOneSourcePositionNull(result);
  return result;
}

//! Build a compound initializer, for vector type initialization
SgCompoundInitializer * SageBuilder::buildCompoundInitializer(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)
{
  SgCompoundInitializer* result = new SgCompoundInitializer(initializers, type);
  ROSE_ASSERT(result);
  if (initializers!=NULL)
  {
    initializers->set_parent(result);
  }
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build a compound initializer, for vector type initialization
SgCompoundInitializer * SageBuilder::buildCompoundInitializer_nfi(SgExprListExp * initializers/* = NULL*/, SgType *type/* = NULL */)
{
  SgCompoundInitializer* result = new SgCompoundInitializer(initializers, type);
  ROSE_ASSERT(result);
  if (initializers!=NULL)
  {
    initializers->set_parent(result);
  }
  setOneSourcePositionNull(result);
  return result;
}

// DQ (1/4/2009): Added support for SgConstructorInitializer
SgConstructorInitializer *
SageBuilder::buildConstructorInitializer(
   SgMemberFunctionDeclaration *declaration/* = NULL*/,
   SgExprListExp *args/* = NULL*/,
   SgType *expression_type/* = NULL*/,
   bool need_name /*= false*/,
   bool need_qualifier /*= false*/,
   bool need_parenthesis_after_name /*= false*/,
   bool associated_class_unknown /*= false*/)
   {
  // Prototype:
  // SgConstructorInitializer (SgMemberFunctionDeclaration *declaration, SgExprListExp *args, SgType *expression_type, 
  //    bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown);

     //George Vulov (05/24/2011) Modified this assertion to allow for a NULL declaration (in case of implicit constructors)
     ROSE_ASSERT(declaration == NULL || declaration->get_associatedClassDeclaration() != NULL);

     SgConstructorInitializer* result = new SgConstructorInitializer( declaration, args, expression_type, need_name, 
                                        need_qualifier, need_parenthesis_after_name, associated_class_unknown );
     ROSE_ASSERT(result != NULL);
     if (args != NULL)
        {
          args->set_parent(result);
          setOneSourcePositionForTransformation(args);
        }

     setOneSourcePositionForTransformation(result);

     return result;
   }

// DQ (1/4/2009): Added support for SgConstructorInitializer
SgConstructorInitializer *
SageBuilder::buildConstructorInitializer_nfi(
   SgMemberFunctionDeclaration *declaration/* = NULL*/,
   SgExprListExp *args/* = NULL*/,
   SgType *expression_type/* = NULL*/,
   bool need_name /*= false*/,
   bool need_qualifier /*= false*/,
   bool need_parenthesis_after_name /*= false*/,
   bool associated_class_unknown /*= false*/)
   {
  // Prototype:
  // SgConstructorInitializer (SgMemberFunctionDeclaration *declaration, SgExprListExp *args, SgType *expression_type, bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown);

  // DQ (11/7/2011): Added additional error checking.
  // ROSE_ASSERT(declaration != NULL);
  // DQ (1/4/2009): Error checking
  // ROSE_ASSERT(declaration->get_associatedClassDeclaration() != NULL);

  // DQ (11/7/2011): Fix symetric to the way George did it above.
     ROSE_ASSERT(declaration == NULL || declaration->get_associatedClassDeclaration() != NULL);

     SgConstructorInitializer* result = new SgConstructorInitializer( declaration, args, expression_type, need_name, need_qualifier, need_parenthesis_after_name, associated_class_unknown );
     ROSE_ASSERT(result != NULL);

     setOneSourcePositionNull(result);

     if (args != NULL)
        {
          args->set_parent(result);
        }

  // DQ (11/4/2012): This is required and appears to work fine now.
  // DQ (11/23/2011): Fixup the expression list (but this does not appear to work...)
     if (result->get_args()->get_startOfConstruct() == NULL)
       {
#if 0
         printf ("In buildConstructorInitializer_nfi(): Fixup the source position of result->get_args() \n");
#endif
         setOneSourcePositionNull(result->get_args());
       }

     return result;
   }



//! Build sizeof() expression with an expression parameter
SgSizeOfOp* SageBuilder::buildSizeOfOp(SgExpression* exp/*= NULL*/)
{
  SgType* exp_type =NULL;
  if (exp) exp_type = exp->get_type();

  SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, NULL);
  //SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, exp_type);
  ROSE_ASSERT(result);
  if (exp)
  {
    exp->set_parent(result);
    markLhsValues(result);
  }
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build sizeof() expression with an expression parameter
SgSizeOfOp* SageBuilder::buildSizeOfOp_nfi(SgExpression* exp/*= NULL*/)
{
  SgType* exp_type =NULL;
  if (exp) exp_type = exp->get_type();

  SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, NULL);
  //SgSizeOfOp* result = new SgSizeOfOp(exp,NULL, exp_type);
  ROSE_ASSERT(result);
  if (exp)
  {
    exp->set_parent(result);
    markLhsValues(result);
  }
  setOneSourcePositionNull(result);
  return result;
}

//! Build sizeof() expression with a type parameter
SgSizeOfOp* SageBuilder::buildSizeOfOp(SgType* type /* = NULL*/)
{
  SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,NULL);
  //SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,type);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build sizeof() expression with a type parameter
SgSizeOfOp* SageBuilder::buildSizeOfOp_nfi(SgType* type /* = NULL*/)
{
  SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,NULL);
  //SgSizeOfOp* result = new SgSizeOfOp((SgExpression*)NULL,type,type);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}


//! Build __alignof__() expression with an expression parameter
SgAlignOfOp* SageBuilder::buildAlignOfOp(SgExpression* exp/*= NULL*/)
{
  SgType* exp_type =NULL;
  if (exp) exp_type = exp->get_type();

  SgAlignOfOp* result = new SgAlignOfOp(exp,NULL, NULL);
  ROSE_ASSERT(result);
  if (exp)
  {
    exp->set_parent(result);
    markLhsValues(result);
  }
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build __alignof__() expression with an expression parameter
SgAlignOfOp* SageBuilder::buildAlignOfOp_nfi(SgExpression* exp/*= NULL*/)
{
  SgType* exp_type =NULL;
  if (exp) exp_type = exp->get_type();

  SgAlignOfOp* result = new SgAlignOfOp(exp,NULL, NULL);
  ROSE_ASSERT(result);
  if (exp)
  {
    exp->set_parent(result);
    markLhsValues(result);
  }
  setOneSourcePositionNull(result);
  return result;
}

//! Build __alignof__() expression with a type parameter
SgAlignOfOp* SageBuilder::buildAlignOfOp(SgType* type /* = NULL*/)
{
  SgAlignOfOp* result = new SgAlignOfOp((SgExpression*)NULL,type,NULL);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build __alignof__() expression with a type parameter
SgAlignOfOp* SageBuilder::buildAlignOfOp_nfi(SgType* type /* = NULL*/)
{
  SgAlignOfOp* result = new SgAlignOfOp((SgExpression*)NULL,type,NULL);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}


SgExprListExp * SageBuilder::buildExprListExp(SgExpression * expr1, SgExpression* expr2, SgExpression* expr3, SgExpression* expr4, SgExpression* expr5, SgExpression* expr6, SgExpression* expr7, SgExpression* expr8, SgExpression* expr9, SgExpression* expr10)
{
  SgExprListExp* expList = new SgExprListExp();
  ROSE_ASSERT(expList);

//  printf ("In SageBuilder::buildExprListExp(SgExpression * expr1, SgExpression* expr2, ...): SgExprListExp* expList = %p \n",expList);

  setOneSourcePositionForTransformation(expList);
  if (expr1) appendExpression(expList, expr1);
  if (expr2) appendExpression(expList, expr2);
  if (expr3) appendExpression(expList, expr3);
  if (expr4) appendExpression(expList, expr4);
  if (expr5) appendExpression(expList, expr5);
  if (expr6) appendExpression(expList, expr6);
  if (expr7) appendExpression(expList, expr7);
  if (expr8) appendExpression(expList, expr8);
  if (expr9) appendExpression(expList, expr9);
  if (expr10) appendExpression(expList, expr10);
  return expList;
}

// CH (5/11/2010): Seems that this function is useful.
SgExprListExp * SageBuilder::buildExprListExp(const std::vector<SgExpression*>& exprs)
{
  SgExprListExp* expList = new SgExprListExp();
  ROSE_ASSERT(expList);

  printf ("In SageBuilder::buildExprListExp(const std::vector<SgExpression*>& exprs): SgExprListExp* expList = %p \n",expList);

  setOneSourcePositionForTransformation(expList);
  for (size_t i = 0; i < exprs.size(); ++i) {
    appendExpression(expList, exprs[i]);
  }
  return expList;
}

SgExprListExp * SageBuilder::buildExprListExp_nfi()
   {
     SgExprListExp* expList = new SgExprListExp();
     ROSE_ASSERT(expList);

#if 0
     printf ("In SageBuilder::buildExprListExp_nfi(): SgExprListExp* expList = %p \n",expList);
#endif

     setOneSourcePositionNull(expList);
     return expList;
   }

SgExprListExp * SageBuilder::buildExprListExp_nfi(const std::vector<SgExpression*>& exprs)
   {
     SgExprListExp* expList = new SgExprListExp();
     ROSE_ASSERT(expList != NULL);

#if 0
     printf ("In SageBuilder::buildExprListExp_nfi(const std::vector<SgExpression*>& exprs): SgExprListExp* expList = %p expList->get_expressions().size() = %zu \n",expList,expList->get_expressions().size());
#endif

     setOneSourcePositionNull(expList);
     for (size_t i = 0; i < exprs.size(); ++i)
        {
#if 0
          printf ("In SageBuilder::buildExprListExp_nfi(): exprs[i=%zu] = %p = %s \n",i,exprs[i],exprs[i]->class_name().c_str());
#endif
          appendExpression(expList, exprs[i]);
        }

  // DQ (4/3/2012): Added test to make sure that the pointers are unique.
     testAstForUniqueNodes(expList);

     return expList;
   }

SgVarRefExp*
SageBuilder::buildVarRefExp(SgInitializedName* initname, SgScopeStatement* scope)
   {
     ROSE_ASSERT(initname);
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();
  // ROSE_ASSERT(scope != NULL); // we allow to build a dangling ref without symbol

     SgVarRefExp *varRef = NULL;
  // there is assertion for get_scope() != NULL in get_symbol_from_symbol_table()
     SgSymbol* symbol = NULL;
     if (initname->get_scope()!=NULL)
          symbol = initname->get_symbol_from_symbol_table ();
  
     if (symbol != NULL)
        {
          varRef = new SgVarRefExp(isSgVariableSymbol(symbol));
          setOneSourcePositionForTransformation(varRef);
          ROSE_ASSERT(varRef);
        }
       else
        {
#if 0
          printf ("In SageBuilder::buildVarRefExp(): we might be reusing an existing SgVarRefExp \n");
#endif
          varRef = buildVarRefExp(initname->get_name(), scope);
        }

#if 0
     printf ("In SageBuilder::buildVarRefExp(): Returning SgVarRefExp = %p \n",varRef);
#endif

     return varRef;
   }

SgVarRefExp *
SageBuilder::buildVarRefExp(const char* varName, SgScopeStatement* scope) 
{
   SgName name(varName);   
   return buildVarRefExp(name,scope); 
} 

SgVarRefExp *
SageBuilder::buildVarRefExp(const std::string& varName, SgScopeStatement* scope)
//SageBuilder::buildVarRefExp(std::string& varName, SgScopeStatement* scope=NULL)
{
  SgName name(varName);
  return buildVarRefExp(name,scope);
}

SgVarRefExp *
SageBuilder::buildVarRefExp(const SgName& name, SgScopeStatement* scope/*=NULL*/)
   {
#if 0
     printf ("In SageBuilder::buildVarRefExp(): scope = %p = %s = %s \n",scope,scope->class_name().c_str(),get_name(scope).c_str());
#endif

     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

  // ROSE_ASSERT(scope != NULL); // we allow to build a dangling ref without symbol
     SgSymbol*         symbol    = NULL;
     SgVariableSymbol* varSymbol = NULL;

     if (scope != NULL)
        {
       // DQ (12/30/2011): This is a bad idea for C++ since qualified names might indicate different scopes.
       // If the scope has been provided then is should be the correct scope.
#if 1
       // DQ (8/16/2013): Modified to use the new API supporting template parameters and template arguments, however 
       // this should more likely be using lookupVariableSymbolInParentScopes() instead of lookupSymbolInParentScopes().
       // printf ("In SageBuilder::buildVarRefExp(): switch from lookupSymbolInParentScopes() and lookupVariableSymbolInParentScopes() \n");
       // symbol = lookupSymbolInParentScopes(name,scope);
          symbol = lookupVariableSymbolInParentScopes(name,scope);
#else
#error "DAED CODE!"
          symbol = scope->lookup_variable_symbol(name);
#endif
#if 0
          printf ("In SageBuilder::buildVarRefExp(): scope = %p = %s name = %s symbol = %p \n",scope,scope->class_name().c_str(),name.str(),symbol);
#endif
//        ROSE_ASSERT(symbol != NULL);
        }

     if (symbol != NULL) 
        {
#if 0
          printf ("What type of symbol is this: symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
          varSymbol = isSgVariableSymbol(symbol); 
        }
       else
        {
       // if not found: put fake init name and symbol here and 
       // waiting for a postProcessing phase to clean it up
       // two features: no scope and unknown type for initializedName
          SgInitializedName * name1 = buildInitializedName(name,SgTypeUnknown::createType());
          name1->set_scope(scope);  // buildInitializedName() does not set scope for various reasons
          varSymbol = new SgVariableSymbol(name1);
          varSymbol->set_parent(scope);

       // DQ (4/2/2012): Output a warning:
#if 0
          printf ("WARNING: In SageBuilder::buildVarRefExp(): symbol not found so we built a SgVariableSymbol = %p (but not put into symbol table) \n",varSymbol);
#endif
        }

     if (varSymbol == NULL)
        {
          printf ("Error: varSymbol == NULL for name = %s \n",name.str());
        }
     ROSE_ASSERT(varSymbol != NULL);

     SgVarRefExp *varRef = new SgVarRefExp(varSymbol);
     setOneSourcePositionForTransformation(varRef);
     ROSE_ASSERT(varRef != NULL);

#if 0
     printf ("In SageBuilder::buildVarRefExp(const SgName& name, SgScopeStatement* scope = %p): varRef = %p \n",scope,varRef);
#endif

     return varRef; 
   }

//! Build a variable reference from an existing variable declaration. The assumption is a SgVariableDeclartion only declares one variable in the ROSE AST.
SgVarRefExp *
SageBuilder::buildVarRefExp(SgVariableDeclaration* vardecl)
   {
     SgVariableSymbol* symbol = getFirstVarSym(vardecl);
     ROSE_ASSERT(symbol);

     return buildVarRefExp(symbol);
   }


SgVarRefExp *
SageBuilder::buildVarRefExp(SgVariableSymbol* sym)
   {
     SgVarRefExp *varRef = new SgVarRefExp(sym);
     ROSE_ASSERT(varRef);

     setOneSourcePositionForTransformation(varRef);

#if 0
     printf ("In SageBuilder::buildVarRefExp(SgVariableSymbol* sym): Returning SgVarRefExp = %p \n",varRef);
#endif

     return varRef; 
   }

SgVarRefExp *
SageBuilder::buildVarRefExp_nfi(SgVariableSymbol* sym)
   {
     SgVarRefExp *varRef = new SgVarRefExp(sym);
     ROSE_ASSERT(varRef);

     setOneSourcePositionNull(varRef);

#if 0
     printf ("In SageBuilder::buildVarRefExp_nfi(SgVariableSymbol* sym): Returning SgVarRefExp = %p \n",varRef);
#endif

     return varRef; 
   }

//!Build a variable reference expression at scope to an opaque variable which has unknown information except for its name.  Used when referring to an internal variable defined in some headers of runtime libraries.(The headers are not yet inserted into the file during translation). Similar to buildOpaqueType(); 
/*! It will declare a hidden int varName  at the specified scope to cheat the AST consistence tests.
 */
SgVarRefExp*
SageBuilder::buildOpaqueVarRefExp(const std::string& name,SgScopeStatement* scope/* =NULL */)
   {
     SgVarRefExp *result = NULL;

     if (scope == NULL)
          scope = SageBuilder::topScopeStack();
     ROSE_ASSERT(scope != NULL);

  // DQ (8/16/2013): Modified to use the new API supporting template parameters and template arguments, however 
  // this should more likely be using lookupVariableSymbolInParentScopes() instead of lookupSymbolInParentScopes().
  // SgSymbol * symbol = lookupSymbolInParentScopes(name,scope);
     SgSymbol * symbol = lookupVariableSymbolInParentScopes(name,scope);

     if (symbol)
        {
       // Can be the same opaque var ref built before
       // cerr<<"Error: trying to build an opaque var ref when the variable is actual explicit!"<<endl;
       // ROSE_ASSERT(false);
          ROSE_ASSERT(isSgVariableSymbol(symbol));
          result = buildVarRefExp(isSgVariableSymbol(symbol));  

       // DQ (4/2/2012): Output a warning:
          printf ("WARNING: In SageBuilder::buildOpaqueVarRefExp(): proper symbol used to build SgVarRefExp = %p \n",result);
        }
       else
        {
         SgVariableDeclaration* fakeVar = buildVariableDeclaration(name, buildIntType(),NULL, scope);
         Sg_File_Info* file_info = fakeVar->get_file_info();
         file_info->unsetOutputInCodeGeneration ();
         SgVariableSymbol* fakeSymbol = getFirstVarSym (fakeVar);   
         result = buildVarRefExp(fakeSymbol);

       // DQ (4/2/2012): Output a warning:
          printf ("WARNING: In SageBuilder::buildOpaqueVarRefExp(): fake symbol generated to build SgVarRefExp = %p (but not put into symbol table) \n",result);
        }

     return result;
   } // buildOpaqueVarRefExp()


// DQ (9/4/2013): Added support for building compound literals (similar to a SgVarRefExp).
//! Build function for compound literals (uses a SgVariableSymbol and is similar to buildVarRefExp_nfi()).
SgCompoundLiteralExp*
SageBuilder::buildCompoundLiteralExp_nfi(SgVariableSymbol* varSymbol)
   {
     SgCompoundLiteralExp *compoundLiteral = new SgCompoundLiteralExp(varSymbol);
     ROSE_ASSERT(compoundLiteral != NULL);

     setOneSourcePositionNull(compoundLiteral);

#if 0
     printf ("In SageBuilder::buildCompoundLiteralExp_nfi(SgVariableSymbol* sym): Returning SgCompoundLiteralExp = %p \n",compoundLiteral);
#endif

     return compoundLiteral;
   }

// DQ (9/4/2013): Added support for building compound literals (similar to a SgVarRefExp).
//! Build function for compound literals (uses a SgVariableSymbol and is similar to buildVarRefExp()).
SgCompoundLiteralExp*
SageBuilder::buildCompoundLiteralExp(SgVariableSymbol* varSymbol)
   {
     SgCompoundLiteralExp *compoundLiteral = new SgCompoundLiteralExp(varSymbol);
     ROSE_ASSERT(compoundLiteral != NULL);

     setOneSourcePositionForTransformation(compoundLiteral);

#if 0
     printf ("In SageBuilder::buildCompoundLiteralExp(SgVariableSymbol* sym): Returning SgCompoundLiteralExp = %p \n",compoundLiteral);
#endif

     return compoundLiteral;
   }


//! Build a Fortran numeric label ref exp
SgLabelRefExp * SageBuilder::buildLabelRefExp(SgLabelSymbol * s)
{
   SgLabelRefExp * result= NULL;
   ROSE_ASSERT (s!= NULL);
   result = new SgLabelRefExp(s);
   ROSE_ASSERT (result != NULL);
   setOneSourcePositionForTransformation(result);
   return result;
}

SgFunctionParameterList*
SageBuilder::buildFunctionParameterList(SgFunctionParameterTypeList * paraTypeList)
{
  SgFunctionParameterList* paraList = buildFunctionParameterList();
  if (paraTypeList==NULL) return paraList;

  SgTypePtrList typeList = paraTypeList->get_arguments();
  SgTypePtrList::iterator i;
  for (i=typeList.begin();i!=typeList.end();i++)
  {
    SgInitializedName* arg = buildInitializedName(SgName(""),(*i));
    appendArg(paraList,arg);
  }

  return paraList;
}

SgFunctionParameterList*
SageBuilder::buildFunctionParameterList_nfi(SgFunctionParameterTypeList * paraTypeList)
{
  SgFunctionParameterList* paraList = buildFunctionParameterList();
  ROSE_ASSERT (paraList);
  SgTypePtrList typeList = paraTypeList->get_arguments();
  SgTypePtrList::iterator i;
  for (i=typeList.begin();i!=typeList.end();i++)
  {
    SgInitializedName* arg = buildInitializedName_nfi(SgName(""),(*i),NULL);
    appendArg(paraList,arg);
  }
  return paraList;
}

// lookup function symbol to create a reference to it
SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(const SgName& name,const SgType* funcType, SgScopeStatement* scope /*=NULL*/)
{
  ROSE_ASSERT(funcType); // function type cannot be NULL
  SgFunctionType* func_type = isSgFunctionType(const_cast<SgType*>(funcType));
  ROSE_ASSERT(func_type);

  bool isMemberFunc = isSgMemberFunctionType(func_type);

  if (scope == NULL)
    scope = SageBuilder::topScopeStack();
  ROSE_ASSERT(scope != NULL);
  SgFunctionSymbol* symbol = lookupFunctionSymbolInParentScopes(name,func_type,scope);
  if (symbol == NULL) 
    // in rare cases when function calls are inserted before any prototypes exist
  {
    SgType* return_type = func_type->get_return_type();
    SgFunctionParameterTypeList * paraTypeList = func_type->get_argument_list();
    SgFunctionParameterList *parList = buildFunctionParameterList(paraTypeList);

    SgGlobal* globalscope = getGlobalScope(scope);

    ROSE_ASSERT (isMemberFunc == false);  // Liao, 11/21/2012. We assume only regular functions can go into this if-body so we can insert them into global scope by default
 // TODO: consider C++ template functions and Fortran functions
 // SgFunctionDeclaration * funcDecl= buildNondefiningFunctionDeclaration(name,return_type,parList,globalscope);
 // SgFunctionDeclaration * funcDecl = buildNondefiningFunctionDeclaration_T <SgFunctionDeclaration>(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL);

 // TODO: consider C++ template functions 
    SgFunctionDeclaration * funcDecl = NULL; 
    if (SageInterface::is_Fortran_language ())
       {
      // DQ (8/21/2013): Fixed number of parameters in buildNondefiningFunctionDeclaration_T() function call.
      // funcDecl = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement>(name,return_type,parList,false,globalscope,NULL, false, NULL);
         funcDecl = buildNondefiningFunctionDeclaration_T <SgProcedureHeaderStatement>(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL);
       }
      else
       {
      // DQ (8/21/2013): Fixed number of parameters in buildNondefiningFunctionDeclaration_T() function call.
      // funcDecl = buildNondefiningFunctionDeclaration_T <SgFunctionDeclaration>(name,return_type,parList,false,globalscope,NULL, false, NULL);
          funcDecl = buildNondefiningFunctionDeclaration_T <SgFunctionDeclaration>(name,return_type,parList,false,globalscope,NULL, false, NULL, NULL);
       }

    funcDecl->get_declarationModifier().get_storageModifier().setExtern();

    // This will conflict with prototype in a header
    // prepend_statement(globalscope,funcDecl);
    // Prepend a function prototype declaration in current scope, hide it from the unparser
    // prependStatement(funcDecl,scope);
    // Sg_File_Info* file_info = funcDecl->get_file_info();
    // file_info->unsetOutputInCodeGeneration ();

    symbol = lookupFunctionSymbolInParentScopes(name,func_type,scope);
    ROSE_ASSERT(symbol);
  }
  SgFunctionRefExp* func_ref = new SgFunctionRefExp(symbol,func_type);
  setOneSourcePositionForTransformation(func_ref);

  ROSE_ASSERT(func_ref);
  return func_ref;
}

SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(const char* name,const SgType* funcType, SgScopeStatement* scope /*=NULL*/)
{
  SgName name2(name);
  return buildFunctionRefExp(name2,funcType,scope);
}

// lookup function symbol to create a reference to it
SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(const SgFunctionDeclaration* func_decl)
{
  ROSE_ASSERT(func_decl != NULL);
  SgDeclarationStatement* nondef_func = func_decl->get_firstNondefiningDeclaration ();
  SgDeclarationStatement* def_func = func_decl->get_definingDeclaration ();
  SgSymbol* symbol = NULL; 
  if (nondef_func != NULL)
  {
    ROSE_ASSERT(nondef_func!= NULL);
    symbol = nondef_func->get_symbol_from_symbol_table();
    ROSE_ASSERT( symbol != NULL);
  }
  // Liao 12/1/2010. It is possible that there is no prototype declarations at all
  else if (def_func != NULL)
  {
    symbol = def_func->get_symbol_from_symbol_table();
  }
  else
  {
    cerr<<"Fatal error: SageBuilder::buildFunctionRefExp():defining and nondefining declarations for a function cannot be both NULL"<<endl;
    ROSE_ASSERT (false);
  }
  ROSE_ASSERT( symbol != NULL);
  return buildFunctionRefExp( isSgFunctionSymbol (symbol));
}


// lookup function symbol to create a reference to it
SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(SgFunctionSymbol* sym)
{
  SgFunctionRefExp* func_ref = new SgFunctionRefExp(sym, NULL);
  setOneSourcePositionForTransformation(func_ref);
  ROSE_ASSERT(func_ref);
  return func_ref;
}

// lookup function symbol to create a reference to it
SgFunctionRefExp *
SageBuilder::buildFunctionRefExp_nfi(SgFunctionSymbol* sym)
{
  SgFunctionRefExp* func_ref = new SgFunctionRefExp(sym, NULL);
  setOneSourcePositionNull(func_ref);
  ROSE_ASSERT(func_ref);
  return func_ref;
}

#ifdef ROSE_USE_NEW_EDG_INTERFACE
// DQ (12/15/2011): Adding template declaration support to the AST.
SgTemplateFunctionRefExp *
SageBuilder::buildTemplateFunctionRefExp_nfi(SgTemplateFunctionSymbol* sym)
   {
  // DQ (2/23/2013): Added assertion.
     ROSE_ASSERT(sym != NULL);

     SgTemplateFunctionRefExp* func_ref = new SgTemplateFunctionRefExp(sym);
     ROSE_ASSERT(func_ref != NULL);

     setOneSourcePositionNull(func_ref);

  // DQ (2/23/2013): Added assertion.
     ROSE_ASSERT(func_ref->get_symbol() != NULL);

     return func_ref;
   }
#endif

#ifdef ROSE_USE_NEW_EDG_INTERFACE
// DQ (12/29/2011): Adding template declaration support to the AST.
SgTemplateMemberFunctionRefExp *
SageBuilder::buildTemplateMemberFunctionRefExp_nfi(SgTemplateMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)
   {
     SgTemplateMemberFunctionRefExp* func_ref = new SgTemplateMemberFunctionRefExp(sym, virtual_call, need_qualifier);
     setOneSourcePositionNull(func_ref);
     ROSE_ASSERT(func_ref);
     return func_ref;
   }
#endif

// lookup member function symbol to create a reference to it
SgMemberFunctionRefExp *
SageBuilder::buildMemberFunctionRefExp_nfi(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)
{
  SgMemberFunctionRefExp* func_ref = new SgMemberFunctionRefExp(sym, virtual_call, NULL, need_qualifier);
  setOneSourcePositionNull(func_ref);
  ROSE_ASSERT(func_ref);
  return func_ref;
}

// lookup member function symbol to create a reference to it
SgMemberFunctionRefExp *
SageBuilder::buildMemberFunctionRefExp(SgMemberFunctionSymbol* sym, bool virtual_call, bool need_qualifier)
{
  SgMemberFunctionRefExp* func_ref = new SgMemberFunctionRefExp(sym, virtual_call, NULL, need_qualifier);
  setOneSourcePositionForTransformation(func_ref);
  ROSE_ASSERT(func_ref);
  return func_ref;
}

// lookup class symbol to create a reference to it
SgClassNameRefExp *
SageBuilder::buildClassNameRefExp_nfi(SgClassSymbol* sym)
{
  SgClassNameRefExp* class_ref = new SgClassNameRefExp(sym);
  setOneSourcePositionNull(class_ref);
  ROSE_ASSERT(class_ref);
  return class_ref;
}

SgClassNameRefExp *
SageBuilder::buildClassNameRefExp(SgClassSymbol* sym)
{
  SgClassNameRefExp* class_ref = new SgClassNameRefExp(sym);
  setOneSourcePositionForTransformation(class_ref);
  ROSE_ASSERT(class_ref);
  return class_ref;
}

//! Lookup a C style function symbol to create a function reference expression to it
SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(const SgName& name, SgScopeStatement* scope /*=NULL*/)
{
  if (scope == NULL)
     scope = SageBuilder::topScopeStack();
  ROSE_ASSERT(scope != NULL);
  SgFunctionSymbol* symbol = lookupFunctionSymbolInParentScopes(name,scope);

  if (symbol==NULL) 
// in rare cases when function calls are inserted before any prototypes exist
  {
// assume int return type, and empty parameter list

#if 1
// DQ (7/26/2012): I am at least temporarily removing this function from the API.
// Later if we need it, we can update it to reflect that passing of the new 
// SgTemplateArgumentPtrList function parameter (part of the new API design).

   SgFunctionDeclaration* funcDecl = NULL;
   printf ("Error: buildFunctionRefExp(): This function should not be used! \n");
   ROSE_ASSERT(false);
#else
    SgType* return_type = buildIntType();
    SgFunctionParameterList *parList = buildFunctionParameterList();

    SgGlobal* globalscope = getGlobalScope(scope);

    SgFunctionDeclaration * funcDecl = buildNondefiningFunctionDeclaration(name,return_type,parList,globalscope);
#endif

    funcDecl->get_declarationModifier().get_storageModifier().setExtern();

   
    symbol = lookupFunctionSymbolInParentScopes(name,scope);
    ROSE_ASSERT(symbol);
  }

  SgFunctionRefExp* func_ref = buildFunctionRefExp(symbol);
  setOneSourcePositionForTransformation(func_ref);

  ROSE_ASSERT(func_ref);
  return func_ref;
}

SgFunctionRefExp *
SageBuilder::buildFunctionRefExp(const char* name, SgScopeStatement* scope /*=NULL*/)
{
  SgName name2(name); 
  return buildFunctionRefExp(name2,scope);
}


SgExprStatement*
SageBuilder::buildExprStatement(SgExpression*  exp)
{
  SgExprStatement* expStmt = new SgExprStatement(exp);
  ROSE_ASSERT(expStmt);
  if (exp) exp->set_parent(expStmt);
  setOneSourcePositionForTransformation(expStmt);
  return expStmt;
}

SgExprStatement*
SageBuilder::buildExprStatement_nfi(SgExpression*  exp)
{
  SgExprStatement* expStmt = new SgExprStatement(exp);
  ROSE_ASSERT(expStmt);
  if (exp) exp->set_parent(expStmt);
  setOneSourcePositionNull(expStmt);
  return expStmt;
}

SgFunctionCallExp* 
SageBuilder::buildFunctionCallExp(const SgName& name, SgType* return_type, SgExprListExp* parameters/*=NULL*/, SgScopeStatement* scope/*=NULL*/)
   {
     if (scope == NULL)    
          scope = SageBuilder::topScopeStack();
     ROSE_ASSERT(scope != NULL); 

     if (parameters == NULL)
          parameters = buildExprListExp();

#if 0
     printf ("In SageBuilder::buildFunctionCallExp(): calling buildFunctionParameterTypeList() \n");
#endif

     SgFunctionParameterTypeList * typeList = buildFunctionParameterTypeList(parameters); 
     SgFunctionType * func_type = buildFunctionType(return_type,typeList); 
     SgFunctionRefExp* func_ref = buildFunctionRefExp(name,func_type,scope);
     SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref->get_type());
     parameters->set_parent(func_call_expr);
     setOneSourcePositionForTransformation(func_call_expr);
     ROSE_ASSERT(func_call_expr);

     return func_call_expr;  
   }


SgFunctionCallExp* 
SageBuilder::buildFunctionCallExp(SgFunctionSymbol* sym, 
                                  SgExprListExp* parameters/*=NULL*/)
   {
     ROSE_ASSERT (sym);
     if (parameters == NULL)
          parameters = buildExprListExp();
     ROSE_ASSERT (parameters);

  // DQ (8/21/2011): We want to preserve the support for member functions to be built as SgMemberFunctionRefExp.
  // This is important for the Java support and the C++ support else we will be lowering all mmember function calls
  // to function calls which will be a proble for eht analysis of object oriented languages.
  // SgFunctionRefExp* func_ref = buildFunctionRefExp(sym);
  // SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref->get_type());
  // func_ref->set_parent(func_call_expr);
     SgFunctionCallExp * func_call_expr = NULL;
     SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(sym);
     if (memberFunctionSymbol != NULL)
        {
       // Note that we can't at this point be sure this is not a virtual function.
          bool virtual_call = false;

       // Name qualificaiton is handled separately from the setting of this variable (old API).
          bool need_qualifier = false;

          SgMemberFunctionRefExp* member_func_ref = buildMemberFunctionRefExp(memberFunctionSymbol,virtual_call,need_qualifier);
          func_call_expr = new SgFunctionCallExp(member_func_ref,parameters,member_func_ref->get_type());
          member_func_ref->set_parent(func_call_expr);
        }
       else
        {
          SgFunctionRefExp * func_ref = buildFunctionRefExp(sym);
          func_call_expr = new SgFunctionCallExp(func_ref,parameters,func_ref->get_type());
          func_ref->set_parent(func_call_expr);
        }


     parameters->set_parent(func_call_expr);

     setOneSourcePositionForTransformation(func_call_expr);

     ROSE_ASSERT(func_call_expr);
     return func_call_expr;  
   }

SgFunctionCallExp* 
SageBuilder::buildFunctionCallExp_nfi(SgExpression* f, SgExprListExp* parameters /*=NULL*/)
   {
     SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(f,parameters,f->get_type());
     ROSE_ASSERT(func_call_expr != NULL);

     if (f) f->set_parent(func_call_expr);
     if (parameters) parameters->set_parent(func_call_expr);
     setOneSourcePositionNull(func_call_expr);

     return func_call_expr;  
   }

SgFunctionCallExp* 
SageBuilder::buildFunctionCallExp(SgExpression* f, SgExprListExp* parameters/*=NULL*/)
   {
     SgFunctionCallExp * func_call_expr = new SgFunctionCallExp(f,parameters,f->get_type());
     ROSE_ASSERT(func_call_expr != NULL);

     if (f) f->set_parent(func_call_expr);
     if (parameters) parameters->set_parent(func_call_expr);
     setOneSourcePositionForTransformation(func_call_expr);

     return func_call_expr;  
   }

SgExprStatement*
SageBuilder::buildFunctionCallStmt(const SgName& name, 
                      SgType* return_type, 
                      SgExprListExp* parameters /*= NULL*/, 
                      SgScopeStatement* scope /*=NULL*/)
{
  if (scope == NULL)
    scope = SageBuilder::topScopeStack();
  ROSE_ASSERT(scope != NULL);
  SgFunctionCallExp* func_call_expr = buildFunctionCallExp(name,return_type,parameters,scope);
  SgExprStatement * expStmt = buildExprStatement(func_call_expr);
  return expStmt;
}

//! Build a function call statement using function expression and argument list only, like (*funcPtr)(args);
SgExprStatement*
SageBuilder::buildFunctionCallStmt(SgExpression* function_exp, SgExprListExp* parameters/*=NULL*/)
{
  SgFunctionCallExp* func_call_expr = buildFunctionCallExp(function_exp, parameters);
  SgExprStatement * expStmt = buildExprStatement(func_call_expr);
  return expStmt;
}

SgTypeTraitBuiltinOperator*
SageBuilder::buildTypeTraitBuiltinOperator(SgName functionName, SgNodePtrList parameters)
   {
  // DQ (7/14/2013): This is supporting compiler extensions that are required to support type traits in C++.
  // These operators are used increasingly in newer versions of GNU and other compilers.  They are builtin
  // compiler extensions that typically take types as arguments.

     SgTypeTraitBuiltinOperator * builtin_func_call_expr = new SgTypeTraitBuiltinOperator(functionName);
     ROSE_ASSERT(builtin_func_call_expr != NULL);

  // Note that this is copy by value...on SgNodePtrList (because we have to support both SgExpression and SgType IR nodes as arguments).
  // In this way this is implemented differently from a SgCallExpression ro SgFunctionCallExp (which uses a SgExprListExp).
     builtin_func_call_expr->get_args() = parameters;

     return builtin_func_call_expr;
   }


//! Build a CUDA kernel call expression (kernel<<<config>>>(parameters))
SgCudaKernelCallExp * SageBuilder::buildCudaKernelCallExp_nfi(SgExpression * kernel, SgExprListExp* parameters, SgCudaKernelExecConfig * config) {
  ROSE_ASSERT(kernel);
  ROSE_ASSERT(parameters);
  ROSE_ASSERT(config);

  SgFunctionRefExp * func_ref_exp = isSgFunctionRefExp(kernel);
  if (!func_ref_exp) {
    std::cerr << "SgCudaKernelCallExp accept only direct reference to a function." << std::endl;
    ROSE_ASSERT(false);
  }
  if (!(func_ref_exp->get_symbol_i()->get_declaration()->get_functionModifier().isCudaKernel())) {
    std::cerr << "To build a SgCudaKernelCallExp the callee need to be a kernel (having \"__global__\" attribute)." << std::endl;
    ROSE_ASSERT(false);
  }

  SgCudaKernelCallExp * kernel_call_expr = new SgCudaKernelCallExp(kernel, parameters, kernel->get_type(), config);

  kernel->set_parent(kernel_call_expr);
  parameters->set_parent(kernel_call_expr);
  config->set_parent(kernel_call_expr);

  setOneSourcePositionNull(kernel_call_expr);

  ROSE_ASSERT(kernel_call_expr);

  return kernel_call_expr;  
}

//! Build a CUDA kernel execution configuration (<<<grid, blocks, shared, stream>>>)
SgCudaKernelExecConfig * SageBuilder::buildCudaKernelExecConfig_nfi(SgExpression *grid, SgExpression *blocks, SgExpression *shared, SgExpression *stream) {
  if (!grid || !blocks) {
     std::cerr << "SgCudaKernelExecConfig need fields 'grid' and 'blocks' to be set." << std::endl;
     ROSE_ASSERT(false);
  }

  // TODO-CUDA check types

  SgCudaKernelExecConfig * config = new SgCudaKernelExecConfig (grid, blocks, shared, stream);

  grid->set_parent(config);
  blocks->set_parent(config);
  if (shared)
    shared->set_parent(config);
  if (stream)
    stream->set_parent(config);

  setOneSourcePositionNull(config);
  
  ROSE_ASSERT(config);
  
  return config;
}

SgExprStatement*
SageBuilder::buildAssignStatement(SgExpression* lhs,SgExpression* rhs)
//SageBuilder::buildAssignStatement(SgExpression* lhs,SgExpression* rhs, SgScopeStatement* scope=NULL)
{
  ROSE_ASSERT(lhs != NULL); 
  ROSE_ASSERT(rhs != NULL); 
  
  //SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,lhs->get_type());
// SgBinaryOp::get_type() assume p_expression_type is not set
  SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,NULL);
  ROSE_ASSERT(assignOp);
  setOneSourcePositionForTransformation(assignOp);
  lhs->set_parent(assignOp);
  rhs->set_parent(assignOp);
  
  lhs->set_lvalue (true);
  SgExprStatement* exp = new SgExprStatement(assignOp);
  ROSE_ASSERT(exp);
   // some child nodes are transparently generated, using recursive setting is safer
  setSourcePositionAtRootAndAllChildren(exp);
  //setOneSourcePositionForTransformation(exp);
  assignOp->set_parent(exp);
  return exp;
}

// DQ (8/16/2011): This is an AST translate specific version (see note below). 
// We would like to phase out the version above if possible (but we want to 
// test this later).
SgExprStatement*
SageBuilder::buildAssignStatement_ast_translate(SgExpression* lhs,SgExpression* rhs)
{
  ROSE_ASSERT(lhs != NULL); 
  ROSE_ASSERT(rhs != NULL); 
  
  //SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,lhs->get_type());
// SgBinaryOp::get_type() assume p_expression_type is not set
  SgAssignOp* assignOp = new SgAssignOp(lhs,rhs,NULL);
  ROSE_ASSERT(assignOp);
  setOneSourcePositionForTransformation(assignOp);
  lhs->set_parent(assignOp);
  rhs->set_parent(assignOp);
  
  lhs->set_lvalue (true);
  SgExprStatement* exp = new SgExprStatement(assignOp);
  ROSE_ASSERT(exp);

// DQ (8/16/2011): Modified to avoid recursive call to reset source position information 
// (this version is required for the Java support where we have set source code position
// information on the lhs and rhs and we don't want it to be reset as a transformation.
// some child nodes are transparently generated, using recursive setting is safer
  setOneSourcePositionForTransformation(exp);
  assignOp->set_parent(exp);
  return exp;
}


SgLabelStatement * SageBuilder::buildLabelStatement(const SgName& name,  SgStatement * stmt/*=NULL*/, SgScopeStatement* scope /*=NULL*/)
{
  if (scope == NULL)
    scope = SageBuilder::topScopeStack();
 //  ROSE_ASSERT(scope != NULL); // We support bottom up building of label statements now
 
   // should including current scope when searching for the function definition
   // since users can only pass FunctionDefinition when the function body is not yet attached
  SgLabelStatement * labelstmt = new SgLabelStatement(name,stmt);
  ROSE_ASSERT(labelstmt);
  setOneSourcePositionForTransformation(labelstmt);
  
 if(stmt!=NULL) 
   stmt->set_parent(labelstmt);
 #if 0  // moved to fixLabelStatement()
  SgFunctionDefinition * label_scope = getEnclosingFunctionDefinition(scope,true);
  ROSE_ASSERT (label_scope);
  labelstmt->set_scope(label_scope);
  SgLabelSymbol* lsymbol= new SgLabelSymbol(labelstmt);
  ROSE_ASSERT(lsymbol); 
  // TODO should we prevent duplicated insertion ?
  label_scope->insert_symbol(lsymbol->get_name(), lsymbol);
 #endif 

  // Liao 1/7/2010
  // SgLabelStatement is used for CONTINUE statement in Fortran
  // In this case , it has no inherent association with a Label symbol.
  // It is up to the SageInterface::setNumericalLabel(SgStatement*) to handle label symbol
  if (!SageInterface::is_Fortran_language() &&scope)
    fixLabelStatement(labelstmt,scope);
  // we don't want to set parent here yet
  // delay it until append_statement() or alike
  return labelstmt;
}

SgLabelStatement * SageBuilder::buildLabelStatement_nfi(const SgName& name,  SgStatement * stmt/*=NULL*/, SgScopeStatement* scope /*=NULL*/)
{
  SgLabelStatement * labelstmt = new SgLabelStatement(name,stmt);
  ROSE_ASSERT(labelstmt);
  setOneSourcePositionForTransformation(labelstmt);
  
 if(stmt!=NULL) 
   stmt->set_parent(labelstmt);
  if (scope)
    fixLabelStatement(labelstmt,scope);
  // we don't want to set parent here yet
  // delay it until append_statement() or alike
  return labelstmt;
}

SgIfStmt * SageBuilder::buildIfStmt(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body)
{
  ROSE_ASSERT(conditional);
  ROSE_ASSERT(true_body);
  // ROSE_ASSERT(false_body); -- this is not required anymore
  SgIfStmt *ifstmt = new SgIfStmt(conditional, true_body, false_body);
  ROSE_ASSERT(ifstmt);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
  if (symbol_table_case_insensitive_semantics == true)
       ifstmt->setCaseInsensitive(true);

  setOneSourcePositionForTransformation(ifstmt);
  conditional->set_parent(ifstmt);
  true_body->set_parent(ifstmt);
  if (false_body != NULL) false_body->set_parent(ifstmt);

  if (SageInterface::is_Fortran_language() )
  {
    // Liao 1/20/2010
    // According to Fortran 77 standard Chapter 11.5 to 11.9, 
    // this is a Fortran Block IF statement, if the true body is:
    // 1. A block of statement under SgBasicBlock
    // 2. DO, block if, or another logical if
    // Otherwise it is a logical if statement
    if (isSgBasicBlock(true_body)|| isSgFortranDo(true_body)|| isSgIfStmt(true_body)) 
    {
      ifstmt->set_use_then_keyword(true);
      ifstmt->set_has_end_statement(true);
    } 
  }

  return ifstmt;
}

SgIfStmt * SageBuilder::buildIfStmt_nfi(SgStatement* conditional, SgStatement * true_body, SgStatement * false_body)
   {
     SgIfStmt *ifstmt = new SgIfStmt(conditional, true_body, false_body);
     ROSE_ASSERT(ifstmt);
#if 0
  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          ifstmt->setCaseInsensitive(true);

     setOneSourcePositionNull(ifstmt);
     if (conditional) conditional->set_parent(ifstmt);
     if (true_body) true_body->set_parent(ifstmt);
     if (false_body) false_body->set_parent(ifstmt);
     return ifstmt;
#else
  // DQ (2/13/2012): This allows us to separate teh construction from the initialization (see note below).
     initializeIfStmt(ifstmt,conditional,true_body,false_body);
     return ifstmt;
#endif
   }

// charles4 10/14/2011:  Vanilla allocation. Use prepend_init_stmt and append_init_stmt to populate afterward.
SgForInitStatement * SageBuilder::buildForInitStatement() 
   {
  // return new SgForInitStatement();
     SgForInitStatement* result = new SgForInitStatement();

  // DQ (11/3/2012): Added call to set file info to default settings.
     setSourcePosition(result);

     return result;
   }

// DQ (10/12/2012): Added specific API to handle simple (single) statement.
SgForInitStatement*
SageBuilder::buildForInitStatement( SgStatement* statement )
   {
     SgForInitStatement* forInit = new SgForInitStatement();
     ROSE_ASSERT(forInit != NULL);

     ROSE_ASSERT(statement != NULL);
     forInit->append_init_stmt(statement);

  // DQ (11/3/2012): Added call to set file info to default settings.
     setSourcePosition(forInit);

     return forInit;
   }

SgForInitStatement * SageBuilder::buildForInitStatement(const SgStatementPtrList & statements) 
{
  SgForInitStatement * result = new SgForInitStatement();
  result->get_init_stmt() = statements;

  for (SgStatementPtrList::iterator it = result->get_init_stmt().begin(); it != result->get_init_stmt().end(); it++)
    (*it)->set_parent(result);

  setOneSourcePositionForTransformation(result);
  return result;
}

SgForInitStatement*
SageBuilder::buildForInitStatement_nfi(SgStatementPtrList & statements)
   {
     SgForInitStatement * result = new SgForInitStatement();

     result->get_init_stmt() = statements;

     for (SgStatementPtrList::iterator it = result->get_init_stmt().begin(); it != result->get_init_stmt().end(); it++)
        {
#if 0
          printf ("In buildForInitStatement_nfi(): set the parent for it = %p = %s \n",*it,(*it)->class_name().c_str());
#endif
          (*it)->set_parent(result);
        }

  // DQ (11/3/2012): Added call to set file info to default settings.
     setSourcePosition(result);

     return result;
   }

//! Based on the contribution from Pradeep Srinivasa@ LANL
//Liao, 8/27/2008
SgForStatement * SageBuilder::buildForStatement(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)
{
     SgForStatement * result = new SgForStatement(test,increment, loop_body);
     ROSE_ASSERT(result);

  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionForTransformation(result);
     if (test) 
          test->set_parent(result);
     if (loop_body) 
          loop_body->set_parent(result);
     if (increment) 
          increment->set_parent(result);

  if (else_body)
    else_body->set_parent(result);
  result->set_else_body(else_body);

  // CH (5/13/2010): If the initialize_stmt is an object of SgForInitStatement, we can directly put it 
  // into for statement. Or else, there will be two semicolons after unparsing.
     if (SgForInitStatement* for_init_stmt = isSgForInitStatement(initialize_stmt))
        {
#if 0
          printf ("Handled a proper SgForInitStatement as input! \n");
#endif
       // DQ (7/30/2011): We have to delete the the SgForInitStatement build within the SgForStatement::post_constructor_initialization()
       // to avoid causing errors in the AST consistancy checking later.
          if (result->get_for_init_stmt() != NULL)
             {
#if 0
               printf ("Deleting the old one build in SgForStatement::post_constructor_initialization() \n");
#endif
               delete result->get_for_init_stmt();
               result->set_for_init_stmt(NULL);
             }

          result->set_for_init_stmt(for_init_stmt);
          for_init_stmt->set_parent(result);
          return result;
        }

     SgForInitStatement* init_stmt = new SgForInitStatement();
     ROSE_ASSERT(init_stmt);
     setOneSourcePositionForTransformation(init_stmt);

  // DQ (7/30/2011): We have to delete the the SgForInitStatement build within the SgForStatement::post_constructor_initialization().
  // to avoid causeing errors in the AST consistancy checking later.
     if (result->get_for_init_stmt() != NULL)
        {
          delete result->get_for_init_stmt();
          result->set_for_init_stmt(NULL);
        }

     result->set_for_init_stmt(init_stmt);
     init_stmt->set_parent(result);

     if (initialize_stmt) 
        {
          init_stmt->append_init_stmt(initialize_stmt);
       // Support for "for (int i=0; )", Liao, 3/11/2009
       // The symbols are inserted into the symbol table attached to SgForStatement
          if (isSgVariableDeclaration(initialize_stmt))
             {
               fixVariableDeclaration(isSgVariableDeclaration(initialize_stmt),result);
            // fix varRefExp to the index variable used in increment, conditional expressions
               fixVariableReferences(result);
             }
        }

     return result;
   }


//! Based on the contribution from Pradeep Srinivasa@ LANL
//Liao, 8/27/2008
SgForStatement*
SageBuilder::buildForStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)
   {
     SgForStatement * result = new SgForStatement(test, increment, loop_body);
     ROSE_ASSERT(result);

  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     if (test)      test->set_parent(result);
     if (loop_body) loop_body->set_parent(result);
     if (increment) increment->set_parent(result);
     if (else_body) else_body->set_parent(result);

     result->set_else_body(else_body);

     if (initialize_stmt != NULL)
        {
          SgForInitStatement* init_stmt = result->get_for_init_stmt();
          ROSE_ASSERT(init_stmt);
          setOneSourcePositionNull(init_stmt);
          init_stmt->append_init_stmt(initialize_stmt);
          initialize_stmt->set_parent(init_stmt);
        }

     return result;
   }


SgForStatement*
SageBuilder::buildForStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)
   {
     SgForStatement * result = new SgForStatement(init_stmt, test, increment, loop_body);
     ROSE_ASSERT(result != NULL);

#if 1
  // DQ (9/26/2012): Refactored this function to allow for where the SgForStatement had to be 
  // constructed early to define the scope for types that can be defined in the SgForInitStatement.
     buildForStatement_nfi(result,init_stmt,test,increment,loop_body,else_body);
#else
  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     if (test)           test->set_parent(result);
     if (loop_body) loop_body->set_parent(result);
     if (increment) increment->set_parent(result);
     if (init_stmt) init_stmt->set_parent(result);

     if (else_body) init_stmt->set_parent(result);
     result->set_else_body(else_body);
#endif

     return result;
   }


void
SageBuilder::buildForStatement_nfi(SgForStatement* result, SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body, SgStatement * else_body)
   {
  // DQ (9/26/2012): Refactored this function to allow for where the SgForStatement had to be 
  // constructed early to define the scope for types that can be defined in the SgForInitStatement.

     ROSE_ASSERT(result != NULL);

  // DQ  (9/26/2012): I think we can assert this (fails test2004_77.C).
  // ROSE_ASSERT(init_stmt != NULL);
  // ROSE_ASSERT(test      != NULL);
  // ROSE_ASSERT(increment != NULL);
  // ROSE_ASSERT(loop_body != NULL);

#if 0
  // DQ (9/26/2012): It might be that these should always be set.
#if 0
     if (result->get_for_init_stmt() == NULL)
          result->set_for_init_stmt(init_stmt);
     if (result->get_test() == NULL)
          result->set_test(test);
     if (result->get_increment() == NULL)
          result->set_increment(increment);
     if (result->get_loop_body() == NULL)
          result->set_loop_body(loop_body);
#else
  // This test might make it impossible for us to use this function in SgForStatement* SageBuilder::buildForStatement_nfi()
     if (result->get_for_init_stmt() != NULL)
        {
          if (init_stmt != result->get_for_init_stmt())
             {
               delete result->get_for_init_stmt();
               result->set_for_init_stmt(NULL);
             }
       // delete result->get_for_init_stmt();
       // result->set_for_init_stmt(NULL);
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("Error: In SgForStatement, SgForInitStatement is already set result->get_for_init_stmt() = %p = %s \n",result->get_for_init_stmt(),result->get_for_init_stmt()->class_name().c_str());
#endif
       // ROSE_ASSERT(false);
        }
#endif
#endif

  // DQ (11/4/2012): I have added support for remove existing subtrees if they are different from what is provided as input.
     if (result->get_for_init_stmt() != NULL && init_stmt != result->get_for_init_stmt())
        {
          delete result->get_for_init_stmt();
          result->set_for_init_stmt(NULL);
        }

     if (result->get_test() != NULL && test != result->get_test())
        {
          delete result->get_test();
          result->set_test(NULL);
        }

     if (result->get_increment() != NULL && increment != result->get_increment())
        {
          delete result->get_increment();
          result->set_increment(NULL);
        }

     if (result->get_loop_body() != NULL && loop_body != result->get_loop_body())
        {
          delete result->get_loop_body();
          result->set_loop_body(NULL);
        }

     if (result->get_else_body() != NULL && else_body != result->get_else_body())
        {
          delete result->get_else_body();
          result->set_else_body(NULL);
        }

     result->set_for_init_stmt(init_stmt);
     result->set_test(test);
     result->set_increment(increment);
     result->set_loop_body(loop_body);

  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     if (test)           test->set_parent(result);
     if (loop_body) loop_body->set_parent(result);
     if (increment) increment->set_parent(result);
     if (init_stmt) init_stmt->set_parent(result);

     if (else_body) init_stmt->set_parent(result);
     result->set_else_body(else_body);

     ROSE_ASSERT(result->get_for_init_stmt() != NULL);
     ROSE_ASSERT(result->get_test()          != NULL);
     ROSE_ASSERT(result->get_increment()     != NULL);
     ROSE_ASSERT(result->get_loop_body()     != NULL);
   }


//! Based on the contribution from Pradeep Srinivasa@ LANL
//Liao, 8/27/2008
SgUpcForAllStatement * SageBuilder::buildUpcForAllStatement_nfi(SgStatement* initialize_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body)
{
  SgUpcForAllStatement * result = new SgUpcForAllStatement(test,increment, affinity, loop_body);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  if (test) test->set_parent(result);
  if (loop_body) loop_body->set_parent(result);
  if (increment) increment->set_parent(result);
  if (affinity) affinity->set_parent(result);

  if (initialize_stmt != NULL) {
    SgForInitStatement* init_stmt = result->get_for_init_stmt();
    ROSE_ASSERT(init_stmt);
    setOneSourcePositionNull(init_stmt);
    init_stmt->append_init_stmt(initialize_stmt);
    initialize_stmt->set_parent(init_stmt);
  }

  return result;
}


SgUpcForAllStatement * SageBuilder::buildUpcForAllStatement_nfi(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgExpression* affinity, SgStatement * loop_body)
{
  SgUpcForAllStatement * result = new SgUpcForAllStatement(init_stmt, test, increment, affinity, loop_body);
  ROSE_ASSERT(result);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
  if (symbol_table_case_insensitive_semantics == true)
       result->setCaseInsensitive(true);

  setOneSourcePositionNull(result);
  if (test)           test->set_parent(result);
  if (loop_body) loop_body->set_parent(result);
  if (increment) increment->set_parent(result);
  if (affinity)   affinity->set_parent(result);
  if (init_stmt) init_stmt->set_parent(result);

  return result;
}

// DQ (3/3/2013): Added UPC specific build functions.
SgUpcNotifyStatement*
SageBuilder::buildUpcNotifyStatement_nfi(SgExpression* exp)
   {
     SgUpcNotifyStatement* result = new SgUpcNotifyStatement(exp);

     setOneSourcePositionNull(result);

     exp->set_parent(result);

     ROSE_ASSERT(exp->get_parent() != NULL);

     return result;
   }

SgUpcWaitStatement* 
SageBuilder::buildUpcWaitStatement_nfi(SgExpression* exp)
   {
     SgUpcWaitStatement* result = new SgUpcWaitStatement(exp);

     setOneSourcePositionNull(result);

     exp->set_parent(result);

     ROSE_ASSERT(exp->get_parent() != NULL);

     return result;
   }

SgUpcBarrierStatement* 
SageBuilder::buildUpcBarrierStatement_nfi(SgExpression* exp)
   {
     SgUpcBarrierStatement* result = new SgUpcBarrierStatement(exp);

     setOneSourcePositionNull(result);

     exp->set_parent(result);

     ROSE_ASSERT(exp->get_parent() != NULL);

     return result;
   }

SgUpcFenceStatement* 
SageBuilder::buildUpcFenceStatement_nfi()
   {
     SgUpcFenceStatement* result = new SgUpcFenceStatement();

     setOneSourcePositionNull(result);

     return result;
   }




SgWhileStmt * SageBuilder::buildWhileStmt(SgStatement *  condition, SgStatement *body, SgStatement* else_body)
{
  ROSE_ASSERT(condition);
  ROSE_ASSERT(body);
  SgWhileStmt * result = new SgWhileStmt(condition,body);
  ROSE_ASSERT(result);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
  if (symbol_table_case_insensitive_semantics == true)
       result->setCaseInsensitive(true);

  setOneSourcePositionForTransformation(result);
  condition->set_parent(result);
  body->set_parent(result);

// DQ (8/10/2011): This is added by Michael to support a Python specific feature.
  if (else_body != NULL) {
      result->set_else_body(else_body);
      else_body->set_parent(result);
  }

  return result;
}


SgWhileStmt*
SageBuilder::buildWhileStmt_nfi(SgStatement *  condition, SgStatement *body, SgStatement *else_body)
   {
     SgWhileStmt * result = new SgWhileStmt(condition,body);
     ROSE_ASSERT(result);

#if 0
  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     if (condition) condition->set_parent(result);
     if (body) body->set_parent(result);

  // DQ (8/10/2011): This is added by Michael to support a Python specific feature.
     if (else_body != NULL)
        {
          result->set_else_body(else_body);
          else_body->set_parent(result);
        }
#else
  // DQ (2/15/2012): This function supports the case where in C++ the condition can include a variable declaration.
     initializeWhileStatement(result,condition,body,else_body);
#endif

     return result;
   }


SgWithStatement* SageBuilder::buildWithStatement(SgExpression* expr, SgStatement *body)
{
  ROSE_ASSERT(expr != NULL && body != NULL);
  SgWithStatement* result = new SgWithStatement(expr, body);
  expr->set_parent(result);
  body->set_parent(result);

  setOneSourcePositionForTransformation(result);
  return result;
}

SgWithStatement* SageBuilder::buildWithStatement_nfi(SgExpression* expr, SgStatement *body)
{
  ROSE_ASSERT(expr != NULL && body != NULL);
  SgWithStatement* result = new SgWithStatement(expr, body);
  expr->set_parent(result);
  body->set_parent(result);

  setOneSourcePositionNull(result);
  return result;
}

SgDoWhileStmt * SageBuilder::buildDoWhileStmt(SgStatement *  body, SgStatement *condition)
{
  ROSE_ASSERT(condition);
  ROSE_ASSERT(body);
  SgDoWhileStmt * result = new SgDoWhileStmt(body, condition);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  condition->set_parent(result);
  body->set_parent(result);
  return result;
}

SgDoWhileStmt * SageBuilder::buildDoWhileStmt_nfi(SgStatement *  body, SgStatement *condition)
{
  SgDoWhileStmt * result = new SgDoWhileStmt(body, condition);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  if (condition) condition->set_parent(result);
  if (body) body->set_parent(result);
  return result;
}

SgBreakStmt * SageBuilder::buildBreakStmt()
{
  SgBreakStmt* result = new SgBreakStmt();
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgBreakStmt * SageBuilder::buildBreakStmt_nfi()
{
  SgBreakStmt* result = new SgBreakStmt();
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgContinueStmt * SageBuilder::buildContinueStmt()
{
  SgContinueStmt* result = new SgContinueStmt();
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgContinueStmt * SageBuilder::buildContinueStmt_nfi()
{
  SgContinueStmt* result = new SgContinueStmt();
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgPassStatement * SageBuilder::buildPassStatement()
{
  SgPassStatement* result = new SgPassStatement();
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgPassStatement * SageBuilder::buildPassStatement_nfi()
{
  SgPassStatement* result = new SgPassStatement();
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

SgDeleteExp* SageBuilder::buildDeleteExp(SgExpression *target, bool is_array, bool need_global_specifier, SgFunctionDeclaration *deleteOperatorDeclaration)
{
    SgDeleteExp *result = new SgDeleteExp(target, is_array, need_global_specifier, deleteOperatorDeclaration);
    target->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgDeleteExp* SageBuilder::buildDeleteExp_nfi(SgExpression *target, bool is_array, bool need_global_specifier, SgFunctionDeclaration *deleteOperatorDeclaration)
{
    SgDeleteExp *result = new SgDeleteExp(target, is_array, need_global_specifier, deleteOperatorDeclaration);
    target->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgAssertStmt* SageBuilder::buildAssertStmt(SgExpression* test)
{
  SgAssertStmt* result = new SgAssertStmt(test);
  ROSE_ASSERT(test != NULL);
  test->set_parent(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

// DQ (7/18/2011): Added support for SgJavaInstanceOfOp
//! This is part of Java specific operator support.
SgJavaInstanceOfOp* SageBuilder::buildJavaInstanceOfOp(SgExpression* exp, SgType* type)
   {
     SgType* exp_type = SgTypeBool::createType();

     SgJavaInstanceOfOp* result = new SgJavaInstanceOfOp(exp, type, exp_type);
     ROSE_ASSERT(result);
     if (exp != NULL)
        {
          exp->set_parent(result);
          markLhsValues(result);
        }

     setOneSourcePositionForTransformation(result);
     return result;
   }

SgAssertStmt* SageBuilder::buildAssertStmt(SgExpression* test, SgExpression* exceptionArgument)
{
  SgAssertStmt* result = new SgAssertStmt(test);
  ROSE_ASSERT(test != NULL);
  test->set_parent(result);
  if (exceptionArgument != NULL) {
      result -> set_exception_argument(exceptionArgument);
      exceptionArgument->set_parent(result);
  }
  setOneSourcePositionForTransformation(result);
  return result;
}

SgAssertStmt* SageBuilder::buildAssertStmt_nfi(SgExpression* test)
{
  SgAssertStmt* result = new SgAssertStmt(test);
  ROSE_ASSERT(test != NULL);
  test->set_parent(result);
  setOneSourcePositionNull(result);
  return result;
}

SgYieldExpression* SageBuilder::buildYieldExpression(SgExpression* value)
{
  ROSE_ASSERT(value != NULL);
  SgYieldExpression* result = new SgYieldExpression(value);
  value->set_parent(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgYieldExpression* SageBuilder::buildYieldExpression_nfi(SgExpression* value)
{
  ROSE_ASSERT(value != NULL);
  SgYieldExpression* result = new SgYieldExpression(value);
  value->set_parent(result);
  setOneSourcePositionNull(result);
  return result;
}

SgKeyDatumPair* SageBuilder::buildKeyDatumPair(SgExpression* key, SgExpression* datum)
{
    ROSE_ASSERT(key != NULL && datum != NULL);
    SgKeyDatumPair *result = new SgKeyDatumPair(key, datum);
    key->set_parent(result);
    datum->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgKeyDatumPair* SageBuilder::buildKeyDatumPair_nfi(SgExpression* key, SgExpression* datum)
{
    ROSE_ASSERT(key != NULL && datum != NULL);
    SgKeyDatumPair *result = new SgKeyDatumPair(key, datum);
    key->set_parent(result);
    datum->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgDictionaryExp* SageBuilder::buildDictionaryExp(std::vector<SgKeyDatumPair*> pairs)
{
    SgDictionaryExp *result = new SgDictionaryExp();
    ROSE_ASSERT(result);
    for (size_t i = 0; i < pairs.size(); ++i)
        result->append_pair(pairs[i]);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgDictionaryExp* SageBuilder::buildDictionaryExp_nfi(std::vector<SgKeyDatumPair*> pairs)
{
    SgDictionaryExp *result = new SgDictionaryExp();
    ROSE_ASSERT(result);
    for (size_t i = 0; i < pairs.size(); ++i)
        result->append_pair(pairs[i]);
    setOneSourcePositionNull(result);
    return result;
}

SgComprehension*
SageBuilder::buildComprehension(SgExpression *target, SgExpression *iter, SgExprListExp *ifs)
{
    ROSE_ASSERT(target != NULL);
    ROSE_ASSERT(iter != NULL);
    SgComprehension *result = new SgComprehension(target, iter, ifs);
    ROSE_ASSERT(result);

    target->set_parent(result);
    iter->set_parent(result);
    if (ifs != NULL) ifs->set_parent(result);

    setOneSourcePositionForTransformation(result);
    return result;
}

SgComprehension*
SageBuilder::buildComprehension_nfi(SgExpression *target, SgExpression *iter, SgExprListExp *ifs)
{
    ROSE_ASSERT(target != NULL);
    ROSE_ASSERT(iter != NULL);
    SgComprehension *result = new SgComprehension(target, iter, ifs);
    ROSE_ASSERT(result);
    target->set_parent(result);
    iter->set_parent(result);
    if (ifs != NULL) ifs->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgListComprehension*
SageBuilder::buildListComprehension(SgExpression *elt, SgExprListExp *generators)
{
    ROSE_ASSERT(elt != NULL);
    ROSE_ASSERT(generators != NULL);
    SgListComprehension* result = new SgListComprehension(elt, generators);
    elt->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgListComprehension*
SageBuilder::buildListComprehension_nfi(SgExpression *elt, SgExprListExp *generators)
{
    ROSE_ASSERT(elt != NULL);
    ROSE_ASSERT(generators != NULL);
    SgListComprehension* result = new SgListComprehension(elt, generators);
    elt->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgSetComprehension*
SageBuilder::buildSetComprehension(SgExpression *elt, SgExprListExp *generators)
{
    ROSE_ASSERT(elt != NULL);
    ROSE_ASSERT(generators != NULL);
    SgSetComprehension* result = new SgSetComprehension(elt, generators);
    elt->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgSetComprehension*
SageBuilder::buildSetComprehension_nfi(SgExpression *elt, SgExprListExp *generators)
{
    ROSE_ASSERT(elt != NULL);
    ROSE_ASSERT(generators != NULL);
    SgSetComprehension* result = new SgSetComprehension(elt, generators);
    elt->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgDictionaryComprehension*
SageBuilder::buildDictionaryComprehension(SgKeyDatumPair *kd_pair, SgExprListExp *generators)
{
    ROSE_ASSERT(kd_pair != NULL);
    ROSE_ASSERT(generators != NULL);
    SgDictionaryComprehension* result = new SgDictionaryComprehension(kd_pair, generators);
    kd_pair->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgDictionaryComprehension*
SageBuilder::buildDictionaryComprehension_nfi(SgKeyDatumPair *kd_pair, SgExprListExp *generators)
{
    ROSE_ASSERT(kd_pair != NULL);
    ROSE_ASSERT(generators != NULL);
    SgDictionaryComprehension* result = new SgDictionaryComprehension(kd_pair, generators);
    kd_pair->set_parent(result);
    generators->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgActualArgumentExpression*
SageBuilder::buildActualArgumentExpression(SgName arg_name, SgExpression* arg) {
    ROSE_ASSERT(arg != NULL);
    SgActualArgumentExpression* result = new SgActualArgumentExpression(arg_name, arg);
    arg->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgActualArgumentExpression*
SageBuilder::buildActualArgumentExpression_nfi(SgName arg_name, SgExpression* arg) {
    ROSE_ASSERT(arg != NULL);
    SgActualArgumentExpression* result = new SgActualArgumentExpression(arg_name, arg);
    arg->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgPragmaDeclaration*
SageBuilder::buildPragmaDeclaration(const string& name, SgScopeStatement* scope)
   {
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

     SgPragma* pragma = new SgPragma(name);
     ROSE_ASSERT(pragma);

     setOneSourcePositionForTransformation(pragma);

     SgPragmaDeclaration* result = new SgPragmaDeclaration(pragma);
     ROSE_ASSERT(result);

     setOneSourcePositionForTransformation(result);

     result->set_definingDeclaration (result);
     result->set_firstNondefiningDeclaration(result);
     pragma->set_parent(result);

  // DQ (7/14/2012): Set the parent so that we can be consistent where possible (class declarations and 
  // enum declaration can't have there parent set since they could be non-autonomous declarations).
     result->set_parent(topScopeStack());

    if (topScopeStack())
     ROSE_ASSERT(result->get_parent() != NULL);

     return result;
   }

//!Build SgPragma
SgPragma* SageBuilder::buildPragma(const std::string & name)
{
  SgPragma* result= new SgPragma(name);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgBasicBlock * SageBuilder::buildBasicBlock(SgStatement * stmt1, SgStatement* stmt2, SgStatement* stmt3, SgStatement* stmt4, SgStatement* stmt5, SgStatement* stmt6, SgStatement* stmt7, SgStatement* stmt8, SgStatement* stmt9, SgStatement* stmt10)
{
  SgBasicBlock* result = new SgBasicBlock();
  ROSE_ASSERT(result);

// DQ (11/28/2010): Added specification of case insensitivity for Fortran.
  if (symbol_table_case_insensitive_semantics == true)
       result->setCaseInsensitive(true);

  setOneSourcePositionForTransformation(result);
  if (stmt1) SageInterface::appendStatement(stmt1, result);
  if (stmt2) SageInterface::appendStatement(stmt2, result);
  if (stmt3) SageInterface::appendStatement(stmt3, result);
  if (stmt4) SageInterface::appendStatement(stmt4, result);
  if (stmt5) SageInterface::appendStatement(stmt5, result);
  if (stmt6) SageInterface::appendStatement(stmt6, result);
  if (stmt7) SageInterface::appendStatement(stmt7, result);
  if (stmt8) SageInterface::appendStatement(stmt8, result);
  if (stmt9) SageInterface::appendStatement(stmt9, result);
  if (stmt10) SageInterface::appendStatement(stmt10, result);

  return result;
}

SgBasicBlock * SageBuilder::buildBasicBlock_nfi()
   {
     SgBasicBlock* result = new SgBasicBlock();
     ROSE_ASSERT(result);

  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
        {
          result->setCaseInsensitive(true);
        }

     setOneSourcePositionNull(result);

#if 0
     printf ("In buildBasicBlock_nfi(): returning result = %p \n",result);
#endif

     return result;
   }

SgBasicBlock* SageBuilder::buildBasicBlock_nfi(const vector<SgStatement*>& stmts) 
   {
     SgBasicBlock* result = buildBasicBlock_nfi();
     appendStatementList(stmts, result);

#if 0
     printf ("In buildBasicBlock_nfi(const vector<SgStatement*>& stmts): returning result = %p \n",result);
#endif

#if 0
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif

     return result;
   }

SgGotoStatement * 
SageBuilder::buildGotoStatement(SgLabelStatement *  label)
{
  SgGotoStatement* result = new SgGotoStatement(label);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

SgGotoStatement * 
SageBuilder::buildGotoStatement(SgLabelSymbol*  symbol)
{
  SgGotoStatement* result = NULL;
  ROSE_ASSERT (symbol != NULL);
  if (SageInterface::is_Fortran_language())
  {  // Fortran case
    result = buildGotoStatement((SgLabelStatement *)NULL);
    SgLabelRefExp* l_exp = buildLabelRefExp(symbol);
    l_exp->set_parent(result);
    result->set_label_expression(l_exp);
  }  
  else  // C/C++ case 
  {
    SgLabelStatement* l_stmt = isSgLabelStatement(symbol->get_declaration());
    ROSE_ASSERT (l_stmt != NULL);
    result = buildGotoStatement(l_stmt);
  }  
  ROSE_ASSERT(result);
  return result;
}

SgGotoStatement * 
SageBuilder::buildGotoStatement_nfi(SgLabelStatement *  label)
{
  SgGotoStatement* result = new SgGotoStatement(label);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

//! Build a return statement
SgReturnStmt* SageBuilder::buildReturnStmt(SgExpression* expression /* = NULL */)
{
  // Liao 2/6/2013. We no longer allow NULL express pointer. Use SgNullExpression instead. 
  if (expression == NULL)
    expression = buildNullExpression();
  SgReturnStmt * result = new SgReturnStmt(expression);
  ROSE_ASSERT(result);
  if (expression != NULL) expression->set_parent(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build a return statement
SgReturnStmt* SageBuilder::buildReturnStmt_nfi(SgExpression* expression /* = NULL */)
{
  SgReturnStmt * result = new SgReturnStmt(expression);
  ROSE_ASSERT(result);
  if (expression != NULL) expression->set_parent(result);
  setOneSourcePositionNull(result);
  return result;
}

SgCaseOptionStmt * SageBuilder::buildCaseOptionStmt( SgExpression * key,SgStatement *body)
{
  SgCaseOptionStmt* result = new SgCaseOptionStmt(key,body);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  if (key) key->set_parent(result);
  if (body) body->set_parent(result);
  return result;
}

SgCaseOptionStmt * SageBuilder::buildCaseOptionStmt_nfi( SgExpression * key,SgStatement *body)
{
  SgCaseOptionStmt* result = new SgCaseOptionStmt(key,body);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  if (key) key->set_parent(result);
  if (body) body->set_parent(result);
  return result;
}

SgDefaultOptionStmt * SageBuilder::buildDefaultOptionStmt( SgStatement *body)
{
  SgDefaultOptionStmt* result = new SgDefaultOptionStmt(body);
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  if (body) body->set_parent(result);
  return result;
}

SgDefaultOptionStmt * SageBuilder::buildDefaultOptionStmt_nfi( SgStatement *body)
{
  SgDefaultOptionStmt* result = new SgDefaultOptionStmt(body);
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  if (body) body->set_parent(result);
  return result;
}

SgSwitchStatement* SageBuilder::buildSwitchStatement(SgStatement *item_selector,SgStatement *body)
{
  SgSwitchStatement* result = new SgSwitchStatement(item_selector,body);
  ROSE_ASSERT(result);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
  if (symbol_table_case_insensitive_semantics == true)
       result->setCaseInsensitive(true);

  setOneSourcePositionForTransformation(result);
  if (item_selector) item_selector->set_parent(result);
  if (body) body->set_parent(result);
  return result;
}

SgSwitchStatement*
SageBuilder::buildSwitchStatement_nfi(SgStatement *item_selector,SgStatement *body)
   {
     SgSwitchStatement* result = new SgSwitchStatement(item_selector,body);
     ROSE_ASSERT(result);

#if 0
  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     if (item_selector) item_selector->set_parent(result);
     if (body) body->set_parent(result);
#else
  // DQ (2/15/2012): Modified to handle C++ case where variable declarations are allowed in the condition.
     initializeSwitchStatement(result,item_selector,body);
#endif

     return result;
   }

//! Build a NULL statement
SgNullStatement* SageBuilder::buildNullStatement()
{
  SgNullStatement* result = NULL;
  result = new SgNullStatement();
  ROSE_ASSERT(result);
  setOneSourcePositionForTransformation(result);
  return result;
}

//! Build a NULL statement
SgNullStatement* SageBuilder::buildNullStatement_nfi()
{
  SgNullStatement* result = NULL;
  result = new SgNullStatement();
  ROSE_ASSERT(result);
  setOneSourcePositionNull(result);
  return result;
}

//! Build an exec stmt
SgExecStatement* SageBuilder::buildExecStatement(SgExpression* executable,
                                                 SgExpression* globals,
                                                 SgExpression* locals) {
    if (locals != NULL && globals == NULL)
        ROSE_ASSERT(!"buildExecStatement with non-NULL locals requires non-NULL globals");
    ROSE_ASSERT(executable != NULL);

    SgExecStatement* result = new SgExecStatement(executable, globals, locals);
    executable->set_parent(result);
    if (globals != NULL) globals->set_parent(result);
    if (locals != NULL) locals->set_parent(result);

    setOneSourcePositionForTransformation(result);
    return result;
}

//! Build an exec stmt
SgExecStatement* SageBuilder::buildExecStatement_nfi(SgExpression* executable,
                                                     SgExpression* globals,
                                                     SgExpression* locals) {
    if (locals != NULL && globals == NULL)
        ROSE_ASSERT(!"buildExecStatement with non-NULL locals requires non-NULL globals");
    ROSE_ASSERT(executable != NULL);

    SgExecStatement* result = new SgExecStatement(executable, globals, locals);
    executable->set_parent(result);
    if (globals != NULL) globals->set_parent(result);
    if (locals != NULL) locals->set_parent(result);

    setOneSourcePositionNull(result);
    return result;
}

//! Build a try statement
SgTryStmt* SageBuilder::buildTryStmt(SgStatement* body,
                                     SgCatchOptionStmt* catch0,
                                     SgCatchOptionStmt* catch1,
                                     SgCatchOptionStmt* catch2,
                                     SgCatchOptionStmt* catch3,
                                     SgCatchOptionStmt* catch4
                                     )
   {
     ROSE_ASSERT(body != NULL);
     SgTryStmt* try_stmt = new SgTryStmt(body);
     body->set_parent(try_stmt);

  // DQ (11/3/2012): Added setting default source position info.
     setSourcePosition(try_stmt);

     if (try_stmt->get_catch_statement_seq_root() != NULL)
        {
          if (try_stmt->get_catch_statement_seq_root()->get_startOfConstruct() == NULL)
             {
               ROSE_ASSERT(try_stmt->get_catch_statement_seq_root()->get_endOfConstruct() == NULL);
               setSourcePosition(try_stmt->get_catch_statement_seq_root());
             }

          ROSE_ASSERT(try_stmt->get_catch_statement_seq_root()->get_startOfConstruct() != NULL);
          ROSE_ASSERT(try_stmt->get_catch_statement_seq_root()->get_endOfConstruct()   != NULL);
        }

     if (catch0 != NULL) try_stmt->append_catch_statement(catch0);
     if (catch1 != NULL) try_stmt->append_catch_statement(catch1);
     if (catch2 != NULL) try_stmt->append_catch_statement(catch2);
     if (catch3 != NULL) try_stmt->append_catch_statement(catch3);
     if (catch4 != NULL) try_stmt->append_catch_statement(catch4);

     return try_stmt;
   }


// charles4 09/16/2011
//! Build a try statement (used for Java)
SgTryStmt *SageBuilder::buildTryStmt(SgBasicBlock *try_body, SgBasicBlock *finally_body)
   {
    //
    // charles4 09/23/2011 - Note that when an SgTryStmt is allocated, its constructor
    // preallocates a SgCatchStementSeq for the field p_catch_statement_sequence_root.
    // So, although the method set_catch_statement_seq_root(catch_statement_sequence) is
    // available, it should not be used to set the catch_statement_sequence_root as that 
    // would leave the one that was allocated by the constructor dangling!
    //
    ROSE_ASSERT(try_body != NULL);
    SgTryStmt* try_stmt = new SgTryStmt(try_body);
    try_body -> set_parent(try_stmt);

  // DQ (11/3/2012): Added setting default source position info.
     setSourcePosition(try_stmt);

    if (finally_body) {
        try_stmt -> set_finally_body(finally_body);
        finally_body -> set_parent(try_stmt);
   }

    return try_stmt;
}

// charles4 09/16/2011
// ! Build an initial sequence of Catch blocks containing 0 or 1 element.
SgCatchStatementSeq *SageBuilder::buildCatchStatementSeq(SgCatchOptionStmt *catch_option_stmt) {
    SgCatchStatementSeq *catch_statement_sequence = new SgCatchStatementSeq();

  // DQ (11/3/2012): Added setting default source position info.
     setSourcePosition(catch_statement_sequence);

    if (catch_option_stmt) {
        catch_statement_sequence -> append_catch_statement(catch_option_stmt);
        catch_option_stmt -> set_parent(catch_statement_sequence);
    }

    return catch_statement_sequence;
}

// charles4 09/21/2011 - Make condition and body arguments optional.
//! Build a catch statement
SgCatchOptionStmt* SageBuilder::buildCatchOptionStmt(SgVariableDeclaration* condition, SgStatement* body) {
    SgCatchOptionStmt* result = new SgCatchOptionStmt(condition, body, /* SgTryStmt*= */ NULL);
    if (condition) condition->set_parent(result);
    if (body) body->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgJavaSynchronizedStatement *SageBuilder::buildJavaSynchronizedStatement(SgExpression *expression, SgBasicBlock *body)
{
  ROSE_ASSERT(expression);
  ROSE_ASSERT(body);
  SgJavaSynchronizedStatement *sync_stmt = new SgJavaSynchronizedStatement(expression, body);
  ROSE_ASSERT(sync_stmt);

  expression->set_parent(sync_stmt);
  body->set_parent(sync_stmt);

  return sync_stmt;
}

SgJavaThrowStatement *SageBuilder::buildJavaThrowStatement(SgThrowOp *op)
{
  ROSE_ASSERT(op);
  SgJavaThrowStatement *throw_stmt = new SgJavaThrowStatement(op);
  ROSE_ASSERT(throw_stmt);

  op->set_parent(throw_stmt);

  return throw_stmt;
}

// DQ (9/3/2011): Changed the API to conform to the Java grammar.
// SgJavaForEachStatement *SageBuilder::buildJavaForEachStatement(SgInitializedName *variable, SgExpression *collection, SgStatement *body)
SgJavaForEachStatement *SageBuilder::buildJavaForEachStatement(SgVariableDeclaration *variable, SgExpression *collection, SgStatement *body)
{
  SgJavaForEachStatement *foreach_stmt = new SgJavaForEachStatement(variable, collection, body);
  ROSE_ASSERT(foreach_stmt);
  if (variable) variable -> set_parent(foreach_stmt);
  if (collection) collection -> set_parent(foreach_stmt);
  if (body) body -> set_parent(foreach_stmt);

  return foreach_stmt;
}

SgJavaLabelStatement *SageBuilder::buildJavaLabelStatement(const SgName& name,  SgStatement *stmt /* = NULL */)
{
    SgJavaLabelStatement *label_stmt = new SgJavaLabelStatement(name, stmt);
    ROSE_ASSERT(label_stmt);
    setOneSourcePositionForTransformation(label_stmt);
  
    if (stmt != NULL) 
        stmt -> set_parent(label_stmt);

    SgJavaLabelSymbol *lsymbol = label_stmt -> lookup_java_label_symbol(name);
    if (! lsymbol) // Should be an Assertion - always true!
    {
        lsymbol= new SgJavaLabelSymbol(label_stmt);
        ROSE_ASSERT(lsymbol);
        label_stmt -> insert_symbol(lsymbol -> get_name(), lsymbol);
    }

    return label_stmt;
}

SgPythonPrintStmt*
SageBuilder::buildPythonPrintStmt(SgExpression* dest, SgExprListExp* values) {
    SgPythonPrintStmt* result = new SgPythonPrintStmt(dest, values);
    if (dest) dest->set_parent(result);
    if (values) values->set_parent(result);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgPythonPrintStmt*
SageBuilder::buildPythonPrintStmt_nfi(SgExpression* dest, SgExprListExp* values) {
    SgPythonPrintStmt* result = new SgPythonPrintStmt(dest, values);
    if (dest) dest->set_parent(result);
    if (values) values->set_parent(result);
    setOneSourcePositionNull(result);
    return result;
}

SgPythonGlobalStmt*
SageBuilder::buildPythonGlobalStmt(SgInitializedNamePtrList& names) {
    SgPythonGlobalStmt* result = new SgPythonGlobalStmt();
    foreach (SgInitializedName* name, names)
        result->append_name(name);
    setOneSourcePositionForTransformation(result);
    return result;
}

SgPythonGlobalStmt*
SageBuilder::buildPythonGlobalStmt_nfi(SgInitializedNamePtrList& names) {
    SgPythonGlobalStmt* result = new SgPythonGlobalStmt();
    foreach (SgInitializedName* name, names)
        result->append_name(name);
    setOneSourcePositionNull(result);
    return result;
}

// DQ (4/30/2010): Added support for building asm statements.
//! Build an asm statement
SgAsmStmt* SageBuilder::buildAsmStatement( std::string s )
{
  SgAsmStmt* result = NULL;
  result = new SgAsmStmt();
  ROSE_ASSERT(result);
  result->set_assemblyCode(s);
  setOneSourcePositionForTransformation(result);
  return result;
}

// DQ (4/30/2010): Added support for building asm statements.
//! Build an asm statement
SgAsmStmt* SageBuilder::buildAsmStatement_nfi( std::string s )
{
  SgAsmStmt* result = NULL;
  result = new SgAsmStmt();
  ROSE_ASSERT(result);
  result->set_assemblyCode(s);
  setOneSourcePositionNull(result);
  return result;
}

SgAsmStmt*
SageBuilder::buildMultibyteNopStatement( int n )
   {
// Multi-byte NOP instructions.
// Note: I can't seem to get the memonic versions to work properly
#define NOP_1_BYTE_STRING "nop"
#define NOP_2_BYTE_STRING ".byte 0x66,0x90"
#define NOP_3_BYTE_STRING "nopl (%eax)"
#define NOP_4_BYTE_STRING "nopl 0x01(%eax)"
#define NOP_5_BYTE_STRING ".byte 0x0f,0x1f,0x44,0x00,0x00"
#define NOP_6_BYTE_STRING ".byte 0x66,0x0f,0x1f,0x44,0x00,0x00"
#define NOP_7_BYTE_STRING ".byte 0x0f,0x1f,0x80,0x00,0x00,0x00,0x00"
#define NOP_8_BYTE_STRING ".byte 0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00"
#define NOP_9_BYTE_STRING ".byte 0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00"

     ROSE_ASSERT(n > 0);

     SgAsmStmt* nopStatement = NULL;

     switch (n)
        {
          case 1: nopStatement = buildAsmStatement(NOP_1_BYTE_STRING); break;
          case 2: nopStatement = buildAsmStatement(NOP_2_BYTE_STRING); break;
          case 3: nopStatement = buildAsmStatement(NOP_3_BYTE_STRING); break;
          case 4: nopStatement = buildAsmStatement(NOP_4_BYTE_STRING); break;
          case 5: nopStatement = buildAsmStatement(NOP_5_BYTE_STRING); break;
          case 6: nopStatement = buildAsmStatement(NOP_6_BYTE_STRING); break;
          case 7: nopStatement = buildAsmStatement(NOP_7_BYTE_STRING); break;
          case 8: nopStatement = buildAsmStatement(NOP_8_BYTE_STRING); break;
          case 9: nopStatement = buildAsmStatement(NOP_9_BYTE_STRING); break;

          default:
             {
               printf ("Only supporting values of multi-byte nop's up to 9 bytes long. \n");
               ROSE_ASSERT(false);
             }
        }

     return nopStatement;
   }



//! Build a statement from an arbitrary string, used for irregular statements with macros, platform-specified attributes etc.
// This does not work properly since the global scope expects declaration statement, not just SgNullStatement
#if 0    
SgStatement* SageBuilder::buildStatementFromString(std::string str)
{ 
  SgStatement* result = NULL;
  
    return result;
     
} //buildStatementFromString()
#endif

SgPointerType* SageBuilder::buildPointerType(SgType * base_type /*= NULL*/)
   {
  // DQ (7/26/2010): This needs to call the SgPointerType::createType() function so that we can properly abstract the creation of types into the type table.
  // printf ("ERROR: This function needs to call the SgPointerType::createType() function so that we can properly abstract the creation of types into the type table. \n");
  // ROSE_ASSERT(false);

  // DQ (7/29/2010): This function needs to call the SgPointerType::createType() function to support the new type table.
  // SgPointerType* result = new SgPointerType(base_type);
     SgPointerType* result = SgPointerType::createType(base_type);
     ROSE_ASSERT(result != NULL);

     return result;
   }

SgReferenceType* SageBuilder::buildReferenceType(SgType * base_type /*= NULL*/)
   {
  // DQ (7/26/2010): This needs to call the SgReferenceType::createType() function so that we can properly abstract the creation of types into the type table.
  // printf ("ERROR: This function needs to call the SgReferenceType::createType() function so that we can properly abstract the creation of types into the type table. \n");
  // ROSE_ASSERT(false);

  // DQ (7/29/2010): This function needs to call the SgPointerType::createType() function to support the new type table.
  // SgReferenceType* result= new SgReferenceType(base_type);
     SgReferenceType* result = SgReferenceType::createType(base_type);
     ROSE_ASSERT(result != NULL);

     return result;
   }

#if 0
// Liao, 8/16/2010, This function is being phased out. Please don't call this!!
SgModifierType* SageBuilder::buildModifierType(SgType * base_type /*= NULL*/)
   {
  // DQ (7/30/2010): Note that this is called by the outline test: tests/roseTests/astOutliningTests/moreTest3.cpp
  // DQ (7/28/2010): Now we want to make calling this function an error, the functions buildConst() will return SgModifierType objects instead.
     printf ("Error: this function SageBuilder::buildModifierType() should not be called! (call the buildConst() function (or whatever other function is required) directly \n");
   ROSE_ASSERT(false); 
   // Liao, 8/13/2010, This function is being phased out. Please don't call this!!

  // DQ (7/26/2010): This needs to call the SgModifierType::createType() function so that we can properly abstract the creation of types into the type table.
     SgModifierType* result = new SgModifierType(base_type);
  // SgModifierType* result = SgModifierType::createType(base_type);
     ROSE_ASSERT(result != NULL);

  // DQ (7/28/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     result = SgModifierType::insertModifierTypeIntoTypeTable(result);

     return result;
   }
#endif

SgTypeBool * SageBuilder::buildBoolType() { 
  SgTypeBool * result =SgTypeBool::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeChar * SageBuilder::buildCharType() 
{ 
  SgTypeChar * result =SgTypeChar::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

#if 0 // did not work, build##itemType would be expanded correctly
#define BUILD_SGTYPE_DEF(item) \
  SgType##item * SageBuilder::build##itemType() { \
  SgType##item * result =SgType##item::createType(); \
  ROSE_ASSERT(result); \
  return result; \
  }  

  BUILD_SGTYPE_DEF(Bool)
  BUILD_SGTYPE_DEF(Char)
  BUILD_SGTYPE_DEF(Double)
  BUILD_SGTYPE_DEF(Float)
  BUILD_SGTYPE_DEF(Int)
  BUILD_SGTYPE_DEF(Long)
  BUILD_SGTYPE_DEF(LongDouble)
  BUILD_SGTYPE_DEF(LongLong)
  BUILD_SGTYPE_DEF(Short)
  BUILD_SGTYPE_DEF(Void)

  BUILD_SGTYPE_DEF(Wchar)
  BUILD_SGTYPE_DEF(SignedChar)
  BUILD_SGTYPE_DEF(SignedInt)
  BUILD_SGTYPE_DEF(SignedLong)
  BUILD_SGTYPE_DEF(SignedShort)
  BUILD_SGTYPE_DEF(UnsignedChar)
  BUILD_SGTYPE_DEF(UnsignedInt)
  BUILD_SGTYPE_DEF(UnsignedLong)
  BUILD_SGTYPE_DEF(UnsignedLongLong)
  BUILD_SGTYPE_DEF(UnsignedShort)
#undef BUILD_SGTYPE_DEF
#endif 
SgTypeLongLong * SageBuilder::buildLongLongType() 
{ 
  SgTypeLongLong * result =SgTypeLongLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeLongDouble * SageBuilder::buildLongDoubleType() 
{ 
  SgTypeLongDouble * result =SgTypeLongDouble::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnsignedLongLong * SageBuilder::buildUnsignedLongLongType() 
{ 
  SgTypeUnsignedLongLong * result =SgTypeUnsignedLongLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnsignedLong * SageBuilder::buildUnsignedLongType() 
{ 
  SgTypeUnsignedLong * result =SgTypeUnsignedLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnsignedInt * SageBuilder::buildUnsignedIntType() 
{ 
  SgTypeUnsignedInt * result =SgTypeUnsignedInt::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeSignedShort * SageBuilder::buildSignedShortType() 
{ 
  SgTypeSignedShort * result =SgTypeSignedShort::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeSignedInt * SageBuilder::buildSignedIntType() 
{ 
  SgTypeSignedInt * result =SgTypeSignedInt::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnsignedChar * SageBuilder::buildUnsignedCharType() 
{ 
  SgTypeUnsignedChar * result =SgTypeUnsignedChar::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeSignedLong * SageBuilder::buildSignedLongType() 
{ 
  SgTypeSignedLong * result =SgTypeSignedLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeSignedLongLong * SageBuilder::buildSignedLongLongType() 
{ 
  SgTypeSignedLongLong * result =SgTypeSignedLongLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeWchar * SageBuilder::buildWcharType() 
{ 
  SgTypeWchar * result =SgTypeWchar::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeSignedChar * SageBuilder::buildSignedCharType() 
{ 
  SgTypeSignedChar * result =SgTypeSignedChar::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeVoid * SageBuilder::buildVoidType() 
{ 
  SgTypeVoid * result =SgTypeVoid::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnknown * SageBuilder::buildUnknownType() 
{ 
  SgTypeUnknown * result =SgTypeUnknown::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeShort * SageBuilder::buildShortType() 
{ 
  SgTypeShort * result =SgTypeShort::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeUnsignedShort * SageBuilder::buildUnsignedShortType()
{
  SgTypeUnsignedShort * result = SgTypeUnsignedShort::createType();
  ROSE_ASSERT(result);
  return result;
}

SgTypeLong * SageBuilder::buildLongType() 
{ 
  SgTypeLong * result =SgTypeLong::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

SgTypeString * SageBuilder::buildStringType() 
   {
  // DQ (8/17/2010): This function needs to use a different API to handle a literal 
  // value for the string size (typical) or an expression for the string size (rare).
  // For now we will make it an error to call this function.

  // SgTypeString * result =SgTypeString::createType(); 
     SgTypeString * result = NULL;
     ROSE_ASSERT(result != NULL); 
     return result;
   }

// SgTypeString * SageBuilder::buildStringType( SgExpression* stringLengthExpression, size_t stringLengthLiteral ) 
SgTypeString * SageBuilder::buildStringType( SgExpression* stringLengthExpression ) 
   {
  // DQ (8/21/2010): This is a new API for this function.  This type is specific to Fortran use,
  // in C/C++ a string is just an array of char. We could have a consistant handling between
  // C/C++ and Fortrna, but we have just corrected the implementation in Fortran to use this IR 
  // node and we would have to add such support to C/C++.  The current implementation reflects 
  // the grammar of the two languages.

  // This function needs to use a different API to handle a literal 
  // value for the string size (typical) or an expression for the string size (rare).

  // SgTypeString* result = SgTypeString::createType(stringLengthExpression,stringLengthLiteral); 
     SgTypeString* result = SgTypeString::createType(stringLengthExpression);
     ROSE_ASSERT(result != NULL); 
     return result;
   }

SgTypeInt * SageBuilder::buildIntType() 
{ 
  SgTypeInt * result =SgTypeInt::createType(); 
  ROSE_ASSERT(result); 
  return result;
}
SgTypeDouble * SageBuilder::buildDoubleType() 
{ 
  SgTypeDouble * result =SgTypeDouble::createType(); 
  ROSE_ASSERT(result); 
  return result;
}
SgTypeFloat * SageBuilder::buildFloatType() 
{ 
  SgTypeFloat * result =SgTypeFloat::createType(); 
  ROSE_ASSERT(result); 
  return result;
}

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
//! Build a modifier type.
SgModifierType* SageBuilder::buildModifierType(SgType* base_type /* = NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

  // DQ (7/28/2010): New (similar) approach using type table support.
     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result != NULL);

#if 0
     printf ("In SageBuilder::buildModifierType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/28/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);

     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildModifierType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

  //! Build a constant type.
SgModifierType* SageBuilder::buildConstType(SgType* base_type /*=NULL*/)
   {
#if 0
  // DQ (7/28/2010): Old approach before type table support.
     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);
     result->get_typeModifier().get_constVolatileModifier().setConst();
     return result;
#else
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

  // DQ (7/28/2010): New (similar) approach using type table support.
     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);
     result->get_typeModifier().get_constVolatileModifier().setConst();

#if 0
     printf ("In SageBuilder::buildConstType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/28/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);

     if (result != result2)
        {
#if 0
          printf ("In SageBuilder::buildConstType(result = %p) using type from type table (result2 = %p) deleting result = %p (skipping delete) \n",result,result2,result);
#endif

#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildConstType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
#endif
 }

// DQ (8/27/2010): Added Fortran specific support for types based on kind expressions.
SgModifierType*
SageBuilder::buildFortranKindType(SgType* base_type, SgExpression* kindExpression )
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result != NULL);

     result->set_type_kind(kindExpression);

#if 0
     printf ("In SageBuilder::buildFortranKindType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

     SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);

     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildFortranKindType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a volatile type.
SgModifierType* SageBuilder::buildVolatileType(SgType* base_type /*=NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_constVolatileModifier().setVolatile();

#if 0
     printf ("In SageBuilder::buildVolatileType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);
     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildVolatileType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

string
generate_type_list (SgType* type)
   {
  // This function generates a list of types for each level of the type structure.
     string returnString;

     unsigned char bit_array = (SgType::STRIP_MODIFIER_TYPE | SgType::STRIP_REFERENCE_TYPE | SgType::STRIP_POINTER_TYPE | SgType::STRIP_ARRAY_TYPE | SgType::STRIP_TYPEDEF_TYPE);

     SgType* currentType = type;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

     while (currentType != NULL)
        {
          returnString += currentType->class_name();
#if 0
          printf ("In generate_type_list(): returnString = %s \n",returnString.c_str());
#endif
       // type = type->findBaseType();
          if ( (bit_array & SgType::STRIP_MODIFIER_TYPE) && (modType = isSgModifierType(currentType)) )
             {
               currentType = modType->get_base_type();
             }
            else
             {
               if ( (bit_array & SgType::STRIP_REFERENCE_TYPE) &&  (refType = isSgReferenceType(currentType)) )
                  {
                    currentType = refType->get_base_type();
                  }
                 else
                  {
                    if ( (bit_array & SgType::STRIP_POINTER_TYPE) && (pointType = isSgPointerType(currentType)) )
                       {
                         currentType = pointType->get_base_type();
                       }
                      else
                       {
                         if ( (bit_array & SgType::STRIP_ARRAY_TYPE) && (arrayType = isSgArrayType(currentType)) )
                            {
                              currentType = arrayType->get_base_type();
                            }
                           else
                            {
                              if ( (bit_array & SgType::STRIP_TYPEDEF_TYPE) && (typedefType = isSgTypedefType(currentType)) )
                                 {
                                // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
                                   currentType = typedefType->get_base_type();
                                 }
                                else
                                 {
                                // Exit the while(true){} loop!
                                   break;
                                 }
                            }
                       }
                  }
             }

          if (type != NULL)
               returnString += " , ";
        }

     return returnString;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a restrict type.
SgModifierType* SageBuilder::buildRestrictType(SgType* base_type)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (1/30/2014): We need to include typedefs here as well (see test2014_77.c).
  // DQ (9/28/2012): Added that the base type could be an array (see test2012_03.c (C test code)).
  // if (!isSgPointerType(base_type) && !isSgReferenceType(base_type))
  // if (!isSgPointerType(base_type) && !isSgReferenceType(base_type) && !isSgArrayType(base_type))
  // if (!isSgPointerType(base_type) && !isSgReferenceType(base_type) && !isSgArrayType(base_type) && !isSgTypedefType(base_type))
     if (!isSgPointerType(base_type) && !isSgReferenceType(base_type) && !isSgArrayType(base_type) && !isSgTypedefType(base_type) && !isSgModifierType(base_type))
        {
          printf("ERROR: Base type of restrict type must be on a pointer or reference or array or typedef type: base_type = %p = %s \n",base_type,base_type->class_name().c_str());
          printf ("  --- generate_type_list() = %s \n",generate_type_list(base_type).c_str());
          ROSE_ASSERT(false);
        }

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().setRestrict();

#if 0
     printf ("In SageBuilder::buildRestrictType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);
     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildRestrictType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC strict type.
SgModifierType* SageBuilder::buildUpcStrictType(SgType* base_type /*=NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_modifier(SgUPC_AccessModifier::e_upc_strict);

#if 0
     printf ("In SageBuilder::buildUpcStrictType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType *result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);
     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildUpcStrictType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC relaxed type.
SgModifierType* SageBuilder::buildUpcRelaxedType(SgType* base_type /*=NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_modifier(SgUPC_AccessModifier::e_upc_relaxed);

#if 0
     printf ("In SageBuilder::buildUpcRelaxedType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);
     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildUpcRelaxedType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC shared type.
SgModifierType* SageBuilder::buildUpcSharedType(SgType* base_type /*=NULL*/, long layout /*= -1*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = new SgModifierType(base_type);
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_isShared(true);

  // DQ (7/29/2010): Modified to use new input parameter.
  // result->get_typeModifier().get_upcModifier().set_layout(-1); // No layout ("shared" without a block size)
     result->get_typeModifier().get_upcModifier().set_layout(layout); // No layout ("shared" without a block size)

#if 0
     printf ("In SageBuilder::buildUpcSharedType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     SgModifierType * result2 = SgModifierType::insertModifierTypeIntoTypeTable(result);
     if (result != result2)
        {
#if 0
       // DQ (9/3/2012): While debugging let's skip calling delete so that the slot in the memory pool will not be reused.
          printf ("(debugging) In SageBuilder::buildUpcSharedType(): Skipping delete of SgModifierType = %p = %s \n",result,result->class_name().c_str());
#else
          delete result;
#endif
        }

     return result2;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC shared[] type.
SgModifierType* SageBuilder::buildUpcBlockIndefiniteType(SgType* base_type /*=NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_layout(0); // [] layout

#if 0
     printf ("In SageBuilder::buildUpcBlockIndefiniteType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     result = SgModifierType::insertModifierTypeIntoTypeTable(result);

     return result;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC shared[*] type.
SgModifierType* SageBuilder::buildUpcBlockStarType(SgType* base_type /*=NULL*/)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_layout(-2); // [*] layout

#if 0
     printf ("In SageBuilder::buildUpcBlockStarType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     result = SgModifierType::insertModifierTypeIntoTypeTable(result);

     return result;
   }

// DQ (7/29/2010): Changed return type from SgType to SgModifierType
  //! Build a UPC shared[n] type.
SgModifierType* SageBuilder::buildUpcBlockNumberType(SgType* base_type, long block_factor)
   {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

     SgModifierType *result = isSgModifierType(buildUpcSharedType(base_type));
     ROSE_ASSERT(result!=NULL);

     result->get_typeModifier().get_upcModifier().set_layout(block_factor); // [block_factor] layout

#if 0
     printf ("In SageBuilder::buildUpcBlockNumberType(): Building a SgModifierType: result = %p base_type = %p = %s \n",result,base_type,base_type->class_name().c_str());
#endif

  // DQ (7/29/2010): Insert result type into type table and return it, or 
  // replace the result type, if already available in the type table, with 
  // the type from type table.
     result = SgModifierType::insertModifierTypeIntoTypeTable(result);

     return result;
   }



  //! Build a complex type.
SgTypeComplex* SageBuilder::buildComplexType(SgType* base_type /*=NULL*/)
 {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

   SgTypeComplex *result = new SgTypeComplex(base_type);
   ROSE_ASSERT(result!=NULL);
   return result;
 }

  //! Build an imaginary type.
SgTypeImaginary* SageBuilder::buildImaginaryType(SgType* base_type /*=NULL*/)
 {
  // DQ (9/3/2012): Added assertion.
     ROSE_ASSERT(base_type != NULL);

   SgTypeImaginary *result = new SgTypeImaginary(base_type);
   ROSE_ASSERT(result!=NULL);
   return result;
 }

//! Build a const/volatile type qualifier
SgConstVolatileModifier * SageBuilder::buildConstVolatileModifier (SgConstVolatileModifier::cv_modifier_enum mtype/*=SgConstVolatileModifier::e_unknown*/)
{
  SgConstVolatileModifier * result = NULL;
  result = new SgConstVolatileModifier();
  ROSE_ASSERT (result != NULL);
  result->set_modifier (mtype);  

  return result;
}

//! Build lambda expression
SgLambdaRefExp*
SageBuilder::buildLambdaRefExp(SgType* return_type, SgFunctionParameterList* params, SgScopeStatement* scope)
   {
  // SgFunctionDeclaration* func_decl = buildDefiningFunctionDeclaration("__rose__lambda__",return_type,params,scope,NULL,NULL);
     SgFunctionDeclaration* func_decl = buildDefiningFunctionDeclaration("__rose__lambda__",return_type,params,scope,NULL,false,NULL,NULL);

     SgLambdaRefExp* result = new SgLambdaRefExp(func_decl);
     func_decl->set_parent(result);

     setOneSourcePositionForTransformation(result);

     return result;
   }

SgNamespaceDefinitionStatement*
SageBuilder::buildNamespaceDefinition(SgNamespaceDeclarationStatement* d)
  {
    SgNamespaceDefinitionStatement* result = NULL;
    if (d!=NULL) // the constructor does not check for NULL d, causing segmentation fault
       {
         result = new SgNamespaceDefinitionStatement(d);
         result->set_parent(d); // set_declaration() == set_parent() in this case
       }
      else
       {
         result = new SgNamespaceDefinitionStatement(d);
       }
    
    ROSE_ASSERT(result);

    setOneSourcePositionForTransformation(result);
    return result;
  }



SgClassDefinition*
SageBuilder::buildClassDefinition(SgClassDeclaration *d/*= NULL*/, bool buildTemplateInstantiation )
   {
     SgClassDefinition* result = NULL;
     if (d != NULL) // the constructor does not check for NULL d, causing segmentation fault
        {
       // result->set_parent(d); // set_declaration() == set_parent() in this case
       // result = new SgClassDefinition(d);
          ROSE_ASSERT(buildTemplateInstantiation == false || isSgTemplateInstantiationDecl(d) != NULL);
          result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn(isSgTemplateInstantiationDecl(d)) : new SgClassDefinition(d);
        }
       else 
        {
       // result = new SgClassDefinition();
          result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn() : new SgClassDefinition();
        }

     ROSE_ASSERT(result);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
        {
          result->setCaseInsensitive(true);
        }

     setOneSourcePositionForTransformation(result);

     return result;
   }



SgClassDefinition*
SageBuilder::buildClassDefinition_nfi(SgClassDeclaration *d/*= NULL*/, bool buildTemplateInstantiation )
   {
     SgClassDefinition* result = NULL;
     if (d!=NULL) // the constructor does not check for NULL d, causing segmentation fault
        {
       // result->set_parent(d); // set_declaration() == set_parent() in this case
       // result = new SgClassDefinition(d);
          ROSE_ASSERT(buildTemplateInstantiation == false || isSgTemplateInstantiationDecl(d) != NULL);
          result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn(isSgTemplateInstantiationDecl(d)) : new SgClassDefinition(d);
        }
       else 
        {
       // result = new SgClassDefinition();
          result = (buildTemplateInstantiation == true) ? new SgTemplateInstantiationDefn() : new SgClassDefinition();
        }
    
     ROSE_ASSERT(result);

  // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
     if (symbol_table_case_insensitive_semantics == true)
          result->setCaseInsensitive(true);

     setOneSourcePositionNull(result);
     return result;
   }

SgClassDeclaration*
SageBuilder::buildNondefiningClassDeclaration_nfi(const SgName& XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     SgName nameWithoutTemplateArguments = XXX_name;

     SgName nameWithTemplateArguments = nameWithoutTemplateArguments;

  // SgClassDeclaration* nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
     SgClassDeclaration* nondefdecl = NULL;

  // DQ (11/26/2011): Debugging EDG 3.3 use of templateArguments.
#if 0
     printf ("Building a SgClassDeclaration: buildNondefiningClassDeclaration_nfi() nameWithoutTemplateArguments = %s buildTemplateInstantiation = %s \n",nameWithoutTemplateArguments.str(),buildTemplateInstantiation ? "true:" : "false");
#endif

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);

     if (buildTemplateInstantiation == true)
        {
          ROSE_ASSERT(templateArgumentsList != NULL);
          nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);

#if 0
          printf ("Building a SgClassDeclaration: buildNondefiningClassDeclaration_nfi() nameWithTemplateArguments = %s buildTemplateInstantiation = %s \n",nameWithTemplateArguments.str(),buildTemplateInstantiation ? "true:" : "false");
#endif

       // SgTemplateInstantiationDecl (SgName name, SgClassDeclaration::class_types class_type, SgClassType *type, SgClassDefinition *definition, SgTemplateDeclaration *templateDeclaration, SgTemplateArgumentPtrList templateArguments)
          SgTemplateArgumentPtrList emptyList;
       // nondefdecl = new SgTemplateInstantiationDecl(name,kind,NULL,NULL,NULL,emptyList);
          nondefdecl = new SgTemplateInstantiationDecl(nameWithTemplateArguments,kind,NULL,NULL,NULL,emptyList);

       // DQ (6/6/2012): Added support for template arguments so that they can be a part of any generated type.
          ROSE_ASSERT(templateArgumentsList != NULL);

       // DQ (5/8/2013): This fails for explicit template instantation examples (e.g. template <> class RepeatedPtrField<string>::TypeHandler {};, in test2013_159.C)
       // ROSE_ASSERT(templateArgumentsList->size() > 0);

#if 0
       // DQ (9/16/2012): Call the newly refactored function after the firstNondefiningDeclaration is set.

       // Calling the assignment operator for the STL container class.
          isSgTemplateInstantiationDecl(nondefdecl)->get_templateArguments() = *templateArgumentsList;

#if 1
       // DQ (9/13/2012): Refactored this code.
          setTemplateArgumentParents(nondefdecl);
#else
       // DQ (7/25/2012): Added this code here to reset the parents of the template arguments.
          for (size_t i = 0; i < templateArgumentsList->size(); i++)
             {
            // DQ (7/25/2012): This should be true because the template argument was set to the functions 
            // scope so that the name with template arguments could be computed (with name qualification).
                ROSE_ASSERT((*templateArgumentsList)[i]->get_parent() != NULL);

            // ROSE_ASSERT(isSgGlobal(templateArgumentsList[i]->get_parent()) == NULL);
            // ROSE_ASSERT(templateArgumentsList[i]->get_parent() == nondefining_templateInstantiation);

            // Be we want to reset it to be the function (now that it is available, because this is more precise).
            // All qualified names should compute to the same qualified name (if not then it is a bug in the name 
            // qualification mechanism).
               (*templateArgumentsList)[i]->set_parent(nondefdecl);
             }
#endif
#endif
          ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)->get_templateName().is_null() == true);
          isSgTemplateInstantiationDecl(nondefdecl)->set_templateName(nameWithoutTemplateArguments);
        }
       else
        {
       // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
          nondefdecl = new SgClassDeclaration(nameWithoutTemplateArguments,kind,NULL,NULL);

       // The default name for nameWithTemplateArguments is nameWithoutTemplateArguments so that we can use 
       // nameWithTemplateArguments uniformally as the name of the function and it will work from non-template 
       // instantiations.
          ROSE_ASSERT(nameWithoutTemplateArguments == nameWithTemplateArguments);
        }

     ROSE_ASSERT(nondefdecl != NULL);

  // DQ (6/9/2013): Added assertion to debug test2013_198.C.
     ROSE_ASSERT(nondefdecl->get_definition() == NULL);

  // DQ (3/22/2012): I think we can assert this! No, in fact we can assert that it is not built yet.
  // ROSE_ASSERT(nondefdecl->get_type() != NULL);
     ROSE_ASSERT(nondefdecl->get_type() == NULL);

#if 0
  // DQ (3/22/2012): I think this may be too early.
  // Liao, we ask for explicit creation of SgClassType to avoid duplicated type nodes
     if (nondefdecl->get_type() == NULL)
        {
          nondefdecl->set_type(SgClassType::createType(nondefdecl));
        }
#endif

#if 0
     printf ("SageBuilder::buildNondefiningClassDeclaration_nfi(): (and setting source position) nondefdecl = %p \n",nondefdecl);
#endif

  // The non-defining declaration asociated with a declaration does not have a 
  // source position...unless it is the position of the defining declaration.
  // setOneSourcePositionNull(nondefdecl);
     setSourcePosition(nondefdecl);

  // This is find for now, but a little later in this function (if we can find a symbol) 
  // we want to find the first non-defining declaration (using the symbol table) and use 
  // that as a paramter to "nondefdecl->set_firstNondefiningDeclaration()".
     nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
     nondefdecl->set_definingDeclaration(NULL);
     nondefdecl->setForward();

  // This is the structural parent (the logical scope can be different than the parent).
  // TPS (09/18/2009) added a condition to be able to build this properly
     if (scope == NULL)
          nondefdecl->set_parent(topScopeStack());
       else
          nondefdecl->set_parent(scope);

  // This is the logical scope...
     nondefdecl->set_scope(scope);

     ROSE_ASSERT(nondefdecl->get_parent() != NULL);

     SgClassDeclaration* firstNondefdecl = NULL;
     if (scope != NULL)
        {
#if 0
          SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);
          ROSE_ASSERT(mysymbol != NULL);

       // printf ("In SageBuilder::buildNondefiningClassDeclaration(): for nondefdecl = %p built SgClassSymbol = %p \n",nondefdecl,mysymbol);

#error "DEAD CODE"

          scope->insert_symbol(name, mysymbol);
#else
       // DQ (8/22/2012): Use the template arguments to further disambiguate names that would 
       // not include name qualification on template arguments.
       // Reuse any previously defined symbols (to avoid redundant symbols in the symbol table) 
       // and find the firstNondefiningDeclaration.
       // SgClassSymbol* mysymbol = scope->lookup_class_symbol(name);
       // SgClassSymbol* mysymbol = scope->lookup_nontemplate_class_symbol(name);
       // SgClassSymbol* mysymbol = scope->lookup_nontemplate_class_symbol(nameWithTemplateArguments);
          SgClassSymbol* mysymbol = scope->lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("In SageBuilder::buildNondefiningClassDeclaration(): mysymbol = %p = %s \n",mysymbol,(mysymbol != NULL) ? mysymbol->class_name().c_str() : "null");
#endif
          if (mysymbol != NULL)
             {
               firstNondefdecl = isSgClassDeclaration(mysymbol->get_declaration());
               ROSE_ASSERT(firstNondefdecl != NULL);

            // DQ (9/4/2012): Added assertion.
               ROSE_ASSERT(firstNondefdecl->get_type() != NULL);

            // DQ (3/22/2012): Now we can built the type and have it use the same nondefining declaration as from the symbol (required to match).
               ROSE_ASSERT(nondefdecl->get_type() == NULL);

               if (nondefdecl->get_type() == NULL)
                  {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                    printf ("In SageBuilder::buildNondefiningClassDeclaration(): Why are we creating a new type instead of reusing the type (firstNondefdecl->get_type() = %p) from the firstNondefdecl = %p \n",firstNondefdecl->get_type(),firstNondefdecl);
#endif
                 // Note: It would be better to just call: "nondefdecl->set_type(firstNondefdecl->get_type());"
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                    printf ("NOTE: Call nondefdecl->set_type(firstNondefdecl->get_type()); instead of nondefdecl->set_type(SgClassType::createType(firstNondefdecl)); \n");
#endif
                 // DQ (3/22/2012): Be careful to use the same declaration as from the symbol.
                 // nondefdecl->set_type(SgClassType::createType(nondefdecl));
                    nondefdecl->set_type(SgClassType::createType(firstNondefdecl));
                    ROSE_ASSERT(nondefdecl->get_type() != NULL);

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                    printf ("In SageBuilder::buildNondefiningClassDeclaration(): nondefdecl->get_type() = %p = %s \n",nondefdecl->get_type(),nondefdecl->get_type()->class_name().c_str());
#endif
                 // DQ (9/4/2012): Added assertion.
                    ROSE_ASSERT(nondefdecl->get_type() == firstNondefdecl->get_type());
                  }

#if (REUSE_CLASS_DECLARATION_FROM_SYMBOL == 0)
               ROSE_ASSERT(nondefdecl != NULL);
               ROSE_ASSERT(nondefdecl->get_parent() != NULL);

               nondefdecl->set_firstNondefiningDeclaration(firstNondefdecl);

            // This might be NULL if the defining declaration has not been seen yet!
               nondefdecl->set_definingDeclaration(firstNondefdecl->get_definingDeclaration());

            // DQ (3/22/2012): New assertions.
               ROSE_ASSERT(firstNondefdecl != NULL);
               ROSE_ASSERT(firstNondefdecl->get_type() != NULL);

            // DQ (9/16/2012): This is a newly refactored function (call this after we know the firstNondefiningDeclaration is set correctly).
            // This is called in the other branch (mysymbol == NULL), but there is must be called before the symbol table is appended with 
            // the new symbol for this declaration. So we have to call this in this brach and re can't refactor this be be called one before
            // both branches or once after both branches.
               if (buildTemplateInstantiation == true)
                  {
                    setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);
                  }

            // DQ (9/4/2012): We can now assert this because of how the type is constructed above.
               ROSE_ASSERT (nondefdecl->get_type() == firstNondefdecl->get_type());

            // Share the type!
               if (nondefdecl->get_type() != firstNondefdecl->get_type())
                  {
                 // Remove the type from the new SgClassDeclaration and set the reference to the type in the firstNondefiningDeclaration.
                    printf ("Deleting type in associated non-defining declaration (sharing type) nondefdecl->get_type() = %p = %s \n",nondefdecl->get_type(),nondefdecl->get_type()->class_name().c_str());
                    printf ("Skipping delete of %p so we can maintain unique type pointers \n",nondefdecl->get_type());
                 // delete nondefdecl->get_type();
                    printf ("Setting the new type to be from firstNondefdecl = %p (sharing type) firstNondefdecl->get_type() = %p = %s \n",firstNondefdecl,firstNondefdecl->get_type(),firstNondefdecl->get_type()->class_name().c_str());
                    nondefdecl->set_type(firstNondefdecl->get_type());
#if 1
                 // DQ (12/13/2011): Is this executed!
                    printf ("Unclear if this code is executed \n");
                    ROSE_ASSERT(false);
#endif
                  }
#else
#error "DEAD CODE"

               ROSE_ASSERT(nondefdecl == NULL);
#endif
            // This function should return a new nondefining declaration each time (to support multile class prototypes!).
            // nondefdecl = firstNondefdecl;
             }
            else
             {
#if REUSE_CLASS_DECLARATION_FROM_SYMBOL
            // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.

#error "DEAD CODE"

               nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);

#error "DEAD CODE"

               ROSE_ASSERT(nondefdecl != NULL);
               if (nondefdecl->get_type() == NULL)
                    nondefdel->set_type(SgClassType::createType(nondefdecl));

               printf ("SageBuilder::buildNondefiningClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

               setOneSourcePositionNull(nondefdecl);

#error "DEAD CODE"

               nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
               nondefdecl->set_definingDeclaration(NULL);
               nondefdecl->setForward();
#endif

            // DQ (6/9/2013): Added assertion to debug test2013_198.C.
               ROSE_ASSERT(nondefdecl->get_definition() == NULL);

               mysymbol = new SgClassSymbol(nondefdecl);
               firstNondefdecl = nondefdecl;

            // DQ (6/9/2013): Adding assertions to make sure that symbols only reference non-defining declarations.
               ROSE_ASSERT(nondefdecl->get_definition() == NULL);
               ROSE_ASSERT(mysymbol->get_declaration()->get_definition() == NULL);

            // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).
            // Note that since the symbol tables use the template arguments associated with the declaration it is best to 
            // fixup the template arguments before the symbol table is fixup to have a symbol for this declaration. So we
            // fixup the template arguments here (just after we know that the firstNondefiningDeclaration is set correctly 
            // and just before the symbol is inserted into the symbol table.
               if (buildTemplateInstantiation == true)
                  {
                    setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);
                  }
#if 0
               printf ("BEFORE scope->insert_symbol(): scope = %p = %s nameWithTemplateArguments = %s mysymbol = %p = %s \n",scope,scope->class_name().c_str(),nameWithTemplateArguments.str(),mysymbol,mysymbol->class_name().c_str());
#endif
            // scope->insert_symbol(name, mysymbol);
               scope->insert_symbol(nameWithTemplateArguments, mysymbol);

            // DQ (3/22/2012): Now we can built the type and have it use the same nondefining declaration as from the symbol (required to match).
               ROSE_ASSERT(nondefdecl->get_type() == NULL);
               if (nondefdecl->get_type() == NULL)
                  {
#if 0
                    printf ("In buildNondefiningClassDeclaration_nfi(): nondefdecl = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str());
                    printf ("In buildNondefiningClassDeclaration_nfi(): nondefdecl->get_firstNondefiningDeclaration() = %p \n",nondefdecl->get_firstNondefiningDeclaration());
#endif
                    nondefdecl->set_type(SgClassType::createType(nondefdecl));
                  }

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("NOTE: In buildNondefiningClassDeclaration_nfi(): 2nd time this is a performance issue (maybe) to call the lookup_nontemplate_class_symbol() again \n");
#endif
            // DQ (8/22/2012): Use the template arguments to further disambiguate names that would 
            // not include name qualification on template arguments.
            // DQ (12/27/2011): Added new test.
            // ROSE_ASSERT(scope->lookup_nontemplate_class_symbol(name) != NULL);
               ROSE_ASSERT(scope->lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList) != NULL);

            // DQ (6/9/2013): Added test to make sure that symbols only reference non-defining declarations.
               SgClassSymbol* temp_classSymbol = nondefdecl->get_scope()->lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);
               ROSE_ASSERT(temp_classSymbol->get_declaration()->get_definition() == NULL);
             }

          ROSE_ASSERT(mysymbol != NULL);
          ROSE_ASSERT(firstNondefdecl != NULL);
#endif
          nondefdecl->set_scope(scope);

       // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).
       // TPS (09/18/2009) added a condition to be able to build this properly
          if (scope==NULL)
            nondefdecl->set_parent(topScopeStack());
          else
            nondefdecl->set_parent(scope);
        }

  // The support for SgEnumDeclaration handles the type, but why not for SgClassDeclaration?
     ROSE_ASSERT(nondefdecl->get_type() != NULL);

     ROSE_ASSERT(nondefdecl->get_parent() != NULL);

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
     printf ("NOTE: In buildNondefiningClassDeclaration_nfi(): 3rd time this is a performance issue (maybe) to call the lookup_nontemplate_class_symbol() again \n");
#endif

  // DQ (8/22/2012): Use the template arguments to further disambiguate names that would not include name qualification on template arguments.
  // DQ (12/27/2011): Added new test.
  // ROSE_ASSERT(nondefdecl->get_scope()->lookup_nontemplate_class_symbol(name) != NULL);
     ROSE_ASSERT(nondefdecl->get_scope()->lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList) != NULL);

  // DQ (6/9/2013): Added test to make sure that symbols only reference non-defining declarations.
     SgClassSymbol* temp_classSymbol = nondefdecl->get_scope()->lookup_nontemplate_class_symbol(nameWithTemplateArguments,templateArgumentsList);
     ROSE_ASSERT(temp_classSymbol->get_declaration()->get_definition() == NULL);

     return nondefdecl;
   }

SgStmtDeclarationStatement*
SageBuilder::buildStmtDeclarationStatement_nfi(SgStatement* stmt) {
    ROSE_ASSERT(stmt != NULL);

    SgStmtDeclarationStatement* result = new SgStmtDeclarationStatement(stmt);
    stmt->set_parent(result);

    result->set_definingDeclaration(result);
    setOneSourcePositionNull(result);
    return result;
}

SgStmtDeclarationStatement*
SageBuilder::buildStmtDeclarationStatement(SgStatement* stmt) {
    ROSE_ASSERT(stmt != NULL);

    SgStmtDeclarationStatement* result = new SgStmtDeclarationStatement(stmt);
    stmt->set_parent(result);

    result->set_definingDeclaration(result);
    setOneSourcePositionForTransformation(result);
    return result;
}


// This should take a SgClassDeclaration::class_types kind parameter!
SgClassDeclaration * SageBuilder::buildStructDeclaration(const SgName& name, SgScopeStatement* scope /*=NULL*/)
   {
#if 0
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

  // TODO How about class type??
  // build defining declaration
     SgClassDefinition* classDef = buildClassDefinition();
   
     SgClassDeclaration* defdecl = new SgClassDeclaration (name,SgClassDeclaration::e_struct,NULL,classDef);
     ROSE_ASSERT(defdecl);
     setOneSourcePositionForTransformation(defdecl);
  // constructor is side-effect free
     classDef->set_declaration(defdecl);
     defdecl->set_definingDeclaration(defdecl);

  // build the nondefining declaration
     SgClassDeclaration* nondefdecl = new SgClassDeclaration (name,SgClassDeclaration::e_struct,NULL,NULL);
     ROSE_ASSERT(nondefdecl);

     setOneSourcePositionForTransformation(nondefdecl);
     nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
     nondefdecl->set_definingDeclaration(defdecl);
     defdecl->set_firstNondefiningDeclaration(nondefdecl);
     nondefdecl->setForward();

     if (scope !=NULL )  // put into fixStructDeclaration() or alike later on
        {
          fixStructDeclaration(nondefdecl,scope);
          fixStructDeclaration(defdecl,scope);
#if 0
          SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);
          ROSE_ASSERT(mysymbol);
          scope->insert_symbol(name, mysymbol);
          defdecl->set_scope(scope);
          nondefdecl->set_scope(scope);
          defdecl->set_parent(scope);
          nondefdecl->set_parent(scope);
#endif
        }
#else
  // DQ (1/24/2009): Refactored to use the buildStructDeclaration_nfi function.
  // (if this work it needs to be done uniformally for the other nfi functions)
  // Also, "_nfi" is not a great name.
  // SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL);
     bool buildTemplateInstantiation = false;
  // SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL,buildTemplateInstantiation);
     SgClassDeclaration* defdecl = buildClassDeclaration_nfi(name,SgClassDeclaration::e_struct,scope,NULL,buildTemplateInstantiation,NULL);

     setOneSourcePositionForTransformation(defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != NULL);
     setOneSourcePositionForTransformation(defdecl->get_firstNondefiningDeclaration());
#endif

  // DQ (1/26/2009): I think this should be an error, but that appears it would
  // break the existing interface. Need to discuss this with Liao.
  // ROSE_ASSERT(defdecl->get_parent() != NULL);

     return defdecl;
   }


SgNamespaceDeclarationStatement*
SageBuilder::buildNamespaceDeclaration(const SgName& name, SgScopeStatement* scope /*=NULL*/)
   {
     SgNamespaceDeclarationStatement* defdecl = buildNamespaceDeclaration_nfi(name,false,scope);

     setOneSourcePositionForTransformation(defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != NULL);
     setOneSourcePositionForTransformation(defdecl->get_firstNondefiningDeclaration());

     return defdecl;
   }

SgNamespaceDeclarationStatement*
SageBuilder::buildNamespaceDeclaration_nfi(const SgName& name, bool unnamednamespace, SgScopeStatement* scope)
   {
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

  // TODO How about class type??
  // build defining declaration
     SgNamespaceDefinitionStatement* namespaceDef = buildNamespaceDefinition();

#if 1
     SgNamespaceDeclarationStatement* defdecl = new SgNamespaceDeclarationStatement(name,namespaceDef,unnamednamespace);
     ROSE_ASSERT(defdecl != NULL);
     namespaceDef->set_parent(defdecl);

#if 0
     printf ("#################### SageBuilder::buildNamespaceDeclaration_nfi(): defdecl = %p = %s namespaceDef = %p \n",defdecl,defdecl->get_name().str(),namespaceDef);
#endif

  // setOneSourcePositionForTransformation(defdecl);
     setOneSourcePositionNull(defdecl);

  // constructor is side-effect free
     namespaceDef->set_namespaceDeclaration(defdecl);

  // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.
  // defdecl->set_definingDeclaration(defdecl);
     ROSE_ASSERT(defdecl->get_definingDeclaration() == NULL);
#endif

  // Get the nondefining declaration from the symbol if it has been built (if this works, 
  // then we likely don't need the "SgClassDeclaration* nonDefiningDecl" parameter).
     SgNamespaceDeclarationStatement* nondefdecl = NULL;

  // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/roseTests/astInterfaceTests test codes.
  // ROSE_ASSERT(scope != NULL);
     SgNamespaceSymbol* mysymbol = NULL;
     if (scope != NULL)
        {
          mysymbol = scope->lookup_namespace_symbol(name);
        }
       else
        {
       // DQ (1/26/2009): I think this should be an error, but that appears it would
       // break the existing interface. Need to discuss this with Liao.
          printf ("Warning: In SageBuilder::buildNamespaceDeclaration_nfi(): scope == NULL \n");
        }

#if 0
     printf ("In SageBuilder::buildNamespaceDeclaration_nfi(): mysymbol = %p \n",mysymbol);
#endif

     if (mysymbol != NULL)
        {
       // nondefdecl = isSgNamespaceDeclarationStatement(mysymbol->get_declaration());
          SgNamespaceDeclarationStatement* namespaceDeclaration = mysymbol->get_declaration();
          ROSE_ASSERT(namespaceDeclaration != NULL);
          nondefdecl = isSgNamespaceDeclarationStatement(namespaceDeclaration);

          ROSE_ASSERT(nondefdecl != NULL);
          ROSE_ASSERT(nondefdecl->get_parent() != NULL);

       // DQ (5/16/2013): These should be non-defining declarations for the case of a C++ namespace (all instances are a non-defining declaration).
       // nondefdecl->set_definingDeclaration(defdecl);
       // ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == NULL);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);

       // DQ (5/16/2013): Set the global definition for the new namespace definition.
          ROSE_ASSERT(namespaceDeclaration->get_definition() != NULL);
          if (namespaceDeclaration->get_definition()->get_global_definition() == NULL)
             {
               printf ("ERROR: namespaceDeclaration->get_definition()->get_global_definition() == NULL: namespaceDeclaration = %p = %s namespaceDeclaration->get_definition() = %p \n",
                    namespaceDeclaration,namespaceDeclaration->get_name().str(),namespaceDeclaration->get_definition());
             }
          ROSE_ASSERT(namespaceDeclaration->get_definition()->get_global_definition() != NULL);
          namespaceDef->set_global_definition(namespaceDeclaration->get_definition()->get_global_definition());
          ROSE_ASSERT(namespaceDef->get_global_definition() != NULL);

       // DQ (5/19/2013): Make the global_definition point to itself.
          ROSE_ASSERT(namespaceDef->get_global_definition() == namespaceDef->get_global_definition()->get_global_definition());

          ROSE_ASSERT(defdecl->get_definition()->get_global_definition() != NULL);

          ROSE_ASSERT(nondefdecl->get_definition()->get_previousNamespaceDefinition() == NULL);
       // ROSE_ASSERT(nondefdecl->get_definition()->get_nextNamespaceDefinition() == NULL);

          SgNamespaceDefinitionStatement* i = namespaceDeclaration->get_definition();
          ROSE_ASSERT(i != NULL);
          while (i != NULL && i->get_nextNamespaceDefinition() != NULL)
             {
               i = i->get_nextNamespaceDefinition();
               ROSE_ASSERT(i->get_previousNamespaceDefinition() != NULL);
             }

          ROSE_ASSERT(i != NULL);
          i->set_nextNamespaceDefinition(namespaceDef);
          namespaceDef->set_previousNamespaceDefinition(i);
        }
       else
        {
       // DQ (5/16/2013): Note that since we don't build a SgNamespaceDefinition for the declaration we can't 
       // build the global_definition.  This is a potential problem.

#if 1
          nondefdecl = defdecl;
          ROSE_ASSERT(nondefdecl != NULL);
          namespaceDef = nondefdecl->get_definition();
          ROSE_ASSERT(namespaceDef->get_namespaceDeclaration() != NULL);
#else
       // DQ (5/16/2013): We want to build an associated SgNamespaceDefinitionStatement so that we can 
       // support a reference to a SgNamespaceDefinitionStatement as a global definition.
       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.
       // nondefdecl = new SgNamespaceDeclarationStatement(name,NULL, unnamednamespace);

#error "DEAD CODE!"

          SgNamespaceDefinitionStatement* namespaceDef = buildNamespaceDefinition();
          nondefdecl = new SgNamespaceDeclarationStatement(name,namespaceDef,unnamednamespace);
          ROSE_ASSERT(nondefdecl != NULL);
#if 0
          printf ("In SageBuilder::buildNamespaceDeclaration_nfi(): Built namespace definition for nondefdecl = %p = %s definition = %p \n",nondefdecl,nondefdecl->get_name().str(),namespaceDef);
#endif
       // DQ (5/16/2013): Added tests and setting of the associated declaration.
          ROSE_ASSERT(namespaceDef->get_namespaceDeclaration() == NULL);
          namespaceDef->set_namespaceDeclaration(nondefdecl);
          ROSE_ASSERT(namespaceDef->get_namespaceDeclaration() != NULL);
#endif

       // DQ (5/16/2013): Now add the global definition where we will accumulate all of the symbols for the logical namespace.
          SgNamespaceDefinitionStatement* global_definition_namespaceDef = buildNamespaceDefinition();
          namespaceDef->set_global_definition(global_definition_namespaceDef);
          ROSE_ASSERT(namespaceDef->get_global_definition() != NULL);

       // DQ (5/19/2013): Make the global_definition point to itself.
          global_definition_namespaceDef->set_global_definition(global_definition_namespaceDef);

          global_definition_namespaceDef->set_isUnionOfReentrantNamespaceDefinitions(true);

       // DQ (8/23/2013): Set the parent of the global_definition_namespaceDef.
          ROSE_ASSERT(global_definition_namespaceDef->get_parent() == NULL);
          global_definition_namespaceDef->set_parent(defdecl);
          ROSE_ASSERT(global_definition_namespaceDef->get_parent() != NULL);

       // DQ (5/16/2013): Added tests and setting of the associated declaration.
          ROSE_ASSERT(global_definition_namespaceDef->get_namespaceDeclaration() == NULL);
          global_definition_namespaceDef->set_namespaceDeclaration(nondefdecl);
          ROSE_ASSERT(global_definition_namespaceDef->get_namespaceDeclaration() != NULL);

       // DQ (5/16/2013): Set the associated declaration to be the nondefdecl.
          global_definition_namespaceDef->set_namespaceDeclaration(nondefdecl);
          ROSE_ASSERT(global_definition_namespaceDef->get_namespaceDeclaration() != NULL);

#if 0
          ROSE_ASSERT(defdecl->get_definition()->get_global_definition() == NULL);
       // defdecl->get_definition()->set_global_definition(namespaceDef->get_global_definition());
          defdecl->get_definition()->set_global_definition(global_definition_namespaceDef);
#else
#if 0
          printf ("In SageBuilder::buildNamespaceDeclaration_nfi(): defdecl->get_definition()->get_global_definition() = %p \n",defdecl->get_definition()->get_global_definition());
#endif
          if (defdecl->get_definition()->get_global_definition() == NULL)
             {
               defdecl->get_definition()->set_global_definition(global_definition_namespaceDef);
             }

       // DQ (5/19/2013): Make the global_definition point to itself.
          ROSE_ASSERT(global_definition_namespaceDef == global_definition_namespaceDef->get_global_definition());
#endif
          ROSE_ASSERT(defdecl->get_definition()->get_global_definition() != NULL);
          ROSE_ASSERT(defdecl->get_definition()->get_global_definition() == namespaceDef->get_global_definition());
#if 0
          printf ("In SageBuilder::buildNamespaceDeclaration_nfi(): Built namespace definition for nondefdecl = %p = %s get_global_definition() = %p \n",nondefdecl,nondefdecl->get_name().str(),namespaceDef->get_global_definition());
#endif
       // printf ("SageBuilder::buildNamespaceDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

       // The nondefining declaration will not appear in the source code, but is compiler
       // generated (so we have something about the class that we can reference; e.g in
       // types).  At the moment we make it a transformation, there might be another kind 
       // of source position that would be more precise.  FIXME.
       // setOneSourcePositionNull(nondefdecl);
       // setOneSourcePositionForTransformation(nondefdecl);

          nondefdecl->set_firstNondefiningDeclaration(nondefdecl);

       // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.
       // nondefdecl->set_definingDeclaration(defdecl);
          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == NULL);
          ROSE_ASSERT(defdecl->get_definingDeclaration() == NULL);

          nondefdecl->setForward();

       // nondefdecl->set_parent(topScopeStack());
          nondefdecl->set_parent(scope);
                  ROSE_ASSERT(nondefdecl->get_parent());

          if (scope != NULL)
             {
               mysymbol = new SgNamespaceSymbol(name,nondefdecl); // tps: added name to constructor
               scope->insert_symbol(name, mysymbol);
             }
            else
             {
            // DQ (1/26/2009): I think this should be an error, but that appears it would
            // break the existing interface. Need to discuss this with Liao.
               printf ("Warning: no scope provided to support symbol table entry! \n");
             }

          ROSE_ASSERT(defdecl->get_definition() != NULL);
          ROSE_ASSERT(defdecl->get_definition()->get_global_definition() != NULL);

          ROSE_ASSERT(nondefdecl->get_definition()->get_previousNamespaceDefinition() == NULL);
          ROSE_ASSERT(nondefdecl->get_definition()->get_nextNamespaceDefinition() == NULL);
        }

     ROSE_ASSERT(nondefdecl != NULL);

  // printf ("SageBuilder::buildNamespaceDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

  // setOneSourcePositionForTransformation(nondefdecl);
  // setOneSourcePositionNull(nondefdecl);

  // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
  // nondefdecl->set_definingDeclaration(defdecl);
     defdecl->set_firstNondefiningDeclaration(nondefdecl);

  // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).
  // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless 
  // used in a defining declaration).
     nondefdecl->setForward();

     if (scope != NULL)  // put into fixStructDeclaration() or alike later on
        {
          fixNamespaceDeclaration(nondefdecl,scope);
          fixNamespaceDeclaration(defdecl,scope);
#if 0
          SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);
          ROSE_ASSERT(mysymbol);
          scope->insert_symbol(name, mysymbol);
#endif
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("@@@@@@@@@@@@@@ In buildNamespaceDeclaration_nfi(): setting scope of defining and non-defining declaration to scope = %s \n",scope->class_name().c_str());
#endif
          // tps namespace has no scope
          //defdecl->set_scope(scope);
          //nondefdecl->set_scope(scope);

       // defdecl->set_parent(scope);

       // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).
       // nondefdecl->set_parent(scope);
        //  nondefdecl->set_parent(topScopeStack());
        }

  //   defdecl->set_parent(topScopeStack());

  // DQ (1/26/2009): I think we should assert this, but it breaks the interface as defined
  // by the test code in tests/roseTests/astInterfaceTests.
  // ROSE_ASSERT(defdecl->get_parent() != NULL);

  // ROSE_ASSERT(nonDefiningDecl->get_parent() != NULL);

  // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.
  // ROSE_ASSERT(defdecl->get_definingDeclaration() == defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != defdecl->get_definingDeclaration());

  // DQ (3/6/2012): For namespaces the definingDeclaration should be NULL.
     ROSE_ASSERT(defdecl->get_definingDeclaration() == NULL);

  // DQ (5/16/2013): Added tests.
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(defdecl->get_definition() != NULL);
     ROSE_ASSERT(defdecl->get_definition()->get_global_definition() != NULL);

#if 0
  // DQ (5/19/2013): There should always be proper source file position infomation so this should not be required.
     if (defdecl->get_file_info()->isOutputInCodeGeneration() == true)
        {
          defdecl->get_file_info()->display("In buildNamespaceDeclaration_nfi(): namespaceDeclaration: debug");
        }
  // ROSE_ASSERT(defdecl->get_file_info()->isOutputInCodeGeneration() == false);
#endif

     return defdecl;    
   }

// driscoll6 (7/20/11) : Support n-ary operators for python
SgNaryComparisonOp*
SageBuilder::buildNaryComparisonOp(SgExpression* lhs) {
    SgNaryComparisonOp* result = new SgNaryComparisonOp();

    result->get_operands().push_back(lhs);
    lhs->set_parent(result);

    setOneSourcePositionForTransformation(result);
    return result;
}

SgNaryComparisonOp*
SageBuilder::buildNaryComparisonOp_nfi(SgExpression* lhs) {
    SgNaryComparisonOp* result = new SgNaryComparisonOp();

    result->get_operands().push_back(lhs);
    lhs->set_parent(result);

    setOneSourcePositionNull(result);
    return result;
}

SgNaryBooleanOp*
SageBuilder::buildNaryBooleanOp(SgExpression* lhs) {
    SgNaryBooleanOp* result = new SgNaryBooleanOp();

    result->get_operands().push_back(lhs);
    lhs->set_parent(result);

    setOneSourcePositionForTransformation(result);
    return result;
}

SgNaryBooleanOp*
SageBuilder::buildNaryBooleanOp_nfi(SgExpression* lhs) {
    SgNaryBooleanOp* result = new SgNaryBooleanOp();

    result->get_operands().push_back(lhs);
    lhs->set_parent(result);

    setOneSourcePositionNull(result);
    return result;
}

SgStringConversion*
SageBuilder::buildStringConversion(SgExpression* exp) {
    ROSE_ASSERT(exp);
    SgStringConversion* result = new SgStringConversion(exp);
    exp->set_parent(result);

    setOneSourcePositionForTransformation(result);
    return result;
}


SgStringConversion*
SageBuilder::buildStringConversion_nfi(SgExpression* exp) {
    ROSE_ASSERT(exp);
    SgStringConversion* result = new SgStringConversion(exp);
    exp->set_parent(result);

    setOneSourcePositionNull(result);
    return result;
}

// DQ (11/7/2009): Added more uniform support for building class declarations.
SgClassDeclaration*
SageBuilder::buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope )
   {
     SgClassDeclaration* defdecl    = NULL;
     SgClassDeclaration* nondefdecl = NULL;

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);

#if 1
     printf ("In buildNondefiningClassDeclaration(): name = %s scope = %p = %s \n",name.str(),scope,scope != NULL ? scope->class_name().c_str() : "NULL");

  // DQ (8/12/2013): If this function were to be called then we would have to
  // support a template argument list for the call to lookup_class_symbol().

  // DQ (6/9/2013): I want to know that I'm not debugging this function.
     ROSE_ASSERT(false);
#endif

  // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/roseTests/astInterfaceTests test codes.
  // ROSE_ASSERT(scope != NULL);
     SgClassSymbol* mysymbol = NULL;
     if (scope != NULL)
        {
       // mysymbol = scope->lookup_class_symbol(name);
          mysymbol = scope->lookup_class_symbol(name,NULL);
        }
       else
        {
       // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.   
       // DQ (1/26/2009): I think this should be an error, but that appears it would
       // break the existing interface. Need to discuss this with Liao.
       // printf ("Warning: In SageBuilder::buildClassDeclaration_nfi(): scope == NULL \n");
        }

  // printf ("In SageBuilder::buildClassDeclaration_nfi(): mysymbol = %p \n",mysymbol);
     if (mysymbol != NULL) // set links if nondefining declaration already exists.
        {
          nondefdecl = isSgClassDeclaration(mysymbol->get_declaration());

          ROSE_ASSERT(nondefdecl != NULL);
          ROSE_ASSERT(nondefdecl->get_parent() != NULL);

          nondefdecl->set_definingDeclaration(defdecl);

          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);

       // DQ (10/30/2010): There shuld be a properly defined type at this point!
          ROSE_ASSERT(nondefdecl->get_type() != NULL);
        }
       else // build a nondefnining declaration if it does not exist
        {
       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.

          SgClassDeclaration::class_types kind = SgClassDeclaration::e_class;
          nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
          ROSE_ASSERT(nondefdecl != NULL);
          if (nondefdecl->get_type() == NULL)
            nondefdecl->set_type(SgClassType::createType(nondefdecl));

 //         printf ("SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

       // The nondefining declaration will not appear in the source code, but is compiler
       // generated (so we have something about the class that we can reference; e.g in
       // types).  At the moment we make it a transformation, there might be another kind 
       // of source position that would be more precise.  FIXME.
       // setOneSourcePositionNull(nondefdecl);
          setOneSourcePositionForTransformation(nondefdecl);

          nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
          nondefdecl->set_definingDeclaration(defdecl);
          nondefdecl->setForward();
       // Liao, 9/2/2009. scope stack is optional, it can be empty
      //    nondefdecl->set_parent(topScopeStack());
          nondefdecl->set_parent(scope);

       // DQ (3/24/2011): This should be NULL before we set it (if the scope is known).
          ROSE_ASSERT(nondefdecl->get_scope() == NULL);
          if (scope != NULL)
             {
            // DQ (3/24/2011): Decided with Liao that we should set the scope where possible.  The AST consistancy test will make sure it is consistant with where it is inserted into the AST.
               nondefdecl->set_scope(scope);
               ROSE_ASSERT(nondefdecl->get_scope() != NULL);

               mysymbol = new SgClassSymbol(nondefdecl);
#if 1
               printf ("In buildNondefiningClassDeclaration(): Adding SgClassSymbol: mysymbol = %p from nondefdecl = %p = %s to scope = %p = %s \n",mysymbol,nondefdecl,nondefdecl->class_name().c_str(),scope,scope->class_name().c_str());
#endif
               scope->insert_symbol(name, mysymbol);
             }
            else
             {
            // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unknown.
            // DQ (1/26/2009): I think this should be an error, but that appears it would
            // break the existing interface. Need to discuss this with Liao.
            // printf ("Warning: no scope provided to support symbol table entry! \n");
             }

       // DQ (10/30/2010): There should be a properly defined type at this point!
          ROSE_ASSERT(nondefdecl->get_type() != NULL);

       // DQ (3/24/2011): The scope should be set if the scope was available.
          ROSE_ASSERT(scope == NULL || (scope != NULL && nondefdecl->get_scope() != NULL));
        }

     ROSE_ASSERT(nondefdecl != NULL);

     return nondefdecl;
   }

// DQ (11/7/2009): Added more uniform support for building class declarations.
SgClassDeclaration*
SageBuilder::buildDefiningClassDeclaration ( SgName name, SgScopeStatement* scope )
   {
  // Note that the semantics of this function now differs from that of the buildDefiningFunctionDeclaration().
  // We want to have the non-defining declaration already exist before calling this function.
  // We could still build a higher level function that built both together.  Or we could provide two versions
  // named differently (from this one) and depricate this function...which I like much better.
     printf ("WARNING: This function for building defining class declarations has different semantics from that of the function to build defining function declarations. \n");

#if 1
     printf ("In buildDefiningClassDeclaration(): name = %s scope = %p = %s \n",name.str(),scope,scope != NULL ? scope->class_name().c_str() : "NULL");

  // DQ (6/9/2013): I want to know that I'm not debugging this function.
     ROSE_ASSERT(false);
#endif

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);

     SgClassDeclaration* nondefiningClassDeclaration = buildNondefiningClassDeclaration(name,scope);
     ROSE_ASSERT(nondefiningClassDeclaration != NULL);

     SgClassDefinition* definingClassDefinition = buildClassDefinition();
     ROSE_ASSERT(definingClassDefinition != NULL);

  // DQ (10/30/2010): There should be a properly defined type at this point!
     SgClassType* classType = nondefiningClassDeclaration->get_type();
     ROSE_ASSERT(classType != NULL);

     SgClassDeclaration::class_types kind = SgClassDeclaration::e_class;

  // DQ (10/30/2010): We need to make sure that there is a type defined.
  // SgClassDeclaration* definingClassDeclaration = new SgClassDeclaration (name,kind,NULL,definingClassDefinition);
     SgClassDeclaration* definingClassDeclaration = new SgClassDeclaration (name,kind,classType,definingClassDefinition);
     ROSE_ASSERT(definingClassDeclaration != NULL);

  // printf ("SageBuilder::buildDefiningClassDeclaration(): definingClassDeclaration = %p \n",definingClassDeclaration);

     setOneSourcePositionForTransformation(definingClassDeclaration);

  // constructor is side-effect free
     definingClassDefinition->set_declaration(definingClassDeclaration);
     definingClassDeclaration->set_definingDeclaration(definingClassDeclaration);
     definingClassDeclaration->set_firstNondefiningDeclaration(nondefiningClassDeclaration);

     nondefiningClassDeclaration->set_definingDeclaration(definingClassDeclaration);

  // some error checking
     ROSE_ASSERT(nondefiningClassDeclaration->get_definingDeclaration() != NULL);
     ROSE_ASSERT(nondefiningClassDeclaration->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(definingClassDeclaration->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(definingClassDeclaration->get_definition() != NULL);

     ROSE_ASSERT(definingClassDeclaration->get_scope() == NULL);
     if (scope != NULL)
        {
          definingClassDeclaration->set_scope(scope);
          ROSE_ASSERT(definingClassDeclaration->get_scope() != NULL);
          ROSE_ASSERT(nondefiningClassDeclaration->get_scope() != NULL);
        }

     ROSE_ASSERT(definingClassDeclaration->get_definition()->get_parent() != NULL);

  // DQ (10/30/2010): There should be a properly defined type at this point!
     ROSE_ASSERT(definingClassDeclaration->get_type() != NULL);

     return definingClassDeclaration;
   }

// DQ (11/7/2009): Added more uniform support for building class declarations.
SgClassDeclaration*
SageBuilder::buildClassDeclaration ( SgName name, SgScopeStatement* scope )
   {
     ROSE_ASSERT(scope != NULL);
     SgClassDeclaration* definingClassDeclaration = buildDefiningClassDeclaration(name,scope);
     ROSE_ASSERT(definingClassDeclaration != NULL);

     return definingClassDeclaration;
   }


// DQ (6/6/2012): Added support for template arguments (so that the type could be computing using the template arguments when building a template instantiation).
// DQ (1/24/2009): Built this "nfi" version but factored the code.
// SgClassDeclaration* SageBuilder::buildClassDeclaration_nfi(const SgName& name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl , bool buildTemplateInstantiation )
SgClassDeclaration*
SageBuilder::buildClassDeclaration_nfi(const SgName& XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgClassDeclaration* nonDefiningDecl , bool buildTemplateInstantiation, SgTemplateArgumentPtrList* templateArgumentsList )
   {
  // DQ (3/15/2012): Added function to build C++ class (builds both the non-defining and defining declarations; in that order).
  // The implementation of this function could be simplified to directly call both:
  //    SgClassDeclaration* buildNondefiningClassDeclaration ( SgName name, SgScopeStatement* scope );
  // and
  //    SgClassDeclaration* buildDefiningClassDeclaration    ( SgName name, SgScopeStatement* scope );
  // This might refactor the implementation nicely.


  // Note that the nonDefiningDecl pointer does not appear to be used.
#if 0
      printf ("WARNING: In SageBuilder::buildClassDeclaration_nfi(): the nonDefiningDecl pointer = %p (input parameter) does not appear to be used. \n",nonDefiningDecl);
#endif

     if (scope == NULL)
        {
          scope = SageBuilder::topScopeStack();
        }

#if 0
     printf ("Building a SgClassDeclaration: buildClassDeclaration_nfi() XXX_name = %s buildTemplateInstantiation = %s \n",XXX_name.str(),buildTemplateInstantiation ? "true" : "false");
#endif

  // Step 2 (now step 1). build the nondefining declaration, 
  // but only if the input nonDefiningDecl pointer was NULL and it does not exist

  // Get the nondefining declaration from the symbol if it has been built (if this works, 
  // then we likely don't need the "SgClassDeclaration* nonDefiningDecl" parameter).
     SgClassDeclaration* nondefdecl = NULL;

#if 1
     SgName nameWithoutTemplateArguments = XXX_name;
     SgName nameWithTemplateArguments    = nameWithoutTemplateArguments;
     if (buildTemplateInstantiation == true)
        {
          ROSE_ASSERT(templateArgumentsList != NULL);
          nameWithTemplateArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateArgumentsList);
        }
#else
  // SgName nameWithTemplateArguments    = name;
  // SgName nameWithoutTemplateArguments = generateTemplateNameFromTemplateNameWithTemplateArguments(name);
     SgName nameWithTemplateArguments;
     SgName nameWithoutTemplateArguments;

#error "DEAD CODE!"

     if (buildTemplateInstantiation == true)
        {
          nameWithTemplateArguments    = name;
          nameWithoutTemplateArguments = generateTemplateNameFromTemplateNameWithTemplateArguments(name);
        }
#endif

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
  // This fails for test2005_35.C
  // ROSE_ASSERT(SageInterface::hasTemplateSyntax(nameWithoutTemplateArguments) == false);

  // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/roseTests/astInterfaceTests test codes.
  // ROSE_ASSERT(scope != NULL);
     SgClassSymbol* mysymbol = NULL;
     if (scope != NULL)
        {
#if 0
          printf ("Looking up the SgClassSymbol in scope = %p = %s nameWithTemplateArguments = %s \n",scope,scope->class_name().c_str(),nameWithTemplateArguments.str());
#endif

       // DQ (8/22/2012): We need to provide more information ofr the symbol table lookup to correctly resolve 
       // (and disambiguate template instantations where the name qualification of the template arguments would 
       // be significant).
       // mysymbol = scope->lookup_class_symbol(name);
       // mysymbol = scope->lookup_class_symbol(name);
       // mysymbol = scope->lookup_class_symbol(nameWithTemplateArguments);
          mysymbol = scope->lookup_class_symbol(nameWithTemplateArguments,templateArgumentsList);

#if 0
       // DQ (11/21/2013): Added test based on debugging session with Philippe.
       // This test is not a test for a bug, since we require that symbols in base classes be aliased in the derived classes.
          if (mysymbol != NULL)
             {
               SgClassDeclaration* symbol_declaration = isSgClassDeclaration(mysymbol->get_declaration());
               ROSE_ASSERT(symbol_declaration != NULL);
               ROSE_ASSERT(symbol_declaration->get_scope() == scope);

               printf ("In SageBuilder::buildClassDeclaration_nfi(): Testing scope->get_symbol_table()->exists(mysymbol) == true (expensive) \n");

               ROSE_ASSERT(scope->get_symbol_table()->exists(mysymbol) == true);
             }
#endif
        }
       else
        {
       // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.   
       // DQ (1/26/2009): I think this should be an error, but that appears it would
       // break the existing interface. Need to discuss this with Liao.
       // printf ("Warning: In SageBuilder::buildClassDeclaration_nfi(): scope == NULL \n");
        }

#if 0
     printf ("In SageBuilder::buildClassDeclaration_nfi(): mysymbol = %p \n",mysymbol);
#endif

     if (mysymbol != NULL) // set links if nondefining declaration already exists.
        {
          nondefdecl = isSgClassDeclaration(mysymbol->get_declaration());

          ROSE_ASSERT(nondefdecl != NULL);

#if 0
          printf ("In SageBuilder::buildClassDeclaration_nfi(): mysymbol->get_declaration(): nondefdecl = %p = %s nondefdecl->get_definition() = %p = %s \n",
               nondefdecl,nondefdecl->class_name().c_str(),nondefdecl->get_definition(),
               nondefdecl->get_definition() != NULL ? nondefdecl->get_definition()->class_name().c_str() : "NULL");
#endif
       // DQ (6/8/2013): This should not be true (see test2013_198.C).
       // Fundamentally the symbol should always only have a pointer to a non-defining 
       // declaration, where by definition (get_definition() == NULL).
          ROSE_ASSERT(nondefdecl->get_definition() == NULL);

       // DQ (9/16/2012): This should be true by definition (verify).
          ROSE_ASSERT(nondefdecl == nondefdecl->get_firstNondefiningDeclaration());

       // DQ (9/16/2012): The declaration was build previously, but test it to make sure the template arguments were setup properly.
          testTemplateArgumentParents(nondefdecl);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
       // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.
          detectTransformations(nondefdecl);
#endif

       // DQ (3/22/2012): I think we can assert this.
          ROSE_ASSERT(nondefdecl->get_type() != NULL);

       // ROSE_ASSERT(nondefdecl->get_parent() != NULL);
          if (nondefdecl->get_parent() == NULL)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("In SageBuilder::buildClassDeclaration_nfi(): Note that nondefdecl->get_parent() == NULL, this might be OK. \n");
#endif
             }

       // DQ (9/7/2012): I think this might be the root of a problem in the haskell tests (ROSE compiling ROSE).
          if (nondefdecl->get_definingDeclaration() != NULL)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("ERROR: In SageBuilder::buildClassDeclaration_nfi(): Non defining declaration nondefdecl = %p = %s already has a defining declaration, so we would be build another nondefdecl->get_definingDeclaration() = %p = %s \n",
                    nondefdecl,nondefdecl->class_name().c_str(),nondefdecl->get_definingDeclaration(),nondefdecl->get_definingDeclaration()->class_name().c_str());
#endif
               SgClassDeclaration* nondefining_classDeclaration = isSgClassDeclaration(nondefdecl);
               ROSE_ASSERT(nondefining_classDeclaration != NULL);
               SgClassDeclaration* defining_classDeclaration = isSgClassDeclaration(nondefdecl->get_definingDeclaration());
               ROSE_ASSERT(defining_classDeclaration != NULL);

#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("In SageBuilder::buildClassDeclaration_nfi(): nondefining_classDeclaration: scope = %p = %s name = %s \n",
                    nondefining_classDeclaration->get_scope(),nondefining_classDeclaration->get_scope()->class_name().c_str(),nondefining_classDeclaration->get_name().str());
               printf ("In SageBuilder::buildClassDeclaration_nfi(): defining_classDeclaration:    scope = %p = %s name = %s \n",
                    defining_classDeclaration->get_scope(),defining_classDeclaration->get_scope()->class_name().c_str(),defining_classDeclaration->get_name().str());
#endif
#if 0
               printf ("Error: In SageBuilder::buildClassDeclaration_nfi(): exiting as part of test \n");
               ROSE_ASSERT(false);
#endif
            // DQ (9/24/2012): This only appears to happen for large tests (e.g. ROSE compiling ROSE), alow it for the moment and look into this later.
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("WARNING: In SageBuilder::buildClassDeclaration_nfi(): but a defining declaration was found to have already been built (might be an error), so returning it defining_classDeclaration = %p \n",defining_classDeclaration);
#endif
               return defining_classDeclaration;
             }

#if 0
          nondefdecl->set_definingDeclaration(defdecl);

          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);
#endif
        }
       else // build a nondefnining declaration if it does not exist
        {
#if 0
          printf ("In SageBuilder::buildClassDeclaration_nfi(): building a nondefnining declaration if it does not exist \n");
#endif
       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.
       // DQ (1/1/2012): Fixed to force matching types or IR nodes for defining and non-defining declarations.
          if (buildTemplateInstantiation == true)
             {
            // This adds: SgTemplateDeclaration *templateDeclaration and SgTemplateArgumentPtrList templateArguments
               SgTemplateArgumentPtrList emptyList;
            // nondefdecl = new SgTemplateInstantiationDecl (name,kind,NULL,NULL,NULL,emptyList);
               nondefdecl = new SgTemplateInstantiationDecl (nameWithTemplateArguments,kind,NULL,NULL,NULL,emptyList);
               ROSE_ASSERT(nondefdecl != NULL);
#if 0
               printf ("In SageBuilder::buildClassDeclaration_nfi(): Build SgTemplateInstantiationDecl: nondefdecl = %p \n",nondefdecl);
#endif
#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
            // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.
            // detectTransformations(nondefdecl);
#endif
            // DQ (6/6/2012): Set the first non-defining declaration to be itself.
            // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);

            // DQ (1/1/2012): Added support for setting the template name (I think this should be fixed in the constructor).
            // It can't be fixed in the constructor since it has to be set after construction (or passed in explicitly).
               ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)->get_templateName().is_null() == true);

            // DQ (6/6/2012): Added support for template arguments so that types would be computed with the template arguments.
               ROSE_ASSERT(templateArgumentsList != NULL);
               ROSE_ASSERT(templateArgumentsList->size() > 0);

            // DQ (9/16/2012): Set the firstNondefiningDeclaration so that we can set the template parameters.
               nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
#if 1
            // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).
               setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);
#else
               isSgTemplateInstantiationDecl(nondefdecl)->get_templateArguments() = *templateArgumentsList;

#error "DEAD CODE!"

            // DQ (9/13/2012): Set the parents of the template arguments (if not already set, to the first non-defining declaration).
            // printf ("Calling setTemplateArgumentParents(): nondefdecl = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str());
               setTemplateArgumentParents(nondefdecl);
            // printf ("DONE: Calling setTemplateArgumentParents(): nondefdecl = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str());

               testTemplateArgumentParents(nondefdecl);
#endif
            // DQ (6/6/2012): Generate the name without the template arguments.
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("Warning: In buildClassDeclaration_nfi(): calling set_templateName(nameWithTemplateArguments = %s) for nondefining declaration \n",nameWithTemplateArguments.str());
#endif
            // isSgTemplateInstantiationDecl(nondefdecl)->set_templateName(name);
            // isSgTemplateInstantiationDecl(nondefdecl)->set_templateName("SETME_NONDEFINING_DECL<>");
            // isSgTemplateInstantiationDecl(nondefdecl)->set_templateName(name);
               isSgTemplateInstantiationDecl(nondefdecl)->set_templateName(nameWithoutTemplateArguments);

            // DQ (6/6/2012): I don't think we want this test any more (should apply only to the result of get_templateName()).
            // DQ (5/31/2012): Find locations where this is set and include template syntax.
            // ROSE_ASSERT(name.getString().find('<') == string::npos);
            // printf ("Commented out test for: name.getString().find('<') == string::npos (should apply only to the result of get_templateName() \n");

               ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)->get_templateName().is_null() == false);

            // DQ (3/22/2012): Make sure there is template syntax present.
            // if (isSgTemplateInstantiationDecl(nondefdecl)->get_templateName().getString().find('>') == string::npos)
               if (hasTemplateSyntax(isSgTemplateInstantiationDecl(nondefdecl)->get_templateName()) == false);
                  {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                    printf ("WARNING: No template syntax present in name of template class instantiation (nondefdecl) \n");
#endif
                  }
            // ROSE_ASSERT(isSgTemplateInstantiationDecl(nondefdecl)->get_templateName().getString().find('>') != string::npos);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
            // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.
            // detectTransformations(nondefdecl);
#endif
             }
            else
             {
            // We know that the name without template arguments should be used here (but they are the same).
#if 0
               printf ("WARNING: In buildClassDeclaration_nfi(): Are we building a new SgClassDeclaration as a nondefining declaration when we should be using the nonDefiningDecl = %p \n",nonDefiningDecl);
#endif
            // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
               nondefdecl = new SgClassDeclaration(nameWithoutTemplateArguments,kind,NULL,NULL);

               ROSE_ASSERT(nondefdecl != NULL);

               ROSE_ASSERT(nameWithoutTemplateArguments == nameWithTemplateArguments);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
            // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.
            // detectTransformations(nondefdecl);
#endif
            // DQ (9/16/2012): Set the firstNondefiningDeclaration because this is the one branch left were it 
            // was not set (required in the true branch so that we could set the template parameters).
               nondefdecl->set_firstNondefiningDeclaration(nondefdecl);

               testTemplateArgumentParents(nondefdecl);
             }

       // DQ (6/6/2012): This has to be set before we generate the type.
       // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
          ROSE_ASSERT(nondefdecl == nondefdecl->get_firstNondefiningDeclaration());

       // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).
       // setTemplateArgumentsInDeclaration(nondefdecl,templateArgumentsList);

       // DQ (3/14/2012): For C++ we need the scope set so that types will have proper locations to revolve them 
       // from being ambiguous or not properly defined.  Basically, we need a handle from which to generate something
       // that amounts to a kind of name qualification internally (maybe even exactly name qualification, but I would
       // have to think about that a bit more).
          ROSE_ASSERT(scope != NULL);
#if 0
          printf ("In SageBuilder::buildClassDeclaration_nfi(): Set the scope of the new non-defining declaration to %p = %s \n",scope,scope->class_name().c_str());
#endif
          nondefdecl->set_scope(scope);
          ROSE_ASSERT(nondefdecl->get_scope() != NULL);

          ROSE_ASSERT(nondefdecl != NULL);

       // DQ (3/22/2012): I think we can assert this.
       // ROSE_ASSERT(nondefdecl->get_type() != NULL);
          ROSE_ASSERT(nondefdecl->get_type() == NULL);

          if (nondefdecl->get_type() == NULL)
             {
               SgClassType *class_type = (kind == SgClassDeclaration::e_java_parameter 
                                                ? (SgClassType *) SgJavaParameterType::createType(nondefdecl)
                                                : (SgClassType *) SgClassType::createType(nondefdecl));
               nondefdecl->set_type(class_type);
             }

       // DQ (3/22/2012): Added assertions.
          ROSE_ASSERT(nondefdecl->get_type() != NULL);
          if (nondefdecl->get_type()->get_declaration() != nondefdecl)
             {
               printf ("ERROR: nondefdecl->get_type() = %p = %s \n",nondefdecl->get_type(),nondefdecl->get_type()->class_name().c_str());
               printf ("ERROR: nondefdecl = %p = %s nondefdecl->get_type()->get_declaration() = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str(),nondefdecl->get_type()->get_declaration(),nondefdecl->get_type()->get_declaration()->class_name().c_str());
             }
          ROSE_ASSERT(nondefdecl->get_type()->get_declaration() == nondefdecl);

#if 0
          printf ("In buildClassDeclaration_nfi(): after set_type(): nondefdecl = %p = %s nondefdecl->get_type() = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str(),nondefdecl->get_type(),nondefdecl->get_type()->class_name().c_str());
#endif

       // printf ("SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

       // The nondefining declaration will not appear in the source code, but is compiler
       // generated (so we have something about the class that we can reference; e.g in
       // types).  At the moment we make it a transformation, there might be another kind 
       // of source position that would be more precise.  FIXME.
       // setOneSourcePositionNull(nondefdecl);
          setOneSourcePositionForTransformation(nondefdecl);
          ROSE_ASSERT (nondefdecl->get_startOfConstruct() != NULL);

#if BUILDER_MAKE_REDUNDANT_CALLS_TO_DETECT_TRANSFORAMTIONS
       // DQ (5/2/2012): After EDG/ROSE translation, there should be no IR nodes marked as transformations.
          if (SourcePositionClassificationMode != e_sourcePositionTransformation) 
             {
               detectTransformations(nondefdecl);
             }
#endif
       // DQ (6/6/2012): This has to be set before we generate the type.
       // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);

       // DQ (3/15/2012): This is now set below.
       // nondefdecl->set_definingDeclaration(defdecl);
          nondefdecl->setForward();

       // DQ (2/27/2012): I don't like that this is setting the parent to be a scope (not a bad default, but must be reset later if required).
       // Liao, 9/2/2009. scope stack is optional, it can be empty
       // nondefdecl->set_parent(topScopeStack());
#if 0
          printf ("WARNING: In buildClassDeclaration_nfi(): Skipping the setting of the parents (for both defining and nondefining declaration) to be the same as the scope \n");
#endif
       // nondefdecl->set_parent(scope);
       // defdecl->set_parent(scope);

          if (scope != NULL)
             {
               mysymbol = new SgClassSymbol(nondefdecl);
#if 0
               printf ("In buildClassDeclaration_nfi(): Insert the new SgClassSymbol = %p from nondefdecl = %p = %s into the scope = %p = %s \n",mysymbol,nondefdecl,nondefdecl->class_name().c_str(),scope,scope->class_name().c_str());
#endif
            // scope->insert_symbol(name, mysymbol);
               scope->insert_symbol(nameWithTemplateArguments, mysymbol);

            // DQ (11/21/2013): Added test based on debugging session with Philippe.
               ROSE_ASSERT(nondefdecl->get_scope() == scope);
             }
            else
             {
            // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.   
            // DQ (1/26/2009): I think this should be an error, but that appears it would
            // break the existing interface. Need to discuss this with Liao.
               printf ("Warning: no scope provided to support symbol table entry! \n");
             }
        }

  // printf ("SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

#if 1
  // Refactored this code.
     testTemplateArgumentParents(nondefdecl);
#else
     if (buildTemplateInstantiation == true)
        {
       // DQ (7/25/2012): Added this code here to reset the parents of the template arguments.
          for (size_t i = 0; i < templateArgumentsList->size(); i++)
             {
            // DQ (7/25/2012): This should be true because the template argument was set to the functions 
            // scope so that the name with template arguments could be computed (with name qualification).
               ROSE_ASSERT((*templateArgumentsList)[i]->get_parent() != NULL);

#error "DEAD CODE!"

            // ROSE_ASSERT(isSgGlobal(templateArgumentsList[i]->get_parent()) == NULL);
            // ROSE_ASSERT(templateArgumentsList[i]->get_parent() == nondefining_templateInstantiation);

            // Be we want to reset it to be the function (now that it is available, because this is more precise).
            // All qualified names should compute to the same qualified name (if not then it is a bug in the name 
            // qualification mechanism).
               (*templateArgumentsList)[i]->set_parent(nondefdecl);
             }
        }
#endif

  // DQ (3/15/2012): I hhava moved construction of defining declaration to be AFTER the nondefining declaration!
  // This is a better organization ans also should make sure that the declaration in the SgClassType will
  // properly reference the firstNondefiningDeclaration (instead of the defining declaration).

  // step 1 (now step 2). Build defining declaration
  // SgClassDefinition* classDef = buildClassDefinition();
     SgClassDefinition* classDef = buildClassDefinition(NULL,buildTemplateInstantiation);

  // DQ (11/26/2011): Debugging EDG 3.3 use of templateArguments.
#if 0
     printf ("Building a SgClassDeclaration: buildClassDeclaration_nfi() buildTemplateInstantiation = %s \n",buildTemplateInstantiation ? "true:" : "false");
#endif

  // SgClassDeclaration* defdecl = new SgClassDeclaration (name,kind,NULL,classDef);
     SgClassDeclaration* defdecl = NULL;
     if (buildTemplateInstantiation == true)
        {
       // This adds: SgTemplateDeclaration *templateDeclaration and SgTemplateArgumentPtrList templateArguments
          SgTemplateArgumentPtrList emptyList;
       // defdecl = new SgTemplateInstantiationDecl (name,kind,NULL,classDef,NULL,emptyList);
          defdecl = new SgTemplateInstantiationDecl (nameWithTemplateArguments,kind,NULL,classDef,NULL,emptyList);

       // DQ (1/1/2012): Added support for setting the template name (I think this should be fixed in the constructor).
       // It can't be fixed in the constructor since it has to be set after construction (or passed in explicitly).
          ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)->get_templateName().is_null() == true);

#if 0
          printf ("Warning: In buildClassDeclaration_nfi(): calling set_templateName(name = %s) for defining declaration \n",name.str());
#if 0
       // isSgTemplateInstantiationDecl(defdecl)->set_templateName(name);
       // isSgTemplateInstantiationDecl(defdecl)->set_templateName("SETME_DEFINING_DECL<>");
          isSgTemplateInstantiationDecl(defdecl)->set_templateName(name);

#error "DEAD CODE!"

       // DQ (5/31/2012): Find locations where this is set and include template syntax.
          ROSE_ASSERT(name.getString().find('<') == string::npos);
#else
       // DQ (6/1/2012): Make sure that the templateName is set and they it does not include the template syntax.
          SgName templateName = generateTemplateNameFromTemplateNameWithTemplateArguments(name);
          printf ("In buildClassDeclaration_nfi(): templateName = %s \n",templateName.str());
          isSgTemplateInstantiationDecl(defdecl)->set_templateName(templateName);

#error "DEAD CODE!"

       // DQ (5/31/2012): Find locations where this is set and include template syntax.
       // ROSE_ASSERT(templateName.getString().find('<') == string::npos);
          ROSE_ASSERT(hasTemplateSyntax(templateName) == false);

       // DQ (6/1/2012): Not clear if this is always true (for all template instantations).
       // ROSE_ASSERT(name.getString().find('<') != string::npos);
          ROSE_ASSERT(hasTemplateSyntax(name) == true);
#endif
#else
#if 0
          printf ("In buildClassDeclaration_nfi(): nameWithoutTemplateArguments = %s nameWithTemplateArguments = %s \n",nameWithoutTemplateArguments.str(),nameWithTemplateArguments.str());
#endif
          isSgTemplateInstantiationDecl(defdecl)->set_templateName(nameWithoutTemplateArguments);

       // DQ (5/8/2013): This fails for test2013_159.C, and it appears that we have been overly restrictive here.
          if (hasTemplateSyntax(nameWithTemplateArguments) == false)
             {
               printf ("WARNING: In buildClassDeclaration_nfi(): nameWithTemplateArguments = %s is not using template syntax \n",nameWithTemplateArguments.str());
             }
       // ROSE_ASSERT(hasTemplateSyntax(nameWithTemplateArguments) == true);

       // DQ (7/27/2012): This fails for test2005_35.C where conversion operators are seen.
       // ROSE_ASSERT(hasTemplateSyntax(nameWithoutTemplateArguments) == false);
#endif

          ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)->get_templateName().is_null() == false);

       // DQ (3/22/2012): Make sure there is template syntax present.
          if (isSgTemplateInstantiationDecl(defdecl)->get_templateName().getString().find('>') == string::npos)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("WARNING: No template syntax present in name of template class instantiation (defdecl) \n");
#endif
             }
       // ROSE_ASSERT(isSgTemplateInstantiationDecl(defdecl)->get_templateName().getString().find('>') != string::npos);
#if 0
          printf ("Should we have set the template instantiation name at this point? \n");
          ROSE_ASSERT(false);
#endif
       // DQ (3/5/2012): Check that the SgClassDefinition is properly matching.
          ROSE_ASSERT(defdecl->get_definition() != NULL);
          ROSE_ASSERT(isSgTemplateInstantiationDefn(defdecl->get_definition()) != NULL);
        }
       else
        {
       // defdecl = new SgClassDeclaration (name,kind,NULL,classDef);
          defdecl = new SgClassDeclaration (nameWithoutTemplateArguments,kind,NULL,classDef);

       // DQ (3/5/2012): Check that the SgClassDefinition is properly matching.
          ROSE_ASSERT(defdecl->get_definition() != NULL);
          ROSE_ASSERT(isSgTemplateInstantiationDefn(defdecl->get_definition()) == NULL);
        }
     ROSE_ASSERT(defdecl != NULL);

#if 1
  // DQ (3/15/2012): Moved from original location above...
     nondefdecl->set_definingDeclaration(defdecl);

     ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
     ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);
#endif

  // printf ("SageBuilder::buildClassDeclaration_nfi(): defdecl = %p \n",defdecl);

     setOneSourcePositionForTransformation(defdecl);
  // constructor is side-effect free
     classDef->set_declaration(defdecl);
     defdecl->set_definingDeclaration(defdecl);

     testTemplateArgumentParents(nondefdecl);
     testTemplateArgumentParents(defdecl);

  // setOneSourcePositionForTransformation(nondefdecl);
  //
  // Liao 1/18/2011, I changed the semantics of setOneSourcePositionNull to set file_info to null regardless the existence of 
  // file_info of the input node.
  // We do want to keep the file_info of nodefdecl if it is set already as compiler generated.
  //    setOneSourcePositionNull(nondefdecl);

  // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
  // nondefdecl->set_definingDeclaration(defdecl);
     defdecl->set_firstNondefiningDeclaration(nondefdecl);

     if (buildTemplateInstantiation == true)
        {
       // DQ (9/16/2012): This is a newly refactored function (call this after the firstNondefiningDeclaration is set).
          setTemplateArgumentsInDeclaration(defdecl,templateArgumentsList);
        }

  // DQ (3/22/2012): I think we can assert this.
     ROSE_ASSERT(defdecl->get_type() == NULL);

  // Liao, 10/30/2009
  // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType
  // This is not desired when building a defining declaration and an inefficience in the constructor
  // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and 
  // the defining class declaration (and other nondefining declaration) just shared that SgClassType.
     if (defdecl->get_type() != NULL) 
        {
       // if a defining class declaration's type is associated with a defining class.
       // This is a wrong SgClassType and has to be reset
          if (defdecl->get_type()->get_declaration() == isSgDeclarationStatement(defdecl))
             {
            // DQ (3/21/2012): Added this test.
               ROSE_ASSERT (nondefdecl->get_type() != NULL);

            // DQ (3/15/2012): Make this conditional upon the types not already being equal.
               if (nondefdecl->get_type() != defdecl->get_type())
                  {
#if 0
                    printf ("Deleting defdecl->get_type() = %p = %s (using type from nondefdecl = %p) \n",defdecl->get_type(),defdecl->get_type()->class_name().c_str(),nondefdecl);
                    printf ("Skipping delete of %p to maintain unique type pointers \n",defdecl->get_type());
#else
                    delete defdecl->get_type();
#endif
                 // DQ (3/15/2012): This will be reset below.
                    defdecl->set_type(NULL);
#if 0
                 // DQ (12/13/2011): Is this executed...
                    printf ("Is this executed! \n");
                    ROSE_ASSERT(false);
#endif
                 // DQ (3/21/2012): set the types to be the same type.
                    ROSE_ASSERT (nondefdecl->get_type() != NULL);
                    defdecl->set_type(nondefdecl->get_type());

                 // DQ (3/21/2012): Added these checks...
                    SgClassType* classType = nondefdecl->get_type();
                    ROSE_ASSERT(classType != NULL);
                    SgClassDeclaration* local_classDeclaration = isSgClassDeclaration(classType->get_declaration());
                    ROSE_ASSERT (local_classDeclaration != NULL);
                    printf ("In buildClassDeclaration_nfi(): classType = %p local_classDeclaration = %p \n",classType,local_classDeclaration);
                    ROSE_ASSERT (local_classDeclaration->get_firstNondefiningDeclaration() != NULL);
                    ROSE_ASSERT (local_classDeclaration->get_firstNondefiningDeclaration() == local_classDeclaration);
                  }
             }
        }
       else
        {
       // DQ (3/15/2012): Make sure that both the defining and non-defining declarations use the same type.
          ROSE_ASSERT (nondefdecl->get_type() != NULL);
          defdecl->set_type(nondefdecl->get_type());

#if 0
          printf ("In buildClassDeclaration_nfi(): defdecl = %p = %s defdecl->get_type() = %p = %s \n",defdecl,defdecl->class_name().c_str(),defdecl->get_type(),defdecl->get_type()->class_name().c_str());
#endif

          ROSE_ASSERT (nondefdecl->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl->get_firstNondefiningDeclaration()));
        }

  // DQ (9/4/2012): Added assertion.
     ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

  // patch up the SgClassType for the defining class declaration
     ROSE_ASSERT (nondefdecl->get_type() != NULL);
  // ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl)); 
     if (nondefdecl->get_type()->get_declaration() != isSgDeclarationStatement(nondefdecl))
        {
          printf ("nondefdecl                                    = %p = %s \n",nondefdecl,nondefdecl->class_name().c_str());
          printf ("nondefdecl->get_type()                        = %p = %s \n",nondefdecl->get_type(),nondefdecl->get_type()->class_name().c_str());
          printf ("nondefdecl->get_type()->get_declaration()     = %p = %s \n",nondefdecl->get_type()->get_declaration(),nondefdecl->get_type()->get_declaration()->class_name().c_str());
          printf ("nondefdecl->get_firstNondefiningDeclaration() = %p = %s \n",nondefdecl->get_firstNondefiningDeclaration(),nondefdecl->get_firstNondefiningDeclaration()->class_name().c_str());
        }
  // ROSE_ASSERT (defdecl->get_type()->get_declaration() == isSgDeclarationStatement(defdecl));
     ROSE_ASSERT (defdecl->get_type() != NULL);
     ROSE_ASSERT (defdecl->get_type()->get_declaration() != NULL);
     ROSE_ASSERT (defdecl->get_type()->get_declaration() != isSgDeclarationStatement(defdecl));
     ROSE_ASSERT (nondefdecl->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT (nondefdecl->get_firstNondefiningDeclaration() == nondefdecl);
     ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl->get_firstNondefiningDeclaration()));
     ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl));

  // DQ (9/4/2012): Added assertion.
     ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

  // This appears to be redundant...is it?
     defdecl->set_type(nondefdecl->get_type());

#if 0
     printf ("In buildClassDeclaration_nfi(): after calling set_type() again: defdecl = %p = %s defdecl->get_type() = %p = %s \n",defdecl,defdecl->class_name().c_str(),defdecl->get_type(),defdecl->get_type()->class_name().c_str());
#endif

  // DQ (9/4/2012): Added assertion.
     ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

  // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).
  // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless 
  // used in a defining declaration).
     nondefdecl->setForward();

     if (scope != NULL)  // put into fixStructDeclaration() or alike later on
        {
       // DQ (9/4/2012): Added assertion.
          ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

       // Note, this function sets the parent to be the scope if it is not already set.
          fixStructDeclaration(defdecl,scope);

       // DQ (9/4/2012): Added assertion.
          ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

          fixStructDeclaration(nondefdecl,scope);

       // DQ (9/4/2012): Added assertion.
          ROSE_ASSERT (defdecl->get_type() == nondefdecl->get_type());

#if 0
          SgClassSymbol* mysymbol = new SgClassSymbol(nondefdecl);
          ROSE_ASSERT(mysymbol);
          scope->insert_symbol(name, mysymbol);
          printf ("@@@@@@@@@@@@@@ In buildClassDeclaration_nfi(): setting scope of defining and non-defining declaration to scope = %s \n",scope->class_name().c_str());
          defdecl->set_scope(scope);
          nondefdecl->set_scope(scope);

       // defdecl->set_parent(scope);

       // Liao, 9/2/2009. merged into fixStructDeclaration
       // DQ (1/25/2009): The scope is not the same as the parent, since the scope is logical, and the parent is structural (note that topScopeStack() is structural).
          nondefdecl->set_parent(scope);
       // nondefdecl->set_parent(topScopeStack());
       // Liao, 9/2/2009. scope stack is optional, it can be empty
          defdecl->set_parent(scope);
       // defdecl->set_parent(topScopeStack());
#endif
        }

  // DQ (1/26/2009): I think we should assert this, but it breaks the interface as defined
  // by the test code in tests/roseTests/astInterfaceTests.
  // ROSE_ASSERT(defdecl->get_parent() != NULL);

  // ROSE_ASSERT(nonDefiningDecl->get_parent() != NULL);

  // DQ (2/27/2012): Tracking down where parents are not set correctly (class declaration in typedef is incorrectly set to SgGlobal).
     ROSE_ASSERT(defdecl->get_parent()    == NULL);

  // DQ (2/29/2012):  We can't assert this (fails for test2012_09.C).
  // ROSE_ASSERT(nondefdecl->get_parent() == NULL);

     ROSE_ASSERT(defdecl->get_definingDeclaration() == defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != defdecl->get_definingDeclaration());

     testTemplateArgumentParents(nondefdecl);
     testTemplateArgumentParents(defdecl);

     return defdecl;    
   }

SgClassDeclaration* SageBuilder::buildStructDeclaration(const string& name, SgScopeStatement* scope/*=NULL*/)
   {
     SgName myname(name);
     return buildStructDeclaration(myname, scope);
   }

SgClassDeclaration* SageBuilder::buildStructDeclaration(const char* name, SgScopeStatement* scope/*=NULL*/)
   {
     SgName myname(name);
     return buildStructDeclaration(myname, scope);
   }


#if 0
// DQ (11/19/2011): Added more uniform support for building class declarations.
SgTemplateClassDeclaration*
SageBuilder::buildTemplateClassDeclaration ( SgName name, SgScopeStatement* scope )
   {
     ROSE_ASSERT(scope != NULL);
     SgTemplateClassDeclaration* definingClassDeclaration = buildDefiningTemplateClassDeclaration(name,scope);
     ROSE_ASSERT(definingClassDeclaration != NULL);

     return definingClassDeclaration;
   }
#endif


#ifdef ROSE_USE_NEW_EDG_INTERFACE
SgTemplateClassDefinition*
SageBuilder::buildTemplateClassDefinition(SgTemplateClassDeclaration *d /*= NULL*/ )
  {
    SgTemplateClassDefinition* result = NULL;
    if (d != NULL) // the constructor does not check for NULL d, causing segmentation fault
       {
         result = new SgTemplateClassDefinition(d);
      // result->set_parent(d); // set_declaration() == set_parent() in this case
       }
      else
       {
         result = new SgTemplateClassDefinition();
       }

    ROSE_ASSERT(result);

 // DQ (11/28/2010): Added specification of case insensitivity for Fortran.
    if (symbol_table_case_insensitive_semantics == true)
         result->setCaseInsensitive(true);

    setOneSourcePositionForTransformation(result);
    return result;
  }
#endif


#ifdef ROSE_USE_NEW_EDG_INTERFACE
// SgTemplateClassDeclaration * SageBuilder::buildTemplateClassDeclaration_nfi(SgName & name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl )
// SgTemplateClassDeclaration * SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(const SgName& name, SgClassDeclaration::class_types kind, SgScopeStatement* scope )
SgTemplateClassDeclaration*
SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(const SgName& XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
   {
     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

  // DQ (11/20/2011): This is for initial debugging only.
     ROSE_ASSERT(scope != NULL);

#if 0
     printf ("SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): XXX_name = %s scope = %p = %s \n",XXX_name.str(),scope,scope->class_name().c_str());
#endif

  // DQ (9/12/2012): We want to add the template arguments of any specialization to the template name and keep track of the name with and without template specialization arguments.
     SgName nameWithoutTemplateArguments            = XXX_name;
     SgName nameWithTemplateSpecializationArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateSpecializationArgumentList);

  // SgTemplateClassDeclaration::class_types template_class_kind = SgTemplateClassDeclaration::e_class;
  
  // Step 2. build the nondefining declaration, 
  // but only if the input nonDefiningDecl pointer was NULL and it does not exist

  // Get the nondefining declaration from the symbol if it has been built (if this works, 
  // then we likely don't need the "SgClassDeclaration* nonDefiningDecl" parameter).
     SgTemplateClassDeclaration* nondefdecl = NULL;

  // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/roseTests/astInterfaceTests test codes.
  // ROSE_ASSERT(scope != NULL);

  // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.
  // SgTemplateSymbol* mysymbol = NULL;
     SgClassSymbol* mysymbol = NULL;

     if (scope != NULL)
        {
       // DQ (9/12/2012): We want to include the template specialization into the name where it is required (this handling 
       // is similar to normal template arguments for non-template declaration, but different than template parameters).
       // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.
       // mysymbol = scope->lookup_template_symbol(name);
       // mysymbol = scope->lookup_class_symbol(name);
       // mysymbol = scope->lookup_template_class_symbol(name);
       // mysymbol = scope->lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList);
          mysymbol = scope->lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList);
        }
       else
        {
       // Liao 9/2/2009: This is not an error. We support bottom-up AST construction and scope can be unknown.   
       // DQ (1/26/2009): I think this should be an error, but that appears it would
       // break the existing interface. Need to discuss this with Liao.
          printf ("Warning: In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): scope == NULL \n");
        }
#if 0
     printf ("In SageBuilder::buildNondefiningTemplateClassDeclaration_nfi(): mysymbol = %p \n",mysymbol);
#endif

     if (mysymbol != NULL) // set links if nondefining declaration already exists.
        {
       // DQ (3/7/2012): Build a seperate non-defining declaration (reusing the existing one will cause the test for unique statements to fail).
       // printf ("WARNING: Even if the first non-defining SgTemplateClassDeclaration is found in the symbol table then likely we still might want to build a 2nd one. \n");
       // nondefdecl = isSgTemplateClassDeclaration(mysymbol->get_declaration());
          SgClassType* classType = isSgClassType(mysymbol->get_type());
          ROSE_ASSERT(classType != NULL);

       // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
       // nondefdecl = new SgTemplateClassDeclaration(name,kind,classType,(SgClassDefinition*)NULL);
          nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,classType,(SgClassDefinition*)NULL);

          ROSE_ASSERT(nondefdecl != NULL);

       // DQ (9/10/2012): Initialize the template parameter list.
          ROSE_ASSERT(templateParameterList != NULL);
          nondefdecl->get_templateParameters() = *templateParameterList;

       // DQ (9/16/2012): Moved this initialization of firstNondefiningDeclaration from farther down in this branch (and added assertion).
          nondefdecl->set_firstNondefiningDeclaration(mysymbol->get_declaration());
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != NULL);

#if 1
       // DQ (9/16/2012): This newly refactored function can only be called after firstNondefiningDeclaration is set.
       // This also sets the template argument parents to the firstNondefiningDeclaration.
          setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);
#else
       // DQ (9/12/2012): Adding support for template specialization.
          ROSE_ASSERT(templateSpecializationArgumentList != NULL);
          nondefdecl->get_templateSpecializationArguments() = *templateSpecializationArgumentList;
#endif
       // DQ (9/10/2012): Test the just built template with its template parameters.
          if (nondefdecl->get_templateParameters().size() == 0)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("WARNING: In buildNondefiningTemplateClassDeclaration_nfi(): (part 1) nondefdecl->get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n",nondefdecl);
#endif
             }
       // ROSE_ASSERT(nondefdecl->get_templateParameters().size() > 0);

       // DQ (3/7/2012): We want this to be set later, so we can't test it here.
       // ROSE_ASSERT(nondefdecl->get_parent() != NULL);
#if 0
          nondefdecl->set_definingDeclaration(defdecl);

          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);
#endif
       // DQ (3/7/2012): But always refer to the first non-defining declaration so it will be unique (and set the scope).
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != nondefdecl);
          nondefdecl->set_scope(scope);
          nondefdecl->setForward();

       // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.
          nondefdecl->set_templateName(nameWithoutTemplateArguments);

          testTemplateArgumentParents(nondefdecl);
        }
       else // build a nondefnining declaration if it does not exist
        {
       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.
       // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
       // nondefdecl = new SgTemplateClassDeclaration(name,templateString,template_kind,templateParameters,template_class_kind,classType,classDef);
       // nondefdecl = new SgTemplateClassDeclaration(name,templateString,template_kind,templateParameters,template_class_kind,classDef);
#ifdef ROSE_USE_NEW_EDG_INTERFACE
       // nondefdecl = new SgTemplateClassDeclaration(name,template_class_kind,classDef);

       // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
       // DQ (12/21/2011): The new design for SgTemplateClassDeclaration derives from the SgClassDeclaration instead of SgTemplateDeclaration.
       //    Uses same signature as: SgClassDeclaration (SgName name, SgClassDeclaration::class_types class_type, SgClassType *type, SgClassDefinition *definition)
       // nondefdecl = new SgTemplateClassDeclaration(name,template_class_kind,NULL);
       // nondefdecl = new SgTemplateClassDeclaration(name,kind,(SgClassType*)NULL,(SgClassDefinition*)NULL);
          nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,(SgClassType*)NULL,(SgClassDefinition*)NULL);
#else
          nondefdecl = NULL;

          printf ("In buildNondefiningTemplateClassDeclaration_nfi(): This function is not supported for older versions of ROSE \n");
          ROSE_ASSERT(false);
#endif
          ROSE_ASSERT(nondefdecl != NULL);

       // DQ (9/10/2012): Initialize the template parameter list.
          ROSE_ASSERT(templateParameterList != NULL);
          nondefdecl->get_templateParameters() = *templateParameterList;

       // DQ (9/16/2012): Moved this initialization of firstNondefiningDeclaration from farther down in this branch.
          nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
#if 1
       // DQ (9/16/2012): This newly refactored function can only be called after firstNondefiningDeclaration is set.
       // This also sets the template argument parents to the firstNondefiningDeclaration.
          setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);
#else
       // DQ (9/12/2012): Adding support for template specialization.
          ROSE_ASSERT(templateSpecializationArgumentList != NULL);
          nondefdecl->get_templateSpecializationArguments() = *templateSpecializationArgumentList;
#endif
       // DQ (9/12/2012): Adding support for template specialization.
       // ROSE_ASSERT(templateSpecializationArgumentList != NULL);
       // nondefdecl->get_templateSpecializationArguments() = *templateSpecializationArgumentList;

       // DQ (9/10/2012): Test the just built template with its template parameters.
          if (nondefdecl->get_templateParameters().size() == 0)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("WARNING: In buildNondefiningTemplateClassDeclaration_nfi(): (part 2) nondefdecl->get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n",nondefdecl);
#endif
             }
       // ROSE_ASSERT(nondefdecl->get_templateParameters().size() > 0);

       // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.
          nondefdecl->set_templateName(nameWithoutTemplateArguments);

#if 0
       // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.
          if (nondefdecl->get_type() == NULL)
             {
            // nondefdecl->set_type(SgClassType::createType(nondefdecl));
            // nondefdecl->set_type(NULL);
            // nondefdecl->set_type(SgTemplateType::createType(nondefdecl));
            // nondefdecl->set_type(SgTemplateType::createType());
               nondefdecl->set_type(SgClassType::createType(nondefdecl));
               ROSE_ASSERT(nondefdecl->get_type() != NULL);
             }
#endif
       // printf ("SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

       // The nondefining declaration will not appear in the source code, but is compiler
       // generated (so we have something about the class that we can reference; e.g in
       // types).  At the moment we make it a transformation, there might be another kind 
       // of source position that would be more precise.  FIXME.
       // setOneSourcePositionNull(nondefdecl);
          setOneSourcePositionForTransformation(nondefdecl);
          ROSE_ASSERT (nondefdecl->get_startOfConstruct() != NULL);

       // nondefdecl->set_definingDeclaration(defdecl);
          nondefdecl->setForward();

       // Liao, 9/2/2009. scope stack is optional, it can be empty
       // nondefdecl->set_parent(topScopeStack());
#if 0
          printf ("In buildNondefiningTemplateClassDeclaration_nfi(): Commented out setting the parent to the scope. \n");
#endif
       // printf ("Note that for C++, the parent may not be the same as the scope (dangerous code). \n");
       // nondefdecl->set_parent(scope);

          nondefdecl->set_scope(scope);

#if 1
       // DQ (12/4/2011): Set the scope first and then set the type (scope is required to compute the type (name mangling)).
       // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.
          if (nondefdecl->get_type() == NULL)
             {
            // nondefdecl->set_type(SgClassType::createType(nondefdecl));
            // nondefdecl->set_type(NULL);
            // nondefdecl->set_type(SgTemplateType::createType(nondefdecl));
            // nondefdecl->set_type(SgTemplateType::createType());
               nondefdecl->set_type(SgClassType::createType(nondefdecl));
               ROSE_ASSERT(nondefdecl->get_type() != NULL);
             }
#endif

       // Build a SgTemplateClassSymbol and put it into the specified scope.
          if (scope != NULL)
             {
#if 0
               printf ("Building a SgTemplateSymbol using nameWithTemplateSpecializationArguments = %s and nondefdecl = %p = %s \n",nameWithTemplateSpecializationArguments.str(),nondefdecl,nondefdecl->class_name().c_str());
#endif
            // DQ (12/21/2011): We want to use a newer design that derives the SgTemplateClassDeclaration from the SgClassDeclaration.
            // mysymbol = new SgTemplateSymbol(nondefdecl);
            // mysymbol = new SgClassSymbol(nondefdecl);
#ifdef TEMPLATE_DECLARATIONS_DERIVED_FROM_NON_TEMPLATE_DECLARATIONS
               mysymbol = new SgTemplateClassSymbol(nondefdecl);
#else
               printf ("Error: This functionality is not yet been made backwardly compatable to EDG 3.3 template design \n");
               mysymbol = new SgClassSymbol(NULL);

               printf ("Exiting to avoid further errors \n");
               ROSE_ASSERT(false);
#endif
               ROSE_ASSERT(mysymbol != NULL);

            // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
            // DQ (3/6/2012): Added test for existing symbol (see test2012_18.C).
            // ROSE_ASSERT(scope->lookup_template_class_symbol(name) == NULL);
            // ROSE_ASSERT(scope->lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList) == NULL);
               ROSE_ASSERT(scope->lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList) == NULL);

            // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
            // scope->insert_symbol(name, mysymbol);
               scope->insert_symbol(nameWithTemplateSpecializationArguments, mysymbol);
#if 0
               printf ("SageBuilder::buildNondefiningTemplateClassDeclaration_nfi() (after building symbol): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif
               ROSE_ASSERT(nondefdecl->get_scope() != NULL);

               ROSE_ASSERT(nondefdecl->get_symbol_from_symbol_table() != NULL);

            // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
            // ROSE_ASSERT(scope->lookup_template_class_symbol(name) != NULL);
            // ROSE_ASSERT(scope->lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList) != NULL);
               ROSE_ASSERT(scope->lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList) != NULL);
             }
            else
             {
            // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.   
             }

          testTemplateArgumentParents(nondefdecl);
        }

  // defdecl->set_firstNondefiningDeclaration(nondefdecl);

  // DQ (11/3/2012): Setup the default source position information.
     setSourcePosition(nondefdecl);

#if 0
  // DQ (11/20/2011): SgTemplateClassDeclaration IR nodes don't have a SgType associated with them (template declarations don't have a type in C++, I think).

  // Liao, 10/30/2009
  // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType
  // This is not desired when building a defining declaration and an inefficience in the constructor
  // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and 
  // the defining class declaration (and other nondefining declaration) just shared that SgClassType.
     if (defdecl->get_type() != NULL) 
        {
       // if a defining class declaration's type is associated with a defining class.
       // This is a wrong SgClassType and has to be reset
          if (defdecl->get_type()->get_declaration() == isSgDeclarationStatement(defdecl) )
             {
               delete defdecl->get_type();
             }
        }

  // patch up the SgClassType for the defining class declaration
     ROSE_ASSERT (nondefdecl->get_type() != NULL);
     ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl));
     defdecl->set_type(nondefdecl->get_type());
#else
  // printf ("We might need to force the types used for defining and non-defining SgTemplateClassDeclaration to be the same! \n");
     ROSE_ASSERT(nondefdecl->get_type() != NULL);
#endif

  // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).
  // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless 
  // used in a defining declaration).
     nondefdecl->setForward();

     if (scope != NULL)  // put into fixStructDeclaration() or alike later on
        {
       // fixStructDeclaration(defdecl,scope);
       // fixStructDeclaration(nondefdecl,scope);

       // printf ("***** WARNING *****: Commented out call to fixStructDeclaration() \n");
       // ROSE_ASSERT(false);
        }

#if 0
     ROSE_ASSERT(defdecl->get_definingDeclaration() == defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != defdecl->get_definingDeclaration());

     ROSE_ASSERT(defdecl->get_scope() != NULL);
#endif

  // DQ (7/15/2012): We want to enforce this to not be set yet (might be part of non-autonomous declaration (e.g. nested in a typedef).
     ROSE_ASSERT(nondefdecl->get_parent() == NULL);

  // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).
     ROSE_ASSERT(nondefdecl->get_templateName().is_null() == false);

     testTemplateArgumentParents(nondefdecl);

     return nondefdecl;    
   }

// endif for case of ifdef ROSE_USE_NEW_EDG_INTERFACE
#endif


#ifdef ROSE_USE_NEW_EDG_INTERFACE
// SgTemplateClassDeclaration * SageBuilder::buildTemplateClassDeclaration_nfi(SgName & name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl )
// SgTemplateClassDeclaration * SageBuilder::buildTemplateClassDeclaration_nfi(const SgName& name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl )
SgTemplateClassDeclaration * 
SageBuilder::buildTemplateClassDeclaration_nfi(const SgName& XXX_name, SgClassDeclaration::class_types kind, SgScopeStatement* scope, SgTemplateClassDeclaration* nonDefiningDecl, 
                                               SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
   {
  // DQ (12/26/2011): Notes that the input nonDefiningDecl is not used...this is a confusing point. 
  // The specification of the scope appears to be enough.

     if (scope == NULL)
          scope = SageBuilder::topScopeStack();

#if 0
     printf ("In buildTemplateClassDeclaration_nfi(): nonDefiningDecl = %p \n",nonDefiningDecl);
     if (nonDefiningDecl != NULL)
        {
          printf ("--- nonDefiningDecl->get_firstNondefiningDeclaration() = %p \n",nonDefiningDecl->get_firstNondefiningDeclaration());
          printf ("--- nonDefiningDecl->get_definingDeclaration()         = %p \n",nonDefiningDecl->get_definingDeclaration());
        }
#endif

  // DQ (11/20/2011): This is for initial debugging only.
     ROSE_ASSERT(scope != NULL);

  // DQ (9/12/2012): We want to add the template arguments of any specialization to the template name and keep track of the name with and without template specialization arguments.
     SgName nameWithoutTemplateArguments            = XXX_name;
     SgName nameWithTemplateSpecializationArguments = appendTemplateArgumentsToName(nameWithoutTemplateArguments,*templateSpecializationArgumentList);

  // step 1. Build defining declaration
  // Note that even the SgTemplateClassDeclaration uses a regular SgClassDefinition instead of the currently unused SgTemplateClassDefinition.
  // SgClassDefinition* classDef = buildClassDefinition();
  // SgTemplateClassDefinition* classDef = buildTemplateClassDefinition(name,);

  // DQ (11/29/2011): Added checks...
     if (nonDefiningDecl != NULL)
        {
          ROSE_ASSERT(nonDefiningDecl->get_firstNondefiningDeclaration() == nonDefiningDecl);
        }

     SgName templateString = "template string";
  // SgTemplateDeclaration::template_type_enum template_kind = SgTemplateDeclaration::e_template_class;
     SgTemplateParameterPtrList templateParameters;

  // SgTemplateDeclaration (SgName name, SgName string, SgTemplateDeclaration::template_type_enum template_kind, SgTemplateParameterPtrList templateParameters)
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,kind,NULL,classDef);
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters);

  // SgTemplateClassDeclaration::class_types template_class_kind = SgTemplateClassDeclaration::e_class;
  // SgTemplateType*            classType = NULL;
  // SgTemplateClassDefinition* classDef  = NULL;
     SgTemplateClassDefinition* classDef = buildTemplateClassDefinition();

  // Constructure arguments: SgName, SgName, SgTemplateDeclaration::template_type_enum, SgTemplateParameterPtrList, SgTemplateClassDeclaration::class_types, SgClassType*, SgTemplateClassDefinition*
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters);
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,template_class_kind,classType,classDef);
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,templateString,template_kind,templateParameters,template_class_kind,classDef);
#ifdef ROSE_USE_NEW_EDG_INTERFACE

#if 0
     printf ("In buildTemplateClassDeclaration_nfi(): calling new SgTemplateClassDeclaration() name = %s \n",nameWithTemplateSpecializationArguments.str());
#endif

  // DQ (9/12/2012): We want to include the template specialization into the name where it is required (this handling 
  // is similar to normal template arguments for non-template declaration, but different than template parameters).
  // This copy of SgName is required to support passing it to the SgTemplateClassDeclaration constructor.
  // SgName localName = name;
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,template_class_kind,classDef);
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (name,kind,NULL,classDef);

  // DQ (1/13/2013): This is causing two defining declarations to be built for test2012_278.C (and the parent for the second defining 
  // declaration is not being set, though the larger issue is that we have two defining declarations, however this might be acceptable 
  // if this is a specialization).
  // SgTemplateClassDeclaration* defdecl = new SgTemplateClassDeclaration (nameWithTemplateSpecializationArguments,kind,NULL,classDef);
     SgTemplateClassDeclaration* defdecl = NULL;
     if (nonDefiningDecl != NULL)
        {
       // If we have a non-defining declaration specified, try to use any existing defining declaration withouth building a 2nd one 
       // (which would be an error, unless maybe if this is a specialization).
          if (nonDefiningDecl->get_definingDeclaration() != NULL)
             {
            // This must be a valid SgTemplateClassDefinition.
               defdecl = isSgTemplateClassDeclaration(nonDefiningDecl->get_definingDeclaration());
               ROSE_ASSERT(defdecl != NULL);
#if 1
               printf ("In buildTemplateClassDeclaration_nfi(): Reusing the defining declaration previously build: defdecl = %p = %s \n",defdecl,defdecl->get_name().str());
#endif
             }
            else
             {
#if 0
               printf ("In buildTemplateClassDeclaration_nfi(): No defining declaration found, so we have to build one. \n");
#endif
             }
        }

     if (defdecl == NULL)
        {
#if 0
          printf ("Building a defining declaration \n");
#endif
          defdecl = new SgTemplateClassDeclaration (nameWithTemplateSpecializationArguments,kind,NULL,classDef);
        }

#else
     SgTemplateClassDeclaration* defdecl = NULL;

     printf ("In buildTemplateClassDeclaration_nfi(): This function is not supported for older versions of ROSE \n");
     ROSE_ASSERT(false);
#endif

     ROSE_ASSERT(defdecl != NULL);

#if 0
     printf ("In buildTemplateClassDeclaration_nfi(): defdecl = %p = %s \n",defdecl,defdecl->class_name().c_str());
#endif

  // DQ (9/10/2012): Initialize the template parameter list.
     ROSE_ASSERT(templateParameterList != NULL);
     defdecl->get_templateParameters() = *templateParameterList;

  // DQ (9/12/2012): Adding support for template specialization.
     ROSE_ASSERT(templateSpecializationArgumentList != NULL);
     defdecl->get_templateSpecializationArguments() = *templateSpecializationArgumentList;

  // DQ (9/16/2012): We can't test this yet, since the firstNondefiningDeclaration has not be set.
  // testTemplateArgumentParents(defdecl);

  // DQ (9/10/2012): Test the just built template with its template parameters.
     if (defdecl->get_templateParameters().size() == 0)
        {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("WARNING: In buildTemplateClassDeclaration_nfi(): defdecl->get_templateParameters().size() == 0: OK for nested classes/structs in template declarations defdecl = %p \n",defdecl);
#endif
        }
  // ROSE_ASSERT(defdecl->get_templateParameters().size() > 0);

  // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.
     defdecl->set_templateName(nameWithoutTemplateArguments);

#if 0
     printf ("SageBuilder::buildTemplateClassDeclaration_nfi(): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif

     defdecl->set_scope(scope);

  // DQ (7/15/2012): To support non-autonomous declarations (declarations nested in types) we don't want to set the parent here.  It will be set later.
  // DQ (11/20/2011): Can name qualification make this incorrect?
  // defdecl->set_parent(scope);

     ROSE_ASSERT(classDef != NULL);

  // printf ("SageBuilder::buildTemplateClassDeclaration_nfi(): defdecl = %p \n",defdecl);

     setOneSourcePositionForTransformation(defdecl);

  // constructor is side-effect free
     classDef->set_declaration(defdecl);
     defdecl->set_definingDeclaration(defdecl);

  // Step 2. build the nondefining declaration, 
  // but only if the input nonDefiningDecl pointer was NULL and it does not exist

  // Get the nondefining declaration from the symbol if it has been built (if this works, 
  // then we likely don't need the "SgClassDeclaration* nonDefiningDecl" parameter).
     SgTemplateClassDeclaration* nondefdecl = NULL;

  // DQ (1/26/2009): It seems that (scope == NULL) can happen in the tests/roseTests/astInterfaceTests test codes.
  // ROSE_ASSERT(scope != NULL);
  // SgTemplateSymbol* mysymbol = NULL;
     SgClassSymbol* mysymbol = NULL;
     if (scope != NULL)
        {
       // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
       // mysymbol = scope->lookup_template_symbol(name);
       // mysymbol = scope->lookup_class_symbol(name);
       // mysymbol = scope->lookup_template_class_symbol(name);
       // mysymbol = scope->lookup_template_class_symbol(name,templateParameterList,templateSpecializationArgumentList);
          mysymbol = scope->lookup_template_class_symbol(nameWithTemplateSpecializationArguments,templateParameterList,templateSpecializationArgumentList);
        }
       else
        {
       // Liao 9/2/2009: This is not an error. We support bottom-up AST construction and scope can be unkown.   
       // DQ (1/26/2009): I think this should be an error, but that appears it would
       // break the existing interface. Need to discuss this with Liao.
#if 0
          printf ("Warning: In SageBuilder::buildTemplateClassDeclaration_nfi(): scope == NULL \n");
#endif
        }

#if 0
     printf ("In buildTemplateClassDeclaration_nfi(): mysymbol = %p \n",mysymbol);
#endif

     if (mysymbol != NULL) // set links if nondefining declaration already exists.
        {
          nondefdecl = isSgTemplateClassDeclaration(mysymbol->get_declaration());

          ROSE_ASSERT(nondefdecl != NULL);

#if 0
          printf ("In SageBuilder::buildTemplateClassDeclaration_nfi(): Skipped test of nondefdecl->get_parent() != NULL \n");
#endif
       // ROSE_ASSERT(nondefdecl->get_parent() != NULL);

          nondefdecl->set_definingDeclaration(defdecl);

          ROSE_ASSERT(nondefdecl->get_definingDeclaration() == defdecl);
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != defdecl);

       // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).
          ROSE_ASSERT(nondefdecl->get_templateName().is_null() == false);

       // DQ (9/16/2012): Test this previously setup firstNondefiningDeclaration.
          ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() == nondefdecl);
          testTemplateArgumentParents(nondefdecl);
        }
       else // build a nondefnining declaration if it does not exist
        {
       // DQ (1/25/2009): We only want to build a new declaration if we can't reuse the existing declaration.
       // nondefdecl = new SgClassDeclaration(name,kind,NULL,NULL);
       // nondefdecl = new SgTemplateClassDeclaration(name,templateString,template_kind,templateParameters,template_class_kind,classType,classDef);
       // nondefdecl = new SgTemplateClassDeclaration(name,templateString,template_kind,templateParameters,template_class_kind,classDef);
#ifdef ROSE_USE_NEW_EDG_INTERFACE
       // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
       // nondefdecl = new SgTemplateClassDeclaration(name,template_class_kind,classDef);
       // nondefdecl = new SgTemplateClassDeclaration(name,kind,NULL,classDef);
       // nondefdecl = new SgTemplateClassDeclaration(name,kind,NULL,NULL);
          nondefdecl = new SgTemplateClassDeclaration(nameWithTemplateSpecializationArguments,kind,NULL,NULL);
#else
          nondefdecl = NULL;

          printf ("In buildTemplateClassDeclaration_nfi(): This function is not supported for older versions of ROSE \n");
          ROSE_ASSERT(false);
#endif
          ROSE_ASSERT(nondefdecl != NULL);

          nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
          nondefdecl->set_definingDeclaration(defdecl);

       // DQ (9/10/2012): Initialize the template parameter list.
          ROSE_ASSERT(templateParameterList != NULL);
          nondefdecl->get_templateParameters() = *templateParameterList;

#if 1
       // DQ (9/16/2012): Newly refactored code.
          setTemplateSpecializationArgumentsInDeclaration(nondefdecl,templateSpecializationArgumentList);
#else
       // DQ (9/12/2012): Adding support for template specialization.
          ROSE_ASSERT(templateSpecializationArgumentList != NULL);
          nondefdecl->get_templateSpecializationArguments() = *templateSpecializationArgumentList;
#endif
          testTemplateArgumentParents(nondefdecl);

       // DQ (9/10/2012): Test the just built template with its template parameters.
       // ROSE_ASSERT(nondefdecl->get_templateParameters().size() > 0);
          if (nondefdecl->get_templateParameters().size() == 0)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("WARNING: In buildTemplateClassDeclaration_nfi(): nondefdecl->get_templateParameters().size() == 0: OK for nested classes/structs in template declarations nondefdecl = %p \n",nondefdecl);
#endif
             }
       // ROSE_ASSERT(nondefdecl->get_templateParameters().size() > 0);

       // DQ (9/12/2012): Set the template name to be the name without template specialization arguments.
          nondefdecl->set_templateName(nameWithoutTemplateArguments);

       // DQ (12/26/2011): The non defining declaration should not have a valid pointer to the class definition.
          ROSE_ASSERT(nondefdecl->get_definition() == NULL);
#if 0
       // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.
          if (nondefdecl->get_type() == NULL)
             {
            // nondefdecl->set_type(SgClassType::createType(nondefdecl));
            // nondefdecl->set_type(NULL);
            // nondefdecl->set_type(SgTemplateType::createType(nondefdecl));
            // nondefdecl->set_type(SgTemplateType::createType());
               nondefdecl->set_type(SgClassType::createType(nondefdecl));
             }
#endif
       // printf ("SageBuilder::buildClassDeclaration_nfi(): nondefdecl = %p \n",nondefdecl);

       // The nondefining declaration will not appear in the source code, but is compiler
       // generated (so we have something about the class that we can reference; e.g in
       // types).  At the moment we make it a transformation, there might be another kind 
       // of source position that would be more precise.  FIXME.
       // setOneSourcePositionNull(nondefdecl);
          setOneSourcePositionForTransformation(nondefdecl);
          ROSE_ASSERT (nondefdecl->get_startOfConstruct() != NULL);

          nondefdecl->setForward();

       // Liao, 9/2/2009. scope stack is optional, it can be empty
       // nondefdecl->set_parent(topScopeStack());
          nondefdecl->set_parent(scope);

          nondefdecl->set_scope(scope);
#if 1
       // Do this after the scope has been set!
       // DQ (12/4/2011): Now we want to enable this so that the SgClassType will be available from a SgTemplateClassDeclaration.
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("In buildTemplateClassDeclaration_nfi(): nondefdecl->get_type() = %p \n",nondefdecl->get_type());
#endif
          if (nondefdecl->get_type() == NULL)
             {
            // nondefdecl->set_type(SgClassType::createType(nondefdecl));
            // nondefdecl->set_type(NULL);
            // nondefdecl->set_type(SgTemplateType::createType(nondefdecl));
            // nondefdecl->set_type(SgTemplateType::createType());
               nondefdecl->set_type(SgClassType::createType(nondefdecl));
             }
#endif
          if (scope != NULL)
             {
#if 0
               printf ("Building a SgTemplateSymbol using name = %s and nondefdecl = %p = %s \n",name.str(),nondefdecl,nondefdecl->class_name().c_str());
#endif
            // mysymbol = new SgTemplateSymbol(nondefdecl);
            // mysymbol = new SgClassSymbol(nondefdecl);
#ifdef TEMPLATE_DECLARATIONS_DERIVED_FROM_NON_TEMPLATE_DECLARATIONS
               mysymbol = new SgTemplateClassSymbol(nondefdecl);
#else
               printf ("Error: This functionality is not yet been made backwardly compatable to EDG 3.3 template design \n");
               mysymbol = new SgClassSymbol(NULL);

               printf ("Exiting to avoid further errors \n");
               ROSE_ASSERT(false);
#endif
               ROSE_ASSERT(mysymbol != NULL);

            // DQ (9/12/2012): We want to include the template specialization into the name where it is required.
            // scope->insert_symbol(name, mysymbol);
               scope->insert_symbol(nameWithTemplateSpecializationArguments, mysymbol);

#if 0
               printf ("SageBuilder::buildTemplateClassDeclaration_nfi() (after building symbol): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif

               ROSE_ASSERT(nondefdecl->get_scope() != NULL);

               ROSE_ASSERT(nondefdecl->get_symbol_from_symbol_table() != NULL);
             }
            else
             {
            // Liao 9/2/2009: This is not an error. We support bottomup AST construction and scope can be unkown.   
             }

       // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).
          ROSE_ASSERT(nondefdecl->get_templateName().is_null() == false);
        }

#if 0
     printf ("In buildTemplateClassDeclaration_nfi(): Setting the firstNondefiningDeclaration to be nondefdecl = %p \n",nondefdecl);
#endif

     defdecl->set_firstNondefiningDeclaration(nondefdecl);

  // DQ (9/16/2012): Setup the template specialization arguments on the defining declaration (tested below at base of function).
     setTemplateSpecializationArgumentsInDeclaration(defdecl,templateSpecializationArgumentList);

#if 1
  // DQ (11/20/2011): SgTemplateClassDeclaration IR nodes don't have a SgType associated with them (template declarations don't have a type in C++, I think).

  // Liao, 10/30/2009
  // The SgClassDeclaration constructor will automatically generate a SgClassType internally if NULL is passed for SgClassType
  // This is not desired when building a defining declaration and an inefficience in the constructor
  // Ideally, only the first nondefining class declaration should have a dedicated SgClassType and 
  // the defining class declaration (and other nondefining declaration) just shared that SgClassType.
     if (defdecl->get_type() != NULL) 
        {
       // if a defining class declaration's type is associated with a defining class.
       // This is a wrong SgClassType and has to be reset
#if 0
       // if (defdecl->get_type()->get_declaration() == isSgDeclarationStatement(defdecl) )
          if (defdecl->get_type()->get_declaration() == isSgDeclarationStatement(defdecl) )
             {
               delete defdecl->get_type();
             }
#else
       // DQ (1/13/2013): I am not clear what this means... if (defdecl->get_type() != NULL) then it makes 
       // no sense to assert that (defdecl->get_type() == NULL).  This is related to the reuse of the defining 
       // declaration when it is available (instead of building a new one, which still might be required for a 
       // template specialization (or template partial specialization)).
       // ROSE_ASSERT(defdecl->get_type() == NULL);
#endif
        }

  // patch up the SgClassType for the defining class declaration
     ROSE_ASSERT (nondefdecl->get_type() != NULL);
  // ROSE_ASSERT (nondefdecl->get_type()->get_declaration() == isSgDeclarationStatement(nondefdecl));

  // DQ (1/22/2013): This assertion is a problem for boost code represented by ROSE compiling ROSE (see testRoseHeaders_01.C)
     if (isSgClassType(nondefdecl->get_type())->get_declaration() != isSgDeclarationStatement(nondefdecl))
        {
          printf ("In buildTemplateClassDeclaration_nfi(): detected isSgClassType(nondefdecl->get_type())->get_declaration() != isSgDeclarationStatement(nondefdecl) (problem with Boost code in ROSE compiling ROSE) \n");
        }
  // ROSE_ASSERT (isSgClassType(nondefdecl->get_type())->get_declaration() == isSgDeclarationStatement(nondefdecl));

     defdecl->set_type(nondefdecl->get_type());
#endif

  // I don't think this is always a forward declaration (e.g. if it is not used in a prototype).
  // Checking the olded EDG/ROSE interface it appears that it is always marked forward (unless 
  // used in a defining declaration).
     nondefdecl->setForward();

#if 0
     if (scope != NULL)  // put into fixStructDeclaration() or alike later on
        {
       // fixStructDeclaration(defdecl,scope);
       // fixStructDeclaration(nondefdecl,scope);

          printf ("***** WARNING *****: Commented out call to fixStructDeclaration() \n");
       // ROSE_ASSERT(false);
        }
#endif

     ROSE_ASSERT(defdecl->get_definingDeclaration() == defdecl);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != defdecl->get_definingDeclaration());

     ROSE_ASSERT(defdecl->get_scope() != NULL);

  // DQ (12/4/2011): We need a concept for type for SgTemplateClassDeclaration so that we can construct SgMemberFunctionType nodes for template member functions.
  // We use a SgClassType which has been fixed to permit it to hold either a SgClassDeclaration or an SgTemplateClassDeclaration.
     ROSE_ASSERT(defdecl->get_type() != NULL);

  // DQ (12/26/2011): The non defining declaration should not have a valid pointer to the class definition.
     ROSE_ASSERT(nondefdecl->get_definition() == NULL);

  // DQ (7/15/2012): We want to inforce this.
  // ROSE_ASSERT(defdecl->get_parent() == NULL);
     if (defdecl->get_parent() != NULL)
        {
          printf ("WARNING: the parent will have been set if the defining declaration was found and reused! defdecl = %p = %s \n",defdecl,defdecl->class_name().c_str());
        }

  // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).
     ROSE_ASSERT(defdecl->get_templateName().is_null() == false);

  // DQ (9/12/2012): Test that the templateName is set (name without template specialization parameters).
     ROSE_ASSERT(nondefdecl->get_templateName().is_null() == false);

     testTemplateArgumentParents(defdecl);
     testTemplateArgumentParents(nondefdecl);

     return defdecl;    
   }
#endif


SgEnumDeclaration * SageBuilder::buildEnumDeclaration(const SgName& name, SgScopeStatement* scope /*=NULL*/)
  {
 // DQ (1/11/2009): This function has semantics very different from the buildEnumDeclaration_nfi() function!

    if (scope == NULL)
         scope = SageBuilder::topScopeStack();

    SgEnumDeclaration* decl = buildEnumDeclaration_nfi(name, scope);
    setOneSourcePositionForTransformation(decl);
    setOneSourcePositionForTransformation(decl->get_firstNondefiningDeclaration());
    setOneSourcePositionForTransformation(decl->get_definingDeclaration());

  // DQ (7/15/2012): We want to inforce this.
     ROSE_ASSERT(decl->get_parent() == NULL);

    return decl;    
  } //buildEnumDeclaration()


SgEnumDeclaration*
SageBuilder::buildNondefiningEnumDeclaration_nfi(const SgName& name, SgScopeStatement* scope)
   {
  // The support for SgEnumDeclaration is identical to that for SgClassDeclaration (excpet for the type handleing, why is that?).

  // DQ (7/27/2012): Note that the input name should not have template argument syntax.
  // I think this could still fail for a function with a name such as "X<Y>"  strange converstion operators.
     ROSE_ASSERT(SageInterface::hasTemplateSyntax(name) == false);

  // DQ (4/22/2013): We need this to be provided.
     ROSE_ASSERT(scope != NULL);

#if 0
     printf ("In buildNondefiningEnumDeclaration_nfi(): name = %s scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
#endif

  // DQ (5/8/2013): For testing with test2007_140.C, make sure this is not the SgBasicBlock (should be SgClassDefinition).
  // ROSE_ASSERT(isSgBasicBlock(scope) == NULL);

  // DQ (5/8/2013): I think if we searched for the type it might exist and this would allow the types to be shared.
     SgEnumType* enumType = NULL;
  // SgEnumDeclaration* nondefdecl = NULL;
     SgEnumDeclaration* first_nondefdecl = NULL;

     if (scope != NULL)
        {
          SgEnumSymbol* existing_symbol = scope->lookup_enum_symbol(name);
          if (existing_symbol != NULL)
             {
               enumType = isSgEnumType(existing_symbol->get_type());
               first_nondefdecl = existing_symbol->get_declaration();
               ROSE_ASSERT(first_nondefdecl != NULL);
             }
        }

#if 0
     printf ("In buildNondefiningEnumDeclaration_nfi(): name = %s building using enumType = %p first_nondefdecl = %p \n",name.str(),enumType,first_nondefdecl);
#endif

  // DQ (5/8/2013): We do want to build a new SgEnumDeclaration (to avoid sharing).
  // This forces each call to buildNondefiningEnumDeclaration_nfi() to build a unique declaration
  // required to avoid sharing declaration in examples such as test2007_29.C.
  // SgEnumDeclaration* nondefdecl = new SgEnumDeclaration(name, NULL);
     SgEnumDeclaration* nondefdecl = new SgEnumDeclaration(name, enumType);

     ROSE_ASSERT(nondefdecl);
     setOneSourcePositionNull(nondefdecl);

  // DQ (5/8/2013): Set the definig and first non-defining declarations.
  // nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
  // nondefdecl->set_definingDeclaration(NULL);
     if (first_nondefdecl != NULL)
        {
          nondefdecl->set_firstNondefiningDeclaration(first_nondefdecl);
          nondefdecl->set_definingDeclaration(first_nondefdecl->get_definingDeclaration());
        }
       else
        {
          nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
          nondefdecl->set_definingDeclaration(NULL);
        }

  // Any non-defining declaration is not always a forward declaration.
     nondefdecl->setForward();

  // SgEnumDeclaration* first_nondefdecl = NULL;

  // DQ (5/8/2013): Make sure that the enum type is available.
     SgType* type = nondefdecl->get_type();
     ROSE_ASSERT(type != NULL);

     if (scope != NULL)
        {
       // DQ (4/22/2013): check for an existing symbol (reuse it if it is found).
          SgEnumSymbol* mysymbol = NULL;
          SgEnumSymbol* existing_symbol = scope->lookup_enum_symbol(name);
       // ROSE_ASSERT(existing_symbol == NULL);

          if (existing_symbol != NULL)
             {
               mysymbol = existing_symbol;
#if 0
               nondefdecl = new SgEnumDeclaration(name, NULL);
               ROSE_ASSERT(nondefdecl != NULL);
#else
               first_nondefdecl = mysymbol->get_declaration();
#endif
             }
            else
             {
#if 0
               nondefdecl = new SgEnumDeclaration(name, NULL);
               ROSE_ASSERT(nondefdecl != NULL);
               setOneSourcePositionNull(nondefdecl);
               nondefdecl->set_firstNondefiningDeclaration(nondefdecl);
               nondefdecl->set_definingDeclaration(NULL);

            // Any non-defining declaration is not always a forward declaration.
               nondefdecl->setForward();    
#endif
               first_nondefdecl = nondefdecl;

               mysymbol = new SgEnumSymbol(nondefdecl);
               ROSE_ASSERT(mysymbol != NULL);
               scope->insert_symbol(name, mysymbol);
             }

       // SgEnumSymbol* mysymbol = new SgEnumSymbol(nondefdecl);

          nondefdecl->set_scope(scope);

       // Can this be defined in C++ so that it is in a logical scope different from its structural scope?
          nondefdecl->set_parent(scope);
        }

     if (first_nondefdecl != nondefdecl)
        {
          nondefdecl->set_firstNondefiningDeclaration(first_nondefdecl);
       // nondefdecl->set_definingDeclaration(first_nondefdecl->get_definingDeclaration());

          if (first_nondefdecl->get_definingDeclaration() != NULL)
             {
               nondefdecl->set_definingDeclaration(first_nondefdecl->get_definingDeclaration());
             }
        }

  // DQ (1/25/2009): I want to check into this later, since it is not symetric with SageBuilder::buildNondefiningClassDeclaration()
#if 0
     printf ("In buildNondefiningEnumDeclaration_nfi(): Need to check if SgEnumDeclaration constructor builds the SgEnumType already nondefdecl->get_type() = %p \n",nondefdecl->get_type());
#endif
     ROSE_ASSERT(nondefdecl->get_type() != NULL);

  // DQ (4/22/2013): This type should already exist (likely built by call to get_type()).
  // SgEnumType* t = new SgEnumType(nondefdecl);
  // nondefdecl->set_type(t);

#if 0
     printf ("Leaving buildNondefiningEnumDeclaration_nfi(): name = %s nondefdecl = %p \n",name.str(),nondefdecl);
#endif

  // DQ (5/8/2013): Check that the symbol is present.
     ROSE_ASSERT(scope->lookup_enum_symbol(name) != NULL);

     return nondefdecl;
   }


SgEnumDeclaration*
SageBuilder::buildEnumDeclaration_nfi(const SgName& name, SgScopeStatement* scope)
   {
     ROSE_ASSERT(scope != NULL);

#if 0
     printf ("In buildEnumDeclaration_nfi(): name = %s scope = %p = %s \n",name.str(),scope,scope->class_name().c_str());
#endif

  // DQ (5/8/2013): I think if we searched for the type it might exist and this would allow the types to be shared.
     SgEnumType* enumType = NULL;

     if (scope != NULL)
        {
          SgEnumSymbol* existing_symbol = scope->lookup_enum_symbol(name);
          if (existing_symbol != NULL)
             {
               enumType = isSgEnumType(existing_symbol->get_type());
             }
        }

#if 0
     printf ("In buildEnumDeclaration_nfi(): name = %s building using enumType = %p \n",name.str(),enumType);
#endif

  // SgEnumDeclaration* defdecl = new SgEnumDeclaration (name,NULL);
     SgEnumDeclaration* defdecl = new SgEnumDeclaration (name,enumType);
     ROSE_ASSERT(defdecl);

#if 0
     printf ("In buildEnumDeclaration_nfi(): built defining declaration = %p name = %s scope = %p = %s \n",defdecl,name.str(),scope,scope->class_name().c_str());
#endif

  // DQ (5/8/2013): Make sure that the enum type is available.
     SgType* type = defdecl->get_type();
     ROSE_ASSERT(type != NULL);

     setOneSourcePositionNull(defdecl);
  // constructor is side-effect free
     defdecl->set_definingDeclaration(defdecl);

  // build the nondefining declaration
     SgEnumDeclaration* nondefdecl = buildNondefiningEnumDeclaration_nfi(name, scope);
     nondefdecl->set_definingDeclaration(defdecl);
  // defdecl->set_firstNondefiningDeclaration(nondefdecl);
     defdecl->set_firstNondefiningDeclaration(nondefdecl->get_firstNondefiningDeclaration());

  // DQ (4/22/2013): We need to set the defining declaration on the first non-defining declaration.
     if (nondefdecl->get_firstNondefiningDeclaration() != NULL && nondefdecl->get_firstNondefiningDeclaration() != nondefdecl)
        {
          nondefdecl->get_firstNondefiningDeclaration()->set_definingDeclaration(defdecl);
        }

  // DQ (4/22/2013): Thing that should be true at this point.
     ROSE_ASSERT(nondefdecl->get_definingDeclaration() != NULL);
     ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration()->get_definingDeclaration() != NULL);
     ROSE_ASSERT(nondefdecl->get_firstNondefiningDeclaration()->get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(defdecl->get_definingDeclaration() != NULL);
     ROSE_ASSERT(defdecl->get_firstNondefiningDeclaration() != NULL);

  // DQ (1/11/2009): The buildNondefiningEnumDeclaration function builds an entry in the symbol table, and so we don't want a second one!
#if 0
     SgEnumSymbol* mysymbol = new SgEnumSymbol(nondefdecl);
     ROSE_ASSERT(mysymbol);
  // scope->print_symboltable("buildEnumDeclaration_nfi(): before inserting new SgEnumSymbol");
     scope->insert_symbol(name, mysymbol);
#endif

     defdecl->set_scope(scope);
     nondefdecl->set_scope(scope);

#if 0
  // DQ (7/12/2012): We can't set the parent here because if this is a non-autonomous declaration then it must be set later (to the outer declaration where this declaration is nested).
     defdecl->set_parent(scope);
     nondefdecl->set_parent(scope);
#endif

  // DQ (7/12/2012): When this is an unnamed enum declaration, this it is NON-AUTONIMOUS
  // (and will have it's parent set in the associated variable or typedef declaration.
  // In the case of a class declaration this is always NULL (this should be similar).
     ROSE_ASSERT(defdecl->get_parent() == NULL);

#if 0
     printf ("In buildEnumDeclaration_nfi(): name = %s defdecl = %p \n",name.str(),defdecl);
#endif

  // DQ (5/8/2013): Check that the symbol is present.
     ROSE_ASSERT(scope->lookup_enum_symbol(name) != NULL);

     return defdecl;    
   } //buildEnumDeclaration_nfi()


SgBaseClass*
SageBuilder::buildBaseClass ( SgClassDeclaration* classDeclaration, SgClassDefinition* classDefinition, bool isVirtual, bool isDirect )
   {
  // DQ (5/6/2013): Refactored the construction of the SgBaseClass support to the builder API.

  // Note: classDeclaration should be the first non-defining class declaration, not required to be the the declaration associated with the SgClassDefinition.
     ROSE_ASSERT(classDeclaration != NULL);
     ROSE_ASSERT(classDefinition  != NULL);

  // DQ (5/6/2013): This is not always true (see test2013_63.C).
  // ROSE_ASSERT(classDeclaration == classDeclaration->get_firstNondefiningDeclaration());

     ROSE_ASSERT(classDefinition->get_declaration() != NULL);

  // DQ (5/6/2013): This is not always true (see test2004_30.C).
  // ROSE_ASSERT(classDefinition->get_declaration() == classDeclaration->get_firstNondefiningDeclaration());

     SgBaseClass* baseclass = new SgBaseClass ( classDeclaration, isDirect );
     ROSE_ASSERT(baseclass != NULL);

     if (isVirtual == true)
        {
          baseclass->get_baseClassModifier().setVirtual();
        }

  // DQ (4/29/2004): add support to set access specifier
  // baseclass->get_baseClassModifier().get_accessModifier() = set_access_modifiers(bcdp->access);
  // baseclass->get_baseClassModifier().get_accessModifier() = buildAccessModifier(accessModifiers);

  // DQ (6/21/2005): Set the parent of the base class to the class definition
  // (these are not traversed in ROSE currently, so their parents are not set).
     baseclass->set_parent(classDefinition);

  // DQ (6/21/2005): Notice that this is copied by value (the base class list should be a list of pointers to SgBaseClass (later)
     classDefinition->append_inheritance(baseclass);

     return baseclass;
   }


#if 0
// This function would be more complex that I want to support at present since the mapping of 
// edg modifier values to ROSE modifier values is offset and backwards (reversed in numerical order).
SgAccessModifier
SageBuilder::buildAccessModifier ( unsigned int access )
   {
     SgAccessModifier a;

     switch (access)
        {
          case as_public:
#if 0
               printf ("In SageBuilder::set_access_modifiers(): Mark as public \n");
#endif
               a.setPublic();
               break;

          case as_protected:
#if 0
               printf ("In SageBuilder::set_access_modifiers(): Mark as protected \n");
#endif
               a.setProtected();
               break;

          case as_private:
#if 0
               printf ("In SageBuilder::set_access_modifiers(): Mark as private \n");
#endif
               a.setPrivate();
               break;

          default:
               printf ("Error: default reached in SageBuilder::set_access_modifiers() \n");
               ROSE_ASSERT (false);
        }

     return a;
   }
#endif


  //! Build a SgFile node
SgFile*
SageBuilder::buildFile(const std::string& inputFileName, const std::string& outputFileName, SgProject* project/*=NULL*/)
   {
// Note that ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT defines a reduced set of ROSE to support front-end specific development.
// It is mostly used by quinlan to support laptop development where the smaller set of files permits one to do limited
// development work on a Mac (even with OSX's poor performance with large numbers of debug symbols).  This is an 
// infrequently used option.
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT

#if 0
     printf ("In SageBuilder::buildFile(inputFileName = %s, outputFileName = %s, project = %p \n",inputFileName.c_str(),outputFileName.c_str(),project);
#endif

     ROSE_ASSERT(inputFileName.size()!=0);// empty file name is not allowed.
     string sourceFilename = inputFileName, fullname;
     Rose_STL_Container<std::string> arglist;
     int nextErrorCode = 0;

     if (project == NULL)
      // SgProject is created on the fly
      // Make up an arglist in order to reuse the code inside SgFile::setupSourceFilename()
        {
#if 0
          printf ("In SageBuilder::buildFile(): build the SgProject \n");
#endif
          project = new SgProject();
          ROSE_ASSERT(project);
          project->get_fileList().clear();

          arglist.push_back("cc"); 
          arglist.push_back("-c"); 
          project->set_originalCommandLineArgumentList (arglist);
        }

     ifstream testfile(inputFileName.c_str());
     if (!testfile.is_open()) 
        {
       // create a temporary file if the file does not exist.
       // have to do this, otherwise StringUtility::getAbsolutePathFromRelativePath() complains
       // which is called by result->setupSourceFilename(arglist);
          testfile.close();
          ofstream outputfile(inputFileName.c_str(),ios::out); 
       // DQ (2/6/2009): I think this comment is helpful to put into the file (helps explain why the file exists).
          outputfile<<"// Output file generated so that StringUtility::getAbsolutePathFromRelativePath() will see a vaild file ... unparsed file will have rose_ prefix "<<endl;
          outputfile.close();
        }
       else // file already exists , load and parse it
        {
       // should not reparse all files in case their ASTs have unsaved changes, 
       // just parse the newly loaded file only.
       // use argv here, change non-existing input file later on
       // TODO add error code handling 

       // DQ (2/6/2009): Avoid closing this file twice (so put this here, instead of below).
          testfile.close();
          // should remove the old one here, Liao, 5/1/2009
        }

  // DQ (2/6/2009): Avoid closing this file twice (moved to false branch above).
  // testfile.close();

  // DQ (2/6/2009): Need to add the inputFileName to the source file list in the project, 
  // because this list will be used to subtract off the source files as required to build 
  // the commandline for the backend compiler.
     project->get_sourceFileNameList().push_back(inputFileName);

     Rose_STL_Container<string> sourceFilenames = project->get_sourceFileNameList();
  // printf ("In SageBuilder::buildFile(): sourceFilenames.size() = %zu sourceFilenames = %s \n",sourceFilenames.size(),StringUtility::listToString(sourceFilenames).c_str());

     arglist = project->get_originalCommandLineArgumentList();

  // DQ (2/6/2009): We will be compiling the source code generated in the 
  // "rose_<inputFileName>" file, so we don't want this on the argument stack.
     arglist.push_back(sourceFilename);

  // DQ (2/6/2009): Modified.
  // There is output file name specified for rose translators
     if (outputFileName.empty() == false)
        {
          arglist.push_back("-rose:o");
       // arglist.push_back("-o");
          arglist.push_back(outputFileName);
        }

  // DQ (4/15/2010): Turn on verbose mode
     arglist.push_back("-rose:verbose 2");

  // This handles the case where the original command line may have referenced multiple files.
     Rose_STL_Container<string> fileList = CommandlineProcessing::generateSourceFilenames(arglist,/* binaryMode = */ false);
     CommandlineProcessing::removeAllFileNamesExcept(arglist,fileList,sourceFilename);

  // DQ (9/3/2008): Added support for SgSourceFile IR node
  // SgFile* result = new SgFile (arglist, nextErrorCode, 0, project);
  // AS(10/04/08) Because of refactoring we require the determineFileType function to be called 
  // to construct the node.
  // SgSourceFile* result = new SgSourceFile (arglist, nextErrorCode, 0, project);
  // SgSourceFile* result = isSgSourceFile(determineFileType(arglist, nextErrorCode, project));
  // TH (2009-07-15): changed to more generig isSgFile, this also supports SgBinaryComposite
     SgFile* result = determineFileType(arglist, nextErrorCode, project);
     ROSE_ASSERT(result != NULL);

#if 0
     printf ("In SageBuilder::buildFile(): project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif

#if 0
  // DQ (3/4/2014): This fix is only for Java and for C will cause a second SgFile to be redundently added to the file list.
  // For now I will provide a temporary fix and check is this is for a Java project so that we can continue. But the longer
  // term fix would be to make the semantics for Java the same as that of C/C++ (or the other way around, whatever is the 
  // cleaner semantics.
  // This just adds the new file to the list of files stored internally (note: this sets the parent of the newFile).
  // TOO1 (2/28/2014): This is definitely required for Java (ECJ frontend), though C passes without it (I think only
  //                   by luck :-).
  //                   The ECJ frontend uses the SgProject internally (via a global SgProject*). Therefore, the
  //                   SgProject must contain this newly created SgFile, otherwise ECJ won't be able to find it.
  // project->set_file ( *result );
     if (project->get_Java_only() == true)
        {
       // DQ (3/4/2014): For now we want to output a message and clean this up afterward (likely in the Java language support).
          printf ("WARNING: Java specific action to add new file to SgProject (using set_file()) (more uniform language handling symantics would avoid this problem) \n");
          project->set_file ( *result );
        }
#else
  // DQ (3/6/2014): The code below adresses the specific bug faced in the use of the outliner (so we use it directly).
  // This code was moved ahead of the call to "result->runFrontend(nextErrorCode);" because in the case of Java
  // the file must be set to be a part of the SgProject before calling the runFrontend() function.
  // project->set_file ( *result );

     result->set_parent(project);

#if 0
     printf ("In SageBuilder::buildFile(): Outliner::use_dlopen = %s \n",Outliner::use_dlopen ? "true" : "false");
#endif

  // DQ (3/5/2014): I need to check with Liao to understand this part of the code better.
  // I think that the default value for Outliner::use_dlopen is false, so that when the 
  // Java support is used the true branch is taken.  However, if might be the we need
  // to support the outliner using the code below and so this would be a bug for the 
  // outliner.
     if (!Outliner::use_dlopen)
        {
#if 0
          printf ("In SageBuilder::buildFile(): (after test for (!Outliner::use_dlopen) == true: project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif
       // DQ (3/5/2014): If we added the file above, then don't add it here since it is redundant.
          project->set_file(*result);  // equal to push_back()
#if 0
          printf ("In SageBuilder::buildFile(): (after 2nd project->set_file()): project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif
        }
       else
        {
#if 0
          printf ("In SageBuilder::buildFile(): (after test for (!Outliner::use_dlopen) == false: project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif
       // Liao, 5/1/2009, 
       // if the original command line is: gcc -c -o my.o my.c and we want to  
       // add a new file(mynew.c), the command line for the new file would become "gcc -c -o my.o mynew.c "
       // which overwrites the object file my.o from my.c and causes linking error.
       // To avoid this problem, I insert the file at the beginning and let the right object file to be the last generated one
       //
       // TODO This is not an elegant fix and it causes some strange assertion failure in addAssociatedNodes(): default case node 
       // So we only turn this on if Outliner:: use_dlopen is used for now
       // The semantics of adding a new source file can cause changes to linking phase (new object files etc.)
       // But ROSE has a long-time bug in handling combined compiling and linking command like "translator -o a.out a.c b.c"
       // It will generated two command line: "translator -o a.out a.c" and "translator -o a.out b.c", which are totally wrong.
       // This problem is very relevant to the bug.
          SgFilePtrList& flist = project->get_fileList();
          flist.insert(flist.begin(),result);
#if 0
          printf ("In SageBuilder::buildFile(): (after flist.insert(flist.begin(),result)): project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif
        }
#endif

#if 0
     printf ("In SageBuilder::buildFile(): (after project->set_file()): project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif

  // DQ (3/6/2014): For Java, this function can only be called AFTER the SgFile has been added to the file list in the SgProject.
  // For C/C++ it does not appear to matter if the call is made before the SgFile has been added to the file list in the SgProject.
  // DQ (6/14/2013): Since we seperated the construction of the SgFile IR nodes from the invocation of the frontend, we have to call the frontend explicitly.
     result->runFrontend(nextErrorCode);

#if 0
     printf ("In SageBuilder::buildFile(): (after result->runFrontend()): project = %p project->get_fileList_ptr()->get_listOfFiles().size() = %zu \n",project,project->get_fileList_ptr()->get_listOfFiles().size());
#endif

#if 0
     result->display("SageBuilder::buildFile()");
#endif

     project->set_frontendErrorCode(max(project->get_frontendErrorCode(), nextErrorCode));

  // Not sure why a warning shows up from astPostProcessing.C
  // SgNode::get_globalMangledNameMap().size() != 0 size = %zu (clearing mangled name cache)
     if (result->get_globalMangledNameMap().size() != 0) 
          result->clearGlobalMangledNameMap();

     return result;
#else
     return NULL;
#endif
   }

//! Build a SgFile node
SgSourceFile*
SageBuilder::buildSourceFile(const std::string& outputFileName, SgProject* project)
   {
  // DQ (2/9/2013): Adding support to build a SgSourceFile with an empty global scope.
  // This function calls the buildFile(string,string,SgProject*) function and provides
  // a simple API where one wants to create a new SgSourceFile that will then have 
  // statements added to it and then unparsed.

  // This function needs a way to specify the associated language for the generated file.
  // Currently this is taken from the input file (generated from a prefix on the output filename.

#if 0
     printf ("In SageBuilder::buildSourceFile(outputFileName = %s, project = %p \n",outputFileName.c_str(),project);
#endif

  // Call the supporting function to build a file.
     string inputFilePrefix = "temp_dummy_file_";

     SgFile* file = buildFile(inputFilePrefix+outputFileName,outputFileName,project);
     ROSE_ASSERT(file != NULL);

     SgSourceFile* sourceFile = isSgSourceFile(file);
     ROSE_ASSERT(sourceFile != NULL);

     ROSE_ASSERT(sourceFile->get_globalScope() != NULL);

     return sourceFile;

#if 0
  // This is a more direct, alternative implementation (not sure if it is better).
     SgSourceFile* newFile = new SgSourceFile();
     ROSE_ASSERT(newFile != NULL);

  // Mark as a C file for now.
     newFile->set_C_only(true);

  // Specify the name of the file (and line and column numbers), using a Sg_File_Info object.
     Sg_File_Info* fileInfo = new Sg_File_Info(outputFileName,0,0);
     ROSE_ASSERT(fileInfo != NULL);

     newFile->set_startOfConstruct(fileInfo);
     fileInfo->set_parent(newFile);

     SgGlobal* globalScope = new SgGlobal();
     ROSE_ASSERT(globalScope != NULL);

     newFile->set_globalScope(globalScope);
     globalScope->set_parent(newFile);

     ROSE_ASSERT(newFile->get_globalScope() != NULL);

     return newFile;
#endif
   }


PreprocessingInfo* SageBuilder::buildComment(SgLocatedNode* target, const std::string & content,PreprocessingInfo::RelativePositionType position/*=PreprocessingInfo::before*/,PreprocessingInfo::DirectiveType dtype/* = PreprocessingInfo::CpreprocessorUnknownDeclaration*/)
   {
     return SageInterface::attachComment(target,content, position, dtype);  
   }

//! #define xxx yyy 
PreprocessingInfo* SageBuilder::buildCpreprocessorDefineDeclaration(SgLocatedNode* target,const std::string & content,PreprocessingInfo::RelativePositionType position /* =PreprocessingInfo::before*/)
  {
    ROSE_ASSERT(target != NULL); //dangling #define xxx is not allowed in the ROSE AST
    // simple input verification
    std::string content2 = content;  
    boost::algorithm::trim(content2);
    string prefix = "#define";
    string::size_type pos = content2.find(prefix, 0);
    ROSE_ASSERT (pos == 0);

    PreprocessingInfo* result = NULL;

    PreprocessingInfo::DirectiveType mytype = PreprocessingInfo::CpreprocessorDefineDeclaration;

 // DQ (7/19/2008): Modified interface to PreprocessingInfo
 // result = new PreprocessingInfo (mytype,content, "transformation-generated", 0, 0, 0, position, false, true);
    result = new PreprocessingInfo (mytype,content, "transformation-generated", 0, 0, 0, position);
    ROSE_ASSERT(result);
    target->addToAttachedPreprocessingInfo(result);
    return result;
  
  }


#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
//! Build an abstract handle from a SgNode
AbstractHandle::abstract_handle * SageBuilder::buildAbstractHandle(SgNode* n)
{
  // avoid duplicated creation
  static std::map<SgNode*, AbstractHandle::abstract_handle *> handleMap;

  ROSE_ASSERT(n != NULL);
  AbstractHandle::abstract_handle * ahandle =handleMap[n];
  if (ahandle==NULL)
  {
    AbstractHandle::abstract_node* anode = AbstractHandle::buildroseNode(n);
    ROSE_ASSERT(anode !=NULL );
    ahandle = new AbstractHandle::abstract_handle(anode);
    //TODO do we allow NULL handle to be returned?
    ROSE_ASSERT(ahandle != NULL);
  }
  return ahandle;
}
#endif

SgSymbol*
SageBuilder::findAssociatedSymbolInTargetAST(SgDeclarationStatement* snippet_declaration, SgScopeStatement* targetScope)
   {
  // Starting at the snippet_declaration, record the associated scope list to the global scope.
  // The do a reverse traversal on the list starting with the global scope of the target AST.
  // Lookup each declaration as we proceed deeper into the target AST to find the associated 
  // symbol in the target AST (associated with the input declaration from the snippet AST).

     SgSymbol* returnSymbol = NULL;

     typedef Rose_STL_Container<SgScopeStatement*>  SgScopeStatementPtrList;
     SgScopeStatementPtrList snippet_scope_list;
     
  // Starting at the snippet_declaration, record the associated scope list to the global scope.
     SgScopeStatement* snippet_scope = snippet_declaration->get_scope();
#if 0
     printf ("First scope = %p = %s \n",snippet_scope,snippet_scope->class_name().c_str());
#endif
     snippet_scope_list.push_back(snippet_scope);
     while (snippet_scope != NULL && isSgGlobal(snippet_scope) == NULL)
        {
       // The scopes between the snippet declaration and the global scope should be named scopes, 
       // else we will not be able to identify the associated scope in the target AST.
          ROSE_ASSERT(snippet_scope->isNamedScope() == true);

          snippet_scope = snippet_scope->get_scope();
#if 0
          printf ("snippet_scope = %p = %s \n",snippet_scope,snippet_scope->class_name().c_str());
#endif
          snippet_scope_list.push_back(snippet_scope);
        }

#if 0
     printf ("snippet_scope_list.size() = %zu \n",snippet_scope_list.size());
#endif

     SgGlobal* global_scope_in_target_ast = TransformationSupport::getGlobalScope(targetScope);
     SgScopeStatementPtrList::reverse_iterator i = snippet_scope_list.rbegin();
     
     SgScopeStatement* target_AST_scope  = global_scope_in_target_ast;
     SgScopeStatement* snippet_AST_scope = *i;

     ROSE_ASSERT(isSgGlobal(snippet_AST_scope) != NULL);
  // Iterate past the global scope
     i++;

  // Traverse the snippet scopes in the reverse order from global scope to the associated scope in the target AST.
     while (i != snippet_scope_list.rend())
        {
#if 0
          printf ("snippet_AST_scope list *i = %p = %s \n",*i,(*i)->class_name().c_str());
#endif
       // printf ("target_AST_scope = %p = %s \n",target_AST_scope,target_AST_scope ->class_name().c_str());
       // printf ("snippet_AST_scope = %p = %s \n",snippet_AST_scope,snippet_AST_scope ->class_name().c_str());

          SgClassDefinition* classDefinition = isSgClassDefinition(*i);
          if (classDefinition != NULL)
             {
               SgClassDeclaration* classDeclaration = classDefinition->get_declaration();
               SgName className = classDeclaration->get_name();
#if 0
               printf ("Found snippet class name = %s \n",className.str());
#endif
               SgClassSymbol* classSymbol = target_AST_scope->lookup_class_symbol(className);
               ROSE_ASSERT(classSymbol != NULL);
               ROSE_ASSERT(classSymbol->get_declaration() != NULL);
#if 0
               printf ("Associated symbol in taget AST: declaration = %p name = %s \n",classSymbol->get_declaration(),classSymbol->get_declaration()->get_name().str());
#endif
            // Set the return value as we go so that it will be properly set at the end of the reverse iteration over the scopes.
               returnSymbol = classSymbol;

            // Reset the target AST scope (as we traverse down the AST to the associated declaration in the target AST).
               target_AST_scope = classDefinition;
             }

       // Increment the reverse iterator.
          i++;
        }

  // return the last found symbol.
     return returnSymbol;
   }

SgType* 
SageBuilder::getTargetFileType(SgType* snippet_type, SgScopeStatement* targetScope)
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(snippet_type != NULL);
     ROSE_ASSERT(targetScope != NULL);

     SgNamedType* namedType = isSgNamedType(snippet_type);
     if (namedType != NULL)
        {
       // Find the associated declaration and it's corresponding declaration in the target AST.
          SgDeclarationStatement* snippet_declaration = namedType->get_declaration();
          ROSE_ASSERT(snippet_declaration != NULL);
#if 0
          printf ("Need to find the declaration in the target AST that is associated with the snippet_declaration in the snippet AST \n");
          printf ("   --- snippet_declaration = %p = %s = %s \n",snippet_declaration,snippet_declaration->class_name().c_str(),SageInterface::get_name(snippet_declaration).c_str());
#endif
       // There are only a few cases here!
          switch (namedType->variantT())
             {
               case V_SgClassType:
                  {
                    SgClassDeclaration* classDeclaration = isSgClassDeclaration(snippet_declaration);
                    if (classDeclaration != NULL)
                       {
                         SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(classDeclaration->get_name(),targetScope);
                         if (classSymbolInTargetAST == NULL)
                            {
                           // For Java or C++ this could be a name qualified type and so we need a better mechanism 
                           // to identify it thorugh it's parent scopes. Build a list of parent scope back to the 
                           // global scope and then traverse the list backwards to identify each scope in the target 
                           // AST's global scope until we each the associated declaration in the target AST.
#if 0
                              printf ("This is likely a name qualified scope (which can't be seen in a simple traversal of the parent scope (case of C++ or Java) \n");
#endif
                              SgSymbol* symbol = findAssociatedSymbolInTargetAST(classDeclaration,targetScope);
                              ROSE_ASSERT(symbol != NULL);

                              classSymbolInTargetAST = isSgClassSymbol(symbol);
                            }
                         ROSE_ASSERT(classSymbolInTargetAST != NULL);

                         returnType = classSymbolInTargetAST->get_type();
                       }
                    break;
                  }

               case V_SgTypedefType:
                  {
                    SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(snippet_declaration);
                    if (typedefDeclaration != NULL)
                       {
                         SgTypedefSymbol* typedefSymbolInTargetAST = lookupTypedefSymbolInParentScopes(typedefDeclaration->get_name(),targetScope);

                      // Not clear if we have to handle a more general case here.
                         ROSE_ASSERT(typedefSymbolInTargetAST != NULL);

                         returnType = typedefSymbolInTargetAST->get_type();
                       }
                    break;
                  }

               case V_SgEnumType:
                  {
                    SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(snippet_declaration);
                    if (enumDeclaration != NULL)
                       {
                         ROSE_ASSERT(enumDeclaration->get_name().is_null() == false);
                         SgEnumSymbol* enumSymbolInTargetAST = lookupEnumSymbolInParentScopes(enumDeclaration->get_name(),targetScope);

                      // Not clear if we have to handle a more general case here.
                         ROSE_ASSERT(enumSymbolInTargetAST != NULL);

                         returnType = enumSymbolInTargetAST->get_type();
                       }

                    break;
                  }

               case V_SgJavaParameterizedType:
                  {
                    printf ("In getTargetFileType(): case V_SgJavaParameterizedType: snippet_declaration = %p = %s \n",snippet_declaration,snippet_declaration->class_name().c_str());
#if 1
                    SgClassDeclaration* classDeclaration = isSgClassDeclaration(snippet_declaration);
                    if (classDeclaration != NULL)
                       {
                         SgTemplateParameterPtrList* templateParameterList              = NULL;
                         SgTemplateArgumentPtrList*  templateSpecializationArgumentList = NULL;
                         SgTemplateClassSymbol* templateClassSymbolInTargetAST = lookupTemplateClassSymbolInParentScopes(classDeclaration->get_name(),templateParameterList,templateSpecializationArgumentList,targetScope);

                      // Not clear if we have to handle a more general case here.
                         ROSE_ASSERT(templateClassSymbolInTargetAST != NULL);

                         returnType = templateClassSymbolInTargetAST->get_type();
                       }
#else
                    SgJavaParameterizedType* javaParameterizedType = isSgJavaParameterizedType(namedType);
                    if (javaParameterizedType != NULL)
                       {
                      // Not clear how to lookup this type in the target AST.
                         returnType = javaParameterizedType;

                         SgType* internal_type = javaParameterizedType->get_raw_type();
                         ROSE_ASSERT(internal_type != NULL);
                       }
#endif
                    printf ("SgJavaParameterizedType not yet tested! \n");
                    ROSE_ASSERT(false);
                    break;
                  }

               case V_SgJavaQualifiedType:
                  {
                    printf ("In getTargetFileType(): case V_SgJavaQualifiedType: snippet_declaration = %p = %s \n",snippet_declaration,snippet_declaration->class_name().c_str());

                    SgJavaQualifiedType* javaQualifiedType = isSgJavaQualifiedType(namedType);
                    if (javaQualifiedType != NULL)
                       {
                      // Not clear how to lookup this type in the target AST.
                         returnType = javaQualifiedType;

                         SgType* internal_type_1 = javaQualifiedType->get_parent_type();
                         ROSE_ASSERT(internal_type_1 != NULL);
                         SgType* internal_type_2 = javaQualifiedType->get_type();
                         ROSE_ASSERT(internal_type_2 != NULL);
                       }

                    printf ("SgJavaQualifiedType not yet tested! \n");
                    ROSE_ASSERT(false);
                    break;
                  }

               case V_SgJavaWildcardType:
                  {
                    printf ("In getTargetFileType(): case V_SgJavaWildcardType: snippet_declaration = %p = %s \n",snippet_declaration,snippet_declaration->class_name().c_str());

                    SgJavaWildcardType* javaWildcardType = isSgJavaWildcardType(namedType);
                    if (javaWildcardType != NULL)
                       {
                      // Not clear how to lookup this type in the target AST.
                         returnType = javaWildcardType;

                         SgType* internal_type_1 = javaWildcardType->get_extends_type();
                         ROSE_ASSERT(internal_type_1 != NULL);
                         SgType* internal_type_2 = javaWildcardType->get_super_type();
                         ROSE_ASSERT(internal_type_2 != NULL);
                       }

                    printf ("SgJavaWildcardType not yet tested! \n");
                    ROSE_ASSERT(false);
                    break;
                  }

               default:
                  {
                    printf ("Error: In getTargetFileType(): default reached in switch \n");
                    ROSE_ASSERT(false);
                  }
             }

          ROSE_ASSERT(returnType != NULL);
#if 0
          printf ("Exiting as a test! \n");
          ROSE_ASSERT(false);
#endif
        }

     return returnType;
   }


void 
SageBuilder::fixupCopyOfNodeFromSeperateFileInNewTargetAst(SgStatement* insertionPoint, bool insertionPointIsScope, SgNode* node_copy, SgNode* node_original, std::map<SgNode*,SgNode*> & translationMap)
   {
  // This function fixes up invidual IR nodes to be consistant in the context of the target AST 
  // where the node is inserted and at the point specified by insertionPoint.  In this function,
  // node_copy is the copy that was made of node_original by the AST copy function.  The node_original
  // is assumed to be the node that is in the AST snippet (it is still connected in the snippet's
  // AST (from compilation of the snippet file).

  // This function hides the details of handling each different type of IR node.
  // It is assume that the node_copy is from an AST sub-tree generated by the AST copy mechanism,
  // and that the insertionPoint is a location in the target AST where the snippet AST has already 
  // been inserted, this function makes each IR node internally consistant with the target AST.

  // BTW, the translationMap should only be required to support references to things that are name 
  // qualified (which are C++ specific). These are a performance option to simplify tacking back 
  // through scopes with code similarly complex as to what is supported in the name qualification 
  // support.
#if 0
     printf ("In fixupCopyOfNodeFromSeperateFileInNewTargetAst: node_copy = %p = %s \n",node_copy,node_copy->class_name().c_str());
#endif

#if 0
     printf ("Disabled fixupCopyOfNodeFromSeperateFileInNewTargetAst() \n");
     return;
#endif

  // SgFile* targetFile = TransformationSupport::getFile(insertionPoint);
     SgFile* targetFile = getEnclosingFileNode(insertionPoint);

#if 0
     printf ("   --- targetFile            = %p = %s \n",targetFile,targetFile->get_sourceFileNameWithPath().c_str());
     printf ("   --- insertionPointIsScope = %s \n",insertionPointIsScope ? "true" : "false");
#endif

#if 1
  // DQ (3/4/2014): As I recall there is a reason why we can't setup the scope here.

  // We also need to handle the symbol (move it from the body (SgBaicBlock) that was
  // a copy to the scope in the target AST where the SgInitializedName was inserted).
     SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint->get_parent();
#if 0
     printf ("insertionPointScope = %p = %s \n",insertionPointScope,insertionPointScope->class_name().c_str());
#endif
     SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);
     ROSE_ASSERT(targetScope != NULL);

  // Handle what is the same about all statements before getting to the switch.
     SgStatement* statement_copy     = isSgStatement(node_copy);
     SgStatement* statement_original = isSgStatement(node_original);
     if (statement_copy != NULL)
        {
       // Check the scope if it is stored explicitly.
          if (statement_copy->hasExplicitScope() == true)
             {
            // Handle the scope for all statements.
               SgScopeStatement* scope_copy     = statement_copy->get_scope();
               SgScopeStatement* scope_original = statement_original->get_scope();
               ROSE_ASSERT(scope_copy     != NULL);
               ROSE_ASSERT(scope_original != NULL);

            // if (TransformationSupport::getFile(scope_original) != targetFile)
               if (getEnclosingFileNode(scope_original) != targetFile)
                  {
                    printf ("Warning: SgStatement: scope = %p = %s \n",scope_original,scope_original->class_name().c_str());
                 // SgFile* snippetFile = TransformationSupport::getFile(scope_original);
                    SgFile* snippetFile = getEnclosingFileNode(scope_original);
                    ROSE_ASSERT(snippetFile != NULL);
                    ROSE_ASSERT(snippetFile->get_sourceFileNameWithPath().empty() == false);

                    printf ("Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n",snippetFile,snippetFile->get_sourceFileNameWithPath().c_str());
                 // ROSE_ASSERT(false);
                  }
#if 0
               SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint->get_parent();
               printf ("insertionPointIsScope = %s insertionPointScope = %p = %s \n",insertionPointIsScope ? "true" : "false",insertionPointScope,insertionPointScope->class_name().c_str());

            // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);
            // ROSE_ASSERT(targetScope != NULL);

            // SgSymbol* symbol = initializedName_copy->search_for_symbol_from_symbol_table();
            // SgSymbol* symbol = initializedName_copy->search_for_symbol_from_symbol_table();
            // SgVariableSymbol* variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol->get_name(),targetScope);
            // ROSE_ASSERT(variableSymbolInTargetAST != NULL);

            // Unless we know that this is a declaration we can't set the scope here using the information about this being a definng declaration.
            // If this is a defining declaration then we want to set it's scope to targetScope, else we want to lookup
            // the symbol through the parent scope and set the scope using the symbol's first non-defining declaration.
            // statement_copy->set_scope(targetScope);

            // SgSymbol* symbol = statement_copy->search_for_symbol_from_symbol_table();
            // ROSE_ASSERT(symbol != NULL);
#endif
#if 0
               printf ("SgClassDeclaration: Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
#if 0
               if (TransformationSupport::getFile(scope) != targetFile)
                  {
                    printf ("Warning: SgStatement: scope = %p = %s \n",scope,scope->class_name().c_str());
                    SgFile* snippetFile = TransformationSupport::getFile(scope);
                    ROSE_ASSERT(snippetFile != NULL);
                    ROSE_ASSERT(snippetFile->get_sourceFileNameWithPath().empty() == false);

                    printf ("Warning: SgStatement: scope not in target file (snippetFile = %p = %s) \n",snippetFile,snippetFile->get_sourceFileNameWithPath().c_str());
                 // ROSE_ASSERT(false);
                  }
#endif
             }
        }
#endif

  // Handle what is the same about all declaration before getting to the switch.
     SgDeclarationStatement* declarationStatement_copy     = isSgDeclarationStatement(node_copy);
     SgDeclarationStatement* declarationStatement_original = isSgDeclarationStatement(node_original);
     if (declarationStatement_copy != NULL)
        {
       // Check the firstnondefiningDeclaration and definingDeclaration
          SgDeclarationStatement* firstNondefiningDeclaration_original = declarationStatement_original->get_firstNondefiningDeclaration();
       // if (TransformationSupport::getFile(firstNondefiningDeclaration_original) != targetFile)
          if (getEnclosingFileNode(firstNondefiningDeclaration_original) != targetFile)
             {
               printf ("Warning: SgDeclarationStatement: firstNondefiningDeclaration_original is not in target file \n");
            // ROSE_ASSERT(false);
             }
          SgDeclarationStatement* definingDeclaration_original = declarationStatement_original->get_definingDeclaration();
          if (definingDeclaration_original != NULL)
             {
            // if (TransformationSupport::getFile(definingDeclaration_original) != targetFile)
               if (getEnclosingFileNode(definingDeclaration_original) != targetFile)
                  {
                    printf ("Warning: SgDeclarationStatement: definingDeclaration is not in target file \n");
                 // ROSE_ASSERT(false);

                    if (declarationStatement_original == definingDeclaration_original)
                       {
                      // This is a defining declaration, so we can set the scope (or can we?) 
                      // I guess we could if the translation map were complete, but it is not complete yet.
                       }
                  }
             }
        }

  // Handle what is the same about all expressions before getting to the switch.
     SgExpression* expression = isSgExpression(node_copy);
     if (expression != NULL)
        {
       // Check the scope if it is stored explicitly.

       // printf ("WARNING: Need to check if the type is explicitly stored in this expression! \n");

          if (expression->hasExplicitType() == true)
             {
            // Handle the type for all expressions.
               SgType* type = expression->get_type();
               ROSE_ASSERT(type != NULL);
#if 1
            // SgType* new_type = getTargetFileType(type);
               SgType* new_type = getTargetFileType(type->stripType(),targetScope);
               if (new_type != NULL)
                  {
                 // Reset the base type to be the one associated with the target file.
                    expression->set_explicitly_stored_type(new_type);
                  }
#else
            // I am not clear if I have to strip this type. I think so, since it it could be a pointer to a type in the snippet file.
               SgNamedType* namedType = isSgNamedType(type->stripType());
               if (namedType != NULL)
                  {
                    SgDeclarationStatement* declaration = namedType->get_declaration();
                    ROSE_ASSERT(declaration != NULL);

                 // if (TransformationSupport::getFile(declaration) != targetFile)
                    if (getEnclosingFileNode(declaration) != targetFile)
                       {
                         printf ("Warning: SgExpression: declaration = %p = %s \n",declaration,declaration->class_name().c_str());
#if 0
                         SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                         if (classDeclaration != NULL)
                            {
                           // Check the name of the class.
                              printf ("Warning: SgExpression: classDeclaration = %p = %s \n",classDeclaration,classDeclaration->get_name().str());
                            }
#endif
                      // DQ (3/7/2014): Note that the getEnclosingFileNode(declaration) can be NULL for Java if 
                      // the is a class that is not associated with a file (e.g. BigInteger which is java.lang).
                         SgFile* snippetFile = getEnclosingFileNode(declaration);
                      // ROSE_ASSERT(snippetFile != NULL);
                         if (snippetFile != NULL)
                            {
                              ROSE_ASSERT(snippetFile->get_sourceFileNameWithPath().empty() == false);

                              printf ("Warning: SgExpression: type declaration not in target file (snippetFile = %p = %s) \n",snippetFile,snippetFile->get_sourceFileNameWithPath().c_str());
                           // ROSE_ASSERT(false);
                            }
                       }
                  }
#endif
             }
        }

     switch (node_copy->variantT())
        {
          case V_SgInitializedName:
             {
               SgInitializedName* initializedName_copy     = isSgInitializedName(node_copy);
               SgInitializedName* initializedName_original = isSgInitializedName(node_original);

            // See if the scope might be associated with the snippet file.
               SgScopeStatement* scope_copy     = initializedName_copy->get_scope();
               SgScopeStatement* scope_original = initializedName_original->get_scope();

               ROSE_ASSERT(scope_copy != NULL);
               ROSE_ASSERT(scope_original != NULL);

            // if (TransformationSupport::getFile(scope_original) != targetFile)
               if (getEnclosingFileNode(scope_original) != targetFile)
                  {
#if 0
                    printf ("Warning: case V_SgInitializedName: scope_copy     = %p = %s \n",scope_copy,scope_copy->class_name().c_str());
                    printf ("Warning: case V_SgInitializedName: scope_original = %p = %s \n",scope_original,scope_original->class_name().c_str());

                    printf ("Warning: case V_SgInitializedName: initializedName_copy->get_parent()     = %p \n",initializedName_copy->get_parent());
                    printf ("Warning: case V_SgInitializedName: initializedName_original->get_parent() = %p \n",initializedName_original->get_parent());
#endif
                 // SgFile* snippetFile = TransformationSupport::getFile(scope_original);
                    SgFile* snippetFile = getEnclosingFileNode(scope_original);

                    ROSE_ASSERT(snippetFile != NULL);
                    ROSE_ASSERT(snippetFile->get_sourceFileNameWithPath().empty() == false);

                    printf ("Warning: case V_SgInitializedName: scope not in target file (snippetFile = %p = %s) \n",snippetFile,snippetFile->get_sourceFileNameWithPath().c_str());
                 // ROSE_ASSERT(false);
                  }

            // See if the type might be asociated with the snippet file.
               SgType* type_copy     = initializedName_copy->get_type();
            // SgType* type_original = initializedName_original->get_type();
#if 1
               SgType* new_type = getTargetFileType(type_copy->stripType(),targetScope);
               if (new_type != NULL)
                  {
                 // Reset the base type to be the one associated with the target file.
                    initializedName_copy->set_type(new_type);
                  }
#else
               SgNamedType* namedType_copy     = isSgNamedType(type_copy);
               SgNamedType* namedType_original = isSgNamedType(type_original);
               if (namedType_copy != NULL)
                  {
                    if (namedType_copy != namedType_original)
                       {
                         printf ("Found case of named type which might refer to a type from a declaration in another file \n");
                         SgDeclarationStatement* decl = namedType_copy->get_declaration();
                         ROSE_ASSERT(decl != NULL);
                      // if (TransformationSupport::getFile(decl) != targetFile)
                         if (getEnclosingFileNode(decl) != targetFile)
                            {
                              printf ("Warning: case V_SgInitializedName: named type's associated declaration is not in target file \n");
                           // ROSE_ASSERT(false);
                            }
                       }
                  }
#endif
               SgSymbol* symbol = initializedName_copy->search_for_symbol_from_symbol_table();

            // DQ (3/2/2014): If this is a function parameter then there will be no associated symbol.
               if (symbol == NULL)
                  {
#if 0
                    printf ("initializedName_copy->class_name()     = %s \n",initializedName_copy->class_name().c_str());
                    printf ("initializedName_original->class_name() = %s \n",initializedName_original->class_name().c_str());
                    printf ("initializedName_copy->class_name()     = %s \n",initializedName_copy->class_name().c_str());
                    printf ("initializedName_original->class_name() = %s \n",initializedName_original->class_name().c_str());
                    printf ("initializedName_copy->get_scope()->get_name()     = %p = %s \n",initializedName_copy->get_scope(),initializedName_copy->get_scope()->class_name().c_str());
                    printf ("initializedName_original->get_scope()->get_name() = %p = %s \n",initializedName_original->get_scope(),initializedName_original->get_scope()->class_name().c_str());
                    initializedName_copy->get_file_info()->display("initializedName_copy: debug");
                    initializedName_original->get_file_info()->display("initializedName_original: debug");
#endif
#if 0
                 // Alternative way to get the symbol when it was associated with renamed symbol.
                    SgSymbol* initializedName_symbol = initializedName_copy->get_scope()->lookup_variable_symbol(initializedName_copy->get_name());
                    printf ("initializedName_symbol = %p \n",initializedName_symbol);
                    initializedName_symbol = initializedName_copy->get_scope()->lookup_variable_symbol(initializedName_original->get_name());
                    printf ("2nd try using other name: initializedName_symbol = %p \n",initializedName_symbol);

                 // return as a test so that we can graph the problem.
                    printf ("ERROR: (symbol == NULL): returning from fixupCopyOfNodeFromSeperateFileInNewTargetAst() \n");
                    return;
#endif
                  }
               ROSE_ASSERT(symbol != NULL);

               SgVariableSymbol* variableSymbol = isSgVariableSymbol(symbol);
               ROSE_ASSERT(variableSymbol != NULL);
#if 0
               printf ("Insert symbol = %p for initializedName_copy = %p = %s into targetScope = %p = %s \n",variableSymbol,initializedName_copy,initializedName_copy->get_name().str(),targetScope,targetScope->class_name().c_str());
#endif
               targetScope->insert_symbol(initializedName_copy->get_name(),variableSymbol);

            // DQ (3/6/2014): Set the scope of the SgInitializedName IR node.
               initializedName_copy->set_scope(targetScope);

               SgName mangledName = variableSymbol->get_mangled_name();
#if 0
               printf ("initializedName_copy: mangledName = %s \n",mangledName.str());
#endif
            // DQ (3/2/2014): Make sure this is true (I think it should be, but I don't see that it was explicitly set).
            // ROSE_ASSERT(initializedName_copy->get_scope() == targetScope);
               if (initializedName_copy->get_scope() != targetScope)
                  {
                    printf ("WARNING: initializedName_copy->get_scope() != targetScope: initializedName_copy->get_scope() = %p = %s \n",initializedName_copy->get_scope(),initializedName_copy->get_scope()->class_name().c_str());

                    printf ("I think this should be an error! \n");
                    ROSE_ASSERT(false);
                  }

               break;
             }

          case V_SgVariableDeclaration:
             {
            // I think there is nothing to handle for this case (there is not type accessbile here 
            // since they are in the SgInitializedName IR nodes).
               SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(node_copy);
               ROSE_ASSERT(variableDeclaration != NULL);

               break;
             }

          case V_SgFunctionDeclaration:
             {
            // Need to handle the referenced types
               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node_copy);
               SgFunctionType* functionType = functionDeclaration->get_type();
               ROSE_ASSERT(functionType != NULL);

               break;
             }

          case V_SgClassDeclaration:
             {
            // Need to handle the referenced types
               SgClassDeclaration* classDeclaration_copy     = isSgClassDeclaration(node_copy);
               SgClassDeclaration* classDeclaration_original = isSgClassDeclaration(node_original);
               SgClassType* classType = classDeclaration_copy->get_type();
               ROSE_ASSERT(classType != NULL);
#if 0
               printf ("Need to handle named types from class declarations \n");
#endif
               SgClassSymbol* classSymbol_copy = isSgClassSymbol(classDeclaration_copy->search_for_symbol_from_symbol_table());
               ROSE_ASSERT(classSymbol_copy != NULL);
            // if (TransformationSupport::getFile(classSymbol_copy) != targetFile)
               if (getEnclosingFileNode(classSymbol_copy) != targetFile)
                  {
                    printf ("Warning: case V_SgClassDeclaration: classSymbol_copy not in target file \n");

                 // Find the symbol in the target scope.
                 // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint->get_parent();
#if 0
                 // printf ("insertionPointIsScope = %s insertionPointScope = %p = %s \n",insertionPointIsScope ? "true" : "false",insertionPointScope,insertionPointScope->class_name().c_str());
#endif
                 // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).

                 // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);
                 // ROSE_ASSERT(targetScope != NULL);
#if 0
                 // If we randomize the names then we need to handle this case...
                    printf ("case V_SgClassDeclaration: targetScope = %p classSymbol_copy->get_name() = %s \n",targetScope,classSymbol_copy->get_name().str());
#endif
                    SgClassSymbol* classSymbolInTargetAST = lookupClassSymbolInParentScopes(classSymbol_copy->get_name(),targetScope);

                    if (classSymbolInTargetAST == NULL)
                       {
                      // If could be that the symbo is in the local scope of the snippet AST.
                         SgScopeStatement* otherPossibleScope = isSgScopeStatement(classDeclaration_original->get_parent());
                         ROSE_ASSERT(otherPossibleScope != NULL);
#if 0
                         printf ("case V_SgClassDeclaration: otherPossibleScope = %p \n",otherPossibleScope);
#endif
                         classSymbolInTargetAST = lookupClassSymbolInParentScopes(classSymbol_copy->get_name(),otherPossibleScope);

                         ROSE_ASSERT(classSymbolInTargetAST != NULL);
                         SgClassDeclaration* classDeclaration = classSymbolInTargetAST->get_declaration();
                         ROSE_ASSERT(classDeclaration != NULL);
                         SgScopeStatement* scope = classDeclaration->get_scope();
                         ROSE_ASSERT(scope != NULL);
                         classDeclaration_copy->set_scope(scope);

                      // Insert the symbol into the targetScope.
                         targetScope->insert_symbol(classSymbol_copy->get_name(),classSymbolInTargetAST);
                       }
                      else
                       {
                      // In this case the symbol is in a parent scope already (find the scope and set the scope of the classDeclaration_copy.
                         SgClassDeclaration* classDeclaration = classSymbolInTargetAST->get_declaration();
                         ROSE_ASSERT(classDeclaration != NULL);
                         SgScopeStatement* scope = classDeclaration->get_scope();
                         ROSE_ASSERT(scope != NULL);
                         classDeclaration_copy->set_scope(scope);
                       }

                    ROSE_ASSERT(classSymbolInTargetAST != NULL);
                  }
#if 0
               printf ("SgClassDeclaration: Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
               break;
             }

          case V_SgEnumDeclaration:
             {
            // Need to handle the referenced types
               SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(node_copy);
               SgEnumType* enumType = enumDeclaration->get_type();
               ROSE_ASSERT(enumType != NULL);

               printf ("Need to handled named types from enum declarations \n");

               break;
             }

          case V_SgTypedefDeclaration:
             {
            // Need to handle the referenced types
               SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node_copy);
               SgTypedefType* typedefType = typedefDeclaration->get_type();
               ROSE_ASSERT(typedefType != NULL);

               printf ("Need to handled named types from typedef declarations \n");

               SgType* base_type = typedefDeclaration->get_base_type();
               ROSE_ASSERT(base_type != NULL);
               SgType* new_base_type = getTargetFileType(base_type,targetScope);
               if (new_base_type != NULL)
                  {
                 // Reset the base type to be the one associated with the target file.
                    typedefDeclaration->set_base_type(new_base_type);
                  }
               break;
             }

          case V_SgVarRefExp:
             {
            // Need to handle the referenced symbol. 
            // but if we have handle this in the declaration for the variable (case V_SgInitializedName) 
            // then we don't have to do anything here.  However, we have only handled this variable
            // declaration if the variable declaration was a part of the snippet.  If the variable 
            // declaration is not a part of the original snippet (the copy of the snippet's AST that 
            // we are inserting (not the snippet program where it would have to be defined for the 
            // snippet to compile) then we have to find the associated variable sysmbol in the target 
            // AST and reset the SgVarRefExp to use that symbol.

               SgVarRefExp* varRefExp_copy     = isSgVarRefExp(node_copy);
               SgVarRefExp* varRefExp_original = isSgVarRefExp(node_original);
               SgVariableSymbol* variableSymbol_copy = isSgVariableSymbol(varRefExp_copy->get_symbol());
               ROSE_ASSERT(variableSymbol_copy != NULL);
            // if (TransformationSupport::getFile(variableSymbol_copy) != targetFile)
               if (getEnclosingFileNode(variableSymbol_copy) != targetFile)
                  {
#if 0
                    printf ("Warning: case V_SgVarRefExp: variableSymbol not in target file: name = %s \n",variableSymbol_copy->get_name().str());
#endif
#if 0
                    printf ("insertionPoint = %p = %s \n",insertionPoint,insertionPoint->class_name().c_str());
#endif
                 // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint->get_parent();
#if 0
                 // printf ("insertionPointIsScope = %s insertionPointScope = %p = %s \n",insertionPointIsScope ? "true" : "false",insertionPointScope,insertionPointScope->class_name().c_str());
#endif
                 // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).

                 // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);
                 // ROSE_ASSERT(targetScope != NULL);

                    SgVariableSymbol* variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy->get_name(),targetScope);

                    if (variableSymbolInTargetAST == NULL)
                       {
                      // This is a violation of the policy that the a variable with the same name will be found in the target AST.
                      // Note that if the variable could not be found then it should have been added as part of the snippet, or a 
                      // previously added snippet.
#if 0
                         printf ("Error: The associated variable = %s should have been found in a parent scope of the target AST \n",variableSymbol_copy->get_name().str());
#endif
                      // We need to look into the scope of the block used to define the statments as seperate snippets (same issue as for functions).

                      // If could be that the symbol is in the local scope of the snippet AST.
                         SgStatement* enclosingStatement_original = TransformationSupport::getStatement(varRefExp_original);
                         ROSE_ASSERT(enclosingStatement_original != NULL);
#if 0
                         printf ("case V_SgVarRefExp: enclosingStatement_original = %p = %s \n",enclosingStatement_original,enclosingStatement_original->class_name().c_str());
#endif
                         SgScopeStatement* otherPossibleScope_original = isSgScopeStatement(enclosingStatement_original->get_parent());
                         ROSE_ASSERT(otherPossibleScope_original != NULL);
                      // SgFile* file = TransformationSupport::getFile(enclosingStatement_original);
                         SgFile* file = getEnclosingFileNode(enclosingStatement_original);
                         ROSE_ASSERT(file != NULL);
#if 0
                         printf ("enclosingStatement_original: associated file name = %s \n",file->get_sourceFileNameWithPath().c_str());
                      // printf ("   --- targetFile            = %p = %s \n",targetFile,targetFile->get_sourceFileNameWithPath().c_str());

                         printf ("case V_SgClassDeclaration: otherPossibleScope = %p = %s \n",otherPossibleScope_original,otherPossibleScope_original->class_name().c_str());
                         printf ("case V_SgClassDeclaration: variableSymbol_copy->get_name() = %s \n",variableSymbol_copy->get_name().str());
#endif
                         variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy->get_name(),otherPossibleScope_original);
                         if (variableSymbolInTargetAST == NULL)
                            {
#if 0
                              targetScope->get_symbol_table()->print("targetScope: symbol table");
                              otherPossibleScope_original->get_symbol_table()->print("otherPossibleScope_original: symbol table");
#endif

                           // Check for the case of a record reference (member of data structure).
                              SgExpression* parentExpression = isSgExpression(varRefExp_copy->get_parent());
                              SgBinaryOp*   parentBinaryOp   = isSgBinaryOp(parentExpression);
                              SgDotExp*     parentDotExp     = isSgDotExp(parentExpression);
                              SgArrowExp*   parentArrowExp   = isSgArrowExp(parentExpression);
                              if (parentDotExp != NULL || parentArrowExp != NULL)
                                 {
                                // This is a data member reference, so it's scope is the associated data structure.
                                   SgExpression* lhs = parentBinaryOp->get_lhs_operand();
                                   ROSE_ASSERT(lhs != NULL);
                                   ROSE_ASSERT(parentBinaryOp->get_rhs_operand() == varRefExp_copy);

                                   SgType* type = lhs->get_type();
                                   ROSE_ASSERT(type != NULL);
#if 0
                                   printf ("type = %p = %s \n",type,type->class_name().c_str());
#endif
                                   SgNamedType* namedType = isSgNamedType(type);
                                   ROSE_ASSERT(namedType != NULL);
                                   SgDeclarationStatement* declaration = namedType->get_declaration();
                                   ROSE_ASSERT(declaration != NULL);
                                   SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                                   ROSE_ASSERT(classDeclaration != NULL);
                                   SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(declaration->get_definingDeclaration());
                                   ROSE_ASSERT(definingClassDeclaration != NULL);
                                   SgClassDefinition* classDefinition = definingClassDeclaration->get_definition();
                                   ROSE_ASSERT(classDefinition != NULL);
#if 0
                                   printf ("case V_SgClassDeclaration: classDefinition = %p = %s \n",classDefinition,classDefinition->class_name().c_str());
#endif
                                // I think we want the copy.
                                   otherPossibleScope_original = classDefinition;

                                   variableSymbolInTargetAST = lookupVariableSymbolInParentScopes(variableSymbol_copy->get_name(),otherPossibleScope_original);
                                 }
                              
                            }
                         ROSE_ASSERT(variableSymbolInTargetAST != NULL);
                         SgInitializedName* initializedName = variableSymbolInTargetAST->get_declaration();
                         ROSE_ASSERT(initializedName != NULL);
                         SgScopeStatement* scope = initializedName->get_scope();
                         ROSE_ASSERT(scope != NULL);
                         initializedName->set_scope(scope);

                      // Insert the symbol into the targetScope.
                         targetScope->insert_symbol(variableSymbol_copy->get_name(),variableSymbolInTargetAST);
                       }
                    ROSE_ASSERT(variableSymbolInTargetAST != NULL);

                 // Reset the symbol associated with this variable reference.
                    varRefExp_copy->set_symbol(variableSymbolInTargetAST);

                 // printf ("Exiting as a test! \n");
                 // ROSE_ASSERT(false);
                  }
                         
               break;
             }

          case V_SgFunctionRefExp:
             {
            // Need to handle the referenced symbol
               SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(node_copy);
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(functionRefExp->get_symbol());
               ROSE_ASSERT(functionSymbol != NULL);
            // if (TransformationSupport::getFile(functionSymbol) != targetFile)
               if (getEnclosingFileNode(functionSymbol) != targetFile)
                  {
#if 0
                    printf ("Warning: case V_SgFunctionRefExp: functionSymbol not in target file (find function = %s) \n",functionSymbol->get_name().str());
#endif
                 // SgNode* insertionPointScope = (insertionPointIsScope == true) ? insertionPoint : insertionPoint->get_parent();
#if 0
                 // printf ("insertionPointIsScope = %s insertionPointScope = %p = %s \n",insertionPointIsScope ? "true" : "false",insertionPointScope,insertionPointScope->class_name().c_str());
#endif
                 // Find the nearest variable with the same name in an outer scope (starting at insertionPointScope).

                 // SgScopeStatement* targetScope = isSgScopeStatement(insertionPointScope);
                 // ROSE_ASSERT(targetScope != NULL);

                 // I think we need the function's mangled name to support this lookup.
                    SgFunctionSymbol* functionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(functionSymbol->get_name(),targetScope);

                    if (functionSymbolInTargetAST == NULL)
                       {
                      // This is a violation of the policy that the a variable with the same name will be found in the target AST.
                      // Note that if the variable could not be found then it should have been added as part of the snippet, or a 
                      // previously added snippet.
                         printf ("Error: The associated function = %s should have been found in a parent scope of the target AST \n",functionSymbol->get_name().str());
                       }
                    ROSE_ASSERT(functionSymbolInTargetAST != NULL);

                 // Reset the symbol associated with this function reference.
                    functionRefExp->set_symbol(functionSymbolInTargetAST);
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }

               break;
             }

          case V_SgMemberFunctionRefExp:
             {
            // Need to handle the referenced symbol
               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(node_copy);
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(memberFunctionRefExp->get_symbol());
               ROSE_ASSERT(memberFunctionSymbol != NULL);
            // if (TransformationSupport::getFile(memberFunctionSymbol) != targetFile)
               if (getEnclosingFileNode(memberFunctionSymbol) != targetFile)
                  {
                 // Not implemented (initial work is focused on C, then Java, then C++.
                    printf ("Warning: case V_SgMemberFunctionRefExp: memberFunctionSymbol not in target file (find member function = %s) \n",memberFunctionSymbol->get_name().str());
#if 0
                    SgMemberFunctionSymbol* memberFunctionSymbolInTargetAST = lookupFunctionSymbolInParentScopes(memberFunctionSymbol->get_name(),targetScope);

                    if (memberFunctionSymbolInTargetAST == NULL)
                       {
                      // This is a violation of the policy that the a variable with the same name will be found in the target AST.
                      // Note that if the variable could not be found then it should have been added as part of the snippet, or a 
                      // previously added snippet.
                         printf ("Error: The associated function = %s should have been found in a parent scope of the target AST \n",functionSymbol->get_name().str());
                       }
                    ROSE_ASSERT(memberFunctionSymbolInTargetAST != NULL);

                 // Reset the symbol associated with this function reference.
                    memberFunctionRefExp->set_symbol(memberFunctionSymbolInTargetAST);
#endif
                  }

               break;
             }
                     
          default:
             {
            // Most IR nodes do not require specialized fixup (are not processed).
             }
        }
   }


void 
SageBuilder::fixupCopyOfAstFromSeperateFileInNewTargetAst(SgStatement *insertionPoint, bool insertionPointIsScope, SgStatement *toInsert, SgStatement* original_before_copy, std::map<SgNode*,SgNode*> & translationMap)
   {
  // The semantics of the copy is that it will have been disconnected from the snippet AST in a few ways,
  // Namely the root of the copy of the snippet's AST will have been set with a NULL parent, and then
  // the parent would have been reset when the copy of the snippet was inserted into the target AST.
  // So a simple traversal of parents back to the SgFile will return the target AST's SgFile (confirmed below).

     ROSE_ASSERT(insertionPoint != NULL);
     ROSE_ASSERT(toInsert != NULL);
     ROSE_ASSERT(original_before_copy != NULL);

#if 0
     printf ("Inside of fixupCopyOfAstFromSeperateFileInNewTargetAst(): insertionPoint = %p = %s toInsert = %p = %s \n",insertionPoint,insertionPoint->class_name().c_str(),toInsert,toInsert->class_name().c_str());
     printf ("   --- original_before_copy = %p = %s \n",original_before_copy,original_before_copy->class_name().c_str());
#endif

  // DQ (3/4/2014): Switch to using the SageInterface function.
  // SgFile* targetFile = TransformationSupport::getFile(insertionPoint);
     SgFile* targetFile = getEnclosingFileNode(insertionPoint);

  // For Java support this might be NULL, if the insertion point was in global scope.
     ROSE_ASSERT(targetFile != NULL);

  // SgFile* snippetFile_of_copy = TransformationSupport::getFile(toInsert);
     SgFile* snippetFile_of_copy = getEnclosingFileNode(toInsert);

  // At this point the parent pointers are set so that the same SgFile is found via a traversal back to the SgProject.
  // Confirm that the SgFile found by a traversal of parents in the copy of rthe snippet's AST will return that of the 
  // SgFile for the target AST.  This also confirms that the copy of the snippet has already been inserted into the 
  // target AST.
     ROSE_ASSERT(snippetFile_of_copy == targetFile);

  // SgFile* snippetFile_of_original = TransformationSupport::getFile(original_before_copy);
     SgFile* snippetFile_of_original = getEnclosingFileNode(original_before_copy);

     ROSE_ASSERT(snippetFile_of_original != targetFile);

#if 0
     printf ("targetFile              = %p = %s \n",targetFile,targetFile->get_sourceFileNameWithPath().c_str());
     printf ("snippetFile_of_copy     = %p = %s \n",snippetFile_of_copy,snippetFile_of_copy->get_sourceFileNameWithPath().c_str());
     printf ("snippetFile_of_original = %p = %s \n",snippetFile_of_original,snippetFile_of_original->get_sourceFileNameWithPath().c_str());
#endif

  // Any node that has entries not referenced in the target file needs to be fixed up.
  // We can assume that any referenced variable or function that is referenced in the 
  // snippet will exist in either the snippet or the target file.

  // DQ (3/4/2014): This is a test of the structural equality of the original snippet and it's copy.
  // If they are different then we can't support fixing up the AST.  Transformations on the snippet 
  // should have been made after insertion into the AST.  The complexity of this test is a traversal 
  // of the copy of the snippet to be inserted (typically very small compared to the target application).
     bool isStructurallyEquivalent = isStructurallyEquivalentAST(toInsert,original_before_copy);
     if (isStructurallyEquivalent == false)
        {
          printf ("WARNING: The copy of the snippet is a different size than the original snippet (don't do transformations on the copy before inserting into the target AST). \n");
          return;
        }
     ROSE_ASSERT(isStructurallyEquivalent == true);

#ifndef USE_CMAKE
  // DQ (3/8/2014): Make this conditionally compiled based on when CMake is not used because the libraries are not configured yet.

  // This is AST container for the ROSE AST that will provide an iterator.
  // We want two iterators (one for the copy of the snippet and one for the 
  // original snippet so that we can query the original snippet's AST 
  // as we process each IR node of the AST for the copy of the snippet.
  // Only the copy of the snippet is inserted into the target AST.
     RoseAst ast_of_copy(toInsert);
     RoseAst ast_of_original(original_before_copy);

  // printf ("ast_of_copy.size() = %zu \n",ast_of_copy.size());

  // Build the iterators so that we can increment thorugh both ASTs one IR node at a time.
     RoseAst::iterator i_copy     = ast_of_copy.begin();
     RoseAst::iterator i_original = ast_of_original.begin();

  // Iterate of the copy of the snippet's AST.
     while (i_copy != ast_of_copy.end())
        {
#if 0
          printf ("*i_copy = %p = %s \n",*i_copy,(*i_copy)->class_name().c_str());
          printf ("*i_original = %p = %s \n",*i_original,(*i_original)->class_name().c_str());
#endif
       // DQ (2/28/2014): This is a problem for some of the test codes (TEST   store/load heap string [test7a] and [test7a])
       // ROSE_ASSERT((*i_copy)->variantT() == (*i_original)->variantT());
          if ((*i_copy)->variantT() != (*i_original)->variantT())
             {
               printf ("ERROR: return from fixupCopyOfAstFromSeperateFileInNewTargetAst(): (*i_copy)->variantT() != (*i_original)->variantT() \n");
#if 1
               printf ("Making this an error! \n");
               ROSE_ASSERT(false);
#endif
               return;
             }

       // Operate on individual IR nodes.
          fixupCopyOfNodeFromSeperateFileInNewTargetAst(insertionPoint,insertionPointIsScope,*i_copy,*i_original,translationMap);

          i_copy++;

       // Verify that we have not reached the end of the ast for the original (both the 
       // copy and the original are the same structurally, and thus the same size).
          ROSE_ASSERT(i_original != ast_of_original.end());
          i_original++;
        }

  // We have reached the end of both ASTs.
     ROSE_ASSERT(i_copy == ast_of_copy.end() && i_original == ast_of_original.end());
#endif
   }

/**
 * The import_info represents the qualified name of a package, type or static field.
 */
SgJavaPackageStatement *SageBuilder::buildJavaPackageStatement(string package_name) {
    SgJavaPackageStatement *package_statement = new SgJavaPackageStatement(package_name);
    package_statement -> set_firstNondefiningDeclaration(package_statement);
    package_statement -> set_definingDeclaration(package_statement);
    SageInterface::setSourcePosition(package_statement);
    return package_statement;
}

/**
 * The import_info represents the qualified name of a package, type or static field.
 */
SgJavaImportStatement *SageBuilder::buildJavaImportStatement(string import_info, bool contains_wildcard) {
    SgJavaImportStatement *import_statement = new SgJavaImportStatement(import_info, contains_wildcard);
    import_statement -> set_firstNondefiningDeclaration(import_statement);
    import_statement -> set_definingDeclaration(import_statement);
    SageInterface::setSourcePosition(import_statement);
    return import_statement;
}

/**
 *  Build a class with the given name in the given scope and return its SgClassDefinition.
 */
SgClassDeclaration *SageBuilder::buildJavaDefiningClassDeclaration(SgScopeStatement *scope, string name) {
    ROSE_ASSERT(scope);
    SgName class_name = name;
    ROSE_ASSERT(scope -> lookup_class_symbol(class_name) == NULL);

    SgClassDeclaration* nonDefiningDecl              = NULL;
    bool buildTemplateInstantiation                  = false;
    SgTemplateArgumentPtrList* templateArgumentsList = NULL;
    SgClassDeclaration *class_declaration = SageBuilder::buildClassDeclaration_nfi(class_name, SgClassDeclaration::e_java_parameter, scope, nonDefiningDecl, buildTemplateInstantiation, templateArgumentsList);
    ROSE_ASSERT(class_declaration);
    class_declaration -> set_parent(scope);
    class_declaration -> set_scope(scope);
    SageInterface::setSourcePosition(class_declaration);
    SgClassDefinition *class_definition = class_declaration -> get_definition();
    ROSE_ASSERT(class_definition);
    SageInterface::setSourcePosition(class_definition);

    class_definition -> setAttribute("extensions", new AstSgNodeListAttribute());
    class_definition -> setAttribute("extension_type_names", new AstRegExAttribute());

    SgScopeStatement *type_space = new SgScopeStatement();
    type_space -> set_parent(class_definition);
    SageInterface::setSourcePosition(type_space);
    class_declaration -> setAttribute("type_space", new AstSgNodeAttribute(type_space));

    return class_declaration;
}


/**
 * Create a source file in the directory_name for the given type_name and add it to the given project.
 * This function is useful in order to create a new type to be added to a pre-existing Rose AST.
 */
SgSourceFile *SageBuilder::buildJavaSourceFile(SgProject *project, string directory_name, SgClassDefinition *package_definition, string type_name) {
    string filename = directory_name + "/" + type_name + ".java";
    ROSE_ASSERT((*project)[filename] == NULL); // does not already exist!

    string command = string("touch ") + filename; // create the file
    int status = system(command.c_str());
    ROSE_ASSERT(status == 0);
    project -> get_sourceFileNameList().push_back(filename);
    Rose_STL_Container<std::string> arg_list = project -> get_originalCommandLineArgumentList();
    arg_list.push_back(filename);
    Rose_STL_Container<string> fileList = CommandlineProcessing::generateSourceFilenames(arg_list, // binaryMode
                                                                                         false);
    CommandlineProcessing::removeAllFileNamesExcept(arg_list, fileList, filename);
    int error_code = 0;
    SgFile *file = determineFileType(arg_list, error_code, project);
    SgSourceFile *sourcefile = isSgSourceFile(file);
    ROSE_ASSERT(sourcefile);
    sourcefile -> set_parent(project);
    project -> get_fileList_ptr() -> get_listOfFiles().push_back(sourcefile);
    ROSE_ASSERT(sourcefile == isSgSourceFile((*project)[filename]));

    //
    // Create a package statement and add it to the source file
    //
    SgJavaPackageStatement *package_statement = SageBuilder::buildJavaPackageStatement(package_definition -> get_declaration() -> get_qualified_name().getString());
    package_statement -> set_parent(package_definition);
    sourcefile -> set_package(package_statement);

    //
    // Initialize an import-list for the sourcefile
    //
    SgJavaImportStatementList *import_statement_list = new SgJavaImportStatementList();
    import_statement_list -> set_parent(sourcefile);
    sourcefile -> set_import_list(import_statement_list);

    //
    // Initialize a class-declaration-list for the sourcefile
    //
    SgJavaClassDeclarationList *class_declaration_list = new SgJavaClassDeclarationList();
    class_declaration_list -> set_parent(package_definition);
    sourcefile -> set_class_list(class_declaration_list);

    return sourcefile;
}
