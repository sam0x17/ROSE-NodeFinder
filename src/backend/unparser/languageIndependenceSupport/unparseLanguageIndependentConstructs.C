// tps (01/14/2010) : Switching from rose.h to sage3.
#include "sage3basic.h"
#include "unparser.h"
#include <limits>

#include "OmpAttribute.h" // to support unparsing OpenMP constructs

// DQ (10/29/2013): Adding support for unparsing from the token stream.
#include "tokenStreamMapping.h"

// DQ (11/30/2013): Added more support for token handling.
#include "previousAndNextNode.h"


// DQ (12/31/2005): This is OK if not declared in a header file
using namespace std;

#define OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES 0
#define OUTPUT_HIDDEN_LIST_DATA 0
#define OUTPUT_DEBUGGING_INFORMATION 0

// DQ (8/13/2007): This function was implemented by Thomas
std::string
UnparseLanguageIndependentConstructs::resBool(bool val) const
   {
     return val ? "True" : "False" ;
   }

#if 0
// DQ (7/1/2013): This needs to be defined in the header file, else the GNU 4.5 and 4.6 compilers will have undefined references at link time.
// DQ (8/13/2007): This function was implemented by Thomas
template<typename T>
std::string
UnparseLanguageIndependentConstructs::tostring(T t) const
   {
     std::ostringstream myStream; //creates an ostringstream object
     myStream << std::showpoint << t << std::flush; // Distinguish integer and floating-point numbers
     return myStream.str(); //returns the string form of the stringstream object
   }
#endif

// TODO: This code is identical to 'FortranCodeGeneration_locatedNode::curprint'. Factor this!
void
UnparseLanguageIndependentConstructs::curprint (const std::string & str) const
{
#if USE_RICE_FORTRAN_WRAPPING

    if( unp->currentFile != NULL && unp->currentFile->get_Fortran_only() )
    {
        // determine line wrapping parameters -- 'pos' variables are one-based
        bool is_fixed_format = unp->currentFile->get_outputFormat() == SgFile::e_fixed_form_output_format;
        bool is_free_format  = unp->currentFile->get_outputFormat() == SgFile::e_free_form_output_format;
        int usable_cols = ( is_fixed_format ? MAX_F90_LINE_LEN_FIXED
                          : is_free_format  ? MAX_F90_LINE_LEN_FREE - 1 // reserve a column in free-format for possible trailing '&'
                          : unp->cur.get_linewrap() );

        // check whether line wrapping is needed
        int used_cols = unp->cur.current_col();     // 'current_col' is zero-based
        int free_cols = usable_cols - used_cols;
        if( str.size() > free_cols )
        {
            if( is_fixed_format )
            {
                // only noncomment lines need wrapping
                if( ! (used_cols == 0 && str[0] != ' ' ) )
                {
                    // warn if successful wrapping is impossible
                    if( 6 + str.size() > usable_cols )
                        printf("Warning: can't wrap long line in Fortran fixed format (continuation + text is longer than a line)\n");

                    // emit fixed-format line continuation
                    unp->cur.insert_newline(1);
                    unp->u_sage->curprint("     &");
                }
            }
            else if( is_free_format )
            {
                // warn if successful wrapping is impossible
                if( str.size() > usable_cols )
                    printf("Warning: can't wrap long line in Fortran free format (text is longer than a line)\n");

                // emit free-format line continuation even if result will still be too long
                unp->u_sage->curprint("&");
                unp->cur.insert_newline(1);
                unp->u_sage->curprint("&");
            }
            else
                printf("Warning: long line not wrapped (unknown output format)\n");
        }
    }

    unp->u_sage->curprint(str);
     
#else  // ! USE_RICE_FORTRAN_WRAPPING

     // FMZ (3/22/2010) added fortran continue line support
     bool is_fortran90 =  (unp->currentFile != NULL ) &&
                              (unp->currentFile->get_F90_only() ||
                                  unp->currentFile->get_CoArrayFortran_only());

     int str_len       = str.size();
     int curr_line_len = unp->cur.current_col();

     if (is_fortran90 && 
              curr_line_len!=0 && 
               (str_len + curr_line_len)> MAX_F90_LINE_LEN) {
          unp->u_sage->curprint("&");
          unp->cur.insert_newline(1);
     } 

     unp->u_sage->curprint(str);
     
#endif  // USE_RICE_FORTRAN_WRAPPING
}

// DQ (8/13/2007): This has been moved to the base class (language independent code)
void
UnparseLanguageIndependentConstructs::markGeneratedFile() const
   {
     unp->u_sage->curprint ( "\n#define ROSE_GENERATED_CODE\n" );
   }

// This has been simplified by Markus Kowarschik. We need to introduce the
// case of statements that have been introduced by transformations.
// bool Unparser::statementFromFile ( SgStatement* stmt, char* sourceFilename )
// bool UnparseLanguageIndependentConstructs::statementFromFile ( SgStatement* stmt, string sourceFilename )
bool
UnparseLanguageIndependentConstructs::statementFromFile ( SgStatement* stmt, string sourceFilename, SgUnparse_Info& info )
   {
  // If the filename of the statement and the input filename are the same then 
  // the return result is true.  IF not, then we have to look to see if there
  // was a "#line xx "filename"" macro that was used (to explain the difference).

     ROSE_ASSERT (stmt != NULL);

     bool statementInFile = false;

  // FMZ (comment by DQ (11/14/2008)):
  // This is part of the support for module files in Fortran.  Modules seen in the compilation 
  // of a Fortran program cause a "<module name>.rmod" file to be generated. When we unparse 
  // the "*.rmod" we want to output all statements, but since they came from the original 
  // fortran file (a better translation would avoid this problem), the function would conclude
  // that they should not be unparsed (this fix forces the statements in a "*.rmod" file to 
  // always be unparsed.  If the SgSourceFile vuilt to represent the "*.rmod" file had been 
  // constructed as a transformation then the file info objects would have been marked as
  // part of a transforamtion and this fix would not have been required.  At some point this
  // can be improved.  So this is a fine temporary fix for now.
     if (StringUtility::fileNameSuffix(sourceFilename) == "rmod") 
        {
       // If we are to unparse a module into the .rmod file this this is ALWAYS true
          return true;
        }

#if 0
     if (stmt->get_file_info()->isFrontendSpecific() == false)
        {
          int    stmt_line              = stmt->get_file_info()->get_line();
          int    stmt_physical_line     = stmt->get_file_info()->get_physical_line();
          string stmt_filename          = stmt->get_file_info()->get_filenameString();
          string stmt_physical_filename = stmt->get_file_info()->get_physical_filename();

          printf ("In UnparseLanguageIndependentConstructs::statementFromFile(): sourceFilename = %s \n",sourceFilename.c_str());
          printf ("   --- stmt_physical_filename = %s stmt_physical_line = %d \n",stmt_physical_filename.c_str(),stmt_physical_line);
          printf ("   --- stmt = %p = %s stmt_filename  = %s line = %d \n",stmt,stmt->class_name().c_str(),stmt_filename.c_str(),stmt_line);

          if (isSgTemplateInstantiationDecl(stmt) != NULL)
             {
               stmt->get_file_info()->display("case of SgTemplateInstantiationDecl: debug");
             }
        }
#endif

#if 0
  // DQ (2/15/2013): This might not be required now that we support physical filenames (and physical line numbers).

  // DQ (12/23/2012): This special handling of the "conftest.c" file is no linger required.
  // It is used to map filenames generated from a specific #line directives used in autoconf 
  // generated files to the physical filename.  However, now that we internally keep references 
  // to both the logical source position AND the physical source position, this should not 
  // be required.

  // DQ (9/17/2013): Updated this test to handle C++ versions of autoconf tests.
  // DQ (10/8/2012): We want to allow ROSE to work with autoconf tests.  The nature
  // of these tests are that they have a #line directive "#line 1227 "configure"" 
  // and are in a file called: "conftest.c" and in some cases have a include file 
  // named: "confdef.h".
     string stmt_filename = StringUtility::stripPathFromFileName(sourceFilename);
     if ( (stmt_filename == "conftest.c") || (stmt_filename == "conftest.C") )
        {
          ROSE_ASSERT(stmt->get_file_info() != NULL);
          string statementfilename = stmt->get_file_info()->get_filenameString();
#if 0
          printf ("statementfilename = %s \n",statementfilename.c_str());
#endif
       // Note that the #line directive will cause the statement's source file position 
       // to match that of the filename in the line directive.
          if (statementfilename == "configure")
             {
#if 0
               printf ("In statementFromFile(): Detected an autoconf (configure) generated file used to test aspects of the system as part of an application's build system stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
               return true;
             }
        }
#endif

     if (unp->opt.get_unparse_includes_opt() == true)
        {
       // If we are to unparse all included files into the source file this this is ALWAYS true
          statementInFile = true;

       // DQ (9/16/2013): Restrict the unparsing using the -rose:unparse_includes option to eliminate the declarations added as part of the front-end support for compatability with the backend.
          SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(stmt);
          if (declarationStatement != NULL && stmt->get_file_info()->isFrontendSpecific() == true)
             {
#if 0
               curprint ( string("\n/* Inside of UnparseLanguageIndependentConstructs::statementFromFile (" ) + StringUtility::numberToString(stmt) + "): class_name() = " + stmt->class_name() + " (skipped) */ \n");
#endif
               statementInFile = false;
             }
        }
       else
        {
       // Compare the file names from the file info object in each statement
       // char* statementfilename = ROSE::getFileName(stmt);
       // const char* statementfilename = "default";
          string statementfilename = "default";

       // DQ (8/17/2005): At some point all transformation should be marked as isOutputInCodeGeneration
       // DQ (6/17/2005): Not all compiler generated IR nodes are intended to be unparsed (e.g. implicit casts)
       // some compiler generated IR nodes (e.g. required templates) are required in the generated source code 
       // so check explicitly for compiler generated IR nodes which are marked for output withn the generated 
       // source code (unparser).
       // DQ (5/26/2005): Query isCompilerGenerated and isTransformation before processing the filename.
       // bool isCompilerGenerated = stmt->get_file_info()->isCompilerGenerated();
       // bool isCompilerGenerated = stmt->get_file_info()->isCompilerGeneratedNodeToBeUnparsed();
       // bool isTransformation    = stmt->get_file_info()->isTransformation();
       // if (isCompilerGenerated || isTransformation)
          if (stmt->get_file_info() == NULL)
             {
               printf ("Error: stmt->get_file_info() == NULL stmt = %p = %s \n",stmt,stmt->class_name().c_str());
             }
          ROSE_ASSERT(stmt->get_file_info() != NULL);
          bool isOutputInCodeGeneration = stmt->get_file_info()->isOutputInCodeGeneration();

       // DQ (5/19/2011): Output generated code... (allows unparseToString() to be used with template instantations to support name qualification).
          bool forceOutputOfGeneratedCode = info.outputCompilerGeneratedStatements();
#if 0
          printf ("In statementFromFile(): stmt = %p = %s isOutputInCodeGeneration   = %s \n",stmt,stmt->class_name().c_str(),isOutputInCodeGeneration   ? "true" : "false");
          printf ("In statementFromFile(): stmt = %p = %s forceOutputOfGeneratedCode = %s \n",stmt,stmt->class_name().c_str(),forceOutputOfGeneratedCode ? "true" : "false");
#endif
#if 0
          info.display("In statementFromFile()");
#endif
       // DQ (1/11/2006): OutputCodeGeneration is not set to be true where transformations 
       // require it.  Transformation to include header files don't set the OutputCodeGeneration flag.
       // if (isOutputInCodeGeneration || isTransformation)
       // if (isOutputInCodeGeneration == true)

       // DQ (5/19/2011): Output generated code is specified.
          if (isOutputInCodeGeneration == true || forceOutputOfGeneratedCode == true)
             {
               statementInFile = true;
             }
            else
             {
            // DQ (8/17/2005): Need to replace this with call to compare Sg_File_Info::file_id 
            // numbers so that we can remove the string comparision operator.
            // statementfilename = ROSE::getFileName(stmt);

            // DQ (9/20/2013): We need to use the physical file name in checking which statements to unparse.
            // statementfilename = stmt->get_file_info()->get_filenameString();
               statementfilename = stmt->get_file_info()->get_physical_filename();

               if (info.get_language() == SgFile::e_Fortran_output_language)
                  {
                 // DQ (9/24/2013): In the case of Fortran we need to generate the preprocessor name (at least for file requireing CPP).
                 // This was handled properly under the previous implementation using the logical source position, so for Fortran we 
                 // use the logical source position as a basis for knowing which statements to be output.  The case of C/C++ is 
                 // more sophisticated (test autoconf test codes) and so it requires the physical source position.  Ideally, the 
                 // fortran support would have the same implementation, but the handling of intermdiate preprocessed files makes 
                 // this more complex (and it should be a seperate fix to handle that).
                 // statementfilename = SgFile::generate_C_preprocessor_intermediate_filename(stmt->get_file_info()->get_physical_filename());
                 // statementfilename = SgFile::generate_C_preprocessor_intermediate_filename(sourceFilename);
                    statementfilename = stmt->get_file_info()->get_filenameString();
#if 0
                    printf ("sourceFilename                                 = %s \n",sourceFilename.c_str());
                    printf ("statementfilename                              = %s \n",statementfilename.c_str());
                    printf ("stmt->get_file_info()->get_physical_filename() = %s \n",stmt->get_file_info()->get_physical_filename().c_str());
                    printf ("stmt->get_file_info()->get_filenameString()    = %s \n",stmt->get_file_info()->get_filenameString().c_str());
#endif
#if 0
                    printf ("In statementFromFile(): Exiting as a test in the Fortran support for source file identification \n");
                    ROSE_ASSERT(false);
#endif
                  }
                 else
                  {
                    statementfilename = stmt->get_file_info()->get_physical_filename();
#if 0
                    printf ("In statementFromFile(): Exiting as a test in the NON-Fortran support for source file identification \n");
                    ROSE_ASSERT(false);
#endif
                  }
#if 0
               printf ("In statementFromFile(): statementfilename = %s sourceFilename = %s \n",statementfilename.c_str(),sourceFilename.c_str());
               printf ("In statementFromFile(): stmt->get_file_info()->get_physical_filename() = %s \n",stmt->get_file_info()->get_physical_filename().c_str());
#endif
            // DQ (10/22/2007): Allow empty name strings (to support #line n "")
            // ROSE_ASSERT (statementfilename.empty() == false);

            // DQ (9/20/2013): If this is a performance issue, an optimization would be to use file_id's instead of strings (filenames).
            // However, this does not appear to be an important optimization.
               if ( statementfilename == sourceFilename )
                  {
                    statementInFile = true;
                  }

            // negara1 (08/15/2011): Make a special consideration for header file bodies in include directive statements.
            // TODO: Change when SgIncludeDirectiveStatement is used instead of attached PreprocessingInfo.
               SgIncludeDirectiveStatement* includeDirectiveStatement = isSgIncludeDirectiveStatement(stmt);
               if (includeDirectiveStatement != NULL) 
                  {
                    if (includeDirectiveStatement->get_headerFileBody()->get_file_info()->get_filenameString() == sourceFilename)
                       {
                         statementInFile = true;
                       }
                  }
             }
#if 0
          printf ("In statementFromFile (statementInFile = %s output = %s stmt = %p = %s = %s in file = %s sourceFilename = %s ) \n",
               (statementInFile == true) ? "true": "false", (isOutputInCodeGeneration == true) ? "true": "false", stmt, 
               stmt->class_name().c_str(), SageInterface::get_name(stmt).c_str(),statementfilename.c_str(), sourceFilename.c_str());
#endif
#if 0
          stmt->get_file_info()->display("In Unparser::statementFromFile()");
#endif
        }

#if 0
     printf ("In statementFromFile(): statementInFile = %p = %s = %s = %s \n\n",stmt,stmt->class_name().c_str(),SageInterface::get_name(stmt).c_str(),(statementInFile == true) ? "true" : "false");
#endif
#if 0
  // stmt->get_file_info()->display("debug why false");
  // if (statementInFile == false)
        {
          stmt->get_file_info()->display("debug why false");
        }
#endif

#if 0
  // Debugging support
     SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(stmt);
     if (declarationStatement != NULL && statementInFile == false && stmt->get_file_info()->isFrontendSpecific() == false)
        {
          curprint ( string("\n/* Inside of UnparseLanguageIndependentConstructs::statementFromFile (" ) + StringUtility::numberToString(stmt) + "): sage_class_name() = " + stmt->sage_class_name() + " (skipped) */ \n");
        }
#endif

     return statementInFile;
   }


// DQ (9/6/2006): Modified to return "std::string" instead of "char*"
string
UnparseLanguageIndependentConstructs::getFileName(SgNode* stmt)
   {
     string returnString;

  // check to see if fileinfo is not available
     if (stmt->get_file_info() != NULL)
        {
          returnString = stmt->get_file_info()->get_filenameString();
        }
       else
        {
       // the fileinfo was not available, so check the stmt's parent for the fileinfo
          SgNode* p_stmt = stmt->get_parent();
          if (p_stmt != NULL)
               returnString = getFileName(p_stmt);
        }

     return returnString;
   }


// DQ (9/6/2006): Modified to return "std::string" instead of "char*"
string
UnparseLanguageIndependentConstructs::getFileName()
   {
     return currentOutputFileName;
   }


void
UnparseLanguageIndependentConstructs::printOutComments ( SgLocatedNode* locatedNode ) const
   {
  // Debugging function to print out comments in the statements (added by DQ)

     ROSE_ASSERT(locatedNode != NULL);
     AttachedPreprocessingInfoType* comments = locatedNode->getAttachedPreprocessingInfo();

     if (comments != NULL)
        {
          printf ("Found attached comments (at %p of type: %s): \n",locatedNode,locatedNode->class_name().c_str());
          AttachedPreprocessingInfoType::iterator i;
          for (i = comments->begin(); i != comments->end(); i++)
             {
               ROSE_ASSERT ( (*i) != NULL );
               printf ("          Attached Comment (relativePosition=%s): %s\n",
                    ((*i)->getRelativePosition() == PreprocessingInfo::before) ? "before" : "after",
                    (*i)->getString().c_str());
               printf ("Comment/Directive getNumberOfLines = %d getColumnNumberOfEndOfString = %d \n",(*i)->getNumberOfLines(),(*i)->getColumnNumberOfEndOfString());
               (*i)->get_file_info()->display("comment/directive location");
             }
        }
       else
        {
          printf ("No attached comments (at %p of type: %s): \n",locatedNode,locatedNode->sage_class_name());
        }
   }


void
UnparseLanguageIndependentConstructs::outputCompilerGeneratedStatements( SgUnparse_Info & info )
   {
     list<SgStatement*>::iterator i = unp->compilerGeneratedStatementQueue.begin();
  // printf ("compilerGeneratedStatementQueue.size() = %zu \n",compilerGeneratedStatementQueue.size());
     while (info.outputCompilerGeneratedStatements() == false && unp->compilerGeneratedStatementQueue.empty() == false)
        {
       // now output the compiler generated statements
          SgStatement* compilerGeneratedStatement = unp->compilerGeneratedStatementQueue.back();

       // printf ("compilerGeneratedStatement = %p = %s \n",compilerGeneratedStatement,compilerGeneratedStatement->sage_class_name());

       // Drain the queue (remove last element)
          unp->compilerGeneratedStatementQueue.pop_back();

       // Generate a new SgUnparse_Info object
          SgUnparse_Info tempInfo(info);
          tempInfo.set_outputCompilerGeneratedStatements();

       // Now output the previously saved statement (recursive call)
       // printf ("Now output the previously saved statement (recursive call) \n");
          unparseStatement(compilerGeneratedStatement,tempInfo);
        }
   }



// void UnparseLanguageIndependentConstructs::unparseStatementNumbers ( SgStatement* stmt )
void
UnparseLanguageIndependentConstructs::unparseStatementNumbers ( SgStatement* stmt, SgUnparse_Info & info )
   {
  // This is the base class (which is called only for C/C++ code generation).

  // This is a Fortran specific case (different from use of SgLabelStatement in C/C++).
  // This is a virtual function and defined in the base class as just a test on the 
  // value range of the in the numeric_label (default value is -1).
  // ROSE_ASSERT(stmt->get_numeric_label() == -1);
     ROSE_ASSERT(stmt->get_numeric_label() == NULL);
   }


void
UnparseLanguageIndependentConstructs::unparseLineDirectives ( SgStatement* stmt )
   {
  // DQ (12/4/2007): This is the control for the output of #line "" directives
  // This used to be present and was removed at some point.
     if (unp->opt.get_linefile_opt() == true)
        {
          static int previousFileId     = 0;
          static int previousLineNumber = 0;
          int currentFileId             = stmt->get_startOfConstruct()->get_file_id();
          int currentLineNumber         = stmt->get_startOfConstruct()->get_line();

#if 0
       // Try not to output a #line directive for every line number (however this may be required for greater precision).
          bool outputdirective = false;
       // if (currentFileId != previousFileId)
          if (currentFileId != previousFileId || currentLineNumber != previousLineNumber)
             {
               previousFileId = currentFileId;
               outputdirective = true;
             }
#else
          bool outputdirective = true;
#endif

       // There are a number of IR nodes that we don't want to have generate #line directives.
          if ( (isSgGlobal(stmt) != NULL) ||
               (isSgFunctionDefinition(stmt) != NULL) ||
               (isSgClassDefinition(stmt) != NULL) ||
               (isSgBasicBlock(stmt) != NULL) )
             {
               outputdirective = false;
             }

          if (outputdirective == true && ( (currentFileId == previousFileId) && (currentLineNumber == previousLineNumber) ))
             {
               outputdirective = false;
             }
            else
             {
               previousFileId     = currentFileId;
               previousLineNumber = currentLineNumber;
             }

          if (outputdirective == true)
             {
               string filename   = stmt->get_startOfConstruct()->get_filenameString();
               string lineNumber = StringUtility::numberToString(stmt->get_startOfConstruct()->get_line());
               string lineDirective = "#line " + lineNumber + " \"" + filename + "\"";
               unp->u_sage->curprint_newline();
               curprint (lineDirective);
               unp->u_sage->curprint_newline();
             }
        }
   }


bool
UnparseLanguageIndependentConstructs::canBeUnparsedFromTokenStream(SgSourceFile* sourceFile, SgStatement* stmt)
   {
  // This function factors out the details of the conditions under which a statement can be unparsed from the token stream.
  // Note that it is conditional upon if there is a mapping identified between the token stream and the statement.  These
  // mapping can be shared across more than one statement, or not exist, depending on the statement and the use of macro 
  // expansion in the statement (or acorss multiple statements).

  // Note that we might want this function to return a pointer to a TokenStreamSequenceToNodeMapping instead (and NULL if no info is available)

     ROSE_ASSERT(sourceFile != NULL);
     ROSE_ASSERT(stmt != NULL);

     bool canBeUnparsed = false;

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenStreamSequenceMap = sourceFile->get_tokenSubsequenceMap();

  // If a set of statements are associated with the same interval of the token stream, then we have to detect this.
  // The first statement will be mapped to the token stream, but then I am less clear on what happens.

     if (tokenStreamSequenceMap.find(stmt) != tokenStreamSequenceMap.end())
        {
          TokenStreamSequenceToNodeMapping* tokenSubsequence = tokenStreamSequenceMap[stmt];
       // ROSE_ASSERT(tokenSubsequence != NULL);
          if (tokenSubsequence != NULL)
             {
#if 0
               printf ("In canBeUnparsedFromTokenStream(): stmt = %p = %s \n",stmt,stmt->class_name().c_str());
               printf ("   --- tokenStreamSequenceMap: leading  (start,end) = (%d,%d) \n",tokenSubsequence->leading_whitespace_start, tokenSubsequence->leading_whitespace_end);
               printf ("   --- tokenStreamSequenceMap: node     (start,end) = (%d,%d) \n",tokenSubsequence->token_subsequence_start,  tokenSubsequence->token_subsequence_end);
               printf ("   --- tokenStreamSequenceMap: trailing (start,end) = (%d,%d) \n",tokenSubsequence->trailing_whitespace_start,tokenSubsequence->trailing_whitespace_end);
#endif
               ROSE_ASSERT(stmt->get_file_info() != NULL);
#if 0
               stmt->get_file_info()->display("In canBeUnparsedFromTokenStream(): debug");
#endif
               canBeUnparsed = (tokenSubsequence->token_subsequence_start != -1);

            // DQ (11/29/2013): Added support for the detection of redundantly mapped statements to token sequences.
            // E.g. ROSE normalizations of variable declaration with multiple variables into seperate (multiple) 
            // SgVariableDeclaration IR nodes in the AST.
               std::multimap<int,SgStatement*> & redundantlyMappedTokensToStatementMultimap = sourceFile->get_redundantlyMappedTokensToStatementMultimap();

               std::set<int> & redundantTokenEndings = sourceFile->get_redundantTokenEndingsSet();

               std::set<int>::iterator k = redundantTokenEndings.begin();
               while (k != redundantTokenEndings.end())
                  {
                    int lastTokenIndex = *k;
#if 0
                    printf ("Redundant statement list: lastTokenIndex = %d \n",lastTokenIndex);
#endif
                    std::pair<std::multimap<int,SgStatement*>::iterator,std::multimap<int,SgStatement*>::iterator> range_iterator = redundantlyMappedTokensToStatementMultimap.equal_range(lastTokenIndex);
                    std::multimap<int,SgStatement*>::iterator first_iterator = range_iterator.first;
                    std::multimap<int,SgStatement*>::iterator last_iterator  = range_iterator.second;

                    std::multimap<int,SgStatement*>::iterator local_iterator = first_iterator;
                    while (local_iterator != last_iterator)
                       {
#if 0
                         SgStatement* stmt = local_iterator->second;
                         printf ("   --- redundant statement for lastTokenIndex = %d stmt = %p = %s \n",lastTokenIndex,stmt,stmt->class_name().c_str());
#endif
                         local_iterator++;
                       }

                    k++;
                  }
             }
        }
       else
        {
#if 0
          printf ("Note: In canBeUnparsedFromTokenStream(): the requested subsequence mapping object was not found: stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
        }

#if 0
     printf ("Leaving canBeUnparsedFromTokenStream(): stmt = %p = %s canBeUnparsed = %s \n",stmt,stmt->class_name().c_str(),canBeUnparsed ? "true" : "false");
#endif

     return canBeUnparsed;
   }


bool
UnparseLanguageIndependentConstructs::redundantStatementMappingToTokenSequence(SgSourceFile* sourceFile, SgStatement* stmt)
   {
     ROSE_ASSERT(sourceFile != NULL);
     ROSE_ASSERT(stmt != NULL);

     static std::set<SgStatement*> previouslySeenStatement;

     bool redundantStatement = false;

#if 0
     printf ("In redundantStatementMappingToTokenSequence(): stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif

  // std::set<int>::iterator k = redundantTokenEndings.begin();
  // while (k != redundantTokenEndings.end())

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenStreamSequenceMap = sourceFile->get_tokenSubsequenceMap();

     if (tokenStreamSequenceMap.find(stmt) != tokenStreamSequenceMap.end())
        {
          TokenStreamSequenceToNodeMapping* tokenSubsequence = tokenStreamSequenceMap[stmt];
          int lastTokenIndex = tokenSubsequence->token_subsequence_end;

       // DQ (11/29/2013): Added support for the detection of redundantly mapped statements to token sequences.
       // E.g. ROSE normalizations of variable declaration with multiple variables into seperate (multiple) 
       // SgVariableDeclaration IR nodes in the AST.
          std::multimap<int,SgStatement*> & redundantlyMappedTokensToStatementMultimap = sourceFile->get_redundantlyMappedTokensToStatementMultimap();
          std::set<int> & redundantTokenEndings = sourceFile->get_redundantTokenEndingsSet();
#if 0
          printf ("Redundant statement list: lastTokenIndex = %d \n",lastTokenIndex);
#endif
          if (redundantTokenEndings.find(lastTokenIndex) != redundantTokenEndings.end())
             {
               std::pair<std::multimap<int,SgStatement*>::iterator,std::multimap<int,SgStatement*>::iterator> range_iterator = redundantlyMappedTokensToStatementMultimap.equal_range(lastTokenIndex);
               std::multimap<int,SgStatement*>::iterator first_iterator = range_iterator.first;
               std::multimap<int,SgStatement*>::iterator last_iterator  = range_iterator.second;

               std::multimap<int,SgStatement*>::iterator local_iterator = first_iterator;
               while (local_iterator != last_iterator)
                  {
                    SgStatement* redundant_stmt = local_iterator->second;
#if 0
                    printf ("   --- redundant statement for lastTokenIndex = %d redundant_stmt = %p = %s \n",lastTokenIndex,redundant_stmt,redundant_stmt->class_name().c_str());
#endif
                    if (previouslySeenStatement.find(stmt) != previouslySeenStatement.end())
                       {
                      // This is a previously processed statment.
                         redundantStatement = true;
#if 0
                         printf ("   ---   --- Detected redundant statment = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
                       }
                      else
                       {
                      // We have not processed this statement, so add it to the static local map.
                         previouslySeenStatement.insert(redundant_stmt);
                       }

                    local_iterator++;
                  }
             }
            else
             {
#if 0
               printf ("Not found in redundantTokenEndings: lastTokenIndex = %d \n",lastTokenIndex);
#endif
             }
        }
       else
        {
#if 0
          printf ("In redundantStatementMappingToTokenSequence(): not found in tokenStreamSequenceMap: stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
        }

#if 0
     printf ("Leaving redundantStatementMappingToTokenSequence(): stmt = %p = %s redundantStatement = %s \n",stmt,stmt->class_name().c_str(),redundantStatement ? "true" : "false");
#endif

     return redundantStatement;
   }


int
UnparseLanguageIndependentConstructs::unparseStatementFromTokenStream(SgSourceFile* sourceFile, SgStatement* stmt, SgUnparse_Info & info, bool & lastStatementOfGlobalScopeUnparsedUsingTokenStream)
   {
     ROSE_ASSERT(sourceFile != NULL);
     ROSE_ASSERT(stmt != NULL);

  // DQ (1/29/2014): Control use of format mechanism to unparse the token stream vs. a higher fedelity 
  // mechanism that does not drop line endings.  The high fedelity version is just prettier, but 
  // pretty counts...
#define HIGH_FEDELITY_TOKEN_UNPARSING 1

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenStreamSequenceMap = sourceFile->get_tokenSubsequenceMap();

     SgTokenPtrList & tokenVector = sourceFile->get_token_list();

  // This implementation uses the refactored code.
     bool unparseStatus = (canBeUnparsedFromTokenStream(sourceFile,stmt) == true);

  // if (canBeUnparsedFromTokenStream(sourceFile,stmt) == true)
     if (unparseStatus == true)
        {
       // Check if this is a previously processed statement (static map is located in redundantStatementMappingToTokenSequence() function.
          bool redundantStatement = redundantStatementMappingToTokenSequence(sourceFile,stmt);

          if (redundantStatement == false)
             {
            // Check for the leading token stream for this statement.  Unparse it if the previous statement was unparsed as a token stream.
               std::map<SgNode*,PreviousAndNextNodeData*> & previousAndNextFrontierDataMap = sourceFile->get_token_unparse_frontier_adjacency();

               TokenStreamSequenceToNodeMapping* tokenSubsequence = tokenStreamSequenceMap[stmt];
               ROSE_ASSERT(tokenSubsequence != NULL);

               ROSE_ASSERT(tokenSubsequence->token_subsequence_start != -1);

               ROSE_ASSERT(previousAndNextFrontierDataMap.find(stmt) != previousAndNextFrontierDataMap.end());
               PreviousAndNextNodeData* previousAndNextFrontierData = previousAndNextFrontierDataMap[stmt];
               ROSE_ASSERT(previousAndNextFrontierData != NULL);
               ROSE_ASSERT(previousAndNextFrontierData->previous != NULL);
               SgStatement* previousStatement = isSgStatement(previousAndNextFrontierData->previous);
               ROSE_ASSERT(previousStatement != NULL);

            // This fails in the case where the whole AST is unparsed from the token stream.
            // ROSE_ASSERT(previousStatement != stmt);

            // DQ (12/1/2013): Not clear if this is helpful or not (but it communicates in the 
            // unparsed code what statements were unparse using either the AST or the token stream).
               if ( SgProject::get_verbose() > 0 )
                  {
                    string s = "/* Unparsing from the token stream stmt = " + stmt->class_name() + " */ ";
                    curprint (s);
                  }

               bool unparseStatus_previousStatement = (canBeUnparsedFromTokenStream(sourceFile,previousStatement) == true);
               if (unparseStatus_previousStatement == true)
                  {
#if 0
                    printf ("Output the leading tokens for this statement = %p = %s \n",previousStatement,previousStatement->class_name().c_str());
                    printf ("   --- tokenSubsequence->leading_whitespace_start = %d tokenSubsequence->leading_whitespace_end = %d \n",tokenSubsequence->leading_whitespace_start,tokenSubsequence->leading_whitespace_end);
#endif

                    SgGlobal* globalScope = isSgGlobal(stmt);
#if 0
                    printf ("In unparseStatementFromTokenStream(): globalScope = %p \n",globalScope);
                    if (globalScope != NULL)
                       {
                         printf ("globalScope->get_declarations().size() = %zu \n",globalScope->get_declarations().size());
                         for (size_t i = 0; i < globalScope->get_declarations().size(); i++)
                            {
                              SgDeclarationStatement* decl = globalScope->get_declarations()[i];
                              ROSE_ASSERT(decl != NULL);
                              printf ("   --- global scope statements: i = %p = %s \n",decl,decl->class_name().c_str());
                            }
                       }
#endif
                    if (globalScope != NULL)
                       {
#if 0
                         printf ("Processing corner case of empty global scope unparsed using the token stream \n");
#endif
                         if (globalScope->get_declarations().empty() == true)
                            {
                           // If this is the empry global scope then consider the SgGlobal to be the last statement to be unparsed.
                           // This will trigger the output of the remaining tokens in the file and suppress any CPP directives and 
                           // comments that are attached to the SgGlobal (because there was no other IR node to attach them to which
                           // could be considered a part of the input file).
                              lastStatementOfGlobalScopeUnparsedUsingTokenStream = true;
                            }
                           else
                            {
                           // Else we have to make sure that none of the declarations in global scope are from this file.
                           // These can de declarations from header files or the rose_edg_required_macros_and_functions.h 
                           // file that is read to support GNU predefined macros.
                              lastStatementOfGlobalScopeUnparsedUsingTokenStream = true;
                              for (size_t i = 0; i < globalScope->get_declarations().size(); i++)
                                 {
                                   SgDeclarationStatement* decl = globalScope->get_declarations()[i];
                                   ROSE_ASSERT(decl != NULL);
#if 0
                                   printf ("   --- global scope statements: i = %p = %s \n",decl,decl->class_name().c_str());
#endif
                                   if (statementFromFile(decl, getFileName(), info) == true)
                                      {
#if 0
                                        printf ("Found statement that will be output: set lastStatementOfGlobalScopeUnparsedUsingTokenStream == true: decl = %p = %s \n",decl,decl->class_name().c_str());
#endif
                                        lastStatementOfGlobalScopeUnparsedUsingTokenStream = false;
                                      }
                                 }

                              if (lastStatementOfGlobalScopeUnparsedUsingTokenStream == true)
                                 {
                                // This SgGlobal will be treated as the last statement so that we can know to supporess the generation 
                                // of CPP directives and comments that are in the AST and associated with the SgGlobal.
#if 0
                                   printf ("Global scope being treated as last statement in file (will be unparsed using the token sequence and CPP directives associated with SgGlobal will be supressed) \n");
#endif
                                 }
                            }
                       }

                    if (tokenSubsequence->leading_whitespace_start != -1 && tokenSubsequence->leading_whitespace_end != -1)
                       {
                         for (int j = tokenSubsequence->leading_whitespace_start; j <= tokenSubsequence->leading_whitespace_end; j++)
                            {
#if 0
                              printf ("Output leading tokenVector[j=%d]->get_lexeme_string() = %s \n",j,tokenVector[j]->get_lexeme_string().c_str());
#endif
#if HIGH_FEDELITY_TOKEN_UNPARSING
                           // DQ (1/29/2014): Implementing better fedility in the unparsing of tokens (avoid line ending interpretations 
                           // in curprint() function. Note that "unp->get_output_stream().output_stream()" is of type: "std::ostream*" type.
                              *(unp->get_output_stream().output_stream()) << tokenVector[j]->get_lexeme_string();
#else
                           // Note that this will interprete line endings which is not going to provide the precise token based output.
                              curprint(tokenVector[j]->get_lexeme_string());
#endif
                            }
                       }
                  }
#if 0
               printf ("In unparseStatementFromTokenStream(): DONE: previousStatement = %p = %s \n",previousStatement,previousStatement->class_name().c_str());
#endif
               for (int j = tokenSubsequence->token_subsequence_start; j <= tokenSubsequence->token_subsequence_end; j++)
                  {
#if 0
                    printf ("Output tokenVector[j=%d]->get_lexeme_string() = %s \n",j,tokenVector[j]->get_lexeme_string().c_str());
#endif
#if HIGH_FEDELITY_TOKEN_UNPARSING
                 // DQ (1/29/2014): Implementing better fedility in the unparsing of tokens (avoid line ending interpretations 
                 // in curprint() function. Note that "unp->get_output_stream().output_stream()" is of type: "std::ostream*" type.
                    *(unp->get_output_stream().output_stream()) << tokenVector[j]->get_lexeme_string();
#else
                 // Note that this will interprete line endings which is not going to provide the precise token based output.
                    curprint(tokenVector[j]->get_lexeme_string());
#endif
                  }

            // DQ (1/29/2014): The only consequence that I can see in not closing off the trailing token stream is that we 
            // will (at least sometimes) not not out put a trailing CR after the last line.
            // DQ (12/1/2013): I am not clear if there are cases where we need to output the associated trailing tokens.
            // None of these cases appear to be an issue in the C regression tests.

               bool isLastStatementOfGlobalScope = false;
               SgScopeStatement* scope = stmt->get_scope();
               ROSE_ASSERT(scope != NULL);

               SgGlobal* globalScope = isSgGlobal(scope);
               if (globalScope != NULL)
                  {
                 // Check if this is the last statement in the file (global scope).
                    SgDeclarationStatementPtrList & declarationList = globalScope->get_declarations();
                    SgDeclarationStatement* lastDeclaration = NULL;
                    if (declarationList.rbegin() != declarationList.rend())
                       {
                         lastDeclaration = *(declarationList.rbegin());
                         if (stmt == lastDeclaration)
                            {
#if 0
                              printf ("In unparseStatementFromTokenStream(): identified last statement: stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
                              isLastStatementOfGlobalScope = true;
                            }
                       }
                      else
                       {
#if 0
                         printf ("In unparseStatementFromTokenStream(): Global scope is empty! \n");
#endif
                       }
                  }

            // The last statement has to handle the output of the tokens for the rest of the file.
            // If the last statement is output from the AST, then it will be handled using information 
            // in the AST (not the token stream).
               if (isLastStatementOfGlobalScope == true)
                  {
#if 0
                    printf ("Process the tokens associated with the trailing edge of the last statement \n");
#endif
                 // Set the return parameter to skip the unparsing of the tailing CPP directives and 
                 // comments from the AST (since they are being output via the token stream).
                    lastStatementOfGlobalScopeUnparsedUsingTokenStream = true;

                    if (tokenSubsequence->trailing_whitespace_start != -1 && tokenSubsequence->trailing_whitespace_end != -1)
                       {
                         for (int j = tokenSubsequence->trailing_whitespace_start; j <= tokenSubsequence->trailing_whitespace_end; j++)
                            {
#if 0
                              printf ("Output trailing tokenVector[j=%d]->get_lexeme_string() = %s \n",j,tokenVector[j]->get_lexeme_string().c_str());
#endif
#if HIGH_FEDELITY_TOKEN_UNPARSING
                           // DQ (1/29/2014): Implementing better fedility in the unparsing of tokens (avoid line ending interpretations 
                           // in curprint() function. Note that "unp->get_output_stream().output_stream()" is of type: "std::ostream*" type.
                              *(unp->get_output_stream().output_stream()) << tokenVector[j]->get_lexeme_string();
#else
                           // Note that this will interprete line endings which is not going to provide the precise token based output.
                              curprint(tokenVector[j]->get_lexeme_string());
#endif
                            }
                       }
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
             }
        }

#if HIGH_FEDELITY_TOKEN_UNPARSING
  // If we are directly operating on the ostream, then flush after each statement.
     unp->get_output_stream().output_stream()->flush();
#endif

#if 0
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif

  // Test this function here to be true.
  // ROSE_ASSERT(canBeUnparsedFromTokenStream(sourceFile,stmt) == true);

  // Return zero to indicate that there was no error in the unparsing from the token stream.
  // return 0;
     return (unparseStatus == true) ? 0 : 1;
   }


#if 0
bool
UnparseLanguageIndependentConstructs::isTransitionFromTokenUnparsingToASTunparsing(SgStatement* statement)
   {
  // This function helps support the token based unparsing. In transitions bewteen 
  // the token unparsing and the AST unparsing, we have to suppress the output of 
  // CPP directives and comments to avoid them being output redundanrtly (as part 
  // of the token stream).

     printf ("In UnparseLanguageIndependentConstructs::isTransitionFromTokenUnparsingToASTunparsing(): statement = %p = %s \n",statement,statement->class_name().c_str());

     bool returnValue = false;

     SgFile* cur_file = SageInterface::getEnclosingFileNode(stmt);

     if (cur_file != NULL && cur_file->get_unparse_tokens() == true)
        {
          SgSourceFile* sourceFile = isSgSourceFile(cur_file);
          ROSE_ASSERT(sourceFile != NULL);

          bool unparse = unparseStatementFromTokenStream(sourceFile, statement);

        }

     return returnValue;
   }
#endif

//-----------------------------------------------------------------------------------
//  void Unparse_ExprStmt::unparseStatement
//
//  General function that gets called when unparsing a statement. Then it routes
//  to the appropriate function to unparse each kind of statement.
//-----------------------------------------------------------------------------------
void
UnparseLanguageIndependentConstructs::unparseStatement(SgStatement* stmt, SgUnparse_Info & info)
   {
     ROSE_ASSERT(stmt != NULL);

#if 0
  // DQ (10/30/2013): Debugging support for file info data for each IR node (added comment only)
     int line    = stmt->get_startOfConstruct()->get_raw_line();
     string file = stmt->get_startOfConstruct()->get_filenameString();
     printf ("unparseStatement(): (language independent = %s) statement (%p): %s line = %d file = %s \n",languageName().c_str(),stmt,stmt->class_name().c_str(),line,file.c_str());
#endif

#if OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES
  // DQ (10/30/2013): Debugging support for file info data for each IR node (added comment only)
     printf ("Unparse statement (%p): %s name = %s \n",stmt,stmt->class_name().c_str(),SageInterface::get_name(stmt).c_str());

  // DQ (4/17/2007): Added enforcement for endOfConstruct().
     ROSE_ASSERT (stmt->get_endOfConstruct() != NULL);
#endif

#if 0
  // DQ (10/30/2013): Debugging support for file info data for each IR node (added comment only)
     curprint ( string("\n/* Unparse statement (" ) + StringUtility::numberToString(stmt) 
         + "): class_name() = " + stmt->class_name() 
                + " raw line (start) = " + tostring(stmt->get_startOfConstruct()->get_raw_line()) 
                + " raw line (end) = " + tostring(stmt->get_endOfConstruct()->get_raw_line()) 
         + " */ \n");
     char buffer[100];
     snprintf (buffer,100,"%p",stmt);
     curprint ("\n/* Top of unparseStatement " + stmt->class_name() + " at: " + buffer + " */ \n");
#endif

#if 0
  // DQ (10/25/2006): Debugging support for file info data for each IR node
     if (stmt->get_endOfConstruct() == NULL)
        {
          printf ("Error in unparseStatement(): stmt = %p = %s stmt->get_endOfConstruct() == NULL \n",stmt,stmt->class_name().c_str());
          stmt->get_file_info()->display("unparseStatement (debug)");
        }
  // ROSE_ASSERT(stmt->get_endOfConstruct() != NULL);

     curprint ( string("\n/* Top of unparseStatement (UnparseLanguageIndependentConstructs)" ) + string(stmt->sage_class_name()) + " */\n ");
     ROSE_ASSERT(stmt->get_startOfConstruct() != NULL);
  // ROSE_ASSERT(stmt->getAttachedPreprocessingInfo() != NULL);
     int numberOfComments = -1;
     if (stmt->getAttachedPreprocessingInfo() != NULL)
        numberOfComments = stmt->getAttachedPreprocessingInfo()->size();
     curprint ( string("/* startOfConstruct: file = " ) + stmt->get_startOfConstruct()->get_filenameString()
         + " raw filename = " + stmt->get_startOfConstruct()->get_raw_filename()
         + " raw line = "     + StringUtility::numberToString(stmt->get_startOfConstruct()->get_raw_line())
         + " raw column = "   + StringUtility::numberToString(stmt->get_startOfConstruct()->get_raw_col())
         + " #comments = "    + StringUtility::numberToString(numberOfComments)
         + " */\n ");

     if (stmt->get_endOfConstruct() != NULL)
        {
          curprint ( string("/* endOfConstruct: file = " ) + stmt->get_endOfConstruct()->get_filenameString()
              + " raw filename = " + stmt->get_endOfConstruct()->get_raw_filename() 
              + " raw line = "     + StringUtility::numberToString(stmt->get_endOfConstruct()->get_raw_line())
              + " raw column = "   + StringUtility::numberToString(stmt->get_endOfConstruct()->get_raw_col())
              + " */\n ");
        }
       else
        {
          curprint ( string("/* endOfConstruct == NULL */\n " ) );
        }
     
  // ROSE_ASSERT(stmt->get_endOfConstruct() != NULL);

     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(stmt);
     if (variableDeclaration != NULL)
        {
          SgInitializedNamePtrList & nameList = variableDeclaration->get_variables();
          SgInitializedNamePtrList::iterator i = nameList.begin();
          while(i != nameList.end())
             {
               curprint ( string("\n/* SgInitializedName = " ) + (*i)->get_name()  + " in file: " 
                   + (*i)->get_file_info()->get_raw_filename() + " at line: "
                   + StringUtility::numberToString((*i)->get_file_info()->get_raw_line()) + " at column: "
                   + StringUtility::numberToString((*i)->get_file_info()->get_raw_col())  + " */\n ");
               i++;
             }
        }
#endif

#if 0
  // Debugging support
     printOutComments (stmt);
#endif

     ROSE_ASSERT(stmt->get_file_info() != NULL);

  // FIXME cause conflict in "make check"?
  // DQ (5/19/2011): Allow unparsing of even compiler generated statements when specified via the SgUnparse_Info object.
  // FMZ : we have ".rmod" file which will not satisfy this condition
  // JJW (6/23/2008): Move check for statement-within-file here rather than in individual procedures
  // if (!statementFromFile(stmt, getFileName()))
  // if (!statementFromFile(stmt, getFileName(), info))
     if (statementFromFile(stmt, getFileName(), info) == false)
        {
#if 0
          printf ("WARNING: Skipping calls to output statements that are not recorded as being in the target file: stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
#if 0
          stmt->get_file_info()->display("WARNING: Skipping calls to output statements that are not recorded as being in the target file: debug");
#endif

       // If this is not a statement to be unparsed then exit imediately.
          return;
        }

  // saveCompilerGeneratedStatements(stmt,info);
  // DQ (5/27/2005): fixup ordering of comments and any compiler generated code
     if ( info.outputCompilerGeneratedStatements() == false && stmt->get_file_info()->isCompilerGenerated() == true && isSgGlobal(stmt->get_parent()) != NULL )
        {
       // DQ (10/30/2013): This code is executed for C++ code (e.g. for test2004_58.C -- template support).

       // push all compiler generated nodes onto the static stack and unparse them after comments and directives 
       // of the next statement are output but before the associated statement to which they are attached.

       // printf ("Save the compiler-generated statement (%s), putting it onto the queue \n",stmt->class_name().c_str());
          unp->compilerGeneratedStatementQueue.push_front(stmt);

       // This return prevents this code from being trivially separated out into function.
          return;
        }


     if ( unparseLineReplacement(stmt,info) )
        {
       // DQ (10/30/2013): Not clear why we want a return here...
          return;
        }

  // curprint("/* Calling unparseAttachedPreprocessingInfo */ \n ");

  // Markus Kowarschik: This is the new code to unparse directives before the current statement
  // AS(05/20/09): LineReplacement should replace a statement with a line. Override unparsing of subtree.
  // unparseAttachedPreprocessingInfo(stmt, info, PreprocessingInfo::before);

  // DQ (10/20/2012): Note that function definitions need to be processed as a special case (unparsing CCP directived handled directly).
  //    1) UnparseLanguageIndependentConstructs::unparseStatement() (with SgFunctionDeclaration)
  //    2) unparseLanguageSpecificStatement() (with SgFunctionDeclaration)
  //    3) unparseFuncDeclStmt() (with SgFunctionDeclaration)
  //    4) unparse CPP directives on: funcdecl_stmt->get_parameterList()
  //    5) Calling UnparseLanguageIndependentConstructs::unparseStatement()
  //    6) unparseFuncDefnStmt()
  //    7) unparse CPP directives on: funcdecl_stmt->get_parameterList()
  //    8) calling unparseFuncDeclStmt
  //    9) calling unparse for funcdefn_stmt->get_body()
  //   10) then trailing comments and CPP directives are output on the body, the function definition, and the function declaration (in that order).
     bool skipOutputOfPreprocessingInfo = (isSgFunctionDefinition(stmt) != NULL);
#if 0
     printf ("In unparseStatement(): skipOutputOfPreprocessingInfo = %s \n",skipOutputOfPreprocessingInfo ? "true" : "false");
#endif
     if (skipOutputOfPreprocessingInfo == false)
        {
#if 0
          printf ("In unparseStatement(): Output the comments and CCP directives for the SgStatement stmt = %p = %s (before) \n",stmt,stmt->class_name().c_str());
#endif
#if 0
          bool transitionFromTokenUnparsingToASTunparsing = isTransitionFromTokenUnparsingToASTunparsing(stmt);
          if (transitionFromTokenUnparsingToASTunparsing == true)
             {
               curprint ("/* transitionFromTokenUnparsingToASTunparsing == true */ ");
             }
            else
             {
               curprint ("/* transitionFromTokenUnparsingToASTunparsing == false */ ");
             }
#endif
#if 0
       // DQ (11/30/2013): Move this to below where we can better support the token unparsing.
          unparseAttachedPreprocessingInfo(stmt, info, PreprocessingInfo::before);
#endif
#if 0
          printf ("DONE: In unparseStatement(): Output the comments and CCP directives for the SgStatement stmt = %p = %s (before) \n",stmt,stmt->class_name().c_str());
#endif
        }
       else
        {
#if 0
          printf ("In unparseStatement(): skipping output of comments and CCP directives for SgStatement stmt = %p = %s (before) \n",stmt,stmt->class_name().c_str());
#endif
        }

  // This is the other part of the accumulation of the compiler-generated statements into compilerGeneratedStatementQueue
  // so that they can be unparsed after any CPP directives or comments are unparsed (above). Because there is a return
  // in the code to accumulate the compiler-generated statements the code (above) could not be refactored as nicely.
     outputCompilerGeneratedStatements(info);

  // DQ (5/27/2005): fixup ordering of comments and any compiler generated code
  // ROSE_ASSERT(line_to_unparse == 0);

  // DQ (8/19/2007): Please let's get rid of this, it seems that it has been added back in after an intial 
  // attempt to remove it.  See me if you feel your really need this mechanism.
  // ROSE_ASSERT(unp->ltu == 0);

  // DQ (10/25/2006): Debugging support for file info data for each IR node
#define OUTPUT_EMBEDDED_COLOR_CODES_FOR_STATEMENTS 0
#if OUTPUT_EMBEDDED_COLOR_CODES_FOR_STATEMENTS
     vector< pair<bool,std::string> > stateVector;
     if (get_embedColorCodesInGeneratedCode() > 0)
        {
          setupColorCodes ( stateVector );
          printColorCodes ( stmt, true, stateVector );
        }
#endif

  // DQ (12/26/2007): Moved from language independent handling to C/C++ specific handling 
  // becasue we don't want it to appear in the Fortran code generation.
  // DQ (added comments) this is where the new lines are introduced before statements.
  // unp->cur.format(stmt, info, FORMAT_BEFORE_STMT);
  // curprint("/* After FORMAT_BEFORE_STMT */ \n ");

  // This is the added code to support the copy based unparsing mechanism.
  // Since there is a return here, it might be that comments after the 
  // statement will not be unparsed properly (check this at some point).
     if (unp->repl != NULL)
        {
       // printf ("Unparser Delegate found! \n");
          if (unp->repl->unparse_statement(stmt,info, unp->cur))
             {
            // printf ("Delegate unparser retruned true for repl->unparse_statement(%p) \n",stmt);
               return;
             }
        }

  // DQ (1/30/204): We need this to permit knowing when to unparse the trialing CPP directives and 
  // comments from the AST.  If they were unparsed from the token steam (as part of unparsing the 
  // last statement from the token stream) then unparsing them from the AST would be redundant
  // (though likely harmless).
     bool lastStatementOfGlobalScopeUnparsedUsingTokenStream = false;

  // DQ (7/20/2008): This mechanism is now extended to SgStatement and revised to handle 
  // more cases than just replacement of the 
  // AST subtree with a string.  Now we can add arbitrary text into different locations
  // relative to the specific IR node.  For now we are supporting before, replace, and after.
     AstUnparseAttribute* unparseAttribute = dynamic_cast<AstUnparseAttribute*>(stmt->getAttribute(AstUnparseAttribute::markerName));
     if (unparseAttribute != NULL)
        {
       // Note that in most cases unparseLanguageSpecificStatement() will be called, some formatting 
       // via "unp->cur.format(stmt, info, FORMAT_BEFORE_STMT);" may be done.  This can cause extra 
       // CRs to be inserted (which only looks bad).  Not clear now to best clean this up.
          string code = unparseAttribute->toString(AstUnparseAttribute::e_before);
          curprint (code);
        }

  // Only replace the unparsing of the IR node with a string if a string is marked as AstUnparseAttribute::e_replace.
     if (unparseAttribute != NULL && unparseAttribute->replacementStringExists() == true)
        {
          string code = unparseAttribute->toString(AstUnparseAttribute::e_replace);
          curprint (code);
        }
       else
        {
       // Use a static varible to track the previous statement.
       // static SgStatement* previousStatement = NULL;

       // DQ (10/30/2013): We can support the output of the statements using the token stream, it this is done then we don't output the statement as unparsed from the AST.
          bool outputStatementAsTokens = false;

       // Get the file and check if -rose:unparse_tokens was used then we want to try to access the token stream and output this statement directly as tokens.
          SgFile* cur_file = SageInterface::getEnclosingFileNode(stmt);

       // DQ (10/30/2013): This command-line option controls the use of the token stream in the unparsing.
       // Currently in it's development, we are always unparsing the statements using the token stream if 
       // they qualify.  Later we need to connect a test that will detect if a transformation has been done 
       // in the subtree rerpresented by a statement and only qualify the statement on the basis of this 
       // additional test.
       // Note that loopProcessing tests use a generated statement which are not processed for tokens and 
       // in this case the (cur_file == NULL).
          if (cur_file != NULL && cur_file->get_unparse_tokens() == true)
             {
            // First we want to restrict this to unparsing the simplest statements, e.g. those 
            // that are expression statements (e.g. containing no nested statements).

               SgSourceFile* sourceFile = isSgSourceFile(cur_file);
               ROSE_ASSERT(sourceFile != NULL);

            // This will be connected to a test to check if the statement has been transformed (might be 
            // precomputed in a single traversal with results propogated to statements).  Assume no transformations 
            // in early stags of testing (note command-line option -rose:is also required).
               bool statementTransformed = false;

            // We will over time increase the number of types of statements allowed to be unparsed via the token stream.
            // bool unparseViaTokenStream = (isSgExprStatement(stmt) != NULL) && (info.inConditional() == false);

            // Check if this is a frontier node and unparse it using the token stream (we actually need to check that is not marked to be parsed from the AST).
            // vector<FrontierNode*> & frontier_nodes = sourceFile->get_token_unparse_frontier();
            // bool isFrontierNode = (find(frontier_nodes.begin(),frontier_nodes.end(),stmt) != frontier_nodes.end());
               std::map<SgStatement*,FrontierNode*> & frontier_nodes = sourceFile->get_token_unparse_frontier();

               std::map<SgStatement*,FrontierNode*>::iterator i = frontier_nodes.find(stmt);
               bool isFrontierNode = (i != frontier_nodes.end());
               FrontierNode* associatedFrontierNode = (isFrontierNode == true) ? i->second : NULL;

            // Check is this is marked as already being handled via the unparsing of the token stream from another statement.
            // For example, variable declarations containing multiple variables will be represented as seperate SgVariableDeclaration 
            // IR nodes in the AST, but will have been unparsed using a single token stream.
            // static int lastUnparsedToken = 0;

            // bool unparseViaTokenStream = (isFrontierNode == true);
               bool unparseViaTokenStream = (isFrontierNode == true && associatedFrontierNode->unparseUsingTokenStream == true);
#if 0
               printf ("In UnparseLanguageIndependentConstructs::unparseStatement(): stmt = %p = %s unparseViaTokenStream = %s \n",stmt,stmt->class_name().c_str(),unparseViaTokenStream ? "true" : "false");
#endif
            // Only unparse from the token stream if this was not a transformed statement.
               unparseViaTokenStream = unparseViaTokenStream && (statementTransformed == false);

               if (unparseViaTokenStream == true)
                  {
                     int status = unparseStatementFromTokenStream(sourceFile,stmt,info,lastStatementOfGlobalScopeUnparsedUsingTokenStream);

                 // If we have unparsed this statement via the token stream then we don't have to unparse it from the AST (so return).
                    outputStatementAsTokens = (status == 0);
                  }
#if 0
               printf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }

       // Only unparse using the AST if this was not able to be unparsed from the token stream.
          if (outputStatementAsTokens == false)
             {
            // DQ (12/1/2013): Not clear if this is helpful or not (but it communicates in the 
            // unparsed code what statements were unparse using either the AST or the token stream).
               if ( SgProject::get_verbose() > 0 )
                  {
                    string s = "/* Unparsing from the AST stmt = " + stmt->class_name() + " */ ";
                    curprint (s);
                  }

            // bool skipOutputOfPreprocessingInfo = (isSgFunctionDefinition(stmt) != NULL);
               if (skipOutputOfPreprocessingInfo == false)
                  {
                 // DQ (11/30/2013): Move from above to where we can better support the token unparsing.
                    unparseAttachedPreprocessingInfo(stmt, info, PreprocessingInfo::before);
                  }

            // DQ (12/4/2007): Added to ROSE (was removed at some point).
               unparseLineDirectives(stmt);

            // DQ (7/19/2007): This only applies to Fortran where every statement can have a statement number (numeric lable, different from SgLabelStatement)
               unparseStatementNumbers(stmt,info);
#if 0
               printf ("In UnparseLanguageIndependentConstructs::unparseStatement(): Selecting an unparse function for stmt = %p = %s \n",stmt,stmt->class_name().c_str());
               curprint("/* In UnparseLanguageIndependentConstructs::unparseStatement(): Selecting an unparse function for stmt */ \n ");
#endif
               switch (stmt->variantT())
                  {
                    case V_SgGlobal:                        unparseGlobalStmt                    (stmt, info); break;
                    case V_SgFunctionTypeTable:             unparseFuncTblStmt                   (stmt, info); break;
                    case V_SgNullStatement:                 unparseNullStatement                 (stmt, info); break;

                 // DQ (11/29/2008): Added support for unparsing CPP directives now supported as IR nodes.
                    case V_SgIncludeDirectiveStatement:     unparseIncludeDirectiveStatement     (stmt, info); break;
                    case V_SgDefineDirectiveStatement:      unparseDefineDirectiveStatement      (stmt, info); break;
                    case V_SgUndefDirectiveStatement:       unparseUndefDirectiveStatement       (stmt, info); break;
                    case V_SgIfdefDirectiveStatement:       unparseIfdefDirectiveStatement       (stmt, info); break;
                    case V_SgIfndefDirectiveStatement:      unparseIfndefDirectiveStatement      (stmt, info); break;
                    case V_SgDeadIfDirectiveStatement:      unparseDeadIfDirectiveStatement      (stmt, info); break;
                    case V_SgIfDirectiveStatement:          unparseIfDirectiveStatement          (stmt, info); break;
                    case V_SgElseDirectiveStatement:        unparseElseDirectiveStatement        (stmt, info); break;
                    case V_SgElseifDirectiveStatement:      unparseElseifDirectiveStatement      (stmt, info); break;
                    case V_SgEndifDirectiveStatement:       unparseEndifDirectiveStatement       (stmt, info); break;
                    case V_SgLineDirectiveStatement:        unparseLineDirectiveStatement        (stmt, info); break;
                    case V_SgWarningDirectiveStatement:     unparseWarningDirectiveStatement     (stmt, info); break;
                    case V_SgErrorDirectiveStatement:       unparseErrorDirectiveStatement       (stmt, info); break;
                    case V_SgEmptyDirectiveStatement:       unparseEmptyDirectiveStatement       (stmt, info); break;
                    case V_SgIdentDirectiveStatement:       unparseIdentDirectiveStatement       (stmt, info); break;
                    case V_SgIncludeNextDirectiveStatement: unparseIncludeNextDirectiveStatement (stmt, info); break;
                    case V_SgLinemarkerDirectiveStatement:  unparseLinemarkerDirectiveStatement  (stmt, info); break;

                 // Liao 10/21/2010. Handle generic OpenMP directive unparsing here.
                    case V_SgOmpAtomicStatement:
                    case V_SgOmpSectionStatement:
                    case V_SgOmpTaskwaitStatement:
                    case V_SgOmpBarrierStatement:           unparseOmpSimpleStatement        (stmt, info);break;
                    case V_SgOmpThreadprivateStatement:     unparseOmpThreadprivateStatement (stmt, info);break;
                    case V_SgOmpFlushStatement:             unparseOmpFlushStatement         (stmt, info);break;

                 // Generic OpenMP directives with a format of : begin-directive, begin-clauses, body, end-directive , end-clauses
                    case V_SgOmpCriticalStatement:
                    case V_SgOmpMasterStatement:
                    case V_SgOmpOrderedStatement:
                    case V_SgOmpSectionsStatement:
                    case V_SgOmpParallelStatement:
                    case V_SgOmpTargetStatement:
                    case V_SgOmpTargetDataStatement:
                    case V_SgOmpWorkshareStatement:
                    case V_SgOmpSingleStatement:
                    case V_SgOmpTaskStatement:
                    case V_SgOmpSimdStatement:
                         unparseOmpGenericStatement (stmt, info); 
                         break;

                    default:
                      // DQ (11/4/2008): This is a bug for the case of a SgFortranDo statement, unclear what to do about this.
                      // Call the derived class implementation for C, C++, or Fortran specific language unparsing.
                      // unparseLanguageSpecificStatement(stmt,info);
                      // unp->repl->unparseLanguageSpecificStatement(stmt,info);
#if 0
                         printf ("In UnparseLanguageIndependentConstructs::unparseStatement(): Calling unparseLanguageSpecificStatement() for stmt = %p = %s \n",stmt,stmt->class_name().c_str());
#endif
                         unparseLanguageSpecificStatement(stmt,info);
                         break;
                  }

#if 0
               curprint("/* In UnparseLanguageIndependentConstructs::unparseStatement(): DONE Selecting an unparse function for stmt */ \n ");
#endif

            // DQ (5/8/2010): Reset the source code position in the AST.
               if (unp->get_resetSourcePosition() == true)
                  {
                    unp->resetSourcePosition(stmt);
                  }
             }
        }

#if 0
  // DQ (8/7/2012): I don't think we need this.
  // DQ (11/3/2007): Save the original scope so that we can restore it at the end (since we don't use a new SgUnparse_Info object).
     if (scopeStatement != NULL)
        {
       // DQ (12/5/2007): This assertion appears to work better.
          ROSE_ASSERT(savedScope != NULL || isSgGlobal(scopeStatement) != NULL);

#if 0
          printf ("At end of scope: Setting the current_scope in info: scopeStatement = %p = %s = %s \n",
               scopeStatement,scopeStatement->class_name().c_str(),SageInterface::get_name(scopeStatement).c_str());

          if (savedScope != NULL)
               printf ("At end of scope: Resetting using the savedScope = %p = %s = %s \n",
                    savedScope,savedScope->class_name().c_str(),SageInterface::get_name(savedScope).c_str());
#endif
          info.set_current_scope(NULL);
          info.set_current_scope(savedScope);
        }

  // DQ (12/5/2007): Check if the call to unparse any construct changes the scope stored in info.
  // This does error checking on ALL statements!
     SgScopeStatement* scopeAfterUnparseStatement = info.get_current_scope();
     if (savedScope != scopeAfterUnparseStatement)
        {
          printf ("WARNING: scopes stored in SgUnparse_Info object have been changed \n");
          ROSE_ASSERT(false);
        }
#endif

#if OUTPUT_EMBEDDED_COLOR_CODES_FOR_STATEMENTS
     if (get_embedColorCodesInGeneratedCode() > 0)
        {
          printColorCodes ( stmt, false, stateVector );
        }
#endif

  // DQ (7/20/2008): Part of new support for unparsing arbitrary strings into the unparsed code.
     if (unparseAttribute != NULL)
        {
          string code = unparseAttribute->toString(AstUnparseAttribute::e_after);
          curprint (code);
        }

  // DQ (comments) This is where new lines are output after the statement.
     unp->cur.format(stmt, info, FORMAT_AFTER_STMT);

  // Markus Kowarschik: This is the new code to unparse directives after the current statement
#if 0
     printf ("Output the comments and CCP directives for the SgStatement stmt = %p = %s (after) lastStatementOfGlobalScopeUnparsedUsingTokenStream = %s \n",stmt,stmt->class_name().c_str(),lastStatementOfGlobalScopeUnparsedUsingTokenStream ? "true" : "false");
#endif
  // unparseAttachedPreprocessingInfo(stmt, info, PreprocessingInfo::after);
  // if (outputStatementAsTokens == false)
     if (lastStatementOfGlobalScopeUnparsedUsingTokenStream == false)
        {
          unparseAttachedPreprocessingInfo(stmt, info, PreprocessingInfo::after);
        }
#if 0
     printf ("DONE: Output the comments and CCP directives for the SgStatement stmt = %p = %s (after) \n",stmt,stmt->class_name().c_str());
#endif

  // DQ (5/31/2005): special handling for compiler generated statements
     if (isSgGlobal(stmt) != NULL)
        {
       // printf ("Output template definitions after the final comments in the file \n");
          outputCompilerGeneratedStatements(info);
        }

#if OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES
     printf ("Leaving unparse statement (%p): sage_class_name() = %s name = %s \n",stmt,stmt->sage_class_name(),SageInterface::get_name(stmt).c_str());
  // printf ("Leaving unparse statement (%p): sage_class_name() = %s \n",stmt,stmt->sage_class_name());
  // curprint ( string("\n/* Bottom of unparseStatement: sage_class_name() = " + stmt->sage_class_name() + " */ \n";
     curprint ( string("\n/* Bottom of unparseStatement (" ) + StringUtility::numberToString(stmt) 
         + "): sage_class_name() = " + stmt->sage_class_name() + " */ \n");
#endif
   }


//-----------------------------------------------------------------------------------
//  void Unparse_ExprStmt::unparseExpression
//  
//  General unparse function for expressions. Then it routes to the appropriate 
//  function to unparse each kind of expression. Type and symbols still use the 
//  original unparse function because they don't have file_info and therefore, 
//  will not print out file information
//-----------------------------------------------------------------------------------
void
UnparseLanguageIndependentConstructs::unparseExpression(SgExpression* expr, SgUnparse_Info & info)
   {
  // directives(expr);

  // DQ (3/21/2004): This assertion should have been in place before now!
     ROSE_ASSERT (expr != NULL);

#if 0
     printf ("unparseExpression() (language independent = %s) expression (%p): %s compiler-generated = %s \n",languageName().c_str(),expr,expr->class_name().c_str(),expr->get_file_info()->isCompilerGenerated() ? "true" : "false");
     curprint(string("\n /*    unparseExpression(): class name  = ") + expr->class_name().c_str() + " */ \n");
#endif

#if OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES
  // DQ (8/21/2005): Suppress comments when unparsing to build type names
     if ( !info.SkipComments() || !info.SkipCPPDirectives() )
        {
          ROSE_ASSERT(expr->get_startOfConstruct() != NULL);
          ROSE_ASSERT(expr->get_file_info() != NULL);
          printf ("Unparse expression (%p): %s compiler-generated = %s \n",expr,expr->class_name().c_str(),expr->get_file_info()->isCompilerGenerated() ? "true" : "false");
          char buffer[100];
          snprintf (buffer,100,"%p",expr);
          curprint ( "\n/* Top of unparseExpression " + expr->class_name() 
              + " at: " + buffer 
              + " compiler-generated (file_info) = " + (expr->get_file_info()->isCompilerGenerated() ? "true" : "false")
              + " compiler-generated (startOfConstruct) = " + (expr->get_startOfConstruct()->isCompilerGenerated() ? "true" : "false") + " */ \n");
        }
#endif

     ROSE_ASSERT(expr != NULL);
     ROSE_ASSERT(expr->get_startOfConstruct() != NULL);
     ROSE_ASSERT(expr->get_file_info() != NULL);
     if (expr->get_file_info()->isCompilerGenerated() != expr->get_startOfConstruct()->isCompilerGenerated())
        {
          printf ("In unparseExpression(%p = %s): Detected error expr->get_file_info()->isCompilerGenerated() != expr->get_startOfConstruct()->isCompilerGenerated() \n",expr,expr->class_name().c_str());
          printf ("  -- expr->get_file_info() = %p expr->get_operatorPosition() = %p expr->get_startOfConstruct() = %p \n",expr->get_file_info(),expr->get_operatorPosition(),expr->get_startOfConstruct());

          printf ("  -- expr->get_file_info()->isCompilerGenerated()        = %s \n",expr->get_file_info()->isCompilerGenerated()        ? "true" : "false");
          printf ("  -- expr->get_startOfConstruct()->isCompilerGenerated() = %s \n",expr->get_startOfConstruct()->isCompilerGenerated() ? "true" : "false");

       // DQ (9/11/2011): Reorganize to make this better code that can be analyized using static analysis (static analysis tools don't understand access functions).
       // ROSE_ASSERT(expr->get_file_info()->get_parent() != NULL);
       // printf ("parent of file info = %p = %s \n",expr->get_file_info()->get_parent(),expr->get_file_info()->get_parent()->class_name().c_str());
          ROSE_ASSERT(expr != NULL);
          Sg_File_Info* fileInfo = expr->get_file_info();
          ROSE_ASSERT(fileInfo != NULL);
          SgNode* fileInfoParent = fileInfo->get_parent();
          ROSE_ASSERT(fileInfoParent != NULL);
          printf ("parent of file info = %p = %s \n",fileInfoParent,fileInfoParent->class_name().c_str());

       // DQ (9/11/2011): Reorganize to make this better code that can be analyized using static analysis (static analysis tools don't understand access functions).
       // expr->get_file_info()->display("expr->get_file_info(): debug");
       // expr->get_startOfConstruct()->display("expr->get_startOfConstruct(): debug");
          fileInfo->display("expr->get_file_info(): debug");

       // Sg_File_Info* startOfConstructFileInfo = expr->get_file_info();
          Sg_File_Info* startOfConstructFileInfo = expr->get_startOfConstruct();
          ROSE_ASSERT(startOfConstructFileInfo != NULL);
          startOfConstructFileInfo->display("expr->get_startOfConstruct(): debug");
        }
     ROSE_ASSERT(expr->get_file_info()->isCompilerGenerated() == expr->get_startOfConstruct()->isCompilerGenerated());

#if 0
     printf ("In unparseExpression(%p = %s) \n",expr,expr->class_name().c_str());
     expr->get_file_info()->display("unparseExpression (debug)");
#endif

  // DQ (12/5/2006): Let's ignore the case of a transformation for now!
     if (expr->get_endOfConstruct() == NULL && expr->get_file_info()->isTransformation() == false)
        {
          printf ("Error in unparseExpression(): expr = %p = %s expr->get_endOfConstruct() == NULL \n",expr,expr->class_name().c_str());
          expr->get_file_info()->display("unparseExpression (debug)");
        }
  // ROSE_ASSERT(expr->get_endOfConstruct() != NULL);

#if 0
  // DQ (10/25/2006): Debugging support for file info data for each IR node
     curprint ( "\n/* Top of unparseExpression " + string(expr->sage_class_name()) + " */\n ");
     ROSE_ASSERT (expr->get_startOfConstruct() != NULL);
     curprint ( "/* startOfConstruct: file = " << expr->get_startOfConstruct()->get_filenameString() 
         + " raw filename = " << expr->get_startOfConstruct()->get_raw_filename() 
         + " raw line = " << expr->get_startOfConstruct()->get_raw_line() 
         + " raw column = " << expr->get_startOfConstruct()->get_raw_col() 
         + " */\n ");
     if (expr->get_endOfConstruct() != NULL)
        {
          curprint ( "/* endOfConstruct: file = " << expr->get_endOfConstruct()->get_filenameString()
              + " raw filename = " << expr->get_endOfConstruct()->get_raw_filename() 
              + " raw line = " << expr->get_endOfConstruct()->get_raw_line() 
              + " raw column = " << expr->get_endOfConstruct()->get_raw_col() 
              + " */\n ");
        }
#endif

  // DQ (10/25/2006): Debugging support for file info data for each IR node
#define OUTPUT_EMBEDDED_COLOR_CODES_FOR_EXPRESSIONS 0
#if OUTPUT_EMBEDDED_COLOR_CODES_FOR_EXPRESSIONS
     vector< pair<bool,std::string> > stateVector;
     if (get_embedColorCodesInGeneratedCode() > 0)
        {
          setupColorCodes ( stateVector );
          printColorCodes ( expr, true, stateVector );
        }
#endif

#if 0
  // Liao 11/2/2010 Skip the case that an expression is located from another file (included in the current file)
  // I moved the code to the unparser function for SgAggregatedInitializer to have bigger picture about what to parse or not
     SgFile* cur_file = SageInterface::getEnclosingFileNode(expr);
     if (cur_file != NULL)
     {
       // normal file info 
       if (expr->get_file_info()->isTransformation() == false &&  expr->get_file_info()->isCompilerGenerated() ==false)
       {
         if (cur_file->get_file_info()->get_filename() != expr->get_file_info()->get_filename())
           return;
       }
     }
#endif

     if ( unparseLineReplacement(expr,info) )
        {
          return;
        }

  // DQ (7/19/2008): This is the new code to unparse directives before the current expression
     unparseAttachedPreprocessingInfo(expr, info, PreprocessingInfo::before);

  // MS 2003: experimental backend source replacement
  // Either use the source string attached to the AST by a transformation
  // (and do not traverse the subtree with 'epxr' as its root node)
  // OR unparse the expression (the whole subtree)
  // if (expr->attribute.exists("_UnparserSourceReplacement"))
  // if (expr->get_attribute() != NULL && expr->attribute().exists("_UnparserSourceReplacement"))

  // DQ (7/20/2008): This is now revised to handle more cases than just replacement of the 
  // AST subtree with a string.  Now we can add arbitrary text into different locations
  // relative to the specific IR node.  For now we are supporting before, replace, and after.

  // TV (04/22/11): More generic support of Original Expression Tree. Introduce to support function pointer cast
  //     in function pointer initialization (test2006_160.C)
     SgExpression* expressionTree = NULL; //expr->get_originalExpressionTree();
     switch (expr->variantT()) {
       case V_SgVarRefExp:
       {
         expressionTree = isSgExpression(isSgVarRefExp(expr)->get_originalExpressionTree());
         break;
       }
       case V_SgCastExp:
       {
         expressionTree = isSgExpression(isSgCastExp(expr)->get_originalExpressionTree());
         break;
       }
       default:
       {
         SgFunctionRefExp * func_ref = isSgFunctionRefExp(expr);
         if (func_ref) {
           expressionTree = isSgExpression(func_ref->get_originalExpressionTree());
         }
       }
     }
     
     AstUnparseAttribute* unparseAttribute = dynamic_cast<AstUnparseAttribute*>(expr->getAttribute(AstUnparseAttribute::markerName));
     if (unparseAttribute != NULL)
        {
          string code = unparseAttribute->toString(AstUnparseAttribute::e_before);
          curprint (code);
        }
        
  // Only replace the unparsing of the IR node with a string if a string is marked as AstUnparseAttribute::e_replace.
     if (unparseAttribute != NULL && unparseAttribute->replacementStringExists() == true)
        {
          string code = unparseAttribute->toString(AstUnparseAttribute::e_replace);
          curprint (code);
        }
       else if (expressionTree != NULL && info.SkipConstantFoldedExpressions() == false)
        {
          unparseExpression(expressionTree, info);
        }
       else
        {
       // DQ (5/21/2004): revised need_paren handling in EDG/SAGE III and within SAGE III IR)
       // QY (7/9/2004): revised to use the new unp->u_sage->PrintStartParen test
          bool printParen = requiresParentheses(expr,info);
#if 0
          curprint (string("\n/* In unparseExpression(): printParen = ") + (printParen ? "true" : "false") + " */ \n ");
#endif

#if 0
       // DQ (8/21/2005): Suppress comments when unparsing to build type names
          if ( !info.SkipComments() || !info.SkipCPPDirectives() )
             {
               string name = SageInterface::get_name(expr);
               SgFunctionCallExp* functionCall = isSgFunctionCallExp(expr);
               if (functionCall != NULL)
                  {
                    SgExpression* expression = functionCall->get_function();
                    SgDotExp* dotExp = isSgDotExp(expression);
                    if (dotExp != NULL)
                       {
                         SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(dotExp->get_lhs_operand());
                      // ROSE_ASSERT(memberFunctionRefExp != NULL);
                         if (memberFunctionRefExp != NULL)
                            {
                              SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp->get_symbol();
                              ROSE_ASSERT(memberFunctionSymbol != NULL);
                              name = memberFunctionSymbol->get_declaration()->get_name().str();
                            }
                           else
                            {
                              printf ("*** dotExp->get_lhs_operand() not processed: dotExp->get_lhs_operand() = %s \n",dotExp->get_lhs_operand()->class_name().c_str());
                            }
                       }
                      else
                       {
                         printf ("*** functionCall->get_function() not processed: functionCall->get_function() = %s \n",functionCall->get_function()->class_name().c_str());
                       }
                  }
                 else
                  {
                    printf ("*** expr not processed: expr = %s \n",expr->class_name().c_str());
                  }

            // curprint("\n /* In unparseExpression paren " + expr->class_name() + " paren printParen = " + (printParen ? "true" : "false") + " */ \n");
               curprint("\n /* In unparseExpression paren " + expr->class_name() + " name = " + name + " paren printParen = " + (printParen ? "true" : "false") + " */ \n");
             }
#endif

       // if (printParen)
       // ROSE_ASSERT(currentFile != NULL);
       // if ( (printParen == true) && (currentFile->get_Fortran_only() == false) )
          if (printParen == true)
             {
            // Make sure this is not an expresion list
               ROSE_ASSERT (isSgExprListExp(expr) == NULL);
#if 0
               curprint ("/* In unparseExpression(): output ( */ \n ");
#endif
            // Output the left paren
               curprint ("(");
             }

       // DQ (10/7/2004): Definitions should never be unparsed within code generation for expressions
          if (info.SkipClassDefinition() == false)
             {
            // printf ("Skip output of class definition in unparseExpression \n");
            // DQ (10/8/2004): Skip all definitions when outputing expressions!
            // info.set_SkipClassDefinition();
            // info.set_SkipDefinition();
             }

       // DQ (10/13/2006): Remove output of qualified names from this level of generality!
       // DQ (12/22/2005): Output any name qualification that is required 
       // (we only explicitly store the global scope qualification since 
       // this is all that it seems that EDG stores).
       // unparseQualifiedNameList(expr->get_qualifiedNameList());

          switch (expr->variant())
             {
            // DQ (4/18/2013): I don't think this is ever called this way, IR node resolve to the derived classes not the base classes.
               case UNARY_EXPRESSION:
                  {
                    printf ("This should never be called: case UNARY_EXPRESSION\n");
                    ROSE_ASSERT(false);

                    unparseUnaryExpr (expr, info);
                    break; 
                  }

            // DQ (4/18/2013): I don't think this is ever called this way, IR node resolve to the derived classes not the base classes.
               case BINARY_EXPRESSION:
                  {
                    printf ("This should never be called: case BINARY_EXPRESSION\n");
                    ROSE_ASSERT(false);

                    unparseBinaryExpr(expr, info);
                    break;
                  }

            // DQ (8/15/2007): This has been moved to the base class
               case EXPR_LIST: { unparseExprList(expr, info); break; }

            // DQ: These cases are separated out so that we can handle the 
            // original expression tree from any possible constant folding by EDG.
               case BOOL_VAL:
               case SHORT_VAL:
               case CHAR_VAL:
               case UNSIGNED_CHAR_VAL:
               case WCHAR_VAL:
               case STRING_VAL:
               case UNSIGNED_SHORT_VAL:
               case ENUM_VAL:
               case INT_VAL:
               case UNSIGNED_INT_VAL:
               case LONG_INT_VAL:
               case LONG_LONG_INT_VAL:
               case UNSIGNED_LONG_LONG_INT_VAL:
               case UNSIGNED_LONG_INT_VAL:
               case FLOAT_VAL:
               case DOUBLE_VAL:
               case LONG_DOUBLE_VAL:
               case COMPLEX_VAL:
                  {
                    unparseValue(expr, info);
                    break;
                  }

               default:
                  {
                 // Call the derived class implementation for C, C++, or Fortran specific language unparsing.
                    unparseLanguageSpecificExpression(expr,info);

                    break;
                  }
      
             }

          if (printParen)
             {
#if 0
               curprint ("/* In unparseExpression(): output ) */ \n ");
#endif
            // Output the right paren
               curprint (")");
             }

       // calls the logical_unparse function in the sage files
       // expr->logical_unparse(info, curprint);
        } // unparse source replacement END

#if OUTPUT_EMBEDDED_COLOR_CODES_FOR_EXPRESSIONS
     if (get_embedColorCodesInGeneratedCode() > 0)
        {
          printColorCodes ( expr, false, stateVector );
        }
#endif

  // DQ (7/20/2008): Part of new support for unparsing arbitrary strings into the unparsed code.
     if (unparseAttribute != NULL)
        {
          string code = unparseAttribute->toString(AstUnparseAttribute::e_after);
          curprint (code);
        }

  // DQ (7/19/2008): This is the new code to unparse directives before the current expression
     unparseAttachedPreprocessingInfo(expr, info, PreprocessingInfo::after);

#if OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES
  // DQ (8/21/2005): Suppress comments when unparsing to build type names
     if ( !info.SkipComments() || !info.SkipCPPDirectives() )
        {
          printf ("Leaving unparse expression (%p): sage_class_name() = %s \n",expr,expr->sage_class_name());
       // unp->u->sage->curprint ( "\n/* Bottom of unparseExpression " << string(expr->sage_class_name()) << " */ \n");
          curprint ( "\n/* Bottom of unparseExpression " + expr->class_name() + " */ \n");
        }
#endif
   }

#if 0
void
UnparseLanguageIndependentConstructs::unparseLanguageSpecificStatement  (SgStatement* stmt,  SgUnparse_Info& info)
   {
     printf ("Error: base class implementation of unparseLanguageSpecificStatement called \n");
     ROSE_ASSERT(false);
   }
#endif
#if 0
void
UnparseLanguageIndependentConstructs::unparseLanguageSpecificExpression (SgExpression* expr, SgUnparse_Info& info)
   {
     printf ("Error: base class implementation of unparseLanguageSpecificExpression called \n");
     ROSE_ASSERT(false);
   }
#endif

void
UnparseLanguageIndependentConstructs::unparseNullStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
  // Nothing to do here! (unless we need a ";" or something)
     SgNullStatement* nullStatement = isSgNullStatement(stmt);
     ROSE_ASSERT(nullStatement != NULL);

#if 0
     printf ("In unparseNullStatement() stmt = %p \n",stmt);
#endif

  // Not much to do here except output a ";", not really required however.
     if (!info.inConditional() && !info.SkipSemiColon())
        {
          curprint ( string(";"));
        }
       else
        {
#if 0
          printf ("In unparseNullStatement() stmt = %p (skipped output of semi-colon) info.inConditional() = %s info.SkipSemiColon() = %s \n",stmt,info.inConditional() ? "true" : "false",info.SkipSemiColon() ? "true" : "false");
#endif
        }
   }

void
UnparseLanguageIndependentConstructs::unparseNullExpression (SgExpression* expr, SgUnparse_Info& info)
   {
  // Nothing to do here! (unless we need a ";" or something)
#if 0
     printf ("In unparseNullExpression() expr = %p \n",expr);
#endif
   }


bool 
UnparseLanguageIndependentConstructs::isTransformed(SgStatement* stmt)
   {
  // This function must traverse the AST and look for any sign that 
  // the subtree has been transformed.  This might be a difficult 
  // function to write.  We might have to force transformations to
  // do something to make their presence better known (e.g. removing
  // a statement will leave no trace in the AST of the transformation).

  // DQ (3/2/2005): Change this to see if we can output each specialization 
  // as if we were transforming each template specialization
  // Assume no transformation at the moment while we debug templates.

  // DQ (6/29/2005): return false while we try to return to compiling KULL
#if 1
     return false;
#else

#error "DEAD CODE!"

     return true;
#endif
   }


void
UnparseLanguageIndependentConstructs::unparseGlobalStmt (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgGlobal* globalScope = isSgGlobal(stmt);
     ROSE_ASSERT(globalScope != NULL);

#if 0
     printf ("\n ***** Unparsing the global Scope ***** \n\n");
#endif

#if OUTPUT_DEBUGGING_FUNCTION_BOUNDARIES
     printf ("global scope file = %s \n",TransformationSupport::getSourceFile(globalScope)->getFileName().c_str());
     printf ("global scope size = %ld \n",globalScope->get_declarations().size());
#endif

#if OUTPUT_HIDDEN_LIST_DATA
     outputHiddenListData (globalScope);
#endif

#if 0
     curprint(string(" /* In unparseGlobalStmt(): global scope size = ") + StringUtility::numberToString(globalScope->get_declarations().size()) + " */ \n ");
#endif

#if 0
     int declarationCounter = 0;
#endif

  // Setup an iterator to go through all the statements in the top scope of the file.
     SgDeclarationStatementPtrList & globalStatementList = globalScope->get_declarations();
     SgDeclarationStatementPtrList::iterator statementIterator = globalStatementList.begin();
     while ( statementIterator != globalStatementList.end() )
        {
          SgStatement* currentStatement = *statementIterator;
          ROSE_ASSERT(currentStatement != NULL);

#if 0
          printf ("In unparseGlobalStmt(): declaration #%d is %p = %s = %s \n",declarationCounter++,currentStatement,currentStatement->class_name().c_str(),SageInterface::get_name(currentStatement).c_str());
#endif

          if (ROSE_DEBUG > 3)
             {
            // (*primary_os)
               cout << "In run_unparser(): getLineNumber(currentStatement) = "
#if 1
                    << currentStatement->get_file_info()->displayString()
#else
                    << ROSE::getLineNumber(currentStatement)
                    << " getFileName(currentStatement) = " 
                    << ROSE::getFileName(currentStatement)
#endif
                    << " unp->cur_index = " 
                    << unp->cur_index
                    << endl;
             }

       // DQ (6/4/2007): Make a new SgUnparse_Info object for each statement in global scope
       // This should permit children to set the current_scope and not effect other children
       // see test2007_56.C for example "namespace A { extern int x; } int A::x = 42;"
       // Namespace definition scope should not effect scope set in SgGlobal.
       // unparseStatement(currentStatement, info);
          SgUnparse_Info infoLocal(info);
          unparseStatement(currentStatement, infoLocal);

       // Go to the next statement
          statementIterator++;
        }

  // DQ (5/27/2005): Added support for compiler-generated statements that might appear at the end of the applications
  // printf ("At end of unparseGlobalStmt \n");
  // outputCompilerGeneratedStatements(info);

#if 0
     curprint(string(" /* Leaving unparseGlobalStmt(): global scope size = ") + StringUtility::numberToString(globalScope->get_declarations().size()) + " */ \n ");
#endif

#if 0
     printf ("Leaving UnparseLanguageIndependentConstructs::unparseGlobalStmt() \n\n");
#endif

  // DQ (4/21/2005): Output a new line at the end of the file (some compilers complain if this is not present)
     unp->cur.insert_newline(1);
   }


void
UnparseLanguageIndependentConstructs::unparseFuncTblStmt(SgStatement* stmt, SgUnparse_Info& info)
   {
     SgFunctionTypeTable* functbl_stmt = isSgFunctionTypeTable(stmt);
     ROSE_ASSERT(functbl_stmt != NULL);

     stringstream  out;
     functbl_stmt->print_functypetable(out);
     curprint ( out.str());
   }


// DQ (8/13/2007): Who wrote this?  Why is not "basic_stmt->get_statements().size();" enough!
//--------------------------------------------------------------------------------
//  void Unparse_ExprStmt::num_stmt_in_block
//
//  returns the number of statements in the basic block
//--------------------------------------------------------------------------------  
int
UnparseLanguageIndependentConstructs::num_stmt_in_block(SgBasicBlock* basic_stmt)
   {
  // counter to keep number of statements in the block
     int num_stmt = 0;
     SgStatementPtrList::iterator p = basic_stmt->get_statements().begin();
     while (p != basic_stmt->get_statements().end())
        {
          num_stmt++;
          p++;
        }

     return num_stmt;
   }

bool UnparseLanguageIndependentConstructs::unparseLineReplacement(
   SgLocatedNode* stmt,
   SgUnparse_Info& info
    )
{
  int replacedLines = 0;
  // Get atached preprocessing info
  AttachedPreprocessingInfoType *prepInfoPtr= stmt->getAttachedPreprocessingInfo();
  if (prepInfoPtr == NULL)
  {
    // There's no preprocessing info attached to the current statement
    // printf ("No comments or CPP directives associated with this statement ... \n");
    return replacedLines;
  }

  // If we are skiping BOTH comments and CPP directives then there is nothing to do
  if ( info.SkipComments() && info.SkipCPPDirectives() )
  {
    // There's no preprocessing info attached to the current statement
    // printf ("Skipping output or comments and CPP directives \n");
    return replacedLines;
  }

#if 0
  info.display("In Unparse_ExprStmt::unparseLineReplacement()");
#endif

  // Traverse the container of PreprocessingInfo objects
  AttachedPreprocessingInfoType::iterator i;
  for(i = prepInfoPtr->begin(); i != prepInfoPtr->end(); ++i)
  {
    // i ist a pointer to the current prepInfo object, print current preprocessing info
    // Assert that i points to a valid preprocssingInfo object
    ROSE_ASSERT ((*i) != NULL);
    ROSE_ASSERT ((*i)->getTypeOfDirective()  != PreprocessingInfo::CpreprocessorUnknownDeclaration);
    ROSE_ASSERT ((*i)->getRelativePosition() == PreprocessingInfo::before || 
        (*i)->getRelativePosition() == PreprocessingInfo::after  ||
        (*i)->getRelativePosition() == PreprocessingInfo::inside);

#if 0
    printf ("Stored comment: (*i)->getRelativePosition() = %s (*i)->getString() = %s \n",
        ((*i)->getRelativePosition() == PreprocessingInfo::before) ? "before" : "after",
        (*i)->getString().c_str());
#endif

    // Check and see if the info object would indicate that the statement would 
    // be printed, if not then don't print the comments associated with it.
    // These might have to be handled on a case by case basis.
    // bool infoSaysGoAhead = !info.SkipDefinition();
    bool infoSaysGoAhead = !info.SkipEnumDefinition()  &&
      !info.SkipClassDefinition() &&
      !info.SkipFunctionDefinition();

    // DQ (7/19/2008): Allow expressions to have there associated comments unparsed.
    infoSaysGoAhead = (infoSaysGoAhead == true) || (isSgExpression(stmt) != NULL);

#if 0
    printf ("(*i)->getRelativePosition() == whereToUnparse (matches == %s) \n",(*i)->getRelativePosition() == whereToUnparse ? "true" : "false");
    printf ("unp->opt.get_unparse_includes_opt() == %s \n",(unp->opt.get_unparse_includes_opt() == true) ? "true" : "false");
#endif


    switch ( (*i)->getTypeOfDirective() )
    {
      case PreprocessingInfo::LineReplacement:

        if(isSgExpression(stmt) == NULL ) //Do this when line replacement matches a whole statement
          unp->cur.format(stmt, info, FORMAT_BEFORE_DIRECTIVE);

        curprint ( (*i)->getString());
  //      unp->cur.format(stmt, info, FORMAT_AFTER_DIRECTIVE);

        replacedLines++;
        break;
      default:
        break;
    }

  }

  //there should only be one linereplacement directive for a statement
  ROSE_ASSERT(replacedLines <= 1);
  return replacedLines;
};


void
UnparseLanguageIndependentConstructs::unparseAttachedPreprocessingInfo(
// SgStatement* stmt,
   SgLocatedNode* stmt,
   SgUnparse_Info& info,
   PreprocessingInfo::RelativePositionType whereToUnparse)
   {
  // Get atached preprocessing info
     AttachedPreprocessingInfoType *prepInfoPtr = stmt->getAttachedPreprocessingInfo();

#if 0
  // Debugging added by DQ (only output debug information if comments/directives exist for this statement).
     if ( (prepInfoPtr != NULL) && (prepInfoPtr->empty() == false) )
        {
          printf ("\n\n");
          printf ("****************************************************************************** \n");
          printf ("In Unparse_ExprStmt::unparseAttachedPreprocessingInfo(%p = %s): whereToUnparse = %s \n",
               stmt,stmt->sage_class_name(),
               (whereToUnparse == PreprocessingInfo::before) ? "before" : "after");
          printf ("stmt->get_startOfConstruct() = %p stmt->get_endOfConstruct() = %p \n",stmt->get_startOfConstruct(),stmt->get_endOfConstruct());
          stmt->get_startOfConstruct()->display("startOfConstruct");
          if (stmt->get_endOfConstruct() != NULL)
             {
               stmt->get_endOfConstruct()->display("endOfConstruct");
             }
            else
             {
               printf ("Error in unparseAttachedPreprocessingInfo, stmt->get_endOfConstruct() == NULL: stmt = %p = %s = %s \n",
                    stmt,stmt->class_name().c_str(),SageInterface::get_name(stmt).c_str());
             }
          printOutComments (stmt);
        }
#endif

     if (prepInfoPtr == NULL)
        {
       // There's no preprocessing info attached to the current statement
#if 0
          printf ("No comments or CPP directives associated with this statement ... \n");
#endif
          return;
        }

  // If we are skiping BOTH comments and CPP directives then there is nothing to do
     if ( info.SkipComments() && info.SkipCPPDirectives() )
        {
       // There's no preprocessing info attached to the current statement
#if 0
          printf ("Skipping output or comments and CPP directives \n");
#endif
          return;
        }

#if 0
     info.display("In Unparse_ExprStmt::unparseAttachedPreprocessingInfo()");
#endif

  // Traverse the container of PreprocessingInfo objects
     AttachedPreprocessingInfoType::iterator i;
     for(i = prepInfoPtr->begin(); i != prepInfoPtr->end(); ++i)
        {
       // i ist a pointer to the current prepInfo object, print current preprocessing info
       // Assert that i points to a valid preprocssingInfo object
          ROSE_ASSERT ((*i) != NULL);
          ROSE_ASSERT ((*i)->getTypeOfDirective()  != PreprocessingInfo::CpreprocessorUnknownDeclaration);
          ROSE_ASSERT ((*i)->getRelativePosition() == PreprocessingInfo::before || 
                       (*i)->getRelativePosition() == PreprocessingInfo::after  ||
                       (*i)->getRelativePosition() == PreprocessingInfo::inside);

#if 0
       // DQ (1/28/2013): Fixed to use output of PreprocessingInfo::relativePositionName() and thus provide more accurate debug information.
          printf ("Stored comment: (*i)->getRelativePosition() = %s (*i)->getString() = %s \n",
            // ((*i)->getRelativePosition() == PreprocessingInfo::before) ? "before" : "after",
               PreprocessingInfo::relativePositionName((*i)->getRelativePosition()).c_str(),
               (*i)->getString().c_str());
#endif

       // Check and see if the info object would indicate that the statement would 
       // be printed, if not then don't print the comments associated with it.
       // These might have to be handled on a case by case basis.
       // bool infoSaysGoAhead = !info.SkipDefinition();
          bool infoSaysGoAhead = !info.SkipEnumDefinition()  &&
                                 !info.SkipClassDefinition() &&
                                 !info.SkipFunctionDefinition();

       // DQ (7/19/2008): Allow expressions to have there associated comments unparsed.
       // Liao 11/9/2010: allow SgInitializedName also
       // negara1 (08/15/2011): Allow SgHeaderFileBody as well.
          infoSaysGoAhead = (infoSaysGoAhead == true) || (isSgExpression(stmt) != NULL) || (isSgInitializedName (stmt) != NULL) || (isSgHeaderFileBody(stmt) != NULL);

#if 0
          printf ("infoSaysGoAhead = %s \n",infoSaysGoAhead ? "true" : "false");
#endif

#if 0
          static int counter = 0;
          counter++;
          if (counter > 3)
             {
               printf ("Exiting in Unparse_ExprStmt::unparseAttachedPreprocessingInfo() \n");
               ROSE_ABORT();
             }
#endif

       // DQ (2/5/2003):
       // The old directive handling allows all the test codes to parse properly, but
       // is not sufficent for handling the A++ transformations which are more complex.
       // I am trying to recover the old way which permitted all the test codes to work
       // before I fix it to be consistant with how it must work for the A++ transformation
       // to work properly.  This is work that was unfinished by Markus K. summer 2002.
       // (Though he did do a great job not enough information was provided in SAGE from EDG 
       // to finish it (I think)).

       // DQ (2/18/2003): Work to allow all CPP directives to be unparsed correctly on a statement
       //                 by statement basis has been completed, tested, and checked in.

#if 0
          printf ("(*i)->getRelativePosition() == whereToUnparse (matches == %s) \n",(*i)->getRelativePosition() == whereToUnparse ? "true" : "false");
          printf ("unp->opt.get_unparse_includes_opt() == %s \n",(unp->opt.get_unparse_includes_opt() == true) ? "true" : "false");
#endif
          if (infoSaysGoAhead && (*i)->getRelativePosition() == whereToUnparse)
             {

               unp->cur.format(stmt, info, FORMAT_BEFORE_DIRECTIVE);

            // DQ (7/19/2008): If we can assert this, then we can simpleify the code below!
            // It is turned on in the tests/roseTests/programTransformationTests/implicitCodeGenerationTest.C
            // But I still don't know what it does.
            // ROSE_ASSERT(unp->opt.get_unparse_includes_opt() == false);

               if (unp->opt.get_unparse_includes_opt() == true)
                  {
                 // DQ (9/16/2013): This is an error for C style comments spanning more than one line.
                 // To fix this just unparse the comment directly, since the syntax to make it a comment 
                 // is included in the string.
                 // Original comment: If we are unparsing the include files then we can simplify the 
                 // CPP directive processing and unparse them all as comments!
                 // Comments can also be unparsed as comments (I think!).
                 // curprint (  "// " + (*i)->getString());

                 // DQ (9/16/2013): New version of code.
                    switch ( (*i)->getTypeOfDirective() )
                       {
                      // Comments don't have to be further commented
                         case PreprocessingInfo::FortranStyleComment:
                         case PreprocessingInfo::F90StyleComment:
                         case PreprocessingInfo::C_StyleComment:
                         case PreprocessingInfo::CplusplusStyleComment:
                              if ( !info.SkipComments() )
                                 {
                                   curprint ( (*i)->getString());
                                 }
                              break;

                         default:
                            {
                              if ((*i)->getNumberOfLines() == 1)
                                 {
                                // DQ (9/16/2013): Commented out single line CPP directives is easy, so go ahead and do that.
                                // This used later style C comment syntax.  This permits the user to see the original CPP
                                // directives in a way that they will have no effect.
                                   curprint("// " + (*i)->getString());
                                 }
                                else
                                 {
                                // DQ (9/16/2013): Multi-line CPP directives are a bit more complex so ignore them.
                                   curprint("/* multi-line CPP directive ignored (no robust way to comment them out yet implemented) */\n");
                                 }
                            }
                       }
                  }
                 else
                  {
                 // DQ (1/28/2013): Fixed indentation of code block.
                    switch ( (*i)->getTypeOfDirective() )
                       {
                      // All #include directives are unparsed so that we can make the 
                      // output codes as similar as possible to the input codes. This also
                      // simplifies the debugging. On the down side it sets up a chain of 
                      // problems that force us to unparse most of the other directives 
                      // which makes the unparsing a bit more complex.
                         case PreprocessingInfo::CpreprocessorIncludeDeclaration:
                         case PreprocessingInfo::CpreprocessorIncludeNextDeclaration:
                              if ( !info.SkipComments() )
                                 {
                                   ROSE_ASSERT(unp->opt.get_unparse_includes_opt() == false);
#if 1
                                // DQ (9/16/2013): This is simpler code.
                                   curprint((*i)->getString());
#else
                                // DQ (9/16/2013): This predicate should be always false.
                                   if (unp->opt.get_unparse_includes_opt() == true)
                                        curprint ( string("// " ) + (*i)->getString());
                                     else
                                        curprint ( (*i)->getString());
#endif
                                 }
                              break;

                      // Comments don't have to be further commented
                         case PreprocessingInfo::FortranStyleComment:
                         case PreprocessingInfo::F90StyleComment:
                         case PreprocessingInfo::C_StyleComment:
                         case PreprocessingInfo::CplusplusStyleComment:
                              if ( !info.SkipComments() )
                                 {
                                   curprint ( (*i)->getString());
                                 }
                              break;

                      // extern declarations must be handled as comments since the EDG frontend strips them away
                         case PreprocessingInfo::ClinkageSpecificationStart:
                         case PreprocessingInfo::ClinkageSpecificationEnd:
                              if ( !info.SkipComments() )
                                 {
                                   if (unp->opt.get_unparse_includes_opt() == true)
                                        curprint (  string("// ") + (*i)->getString());
                                     else
                                        curprint ( (*i)->getString());
                                 }
                              break;

                      // Must unparse these because they could hide a #define 
                      // directive which would then be seen e.g.
                      //      #if 0
                      //      #define printf parallelPrintf
                      //      #endif
                      // So because we unparse the #define we must unparse 
                      // the #if, #ifdef, #else, and #endif directives.
                      // line declarations should also appear in the output 
                      // to permit the debugger to see the original code
                         case PreprocessingInfo::CpreprocessorIfdefDeclaration:
                         case PreprocessingInfo::CpreprocessorIfndefDeclaration:
                         case PreprocessingInfo::CpreprocessorIfDeclaration:
                      // Rama (08/17/07): Adding support so that pseudo-comments can be attached properly.
                         case PreprocessingInfo::CpreprocessorDeadIfDeclaration:
                         case PreprocessingInfo::CpreprocessorElseDeclaration:
                         case PreprocessingInfo::CpreprocessorElifDeclaration:
                         case PreprocessingInfo::CpreprocessorEndifDeclaration:
                         case PreprocessingInfo::CpreprocessorLineDeclaration:
                      // AS(120506) Added support for skipped tokens for Wave
                         case PreprocessingInfo::CSkippedToken: 
                              if ( !info.SkipComments() )
                                 {
                                   if (unp->opt.get_unparse_includes_opt() == true)
                                      {
                                        curprint ( string("// (previously processed: ignored) " ) + (*i)->getString());
                                      }
                                     else
                                      {
                                        curprint ( (*i)->getString());
                                      }
                                 }
                                else
                                 {
                                   curprint ( (*i)->getString());
                                 }
                              break;

                      // Comment out these declarations where they occur because we don't need
                      // them (they have already been evaluated by the front-end and would be
                      // redundent).
                         case PreprocessingInfo::CpreprocessorWarningDeclaration:
                         case PreprocessingInfo::CpreprocessorErrorDeclaration:
                         case PreprocessingInfo::CpreprocessorEmptyDeclaration:
                              if ( !info.SkipCPPDirectives() )
                                 {
                                // DQ (11/29/2006): Let's try to generate code which handles these better.
                                // curprint ( string("// (previously processed: ignored) " + (*i)->getString() ;
                                   curprint ( (*i)->getString());
                                 }
                              break;

                      // We skip commenting out these cases for the moment
                      // We must unparse these since they could control the path 
                      // taken in header files included separately e.g.
                      //      #define OPTIMIZE_ME
                      //      // optimization.h could include two paths dependent on the value of OPTIMIZE_ME
                      //      #include "optimization.h"
                         case PreprocessingInfo::CpreprocessorDefineDeclaration:
                         case PreprocessingInfo::CpreprocessorUndefDeclaration:
                              if ( !info.SkipCPPDirectives() )
                                 {
                                   if (unp->opt.get_unparse_includes_opt() == true)
                                      {
                                        curprint(string("// (previously processed: ignored) " ) + (*i)->getString());
                                      }
                                     else
                                      {
                                     // curprint((*i)->getString());

                                     // DQ (12/30/2013): Handle the case of a self referential macro declaration e.g. "#define foo  X->foo".
                                        if ((*i)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorDefineDeclaration)
                                           {
#if 0
                                             printf ("In unparser: CPP macro = %s \n",(*i)->getString().c_str());
#endif
                                          // We need to supress the output of self-referential macros since they will be expanded 
                                          // twice in the back-end compilation of the ROSE generated code.
                                             bool isSelfReferential = (*i)->isSelfReferential();
#if 0
                                             printf ("In unparser: isSelfReferential = %s CPP macro = %s \n",isSelfReferential ? "true" : "false",(*i)->getString().c_str());
#endif
                                             if (isSelfReferential == true)
                                                {
#if 1
                                               // DQ (12/31/2013): Note that the final CR is a part of the CPP #define directive (so we don't need another one).
                                                  printf ("Detected self-referential macro (supressed in generated code) macro = %s ",(*i)->getString().c_str());
#endif
                                               // DQ (12/31/2013): We can't use /* */ to comment out the #define macro since it might also include a "/* ... */" substring.
                                               // curprint(string("/* (previously processed: ignoring self-referential macro declaration) " ) + (*i)->getString() + " */\n");
                                               // curprint(string("// (previously processed: ignoring self-referential macro declaration) " ) + (*i)->getString() + " \n");
#if 0
                                                  if ((*i)->getNumberOfLines() == 1)
                                                     {
                                                    // DQ (1/21/2014): This reports: "error: stray '#' in program"
                                                    // curprint(string("// (previously processed: ignoring self-referential macro declaration) " ) + (*i)->getString() + " \n");
                                                       curprint(string("// (previously processed: ignoring self-referential macro declaration) " ) + (*i)->getMacroName() + " \n");
                                                     }
                                                    else
                                                     {
                                                       ROSE_ASSERT((*i)->getNumberOfLines() > 1);
                                                       curprint(string("/* (previously processed: ignoring self-referential macro declaration) " ) + (*i)->getMacroName() + " */\n");
                                                     }
#else
                                               // DQ (1/21/2014): This has to be a C style comments for the options used in Valgrind compilation (not C99, I think).
                                                  curprint(string("/* (previously processed: ignoring self-referential macro declaration) macro name = " ) + (*i)->getMacroName() + " */ \n");
#endif
                                                }
                                               else
                                                {
                                                  curprint((*i)->getString());
                                                }
                                           }
                                          else
                                           {
                                             curprint((*i)->getString());
                                           }
                                      }
                                 }
                              break;

                         case PreprocessingInfo::CpreprocessorUnknownDeclaration:
                              printf ("Error: CpreprocessorUnknownDeclaration found \n");
                              ROSE_ABORT();
                              break;
                         case PreprocessingInfo::CMacroCall:
                           // AS(1/04/07) Macro rewrapping is currently not supported
                              break;
                         case PreprocessingInfo::CMacroCallStatement:
                              curprint ( (*i)->getString());
                              break;

                         case PreprocessingInfo::LineReplacement:
                              break;

                         case PreprocessingInfo::CpreprocessorIdentDeclaration:
                              curprint ( (*i)->getString());
                              break;

                         case PreprocessingInfo::CpreprocessorCompilerGeneratedLinemarker:
                              curprint ( (*i)->getString());
                              break;

                         default:
                              printf ("Error: default reached in switch in Unparse_ExprStmt::unparseAttachedPreprocessingInfo()\n");
                              ROSE_ABORT();
                       }
                  }

            // DQ (7/19/2008): Moved from outer nested scope level (below)
               unp->cur.format(stmt, info, FORMAT_AFTER_DIRECTIVE);
             }

       // DQ (7/19/2008): Moved to previous nested scope level
       // unp->cur.format(stmt, info, FORMAT_AFTER_DIRECTIVE);
        }
   }



void
UnparseLanguageIndependentConstructs::unparseUnaryExpr(SgExpression* expr, SgUnparse_Info& info) 
   {
#if 0
     printf ("In unparseUnaryExpr(): expr = %p = %s \n",expr,expr->class_name().c_str());
     curprint ("\n /* Inside of unparseUnaryExpr */ \n");
     curprint (string("/* Inside of unparseUnaryExpr() expr = ") + expr->class_name() + " */ \n");
     unp->u_debug->printDebugInfo("entering unparseUnaryExpr", true);
#endif

#if 0
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif

     SgUnaryOp* unary_op = isSgUnaryOp(expr);
     ROSE_ASSERT(unary_op != NULL);

  // int toplevel_expression = !info.get_nested_expression();

     info.set_nested_expression();

  //
  // Flag to indicate whether the operand contains an overloaded arrow operator
  //
     bool arrow_op = false;
     arrow_op = unp->u_sage->NoDereference(expr);

#if 0
     printf ("In Unparse_ExprStmt::unparseUnaryExpr: unary_op->get_parent() = %s pointer \n",
          (unary_op->get_parent() != NULL) ? "VALID" : "NULL");
  // printf ("In Unparse_ExprStmt::unparseUnaryExpr: toplevel_expression = %d arrow_op = %d \n",toplevel_expression,arrow_op);
#endif

  // We have to test to see if the operand associated with this unary expression is a function pointer 
  // then we can use either function pointer calling syntax
  // (for void (*functionPointer) (int) as a declaration):
  //      1) functionPointer (x);
  //      2) (*functionPointer) (x);
  // Either is valid syntax (see Stroustrup (2nd Edition) section 7.7 "Pointer to Function" page 156.)
  // It seems that EDG and SAGE represent the two similarly, so we have to choose which format we 
  // want to have in the unparsing. Likely this should be an option to the unparser.

  // bool isFunctionType = (isSgFunctionType(unary_op->get_type()) != NULL) ? true : false;

#if 0
     printf ("unary_op->get_mode() != SgUnaryOp::postfix is %s \n",(unary_op->get_mode() != SgUnaryOp::postfix) ? "true" : "false");
     printf ("In Unparse_ExprStmt::unparseUnaryExpr: arrow_op = %s \n",arrow_op ? "true" : "false");
  // printf ("isFunctionType = %s \n",(isFunctionType == true) ? "true" : "false");

     printf ("unary_op->get_operand()->class_name() = %s \n",unary_op->get_operand()->class_name().c_str());
     printf ("unary_op->get_type()->class_name()    = %s \n",unary_op->get_type()->class_name().c_str());
     printf ("info.get_operator_name()              = %s \n",info.get_operator_name().c_str());
#endif

  // DQ (2/22/2005): Ignoring if this is a SgFunctionType (test ...)
  // Bugfix (2/26/2001) If this is for a function pointer then skip printing out 
  // the operator name (for dereferencing operator)
#if 1
  // if (unary_op->get_mode() != SgUnaryOp::postfix && !arrow_op)
     if (unary_op->get_mode() != SgUnaryOp::postfix)
#else
#error "DEAD CODE!"
     if (unary_op->get_mode() != SgUnaryOp::postfix && !arrow_op && !isFunctionType)
#endif
        {
       // curprint ( "\n /* Unparsing a prefix unary operator */ \n";
       // DQ (2/25/2005): Trap case of SgPointerDerefExp so that "*" can't be 
       // turned into "/*" if preceeded by a SgDivideOp or overloaded "operator/()"
       // Put in an extra space so that if this happens we only generate "/ *"
       // test2005_09.C demonstrates this bug!
          if (isSgPointerDerefExp(expr) != NULL)
             {
               curprint(" ");
             }
          curprint(info.get_operator_name());
        }

#if 0
     printf ("In unparseUnaryExpr(): info.isPrefixOperator() = %s \n",info.isPrefixOperator() ? "true" : "false");
#endif

  // DQ (1/25/2014): Added support to avoid unparsing "- -5" as "--5".
     SgValueExp* valueExp = isSgValueExp(unary_op->get_operand());
     SgMinusOp* minus_op = isSgMinusOp(unary_op);
     if (minus_op != NULL && valueExp != NULL)
        {
       // We need to make sure we don't unparse: "- -5" as "--5".
       // I think we need an isNegative() query function so that we could refine this test to only apply to negative literals.
#if 0
          printf ("We need to make sure we don't unparse: \"- -5\" as \"--5\" \n");
#endif
          curprint(" ");
        }

#if 0
     curprint ("\n /* Calling unparseExpression from unparseUnaryExpr */ \n");
#endif
     unparseExpression(unary_op->get_operand(), info);
#if 0
     curprint ("\n /* DONE: Calling unparseExpression from unparseUnaryExpr */ \n");
#endif

     if (unary_op->get_mode() == SgUnaryOp::postfix && !arrow_op)
        {
          curprint(info.get_operator_name());
        }

     info.unset_nested_expression();

#if 0
     curprint ("\n /* Leaving of unparseUnaryExpr */ \n");
#endif
   }


bool
UnparseLanguageIndependentConstructs::isDotExprWithAnonymousUnion(SgExpression* expr)
   {
  // DQ (1/23/2014): This function support detecting when the supress the output of the SgDotExp
  // in the access of data members from un-named unions.  Note that variables of type that are
  // un-named unions are given a unique generated name of the form "__anonymous_0x" as a 
  // prefix to the pointer value of the declaration that defines the un-named union.  The
  // handling here is not specific to unions and handles any type where the declaration is
  // using a generated name of this specific form.

     bool returnValue = false;

     SgDotExp* dotExp = isSgDotExp(expr);
     if (dotExp != NULL)
        {
          SgBinaryOp* binary_op = isSgBinaryOp(dotExp->get_lhs_operand());
          if (binary_op != NULL)
             {
               SgExpression* rhs = binary_op->get_rhs_operand();
               ROSE_ASSERT (rhs != NULL);
               SgVarRefExp* varRefExp = isSgVarRefExp(rhs);
               if (varRefExp != NULL)
                  {
                    bool isAnonymousName = (string(varRefExp->get_symbol()->get_name()).substr(0,14) == "__anonymous_0x");
#if 0
                    printf ("In isDotExprWithAnonymousUnion(): (hidden in SgBinaryOp): dotExp = %p isAnonymousName = %s \n",dotExp,isAnonymousName ? "true" : "false");
#endif
                    returnValue = isAnonymousName;
                  }
             }
            else
             {
            // The other case we have to handle is that the lhs is a SgVarRefExp to an un-named variable.  See test2014_152.C.
               SgVarRefExp* varRefExp = isSgVarRefExp(dotExp->get_lhs_operand());
               if (varRefExp != NULL)
                  {
                    bool isAnonymousName = (string(varRefExp->get_symbol()->get_name()).substr(0,14) == "__anonymous_0x");
#if 0
                    printf ("In isDotExprWithAnonymousUnion(): (hidden directly in the lhs operand): dotExp = %p isAnonymousName = %s \n",dotExp,isAnonymousName ? "true" : "false");
#endif
                    returnValue = isAnonymousName;
                  }
             }
        }

     return returnValue;
   }


// DQ (4/14/2013): This is the new reimplemented version of the function (above).
void
UnparseLanguageIndependentConstructs::unparseBinaryExpr(SgExpression* expr, SgUnparse_Info& info) 
   {

#define DEBUG_BINARY_OPERATORS 0

     SgBinaryOp* binary_op = isSgBinaryOp(expr);
     ROSE_ASSERT(binary_op != NULL);

#if DEBUG_BINARY_OPERATORS
      curprint ( string("\n\n /* @@@@@ Inside of unparseBinaryExpr (operator name = ") + info.get_operator_name() + " */ \n");
      printf ("\n @@@@@ In unparseBinaryExpr() expr = %p %s \n",expr,expr->class_name().c_str());
#endif

   // DQ (1/23/2014): Added better support for unparsing of data member access of un-named class (structs and unions) typed variables.
      bool suppressOutputOfDotExp = isDotExprWithAnonymousUnion(expr);

#if DEBUG_BINARY_OPERATORS
  // printf ("In Unparse_ExprStmt::unparseBinaryExpr() expr = %s \n",expr->sage_class_name());
      curprint ( string("\n /* Inside of unparseBinaryExpr (expr class name        = ") + binary_op->class_name() + " */ \n");
      curprint ( string("\n /*                              lhs class name         = ") + binary_op->get_lhs_operand()->class_name() + " */ \n");
      curprint ( string("\n /*                              rhs class name         = ") + binary_op->get_rhs_operand()->class_name() + " */ \n");
      curprint ( string("\n /*                              suppressOutputOfDotExp = ") + (suppressOutputOfDotExp ? "true" : "false") + " */ \n");
#endif

  // DQ (4/9/2013): Added support for unparsing "operator+(x,y)" in place of "x+y".  This is 
  // required in places even though we have historically defaulted to the generation of the 
  // operator syntax (e.g. "x+y"), see test2013_100.C for an example of where this is required.
     SgNode* possibleParentFunctionCall = binary_op->get_parent();

  // DQ (4/9/2013): This fails for test2006_92.C.
  // ROSE_ASSERT(possibleFunctionCall != NULL);
     bool parent_function_call_uses_operator_syntax = false;
     if (possibleParentFunctionCall != NULL)
        {
          SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(possibleParentFunctionCall);
          if (functionCallExp != NULL)
             {
               parent_function_call_uses_operator_syntax = functionCallExp->get_uses_operator_syntax();
             }
        }

  // DQ (4/13/13): Checking the current level function call expression.
     SgNode* possibleFunctionCall = binary_op->get_lhs_operand();
     ROSE_ASSERT(possibleFunctionCall != NULL);
     bool current_function_call_uses_operator_syntax = false;
     if (possibleFunctionCall != NULL)
        {
          SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(possibleFunctionCall);
          if (functionCallExp != NULL)
             {
               current_function_call_uses_operator_syntax = functionCallExp->get_uses_operator_syntax();
             }
        }

  // If unp->opt.get_overload_opt() == true then use the overloaded operator names uniformally (Note that this is not well tested).
     current_function_call_uses_operator_syntax = ( (current_function_call_uses_operator_syntax == true) && !(unp->opt.get_overload_opt()) );

#if 0
  // Setting this to call or true should reproduce the older default behavior in ROSE.
     parent_function_call_uses_operator_syntax  = false;
     current_function_call_uses_operator_syntax = false;
#endif
#if 0
  // Setting this to call or true should reproduce the older default behavior in ROSE.
     parent_function_call_uses_operator_syntax  = true;
     current_function_call_uses_operator_syntax = true;
#endif
#if DEBUG_BINARY_OPERATORS
     printf ("In unparseBinaryExpr(): parent_function_call_uses_operator_syntax  = %s \n",parent_function_call_uses_operator_syntax  == true ? "true" : "false");
     printf ("In unparseBinaryExpr(): current_function_call_uses_operator_syntax = %s \n",current_function_call_uses_operator_syntax == true ? "true" : "false");
#endif

  // DQ (2/7/2011): Unparser support for more general originalExpressionTree handling.
     SgExpression* expressionTree = binary_op->get_originalExpressionTree();
     if (expressionTree != NULL && info.SkipConstantFoldedExpressions() == false)
        {
#if DEBUG_BINARY_OPERATORS
          printf ("Found and expression tree representing a cast expression (unfolded constant expression requiring a cast) expressionTree = %p = %s \n",
               expressionTree,expressionTree->class_name().c_str());
#endif
          unparseExpression(expressionTree,info);

          return;
        }

     info.set_nested_expression();

     if (info.get_operator_name() == "[]" )
        {
       // Special case:

       // DQ (4/14/2013): This likely requires some extra support where the operator syntax is not being used, but for
       // now this operator is always unparsed using it's operator syntax instead of using the overloaded operator name.
       // This needs to be fixed later.
#if DEBUG_BINARY_OPERATORS
          printf ("In unparseBinaryExp(): Special case of operator[] found \n");
          curprint ("/* Special case of operator[] found */\n");
#endif
          unparseExpression(binary_op->get_lhs_operand(),info);
          curprint ("[") ;
          unparseExpression(binary_op->get_rhs_operand(),info);
          curprint ("]");
        }
       else
        {
       // This is the more general case (supporting both infix, prefix, and postfix operators.
       // DQ (4/14/2013): I think that postfix operators and handled using specific mechanims and may not be well tested.
#if DEBUG_BINARY_OPERATORS
          printf ("In unparseBinaryExp(): Case 1 \n");
          curprint ( "/* NOT a special case of operator[] */\n");
#endif
          if (current_function_call_uses_operator_syntax == true)
             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Case 1.1 \n");
#endif
            // printf ("overload option is turned off! (output as "A+B" instead of "A.operator+(B)") \n");
            // First check if the right hand side is an unary operator function.
#if DEBUG_BINARY_OPERATORS
               curprint ( string("\n /* output as A+B instead of A.operator+(B): (u_sage->isUnaryOperator(binary_op->get_rhs_operand())) = ") + 
                    ((unp->u_sage->isUnaryOperator(binary_op->get_rhs_operand())) ? "true" : "false") + " */ \n");
#endif
            // if (unp->u_sage->isUnaryOperator(binary_op->get_rhs_operand())
               if (unp->u_sage->isUnaryOperator(binary_op->get_rhs_operand()) == true)
                  {
                 // printf ("Found case of rhs being a unary operator! \n");
#if DEBUG_BINARY_OPERATORS
                    printf ("In unparseBinaryExp(): Case 1.1.1 \n");
#endif

                    if (unp->u_sage->isUnaryPostfixOperator(binary_op->get_rhs_operand()))  // Postfix unary operator.
                       {
                      // ... nothing to do here (output the operator later!) ???
                      // printf ("... nothing to do here (output the postfix operator later!) \n");
#if DEBUG_BINARY_OPERATORS
                         printf ("In unparseBinaryExp(): Case 1.1.1.1 \n");
#endif
                       }
                      else 
                       {
                      // Prefix unary operator.
#if DEBUG_BINARY_OPERATORS
                         printf ("In unparseBinaryExp(): Case 1.1.1.2 \n");
#endif
#if DEBUG_BINARY_OPERATORS
                      // printf ("Handle prefix operator ... \n");
                         printf ("Prefix unary operator: Output the RHS operand ... = %s \n",binary_op->get_rhs_operand()->sage_class_name());
                         curprint("\n /* Prefix unary operator: Output the RHS operand ... */ \n");
#endif
                         if (info.isPrefixOperator() == false)
                            {
#if DEBUG_BINARY_OPERATORS
                              printf ("In unparseBinaryExp(): info.isPrefixOperator() == false: reset to be true! \n");
#endif
                              info.set_prefixOperator();
                            }
#if DEBUG_BINARY_OPERATORS
                         printf ("In unparseBinaryExpr(): info.isPrefixOperator() = %s \n",info.isPrefixOperator() ? "true" : "false");
#endif
                         unparseExpression(binary_op->get_rhs_operand(), info);
                       }
                  }
             }
            else
             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Case 1.2 \n");
#endif
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): parent_function_call_uses_operator_syntax  = %s \n",parent_function_call_uses_operator_syntax == true ? "true" : "false");
               printf ("In unparseBinaryExp(): current_function_call_uses_operator_syntax = %s (unhandled case) \n",current_function_call_uses_operator_syntax == true ? "true" : "false");
               printf ("In unparseBinaryExp(): binary_op->get_rhs_operand() = %p = %s \n",binary_op->get_rhs_operand(),binary_op->get_rhs_operand()->class_name().c_str());
#endif
            // DQ (4/13/2013): Adding support for prefix operators.
               if ( (parent_function_call_uses_operator_syntax == true) && (SageInterface::isPrefixOperator(binary_op->get_rhs_operand()) == true) )
                  {
#if DEBUG_BINARY_OPERATORS
                    printf ("In unparseBinaryExp(): Case 1.2.1 \n");
#endif
#if 0
                    printf ("Special handling for overloaded prefix operators \n");
                    ROSE_ASSERT(false);
#endif
#if DEBUG_BINARY_OPERATORS
                    curprint ( "\n /* unparseBinaryExpr(): Test 15  before unparseExpression() binary_op->get_rhs_operand() = " + binary_op->get_rhs_operand()->class_name() + "*/ \n");
#endif
                 // unparseExpression(binary_op->get_rhs_operand(), info);

                 // Mark this as a prefix operator so that unparseMFuncRefSupport() will know to unparse the operator name.
                    SgUnparse_Info newinfo(info);
                    newinfo.set_prefixOperator();

                    unparseExpression(binary_op->get_rhs_operand(), newinfo);
#if DEBUG_BINARY_OPERATORS
                    curprint ( "\n /* unparseBinaryExpr(): Test 16  after unparseExpression() binary_op->get_rhs_operand() = " + binary_op->get_rhs_operand()->class_name() + "*/ \n");
#endif
                  }
             }

#if DEBUG_BINARY_OPERATORS
          printf ("DONE with possible prefix operator processing expr = %p = %s \n",expr,expr->class_name().c_str());
#endif

#if DEBUG_BINARY_OPERATORS
          printf ("parent_function_call_uses_operator_syntax  = %s \n",parent_function_call_uses_operator_syntax  ? "true" : "false");
          printf ("current_function_call_uses_operator_syntax = %s \n",current_function_call_uses_operator_syntax ? "true" : "false");
          printf ("unp->opt.get_this_opt()                    = %s \n",unp->opt.get_this_opt()                    ? "true" : "false");
          printf ("unp->opt.get_overload_opt()                = %s \n",unp->opt.get_overload_opt()                ? "true" : "false");
          printf ("expr                          = %p = %s \n",expr,expr->class_name().c_str());
#endif

#if DEBUG_BINARY_OPERATORS
          curprint ("/* lhs = " + binary_op->get_lhs_operand()->class_name() + " */\n ");
#endif
          unparseExpression(binary_op->get_lhs_operand(), info);
#if DEBUG_BINARY_OPERATORS
          curprint ("/* DONE: lhs = " + binary_op->get_lhs_operand()->class_name() + " */\n ");
#endif

       // if (SageInterface::isPrefixOperator(binary_op->get_rhs_operand()) == true)
          if ( (parent_function_call_uses_operator_syntax == true) && (SageInterface::isPrefixOperator(binary_op->get_rhs_operand()) == true) )
             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Leaving after output of prefix operator and lhs in Case 1 \n");
#endif
               return;
             }

#if DEBUG_BINARY_OPERATORS
          printf ("In unparseBinaryExpr(): binary_op->get_rhs_operand()  = %p = %s \n",binary_op->get_rhs_operand(),binary_op->get_rhs_operand()->class_name().c_str());
          printf ("unp->u_sage->isOperator(binary_op->get_rhs_operand()) = %s \n",unp->u_sage->isOperator(binary_op->get_rhs_operand()) ? "true" : "false");
#endif
       // Before checking to insert a newline to prevent linewrapping, check that this
       // expression is a primitive operator and not dot or arrow expressions.
#if DEBUG_BINARY_OPERATORS
          curprint ( string("\n/* output info.get_operator_name() = ") + info.get_operator_name() + " */ \n");
          curprint ( string("\n/*    --- current_function_call_uses_operator_syntax = ") + (current_function_call_uses_operator_syntax ? "true" : "false") + " */ \n");
          curprint ( string("\n/*    --- parent_function_call_uses_operator_syntax  = ") + (parent_function_call_uses_operator_syntax ? "true" : "false") + " */ \n");
#endif
#if DEBUG_BINARY_OPERATORS
          printf ("parent_function_call_uses_operator_syntax  = %s \n",parent_function_call_uses_operator_syntax ? "true" : "false");
          printf ("current_function_call_uses_operator_syntax = %s \n",current_function_call_uses_operator_syntax ? "true" : "false");
#endif

#if 0
       // DQ (1/22/2014): Look ahead to see if this is a SgVarRefExp of a variable with a generated name.
       // We can't support this approach.  We have to look from the SgDotExp down to see if their is a 
       // variable reference to a variables named "__anonymous_0x" so that we can know to not output the
       // SgDotExp operator name, and then always in the SgVarRef supress the name when we detect the
       // "__anonymous_0x" named variables.

          bool rhs_is_varRef = (isSgVarRefExp(binary_op->get_rhs_operand()) != NULL);
          bool isAnonymousName = false;
          if (rhs_is_varRef == true)
             {
#if DEBUG_BINARY_OPERATORS
               printf ("Identified a SgVarRefExp: checking the name for __anonymous_0x \n");
#endif
               SgVarRefExp* varRefExp = isSgVarRefExp(binary_op->get_rhs_operand());
               ROSE_ASSERT(varRefExp != NULL);
               SgVariableSymbol* variableSymbol = varRefExp->get_symbol();
               ROSE_ASSERT(variableSymbol != NULL);
            // SgInitializedName* initializedName = variableSymbol->get_definition();
            // ROSE_ASSERT(initializedName != NULL);
            // isAnonymousName = (string(initializedName->get_name()).substr(0,14) == "__anonymous_0x");
               isAnonymousName = (string(variableSymbol->get_name()).substr(0,14) == "__anonymous_0x");
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExpr(): isAnonymousName = %s \n",isAnonymousName ? "true" : "false");
#endif
             }
#endif

          if (suppressOutputOfDotExp == false)
          {
          if ( ( (current_function_call_uses_operator_syntax == false) && (parent_function_call_uses_operator_syntax == false) ) || 
                 isRequiredOperator(binary_op,current_function_call_uses_operator_syntax,parent_function_call_uses_operator_syntax) == true )
             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Case 1.4.2.2.1 \n");
#endif
#if DEBUG_BINARY_OPERATORS
               printf ("   --- In unparseBinaryExpr(): Output operator name = %s \n",info.get_operator_name().c_str());
               curprint ( "/* Output operator name = " + info.get_operator_name() + " */\n ");
#endif
               curprint ( string(" ") + info.get_operator_name() + " ");
            }
           else
            {
#if DEBUG_BINARY_OPERATORS
               printf ("~~~~~~~ In unparseBinaryExpr(): SKIPPING output of operator name = %s \n",info.get_operator_name().c_str());
               curprint ( "/* SKIPPING output of operator name = " + info.get_operator_name() + " */\n ");
#endif
            }
          }
          else
             {
            // If this is the case of suppressOutputOfDotExp == true, then output a space to seperate the output tokens (simplifies debugging).
               curprint(" ");
             }
          

       // DQ (2/9/2010): Shouldn't this be true (it should also return a bool type).
          ROSE_ASSERT(info.get_nested_expression() != 0);
#if DEBUG_BINARY_OPERATORS
          printf ("In unparseBinaryExpr() -- before output of RHS: info.get_nested_expression() = %d info.get_operator_name() = %s \n",info.get_nested_expression(),info.get_operator_name().c_str());
          curprint ("\n /* unparseBinaryExpr(): Test 4.9  before unparseExpression() info.get_operator_name() = " + info.get_operator_name() + "*/ \n");
#endif
          SgExpression* rhs = binary_op->get_rhs_operand();

       // DQ (4/13/2013): We need to detect if this is a prefix operator, and if we unparse it before 
       // the LHS if we are using the oprator syntax, e.g. when current_function_call_uses_operator_syntax == true

#if 0
       // DQ (4/21/2013): I don't think this should be a special case.
          if (info.get_operator_name() == ",")
             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Case 1.5 \n");
#endif
               SgUnparse_Info newinfo(info);
               newinfo.set_inRhsExpr();
               unp->u_debug->printDebugInfo("rhs: ", false);

               unparseExpression(rhs, newinfo);
             }
            else
#endif

             {
#if DEBUG_BINARY_OPERATORS
               printf ("In unparseBinaryExp(): Case 1.6 \n");
               curprint ( "\n /* unparseBinaryExpr(): Test 5  before unparseExpression() rhs = " + rhs->class_name() + "*/ \n");
#endif
            // unparseExpression(rhs, info);

#if DEBUG_BINARY_OPERATORS
               printf ("++++++++++++++++ Evaluate use of RHS: parent_function_call_uses_operator_syntax = %s \n",parent_function_call_uses_operator_syntax ? "true" : "false");
#endif
               if (parent_function_call_uses_operator_syntax == true)
                  {
                 // DQ (4/20/2013): I think we want to restrict this to the case of overloaded operators for "->" (and maybe ".").
                 // test2013_114.C demonstrates where just because we detect a cast we don't want to skip the output of other operators.
                 // This is because the introduction of the compiler generated case causes only a restricted number of extra functions
                 // to be calls (e.g. SgArrowExp or it's overloaded version).  I am unclear if the SgDotExp can be caused to be generated 
                 // by a cases (but I expect it can).

                    bool isRelevantOverloadedOperator = false;
                    SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(rhs);
                    if (memberFunctionRefExp != NULL)
                       {
                         string functionName = memberFunctionRefExp->get_symbol()->get_name();
#if DEBUG_BINARY_OPERATORS
                         printf ("++++++++++++++++ functionName = %s \n",functionName.c_str());
#endif
                         if (functionName == "operator->")
                            {
                              isRelevantOverloadedOperator = true;
                            }
                       }

#if DEBUG_BINARY_OPERATORS
                    printf ("++++++++++++++++ binary_op = %p = %s parent_function_call_uses_operator_syntax == true: search for SgCastExp \n",binary_op,binary_op->class_name().c_str());
#endif
                 // If this is a consequence of a cast that was implicit (compiler generated), then we don't want to output this operator.
                    ROSE_ASSERT(binary_op->get_parent() != NULL);
                    ROSE_ASSERT(binary_op->get_parent()->get_parent() != NULL);

#if DEBUG_BINARY_OPERATORS
                    printf ("++++++++++++++++ binary_op->get_parent()->get_parent() = %p = %s \n",binary_op->get_parent()->get_parent(),binary_op->get_parent()->get_parent()->class_name().c_str());
#endif
                    SgCastExp* castExp = isSgCastExp(binary_op->get_parent()->get_parent());
                 // if (castExp != NULL)
                    if (castExp != NULL && isRelevantOverloadedOperator == true)
                       {
#if DEBUG_BINARY_OPERATORS
                         printf ("++++++++++++++++ Found SgCastExp \n");
#endif
                         if (castExp->get_startOfConstruct()->isCompilerGenerated() == true)
                            {
                           // Skip the output of the RHS.
#if DEBUG_BINARY_OPERATORS
                              printf ("++++++++++++++++ Skipping the output of the RHS \n");
#endif
#if 0
                              printf ("Exiting as a test! \n");
                              ROSE_ASSERT(false);
#endif
                            }
                           else
                            {
#if DEBUG_BINARY_OPERATORS
                              curprint ( "\n /* unparseBinaryExpr(): output RHS 1 */ \n");
#endif
                              unparseExpression(rhs, info);
                            }
                       }
                      else
                       {
#if DEBUG_BINARY_OPERATORS
                         curprint ( "\n /* unparseBinaryExpr(): output RHS 2 */ \n");
#endif
                         unparseExpression(rhs, info);
                       }
                  }
                 else
                  {
#if DEBUG_BINARY_OPERATORS
                    curprint ( "\n /* unparseBinaryExpr(): output RHS 3 */ \n");
#endif
                    unparseExpression(rhs, info);

#if DEBUG_BINARY_OPERATORS
                    curprint ( "\n /* DONE: unparseBinaryExpr(): output RHS 3 */ \n");
#endif
                  }

#if DEBUG_BINARY_OPERATORS
               curprint ( "\n /* unparseBinaryExpr(): Test 6  after unparseExpression() rhs = " + rhs->class_name() + "*/ \n");
#endif
             }
        }

     info.unset_nested_expression();

#if DEBUG_BINARY_OPERATORS
     printf ("Leaving unparseBinaryExpr(): exp = %p = %s \n",expr,expr->class_name().c_str());
     curprint ( "\n /* Leaving unparseBinaryExpr */ \n");
#endif
   }



bool
UnparseLanguageIndependentConstructs::isRequiredOperator( SgBinaryOp* binary_op, bool current_function_call_uses_operator_syntax, bool parent_function_call_uses_operator_syntax )
   {
  // DQ (4/14/2013): The mixing of overloaded operator names and operator syntax has been a bit complex.
  // There are special cases that are especially troubling, so this code tries to handle this.
  // ROSE now preserves the original form of the operator if it was used as either:
  //    1) the overloaded operator name, e.g. "i = result.operator&()->size();", or
  //    2) using the operator syntax, e,g, "i = (&result)->size();"
  // There are different function resolution lookup rules for each type of representaion.
  // So this is a subtle area of C++ to start with.  ROSE tracks in the IR (in the SgFunctionCallExp)
  // if the function call uses the operator syntax (data member, p_uses_operator_syntax, with 
  // set and get access functions automatically generated by ROSETTA.

  // Some complex examples are:
  //    1) "i = result.operator&()->size();" vs. "i = (&result)->size();", the use of SgArrowOp "->" is required.
  //    2) "ref.operator->()->getFormat();" vs. "ref->getFormat();", the use of SgArrowOp "->" is supressed.
  //    3) "s.operator&();" vs. "&s;", example of prefix operator syntax.

     bool returnValue = false;

     ROSE_ASSERT(binary_op != NULL);

#if 0
     printf ("In isRequiredOperator(binary_op = %p = %s, current_function_call_uses_operator_syntax = %s, parent_function_call_uses_operator_syntax = %s \n",
          binary_op,binary_op->class_name().c_str(), current_function_call_uses_operator_syntax ? "true" : "false",parent_function_call_uses_operator_syntax ? "true" : "false");
     printf ("   --- binary_op->get_lhs_operand() = %p = %s \n",binary_op->get_lhs_operand(),binary_op->get_lhs_operand()->class_name().c_str());
     printf ("   --- binary_op->get_rhs_operand() = %p = %s \n",binary_op->get_rhs_operand(),binary_op->get_rhs_operand()->class_name().c_str());
#endif

  // if (unp->u_sage->isOperator(binary_op->get_rhs_operand()) == false)
  //      returnValue = true;

     SgExpression* lhs = binary_op->get_lhs_operand();
     ROSE_ASSERT(lhs != NULL);
  // SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(lhs);

     SgType* lhs_type = lhs->get_type();
     ROSE_ASSERT(lhs_type != NULL);

  // DQ (4/15/2013): This is required for test2005_129.C
  // SgType::stripType (unsigned char bit_array=STRIP_MODIFIER_TYPE|STRIP_REFERENCE_TYPE|STRIP_POINTER_TYPE|STRIP_ARRAY_TYPE|STRIP_TYPEDEF_TYPE) const
     SgType* stripped_lhs_type = lhs_type->stripType (SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_ARRAY_TYPE|SgType::STRIP_TYPEDEF_TYPE);
     ROSE_ASSERT(stripped_lhs_type != NULL);

#if 0
     printf ("In isRequiredOperator(): lhs_type = %p = %s stripped_lhs_type = %p = %s \n",lhs_type,lhs_type->class_name().c_str(),stripped_lhs_type,stripped_lhs_type->class_name().c_str());
#endif

  // SgClassType*     classType     = isSgClassType    (stripped_lhs_type);
  // SgReferenceType* referenceType = isSgReferenceType(stripped_lhs_type);
     SgPointerType*   pointerType   = isSgPointerType  (stripped_lhs_type);

  // DQ (4/15/2013): I think what makes a greater difference is that this is not a SgArrowExp (see test2013_108.C).
  // DQ (4/15/2013): Added support for SgClassType to handle test2005_141.C.
  // DQ (4/15/2013): Note that of stripped_lhs_type is SgTypeBool we also want to process this branch, I think the 
  // point is that the type is not SgPointerType.
  // if (referenceType != NULL && isSgDotExp(binary_op) != NULL)
  // if (referenceType != NULL && isSgArrowExp(binary_op) == NULL)
  // if ( (referenceType != NULL || classType != NULL) && isSgArrowExp(binary_op) == NULL)
     if ( (pointerType == NULL) && (isSgArrowExp(binary_op) == NULL) )
        {
       // In case of operator>> we need to investigate further, just like the case of operator-> for the SgArrowExp.
       // returnValue = true;

          if (parent_function_call_uses_operator_syntax == true)
             {
            // This addresses the requirement of test2013_97.C
               returnValue = false;
             }
            else
             {
               returnValue = true;
             }
        }
       else
        {
          if (pointerType != NULL && isSgArrowExp(binary_op) != NULL)
             {
            // This make since unless the lhs is an operator->.

               SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(lhs);
               ROSE_ASSERT(functionCallExp != NULL);

               SgDotExp* dotExp = isSgDotExp(functionCallExp->get_function());
               ROSE_ASSERT(dotExp != NULL);

               SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(dotExp->get_rhs_operand());
               if (memberFunctionRefExp != NULL)
                  {
                    SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionRefExp->getAssociatedMemberFunctionDeclaration();
                    ROSE_ASSERT(memberFunctionDeclaration != NULL);
#if 0
                    printf ("In isRequiredOperator(): memberFunctionDeclaration->get_name() = %s \n",memberFunctionDeclaration->get_name().str());
#endif
                    if (memberFunctionDeclaration->get_name() == "operator->")
                       {
                      // Avoid putting out "->->"
                         returnValue = false;
                       }
                      else
                       {
                         returnValue = true;
                       }
                  }
                 else
                  {
                    returnValue = true;
                  }
             }
            else
             {
            // This is the case for test2013_121.C
               returnValue = true;
             }
        }

#if 0
     printf ("Leaving isRequiredOperator(): returnValue = %s \n",returnValue ? "true" : "false");
#endif

     return returnValue;
   }


void
UnparseLanguageIndependentConstructs::unparseValue(SgExpression* expr, SgUnparse_Info& info)
   {
  // DQ (11/9/2005): refactored handling of expression trees stemming from the folding of constants.
     SgValueExp* valueExp = isSgValueExp(expr);

  // DQ (9/11/2011): Added error checking pointed out from static analysis.
     ROSE_ASSERT(valueExp != NULL);

#if 0
     printf ("Inside of unparseValue = %p \n",valueExp);
     valueExp->get_file_info()->display("unparseValue");
#endif

     SgExpression* expressionTree = valueExp->get_originalExpressionTree();
     if (expressionTree != NULL && info.SkipConstantFoldedExpressions() == false)
        {
#if 0
          printf ("Found and expression tree representing a constant generated via constant folding \n");
#endif
#if 0
          curprint ( "\n/* Found and expression tree representing a constant generated via constant folding */\n ");
#endif
       // unparseExpression(expressionTree,info);
          switch (valueExp->variantT())
             {
            // Handle enums so that they will be unparsed as "enum name" instead of as integers
            // bool does not require special handling.
            // case V_SgBoolValExp:             { unparseBoolVal(expr, info);         break; }
               case V_SgEnumVal:                { unparseEnumVal(expr, info);         break; }
               default:
                  {
                    unparseExpression(expressionTree,info);
                  }
             }
        }
       else
        {
          switch (valueExp->variantT())
             {
               case V_SgBoolValExp:             { unparseBoolVal(expr, info);         break; }
               case V_SgCharVal:                { unparseCharVal(expr, info);         break; }
               case V_SgShortVal:               { unparseShortVal(expr, info);        break; }
               case V_SgUnsignedCharVal:        { unparseUCharVal(expr, info);        break; }
               case V_SgWcharVal:               { unparseWCharVal(expr, info);        break; }
               case V_SgStringVal:              { unparseStringVal(expr, info);       break; }
               case V_SgUnsignedShortVal:       { unparseUShortVal(expr, info);       break; }
               case V_SgEnumVal:                { unparseEnumVal(expr, info);         break; }
               case V_SgIntVal:                 { unparseIntVal(expr, info);          break; }
               case V_SgUnsignedIntVal:         { unparseUIntVal(expr, info);         break; }
               case V_SgLongIntVal:             { unparseLongIntVal(expr, info);      break; }
               case V_SgLongLongIntVal:         { unparseLongLongIntVal(expr, info);  break; }
               case V_SgUnsignedLongLongIntVal: { unparseULongLongIntVal(expr, info); break; }
               case V_SgUnsignedLongVal:        { unparseULongIntVal(expr, info);     break; }
               case V_SgFloatVal:               { unparseFloatVal(expr, info);        break; }
               case V_SgDoubleVal:              { unparseDoubleVal(expr, info);       break; }
               case V_SgLongDoubleVal:          { unparseLongDoubleVal(expr, info);   break; }
               case V_SgComplexVal:             { unparseComplexVal(expr, info);      break; }

               default:
                  {
                    printf ("Default reached in switch statement valueExp = %p = %s \n",valueExp,valueExp->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
                
             }
        }
   }



void
UnparseLanguageIndependentConstructs::unparseBoolVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgBoolValExp* bool_val = isSgBoolValExp(expr);
     ROSE_ASSERT(bool_val != NULL);

  // Bug reported by Yarden (IBM), output for C should not use C++ keywords ("true" and "false")
  // Note that the getProject() function will use the parent pointers to traverse back to the SgProject node
     bool C_language_support = false;
     SgFile* file = TransformationSupport::getFile(expr);

#if 0
     printf ("In unparseBoolVal(): resolving file to be %p \n",file);
#endif

     if (file == NULL)
        {
       // DQ (9/15/2012): We have added a mechanism for the language to be specified directly.
       // C_language_support = true;
          if (info.get_language() != SgFile::e_default_output_language)
             {
#if 0
               printf ("In unparseBoolVal(): The output language has been specified directly info.get_language() = %d \n");
#endif
               C_language_support = (info.get_language() == SgFile::e_C_output_language);
             }
            else
             {
               C_language_support = true;
             }
#if 0
          printf ("Warning: getting the SgFile from SgBoolValExp() expr = %p (trace back to SgFile failed, assuming C language support) \n",expr);
          ROSE_ASSERT(expr->get_file_info() != NULL);
          expr->get_file_info()->display("location of problem bool expression");
          ROSE_ASSERT(expr->get_parent() != NULL);
          printf ("expr->get_parent() = %p = %s \n",expr->get_parent(),expr->get_parent()->class_name().c_str());
          SgTemplateArgument* templateArgument = isSgTemplateArgument(expr->get_parent());
          if (templateArgument != NULL)
             {
               printf ("templateArgument->get_type()                  = %p \n",templateArgument->get_type());
               printf ("templateArgument->get_expression()            = %p \n",templateArgument->get_expression());
            // printf ("templateArgument->get_templateInstantiation() = %p \n",templateArgument->get_templateInstantiation());
             }
            else
             {
               ROSE_ASSERT(expr->get_parent()->get_file_info() != NULL);
               expr->get_parent()->get_file_info()->display("location of problem bool expression (parent)");
             }
#endif
        }
       else
        {
          ROSE_ASSERT(file != NULL);
          C_language_support = file->get_C_only() || file->get_C99_only();
        }

     if (unp->opt.get_num_opt() || (C_language_support == true))
        {
       // The C language does not support boolean values (C99 does, as I recall)
       // we want to print the boolean values as numerical values
       // DQ (11/29/2009): get_value() returns an "int" and MSVC issues a warning for mixed type predicates.
       // if (bool_val->get_value() == true)
          if (bool_val->get_value() != 0)
             {
               curprint("1");
             }
            else
             {
               curprint("0");
             }
        }
       else
        {
       // This is the C++ case (and any language supporting boolean values).

       // print them as "true" or "false"
       // DQ (11/29/2009): get_value() returns an "int" and MSVC issues a warning for mixed type predicates.
       // if (bool_val->get_value() == true)
          if (bool_val->get_value() != 0)
             {
               curprint("true");
             }
            else
             {
               curprint("false");
             }
        }
   }

void
UnparseLanguageIndependentConstructs::unparseShortVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgShortVal* short_val = isSgShortVal(expr);
     ROSE_ASSERT(short_val != NULL);

  // DQ (8/30/2006): Make change suggested by Rama (patch)
  // curprint ( short_val->get_value();
     if (short_val->get_valueString() == "")
        {
          curprint ( tostring(short_val->get_value()));
        }
       else
        {
          curprint ( short_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseCharVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgCharVal* char_val = isSgCharVal(expr);
     ROSE_ASSERT(char_val != NULL);

  // DQ (9/30/2006): Use the string where it is available (I think the string 
  // based literals for non-floating point cases are not finished yet).
     if (char_val->get_valueString() == "")
        {
       // curprint ( char_val->get_value();

       // DQ (3/19/2005): Many different literal characters were not being output properly or were being output as 
       // integers which when used as function parameters lead to the wrong function resolution.
       // We can't just output the integer conversion of the character since where this is used as a function 
       // argument it will match a different function prototype (which might not even exist) (see bug 2005_30.C).
       // curprint ( (int) char_val->get_value();
          switch(char_val->get_value())
             {
               case '\0': curprint ( "\'\\0\'"); break;
               case '\1': curprint ( "\'\\1\'"); break;
               case '\2': curprint ( "\'\\2\'"); break;
               case '\3': curprint ( "\'\\3\'"); break;
               case '\4': curprint ( "\'\\4\'"); break;
               case '\5': curprint ( "\'\\5\'"); break;
               case '\6': curprint ( "\'\\6\'"); break;
            // EDG complains that \7, \8, and \9 are redundent (and EDG is correct!)
            // This case is replicated with ASCII BS case '\a' (below)
            // case '\7': curprint ( "\'\\7\'"; break;
            // This case is replicated with ASCI BEL case '\b' (below)
            // case '\8': curprint ( "\'\\8\'"; break;
            // This case is replicated with ASCI HT case '\t' (below)
            // case '\9': curprint ( "\'\\9\'"; break;
            // Note that if we skip this case then '\b' is converted to '^H' which is likely 
            // equivalant but is different enough to be annoying.  Likely other literals have 
            // similar equivalants.  I now expect that '^H' is the wrong translation of '\b'.
            // So the cases below are required.
               case '\n': curprint ( "\'\\n\'"); break;
               case '\t': curprint ( "\'\\t\'"); break;
               case '\v': curprint ( "\'\\v\'"); break;
               case '\b': curprint ( "\'\\b\'"); break;
               case '\r': curprint ( "\'\\r\'"); break;
               case '\f': curprint ( "\'\\f\'"); break;
               case '\a': curprint ( "\'\\a\'"); break;
               case '\'': curprint ( "\'\\'\'"); break;
               case '\"': curprint ( "\'\"\'"); break;
            // Handle special case of ASCI DEL (decimal 127)
            // case '\177': curprint ( "\'\177\'"; break;
            // case 127: curprint ( "\'\177\'"; break;
               case 127: curprint ( "char(127)"); break;
            // This case is required since "\\" is the C++ name of the ASCII "\" character
               case '\\': curprint ( "\'\\\\'"); break;

#if 0
            // DQ (3/19/2005): These should no longer be required, since they are handled properly by the C++ string output!
            // Provide these cases explicitly so that '0' is not converted to '48' 
            // (which is a multi-character character constant, not what we want!)
               case '0': curprint ( "\'0\'"); break;
               case '1': curprint ( "\'1\'"); break;
               case '2': curprint ( "\'2\'"); break;
               case '3': curprint ( "\'3\'"); break;
               case '4': curprint ( "\'4\'"); break;
               case '5': curprint ( "\'5\'"); break;
               case '6': curprint ( "\'6\'"); break;
               case '7': curprint ( "\'7\'"); break;
               case '8': curprint ( "\'8\'"); break;
               case '9': curprint ( "\'9\'"); break;

               case '\?': curprint ( "\'\\?\'"); break;
               case '`': curprint ( "\'`\'"); break;
               case '~': curprint ( "\'~\'"); break;
               case '_': curprint ( "\'_\'"); break;
#endif
               default:
                  {
                 // I could not get char to be output as anything but an integer, so I converted the char to a string 
                 // and then output the string this resulted in not every case (value of char) requiring special handling.
                 // Generate a C string and copy it to a C++ string and then output the C++ string so that we 
                 // can leverage the C++ string handling of character literals.
                    char c[2]; 
                    c[0] = char_val->get_value();
                    c[1] = '\0';
                    string s = c;
                 // curprint ( "\'" + (char)char_val->get_value() + "\'";
                    curprint ( "\'" + s + "\'");
                    break;
                  }
             }
        }
       else
        {
       // Use the string representing the literal where it is available
          curprint ( char_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseUCharVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgUnsignedCharVal* uchar_val = isSgUnsignedCharVal(expr);
     ROSE_ASSERT(uchar_val != NULL);

  // DQ (8/30/2006): Make change suggested by Rama (patch)
  // curprint ( (int) uchar_val->get_value();
     if (uchar_val->get_valueString() == "")
        {
          curprint ( tostring((int) uchar_val->get_value()));
        }
       else
        {
          curprint ( uchar_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseWCharVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgWcharVal* wchar_val = isSgWcharVal(expr);
     ROSE_ASSERT(wchar_val != NULL);

  //DONT KNOW HOW TO GET ACCESS TO p_valueUL, so just use p_value for now
  //if(wchar_val->p_valueUL) {
  //  curprint ( (wchar_t ) wchar_val->p_valueUL;
  //} else curprint ( (int) wchar_val->get_value();

  // DQ (8/30/2006): Make change suggested by Rama (patch)
  // curprint ( (int) wchar_val->get_value();
     if (wchar_val->get_valueString() == "")
        {
          curprint ( tostring(wchar_val->get_value()));
        }
       else
        {
          curprint ( wchar_val->get_valueString());
        }
   }

#if 0
// Because of the details of Fortran string, this can't be language independent.
void
UnparseLanguageIndependentConstructs::unparseStringVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgStringVal* str_val = isSgStringVal(expr);
     ROSE_ASSERT(str_val != NULL);

  // Handle special case of macro specification (this is a temporary hack to permit us to
  // specify macros within transformations)

     int wrap = unp->u_sage->cur_get_linewrap();
     unp->u_sage->cur_get_linewrap();

#if 0
  // const char* targetString = "ROSE-TRANSFORMATION-MACRO:";
     const char* targetString = "ROSE-MACRO-EXPRESSION:";
     int targetStringLength = strlen(targetString);
  // if (str_val->get_value() == NULL)
     if (str_val->get_value().empty() == true)
        {
          printf ("Found an pointer in SgStringVal = %p for value of string! \n",str_val);
          str_val->get_file_info()->display("Called from unparseStringVal: debug");
        }
     ROSE_ASSERT(str_val->get_value() != NULL);
     if (strncmp(str_val->get_value(),targetString,targetStringLength) == 0)
        {
       // unparse the string without the surrounding quotes and with a new line at the end
          char* remainingString = str_val->get_value()+targetStringLength;
          printf ("Specify a MACRO: remainingString = %s \n",remainingString);
       // Put in a leading CR so that the macro will always be unparsed onto its own line
       // Put in a trailing CR so that the trailing ";" will be unparsed onto its own line too!
          curprint ( "\n" + remainingString + "\n");
        }
       else
        {
          curprint ( "\"" + str_val->get_value() + "\"");
        }
     ROSE_ASSERT(str_val->get_value() != NULL);
#else
  // DQ (3/25/2006): Finally we can use the C++ string class
     string targetString = "ROSE-MACRO-CALL:";
     int targetStringLength = targetString.size();
     string stringValue = str_val->get_value();
     string::size_type location = stringValue.find(targetString);
     if (location != string::npos)
        {
       // unparse the string without the surrounding quotes and with a new line at the end
          string remainingString = stringValue.replace(location,targetStringLength,"");
       // printf ("Specify a MACRO: remainingString = %s \n",remainingString.c_str());
          remainingString.replace(remainingString.find("\\\""),4,"\"");
          curprint ( "\n" + remainingString + "\n");
        }
       else
        {
       // curprint ( "\"" + str_val->get_value() + "\"";
          if (str_val->get_wcharString() == true)
               curprint ( "L");
          curprint ( "\"" + str_val->get_value() + "\"");
        }
#endif
     unp->u_sage->cur_set_linewrap(wrap);
   }
#endif


void
UnparseLanguageIndependentConstructs::unparseUShortVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgUnsignedShortVal* ushort_val = isSgUnsignedShortVal(expr);
     ROSE_ASSERT(ushort_val != NULL);

     curprint ( tostring(ushort_val->get_value()));
#if 0
  // DQ (8/30/2006): Make change suggested by Rama (patch)
  // There appears to not be a concept of "short" literal (even in hex or octal).
  // So it may be that the unsigned short and short types are not even used!
     if (ushort_val->get_valueString() == "")
        {
          curprint ( tostring(ushort_val->get_value()));
        }
       else
        {
          curprint ( ushort_val->get_valueString());
        }
#endif
   }


void
UnparseLanguageIndependentConstructs::unparseEnumVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgEnumVal* enum_val = isSgEnumVal(expr);
     ROSE_ASSERT(enum_val != NULL);

#if 0
     printf ("In Unparse_ExprStmt::unparseEnumVal: info.inEnumDecl() = %s \n",info.inEnumDecl() ? "true" : "false");
  // curprint("\n/* In Unparse_ExprStmt::unparseEnumVal() */\n");
#endif

  // todo: optimize this so that the qualified name is only printed when necessary.
     if (info.inEnumDecl() == true)
        {
       // The enum value output in the enum declaration should be a value (it could be an enum constant
       // if it has already been output as a value (repreated reference) but this is an obsure detail).
          curprint(tostring(enum_val->get_value()));
        }
       else
        {
       // DQ (12/20/2005): Added more general support for name qualification for enum values (to fix test2005_188.C).
       // ROSE_ASSERT(enum_val->get_declaration() != NULL);
       // ROSE_ASSERT(enum_val->get_declaration()->get_scope() != NULL);

       // DQ (10/14/2006): Reimplemented support for name qualification.
       // if (SageInterface::is_Cxx_language() == true)
          if (enum_val->get_declaration() != NULL)
             {
            // DQ (12/20/2005): Added more general support for name qualification for enum values (to fix test2005_188.C).
               ROSE_ASSERT(enum_val->get_declaration() != NULL);
               ROSE_ASSERT(enum_val->get_declaration()->get_scope() != NULL);

            // DQ (10/14/2006): Reimplemented support for name qualification.
               if (SageInterface::is_Cxx_language() == true)
                  {
                 // SgScopeStatement* parentScope = decl_item->get_scope();
#if 0
                 // DQ (6/15/2013): Added in name qualification support for enum values.
                 // SgName nameQualifier = "NEED_QUALIFIED_NAME_for_unparseEnumVal::";
                 // DQ (5/29/2011): Newest refactored support for name qualification.
                 // printf ("In unparseFuncRef(): Looking for name qualification for SgFunctionRefExp = %p \n",func_ref);
                    SgName nameQualifier = enum_val->get_qualified_name_prefix();
#else
                 // DQ (12/22/2006): This is use the information that qualification is required. This will trigger the use of 
                 // global qualification even if it is not required with normal qualification.  That is that the specification 
                 // of qualification triggers possible (likely) over qualification.  Overqualification is generally the default
                 // this flag is sometime taken to mean that the "::" is required as well.
#if 0
                    printf ("enum_val->get_requiresNameQualification() = %s \n",enum_val->get_requiresNameQualification() ? "true" : "false");
#endif
                 // cur << "\n/* funcdecl_stmt->get_requiresNameQualificationOnReturnType() = " << (funcdecl_stmt->get_requiresNameQualificationOnReturnType() ? "true" : "false") << " */ \n";
                    if (enum_val->get_requiresNameQualification() == true)
                       {
                      // Note that general qualification of types is separated from the use of globl qualification.
                      // info.set_forceQualifiedNames();
                         info.set_requiresGlobalNameQualification();
                       }

                 // DQ (6/9/2011): Newest refactored support for name qualification.
                 // SgName nameQualifier = unp->u_name->generateNameQualifier(enum_val->get_declaration(),info);
                    SgName nameQualifier = enum_val->get_qualified_name_prefix();
#if 0
                    printf ("In Unparse_ExprStmt::unparseEnumVal: nameQualifier = %s \n",nameQualifier.str());
#endif
                 // DQ (8/31/2012): If we are going to NOT output a name, then we had better not out any name qualification.
                    if (enum_val->get_name().is_null() == true)
                       {
                         printf ("If the enum name does not exist, then we can't qualify it nameQualifier = %s (reset) \n",(nameQualifier.is_null() == false) ? nameQualifier.str() : "NULL");
                         nameQualifier = "";
                         ROSE_ASSERT(nameQualifier.is_null() == true);
                       }
#endif
#if 0
                    printf ("enum value's nameQualifier = %s \n",(nameQualifier.is_null() == false) ? nameQualifier.str() : "NULL");
#endif
                 // ROSE_ASSERT (nameQualifier.is_null() == false);
                    if (nameQualifier.is_null() == false)
                       {
                         curprint ( nameQualifier.str() );
                       }
                  }
            // printf ("In Unparser::unparseEnumVal: classdefn = %s pointer \n",classdefn ? "VALID" : "NULL");
             }
            else
             {
               ROSE_ASSERT (enum_val->get_name().is_null() == false);
               printf ("Warning in Unparser::unparseEnumVal(): no associated enum declaration specificed for enum value = %s \n",enum_val->get_name().str());
             }

#if 0
       // printf ("In Unparse_ExprStmt::unparseEnumVal: classdefn = %s pointer \n",classdefn ? "VALID" : "NULL");
          printf ("In Unparse_ExprStmt::unparseEnumVal: enum_val->get_name().is_null() = %s \n",enum_val->get_name().is_null() ? "true" : "false");
#endif
       // DQ (8/31/2012): We need to allow for values that would not be mapped to enum names and in this case 
       // are output as enum values (see test2012_202.C for an example of this).
       // DQ (6/18/2006): Identify the case of an un-named enum, would be an error if we unparsed this directly.
       // ROSE_ASSERT (enum_val->get_name().is_null() == false);
       // curprint (  enum_val->get_name().str());

       // DQ (11/4/2012): Detect if this is a generated name with an cast from an un-named type (we can't output these names).
          SgName enum_value_name = enum_val->get_name();
          SgName substring = enum_value_name.head(strlen("__anonymous_"));
          bool isGeneratedName = (substring == "__anonymous_");
#if 0
          printf ("enum_value_name = %s \n",enum_value_name.str());
          printf ("substring = %s \n",substring.str());
          printf ("isGeneratedName = %s \n",isGeneratedName ? "true" : "false");
#endif

       // DQ (11/4/2012): Never output a generated name since it will cause link failures 
       // (and frequently also interpretation as implicit function calls in C).
       // if (enum_val->get_name().is_null() == false)
          if ( (enum_val->get_name().is_null() == false) && (isGeneratedName == false) )
             {
            // This is the typical case.
               curprint(enum_val->get_name().str());
             }
            else
             {
               curprint(tostring(enum_val->get_value()));
             }
        }

#if 0
     printf ("Leaving Unparse_ExprStmt::unparseEnumVal: info.inEnumDecl() = %s \n",info.inEnumDecl() ? "true" : "false");
  // curprint("\n/* Leaving Unparse_ExprStmt::unparseEnumVal() */\n");
#endif

#if 0
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif
   }


void 
UnparseLanguageIndependentConstructs::unparseIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgIntVal* int_val = isSgIntVal(expr);
     ROSE_ASSERT(int_val != NULL);

  // printf ("In Unparse_ExprStmt::unparseIntVal(): int_val->get_value() = %d \n",int_val->get_value());
  // curprint ( int_val->get_value();
  // curprint ( int_val->get_valueString();

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (int_val->get_valueString() == "")
        {
          curprint(tostring(int_val->get_value()));
        }
       else
        {
          curprint(int_val->get_valueString());
        }
   }


void
UnparseLanguageIndependentConstructs::unparseUIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgUnsignedIntVal* uint_val = isSgUnsignedIntVal(expr);
     ROSE_ASSERT(uint_val != NULL);

  // curprint ( uint_val->get_value();
  // DQ (7/20/2006): Bug reported by Yarden, see test2006_94.C for where this is important (e.g. evaluation of "if (INT_MAX + 1U > 0)").
  // curprint ( "U";

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (uint_val->get_valueString() == "")
        {
          curprint(tostring(uint_val->get_value()));
        }
       else
        {
          curprint(uint_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseLongIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgLongIntVal* longint_val = isSgLongIntVal(expr);
     ROSE_ASSERT(longint_val != NULL);

  // curprint ( longint_val->get_value();
  // DQ (7/20/2006): Bug reported by Yarden, see test2006_94.C for where this is important (e.g. evaluation of "if (INT_MAX + 1U > 0)").
  // curprint ( "L";

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (longint_val->get_valueString() == "")
        {
          curprint(tostring(longint_val->get_value()));
        }
       else
        {
          curprint(longint_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseLongLongIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgLongLongIntVal* longlongint_val = isSgLongLongIntVal(expr);
     ROSE_ASSERT(longlongint_val != NULL);

  // curprint ( longlongint_val->get_value();
  // DQ (7/20/2006): Bug reported by Yarden, see test2006_94.C for where this is important (e.g. evaluation of "if (INT_MAX + 1U > 0)").
  // curprint ( "LL";

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (longlongint_val->get_valueString() == "")
        {
          curprint(tostring(longlongint_val->get_value()));
        }
       else
        {
          curprint(longlongint_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseULongLongIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgUnsignedLongLongIntVal* ulonglongint_val = isSgUnsignedLongLongIntVal(expr);
     ROSE_ASSERT(ulonglongint_val != NULL);

  // curprint ( ulonglongint_val->get_value();
  // DQ (7/20/2006): Bug reported by Yarden, see test2006_94.C for where this is important (e.g. evaluation of "if (INT_MAX + 1U > 0)").
  // curprint ( "ULL";

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (ulonglongint_val->get_valueString() == "")
        {
          curprint(tostring(ulonglongint_val->get_value()));
        }
       else
        {
          curprint(ulonglongint_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseULongIntVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgUnsignedLongVal* ulongint_val = isSgUnsignedLongVal(expr);
     ROSE_ASSERT(ulongint_val != NULL);

  // curprint ( ulongint_val->get_value();
  // DQ (7/20/2006): Bug reported by Yarden, see test2006_94.C for where this is important (e.g. evaluation of "if (INT_MAX + 1U > 0)").
  // curprint ( "UL";

  // DQ (8/30/2006): Make change suggested by Rama (patch)
     if (ulongint_val->get_valueString() == "")
        {
          curprint(tostring(ulongint_val->get_value()));
        }
       else
        {
          curprint(ulongint_val->get_valueString());
        }
   }

void
UnparseLanguageIndependentConstructs::unparseFloatVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgFloatVal* float_val = isSgFloatVal(expr);
     ROSE_ASSERT(float_val != NULL);

#if 0
     printf ("Inside of unparseFloatVal = %p \n",float_val);
     float_val->get_file_info()->display("unparseFloatVal");
#endif

  // DQ (10/18/2005): Need to handle C code which cannot use C++ mechanism to specify 
  // infinity, quiet NaN, and signaling NaN values.  Note that we can't use the C++
  // interface since the input program, and thus the generated code, might not have 
  // included the "limits" header file.
     float float_value = float_val->get_value();
#if 0
     if (SageInterface::is_C_language() == true)
        {
          if (float_val->get_valueString() == "")
             {
               curprint(tostring(float_val->get_value()));
             }
            else
             {
               curprint(float_val->get_valueString());
             }
        }
       else
        {
        }
#endif

     if (float_value == std::numeric_limits<float>::infinity())
        {
       // printf ("Infinite value found as value in unparseFloatVal() \n");
       // curprint ( "std::numeric_limits<float>::infinity()";
          curprint( "__builtin_huge_valf()");
        }
       else
        {
       // Test for NaN value (famous test of to check for equality) or check for C++ definition of NaN.
       // We detect C99 and C "__NAN__" in EDG, but translate to backend specific builtin function.
          if ((float_value != float_value) || (float_value == std::numeric_limits<float>::quiet_NaN()) )
             {
            // curprint ( "std::numeric_limits<float>::quiet_NaN()";
               curprint( "__builtin_nanf (\"\")");
             }
            else
             {
               if (float_value == std::numeric_limits<float>::signaling_NaN())
                  {
                 // curprint ( "std::numeric_limits<float>::signaling_NaN()";
                    curprint("__builtin_nansf (\"\")");
                  }
                 else
                  {
                 // typical case!
                 // curprint ( float_val->get_value();
                 // AS (11/08/2005) add support for values as string
                    if (float_val->get_valueString() == "")
                       {
                         curprint(tostring(float_val->get_value()));
                       }
                      else
                       {
                         curprint(float_val->get_valueString());
                       }
                  }
             }
        }
   }

#if 0
// DQ: This is no longer used (we use properties of the iostream to formate floating point now).
bool
UnparseLanguageIndependentConstructs::zeroRemainder( long double doubleValue )
   {
     int integerValue = (int)doubleValue;
     double remainder = doubleValue - (double)integerValue;

     return (remainder == 0) ? true : false;
   }
#endif

void
UnparseLanguageIndependentConstructs::unparseDoubleVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgDoubleVal* dbl_val = isSgDoubleVal(expr);
     ROSE_ASSERT(dbl_val != NULL);

#if 0
     printf ("Inside of unparseDblVal = %p \n",dbl_val);
     dbl_val->get_file_info()->display("unparseDblVal");
#endif

  // os->setf(ios::showpoint);
  // curprint ( dbl_val->get_value();
  // curprint ( setiosflags(ios::showpoint) + setprecision(4) + dbl_val->get_value();

     setiosflags(ios::showpoint);

  // DQ (10/16/2004): Not sure what 4 implies, but we get 16 digits after the decimal 
  // point so it should be fine (see test2004_114.C)!
     setprecision(4);

  // curprint ( dbl_val->get_value();
  // os->unsetf(ios::showpoint);

  // DQ (10/18/2005): Need to handle C code which cannot use C++ mechanism to specify 
  // infinity, quiet NaN, and signaling NaN values.
     double double_value = dbl_val->get_value();
     if (double_value == std::numeric_limits<double>::infinity())
        {
       // printf ("Infinite value found as value in unparseFloatVal() \n");
       // curprint ( "std::numeric_limits<double>::infinity()";
          curprint ( "__builtin_huge_val()");
        }
       else
        {
       // Test for NaN value (famous test of to check for equality) or check for C++ definition of NaN.
       // We detect C99 and C "__NAN__" in EDG, but translate to backend specific builtin function.
          if ( (double_value != double_value) || (dbl_val->get_value() == std::numeric_limits<double>::quiet_NaN()) )
             {
            // curprint ( "std::numeric_limits<double>::quiet_NaN()";
               curprint ( "__builtin_nan (\"\")");
             }
            else
             {
               if (double_value == std::numeric_limits<double>::signaling_NaN())
                  {
                 // curprint ( "std::numeric_limits<double>::signaling_NaN()";
                    curprint ( "__builtin_nans (\"\")");
                  }
                 else
                  {
                 // typical case!
                 // curprint ( dbl_val->get_value();
                 // AS (11/08/2005) add support for values as string
                    if (dbl_val->get_valueString() == "")
                         curprint(tostring(double_value));
                      else
                         curprint(dbl_val->get_valueString());
                  }
             }
        }
   }

void
UnparseLanguageIndependentConstructs::unparseLongDoubleVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgLongDoubleVal* longdbl_val = isSgLongDoubleVal(expr);
     ROSE_ASSERT(longdbl_val != NULL);
  /* code inserted from specification */
  
  // curprint ( longdbl_val->get_value();

  // DQ (10/18/2005): Need to handle C code which cannot use C++ mechanism to specify 
  // infinity, quiet NaN, and signaling NaN values.
     long double longDouble_value = longdbl_val->get_value();
     if (longDouble_value == std::numeric_limits<long double>::infinity())
        {
       // printf ("Infinite value found as value in unparseFloatVal() \n");
       // curprint ( "std::numeric_limits<long double>::infinity()";
          curprint ( "__builtin_huge_vall()");
        }
       else
        {
       // Test for NaN value (famous test of to check for equality) or check for C++ definition of NaN.
       // We detect C99 and C "__NAN__" in EDG, but translate to backend specific builtin function.
          if ( (longDouble_value != longDouble_value) || (longDouble_value == std::numeric_limits<long double>::quiet_NaN()) )
             {
            // curprint ( "std::numeric_limits<long double>::quiet_NaN()";
               curprint ( "__builtin_nanl (\"\")");
             }
            else
             {
               if (longDouble_value == std::numeric_limits<long double>::signaling_NaN())
                  {
                 // curprint ( "std::numeric_limits<long double>::signaling_NaN()";
                    curprint ( "__builtin_nansl (\"\")");
                  }
                 else
                  {
                 // typical case!
                 // curprint ( longdbl_val->get_value();
                 // AS (11/08/2005) add support for values as string
                    if (longdbl_val->get_valueString() == "")
                         curprint ( tostring(longDouble_value));
                      else
                         curprint ( longdbl_val->get_valueString());
                  }
             }
        }
   }

void
UnparseLanguageIndependentConstructs::unparseComplexVal(SgExpression* expr, SgUnparse_Info& info)
   {
     SgComplexVal* complex_val = isSgComplexVal(expr);
     ROSE_ASSERT(complex_val != NULL);

     if (complex_val->get_valueString() != "") { // Has string
       curprint (complex_val->get_valueString());
     } else if (complex_val->get_real_value() == NULL) { // Pure imaginary
       curprint ("(0.0, ");
       unparseValue(complex_val->get_imaginary_value(), info);
       curprint (")");
     } else { // Complex number
       curprint ("(");
       unparseValue(complex_val->get_real_value(), info);
       curprint (", ");
       unparseValue(complex_val->get_imaginary_value(), info);
       curprint (")");
     }
   }


void
UnparseLanguageIndependentConstructs::unparseExprList(SgExpression* expr, SgUnparse_Info& info)
   {
     SgExprListExp* expr_list = isSgExprListExp(expr);
     ROSE_ASSERT(expr_list != NULL);
  /* code inserted from specification */
  
     SgExpressionPtrList::iterator i = expr_list->get_expressions().begin();

     if (i != expr_list->get_expressions().end())
        {
          while (true)
             {
               SgUnparse_Info newinfo(info);
               newinfo.set_SkipBaseType();
               unparseExpression(*i, newinfo);
               i++;
               if (i != expr_list->get_expressions().end())
                  {
                    curprint ( ",");
                  }
                 else
                  {
                    break;
                  }
             }
        }
   }


void 
UnparseLanguageIndependentConstructs::unparseIncludeDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIncludeDirectiveStatement* directive = isSgIncludeDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     
     //negara1 (08/15/2011): Do not unparse the directive string as long as there are PreprocessorInfos attached to nodes in order to avoid double unparsing.
     //Also, note that it might belong to a different file since the code can reach here when the include directive statement's header file body belongs to the unparsed file.     
     //curprint(directive->get_directiveString());
     //unp->cur.insert_newline(1);
     
     SgHeaderFileBody* headerFileBody = directive -> get_headerFileBody();
     if (headerFileBody -> get_file_info() -> get_filenameString() == getFileName()) {
        unparseAttachedPreprocessingInfo(headerFileBody, info, PreprocessingInfo::after); //Its always "after" if attached to a header file body.
     }
   }

void 
UnparseLanguageIndependentConstructs::unparseDefineDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgDefineDirectiveStatement* directive = isSgDefineDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
  // unp->u_sage->curprint_newline();
     unp->cur.insert_newline(1);
   }

void 
UnparseLanguageIndependentConstructs::unparseUndefDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgUndefDirectiveStatement* directive = isSgUndefDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseIfdefDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIfdefDirectiveStatement* directive = isSgIfdefDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseIfndefDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIfndefDirectiveStatement* directive = isSgIfndefDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseDeadIfDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgDeadIfDirectiveStatement* directive = isSgDeadIfDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseIfDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIfDirectiveStatement* directive = isSgIfDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseElseDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgElseDirectiveStatement* directive = isSgElseDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseElseifDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgElseifDirectiveStatement* directive = isSgElseifDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseEndifDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgEndifDirectiveStatement* directive = isSgEndifDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseLineDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgLineDirectiveStatement* directive = isSgLineDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseWarningDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgWarningDirectiveStatement* directive = isSgWarningDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseErrorDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgErrorDirectiveStatement* directive = isSgErrorDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseEmptyDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgEmptyDirectiveStatement* directive = isSgEmptyDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseIdentDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIdentDirectiveStatement* directive = isSgIdentDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseIncludeNextDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgIncludeNextDirectiveStatement* directive = isSgIncludeNextDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void 
UnparseLanguageIndependentConstructs::unparseLinemarkerDirectiveStatement (SgStatement* stmt, SgUnparse_Info& info)
   {
     SgLinemarkerDirectiveStatement* directive = isSgLinemarkerDirectiveStatement(stmt);
     ROSE_ASSERT(directive != NULL);
     curprint(directive->get_directiveString());
     unp->u_sage->curprint_newline();
   }

void UnparseLanguageIndependentConstructs::unparseOmpDefaultClause(SgOmpClause* clause, SgUnparse_Info& info)
{
  ROSE_ASSERT(clause != NULL);
  SgOmpDefaultClause * c = isSgOmpDefaultClause(clause);
  ROSE_ASSERT(c!= NULL);
  curprint(string(" default("));
  SgOmpClause::omp_default_option_enum dv = c->get_data_sharing(); 
  switch (dv)
  {
    case SgOmpClause::e_omp_default_none:
      {
        curprint(string("none"));
        break;
      }
    case SgOmpClause::e_omp_default_shared:
      {   
        curprint(string("shared"));
        break;
      }   
    case SgOmpClause::e_omp_default_private:
      {
        curprint(string("private"));
        break;
      }
    case SgOmpClause::e_omp_default_firstprivate:
      {
        curprint(string("firstprivate"));
        break; 
      }
    default:
      cerr<<"Error: UnparseLanguageIndependentConstructs::unparseOmpDefaultClause() meets unacceptable default option value:"<<dv<<endl;
      break;
  }    
  curprint(string(")"));
}

void UnparseLanguageIndependentConstructs::unparseOmpScheduleClause(SgOmpClause* clause, SgUnparse_Info& info)
{
  ROSE_ASSERT(clause != NULL);
  SgOmpScheduleClause* c = isSgOmpScheduleClause(clause);
  ROSE_ASSERT(c!= NULL);
  curprint (string (" schedule("));
  SgOmpClause::omp_schedule_kind_enum skind = c-> get_kind ();
  switch (skind)
  {
    case SgOmpClause::e_omp_schedule_static:
      {
        curprint(string("static"));
        break;
      }
    case SgOmpClause::e_omp_schedule_dynamic:
      {
        curprint(string("dynamic"));
        break;
      }
    case SgOmpClause::e_omp_schedule_guided:
      {
        curprint(string("guided"));
        break;
      }
    case SgOmpClause::e_omp_schedule_auto :
      {
        curprint(string("auto"));
        break;
      }
    case SgOmpClause::e_omp_schedule_runtime :
      {
        curprint(string("runtime"));
        break;
      }
    default:
      cerr<<"Error: UnparseLanguageIndependentConstructs::unparseOmpScheduleClause() meets unacceptable kind option value:"<<skind<<endl;
      break;
  }

  // chunk_size expression
  SgUnparse_Info ninfo(info);
  if (c->get_chunk_size())
  {
    curprint(string(" , "));
    unparseExpression(c->get_chunk_size(), ninfo);
  }

  curprint(string(")"));
}

#if 1
//! A helper function to convert reduction operators to strings
// TODO put into a better place and expose it to users.
static std::string reductionOperatorToString(SgOmpClause::omp_reduction_operator_enum ro)
{
  string result;
  switch (ro)
  {
    case SgOmpClause::e_omp_reduction_plus: 
      {
        result = "+";
        break;
      }
    case SgOmpClause::e_omp_reduction_mul: 
      {
        result = "*";
        break;
      }
    case SgOmpClause::e_omp_reduction_minus:   
      {
        result = "-";
        break;
      }
    case SgOmpClause::e_omp_reduction_bitand:  
      {
        result = "&";
        break;
      }
    case SgOmpClause::e_omp_reduction_bitor :  
      {
        result = "|";
        break;
      }
      //------------
    case SgOmpClause::e_omp_reduction_bitxor:  
      {
        result = "^";
        break;
      }
    case SgOmpClause::e_omp_reduction_logand:  
      {
        result = "&&";
        break;
      }
    case SgOmpClause::e_omp_reduction_logor :  
      {
        result = "||";
        break;
      }
    case SgOmpClause::e_omp_reduction_and  : 
      {
        result = ".and.";
        break;
      }
    case SgOmpClause::e_omp_reduction_or : 
      {
        result = ".or.";
        break;
      }
     //------------
    case SgOmpClause::e_omp_reduction_eqv:   
      {
        result = ".eqv.";
        break;
      }
    case SgOmpClause::e_omp_reduction_neqv : 
      {
        result = ".neqv.";
        break;
      }
    case SgOmpClause::e_omp_reduction_max  : 
      {
        result = "max";
        break;
      }
    case SgOmpClause::e_omp_reduction_min  : 
      {
        result = "min";
        break;
      }
    case SgOmpClause::e_omp_reduction_iand : 
      {
        result = "iand";
        break;
      }

      //------------
    case SgOmpClause::e_omp_reduction_ior  : 
      {
        result = "ior";
        break;
      }
    case SgOmpClause::e_omp_reduction_ieor : 
      {
        result = "ieor";
        break;
      }
    default:
      {
        cerr<<"Error: unhandled operator type reductionOperatorToString():"<< ro <<endl;
        ROSE_ASSERT(false);
      }
  }
  return result;
}

static std::string mapOperatorToString(SgOmpClause::omp_map_operator_enum ro)
{
  string result;
  switch (ro)
  {
    case SgOmpClause::e_omp_map_inout: 
      {
        result = "inout";
        break;
      }
    case SgOmpClause::e_omp_map_in: 
      {
        result = "in";
        break;
      }
    case SgOmpClause::e_omp_map_out:   
      {
        result = "out";
        break;
      }
    case SgOmpClause::e_omp_map_alloc:  
      {
        result = "alloc";
        break;
      }
   default:
      {
        cerr<<"Error: unhandled operator type MapOperatorToString():"<< ro <<endl;
        ROSE_ASSERT(false);
      }
  }
  return result;
}

#endif

//! Unparse an OpenMP clause with a variable list
void UnparseLanguageIndependentConstructs::unparseOmpVariablesClause(SgOmpClause* clause, SgUnparse_Info& info)
{
  ROSE_ASSERT(clause != NULL);
  SgOmpVariablesClause* c= isSgOmpVariablesClause (clause);  
  ROSE_ASSERT(c!= NULL);
  bool is_map = false;
  // unparse the  clause name first
  switch (c->variantT())
  {
    case V_SgOmpCopyinClause:
      curprint(string(" copyin("));
      break;
    case V_SgOmpCopyprivateClause:
      curprint(string(" copyprivate("));
      break;
    case V_SgOmpFirstprivateClause:
      curprint(string(" firstprivate("));
      break;
    case V_SgOmpLastprivateClause:
      curprint(string(" lastprivate("));
      break;
    case V_SgOmpPrivateClause:
      curprint(string(" private("));
      break;
    case V_SgOmpUniformClause:
      curprint(string(" uniform("));
      break;
    case V_SgOmpAlignedClause:
      curprint(string(" aligned("));
      break;
    case V_SgOmpReductionClause:
      {
        curprint(string(" reduction("));
        //reductionOperatorToString() will handle language specific issues 
        curprint(reductionOperatorToString(isSgOmpReductionClause(c)->get_operation()));
        curprint(string(" : "));
      break;
    case V_SgOmpLinearClause:
      curprint(string(" linear("));
      break;
      }
    case V_SgOmpMapClause:
      {
        is_map = true;
        curprint(string(" map("));
        curprint(mapOperatorToString(isSgOmpMapClause(c)->get_operation()));
        curprint(string(" : "));
      break;
      }
 
    case V_SgOmpSharedClause:
      curprint(string(" shared("));
      break;
    default:
      cerr<<"Error: unhandled clause type in UnparseLanguageIndependentConstructs::unparseOmpVariablesClause ():"<< clause->class_name()<<endl;
      ROSE_ASSERT(false);
      break;
  }

  // prepare array dimension info for map variables
  std::map<SgSymbol*, std::vector<std::pair<SgExpression*, SgExpression*> > > dims;
  if (is_map)
  {
    SgOmpMapClause * m_clause = isSgOmpMapClause (clause);
    ROSE_ASSERT (m_clause != NULL);
    dims = m_clause->get_array_dimensions();
  }  


  //unparse variable list then
  SgVarRefExpPtrList::iterator p = c->get_variables().begin();
  while ( p != c->get_variables().end() )
  {
    SgInitializedName* init_name = (*p)->get_symbol()->get_declaration();           
    SgName tmp_name  = init_name->get_name();
    curprint( tmp_name.str());
    SgVariableSymbol * sym  = (*p)->get_symbol();
    ROSE_ASSERT (sym != NULL);
    if (is_map)
    {
      std::vector<std::pair<SgExpression*, SgExpression*> > bounds = dims[sym];
      if (bounds.size() >0)
      {
        std::vector<std::pair<SgExpression*, SgExpression*> >:: const_iterator iter;
        for (iter = bounds.begin(); iter != bounds.end(); iter ++)
        {
          SgUnparse_Info ninfo(info);
          std::pair<SgExpression*, SgExpression*> bound  = (*iter);
          SgExpression* lower = bound.first;
          SgExpression* upper = bound.second;
          ROSE_ASSERT (lower != NULL);
          ROSE_ASSERT (upper != NULL);

          curprint(string("["));
//          curprint(lower->unparseToString());
          unparseExpression(lower, ninfo);
          curprint(string(":"));
//          curprint(upper->unparseToString());
          unparseExpression(upper, ninfo);
          curprint(string("]"));
        } // end for
      } // end if has bounds
    } // end if map 

    // output the optional dimension info for map() variable 
    // Move to the next argument
    p++;

    // Check if this is the last argument (output a "," separator if not)
    if (p != c->get_variables().end())
    {
      curprint( ",");
    }
  }

  curprint(string(")"));
}

void UnparseLanguageIndependentConstructs::unparseOmpExpressionClause(SgOmpClause* clause, SgUnparse_Info& info)
{
  ROSE_ASSERT(clause != NULL);
  SgOmpExpressionClause * c = isSgOmpExpressionClause (clause);
  ROSE_ASSERT  (c);
  SgOmpExpressionClause* exp_clause = isSgOmpExpressionClause(c);
  ROSE_ASSERT(exp_clause);
  if (isSgOmpCollapseClause(c))
    curprint(string(" collapse("));
  else if (isSgOmpIfClause(c))
    curprint(string(" if("));
  else if (isSgOmpNumThreadsClause(c))
    curprint(string(" num_threads("));
  else if (isSgOmpDeviceClause(c))
    curprint(string(" device("));
  else {
    cerr<<"Error: unacceptable clause type within unparseOmpExpressionClause():"<< clause->class_name()<<endl;
    ROSE_ASSERT(false);
  }    

  // unparse the expression
  SgUnparse_Info ninfo(info);
  if (exp_clause->get_expression())
    unparseExpression(exp_clause->get_expression(), ninfo);
  else
  {
    cerr<<"Error: missing expression within unparseOmpExpressionClause():"<< clause->class_name()<<endl;
    ROSE_ASSERT(false);
  }

  curprint(string(")"));
}      

// Entry point for unparsing OpenMP clause
void UnparseLanguageIndependentConstructs::unparseOmpClause(SgOmpClause* clause, SgUnparse_Info& info)
{
  ROSE_ASSERT(clause != NULL);
  switch (clause->variantT())
  {
    case V_SgOmpDefaultClause:
      {
        unparseOmpDefaultClause(isSgOmpDefaultClause(clause),info);
        break;
      }
    case V_SgOmpNowaitClause:
      {
        curprint(string(" nowait"));
        break;
      }
    case V_SgOmpOrderedClause:
      {
        curprint(string(" ordered"));
        break;
      }
    case V_SgOmpUntiedClause:
      {
        curprint(string(" untied"));
        break;
      }
    case V_SgOmpScheduleClause:
      {
        unparseOmpScheduleClause(isSgOmpScheduleClause(clause), info);
        break;
      }
    case V_SgOmpDeviceClause:
    case V_SgOmpCollapseClause:
    case V_SgOmpIfClause:  
    case V_SgOmpNumThreadsClause:  
      //case V_SgOmpExpressionClause: // there should be no instance for this clause
      {
        unparseOmpExpressionClause(isSgOmpExpressionClause(clause), info);
        break; 
      }                       
    case V_SgOmpCopyprivateClause:
    case V_SgOmpCopyinClause:
    case V_SgOmpFirstprivateClause:
    case V_SgOmpLastprivateClause:
    case V_SgOmpPrivateClause:
    case V_SgOmpReductionClause:
    case V_SgOmpMapClause:
    case V_SgOmpSharedClause:
    case V_SgOmpLinearClause:
    case V_SgOmpUniformClause:
    case V_SgOmpAlignedClause:
      {     
        unparseOmpVariablesClause(isSgOmpVariablesClause(clause), info);
        break;
      }     

    default:
      {
        cerr<<"Unhandled OpenMP clause type in UnparseLanguageIndependentConstructs::unparseOmpClause():"<<clause->class_name()<<endl;
        ROSE_ASSERT(false);
        break;  
      }
  }    
}

//! This is not intended to be directly called anytime.
//  Individual languages should have implemented their own OpenMP prefixes 
void UnparseLanguageIndependentConstructs::unparseOmpPrefix(SgUnparse_Info& info)
{
  cerr<<"Error: UnparseLanguageIndependentConstructs::unparseOmpPrefix() should not be called directly!"<<endl;
  cerr<<"Individual languages should have implemented their own OpenMP prefixes."<<endl; 
  ROSE_ASSERT (false);
}
// simple directives: atomic, section, taskwait, barrier
void UnparseLanguageIndependentConstructs::unparseOmpSimpleStatement(SgStatement * stmt,  SgUnparse_Info& info)
{
  ROSE_ASSERT (stmt != NULL);
  unparseOmpDirectivePrefixAndName(stmt, info); 
  unp->u_sage->curprint_newline();
  SgOmpBodyStatement* b_stmt = isSgOmpBodyStatement(stmt);
  if (b_stmt)
  {
    ROSE_ASSERT (stmt->variantT() == V_SgOmpAtomicStatement || stmt->variantT() == V_SgOmpSectionStatement);
    SgUnparse_Info ninfo(info);
    unparseStatement(b_stmt->get_body(), ninfo);
  }
}

//----- refactor unparsing for threadprivate and flush ???
void UnparseLanguageIndependentConstructs::unparseOmpFlushStatement(SgStatement* stmt,     SgUnparse_Info& info)
{
  ROSE_ASSERT (stmt != NULL);
  SgOmpFlushStatement * s = isSgOmpFlushStatement(stmt);
  ROSE_ASSERT (s!= NULL);

  unparseOmpDirectivePrefixAndName(stmt, info); 
  if (s->get_variables().size()>0)
    curprint(string ("("));
  //unparse variable list then
  SgVarRefExpPtrList::iterator p = s->get_variables().begin();
  while ( p != s->get_variables().end() )
  {
    ROSE_ASSERT ((*p)->get_symbol() != NULL);
    SgInitializedName* init_name = (*p)->get_symbol()->get_declaration();
    ROSE_ASSERT (init_name != NULL);
    SgName tmp_name  = init_name->get_name();
    curprint( tmp_name.str());

    // Move to the next argument
    p++;

    // Check if this is the last argument (output a "," separator if not)
    if (p != s->get_variables().end())
    {
      curprint( ",");
    }
  }
  if (s->get_variables().size()>0)
    curprint (string (")"));
  unp->u_sage->curprint_newline();
}

void UnparseLanguageIndependentConstructs::unparseOmpThreadprivateStatement(SgStatement* stmt,     SgUnparse_Info& info)
{
  ROSE_ASSERT (stmt != NULL);
  SgOmpThreadprivateStatement * s = isSgOmpThreadprivateStatement(stmt);
  ROSE_ASSERT (s!= NULL);
  unparseOmpDirectivePrefixAndName(stmt, info); 
  curprint(string ("("));
  //unparse variable list then
  SgVarRefExpPtrList::iterator p = s->get_variables().begin();
  while ( p != s->get_variables().end() )
  {
    ROSE_ASSERT ( (*p)->get_symbol() != NULL);
    SgInitializedName* init_name = (*p)->get_symbol()->get_declaration();
    ROSE_ASSERT (init_name);
    SgName tmp_name  = init_name->get_name();
    curprint( tmp_name.str());

    // Move to the next argument
    p++;

    // Check if this is the last argument (output a "," separator if not)
    if (p != s->get_variables().end())
    {
      curprint( ",");
    }
  } // end while

  curprint (string (")"));
  unp->u_sage->curprint_newline();
}

// A helper function to just unparse omp-prefix directive-name, without bothering clauses
// examples: 
//  #pragma omp parallel, 
//  !$omp parallel, 
void UnparseLanguageIndependentConstructs::unparseOmpDirectivePrefixAndName (SgStatement* stmt,     SgUnparse_Info& info)
{
  ROSE_ASSERT(stmt != NULL);
  unp->u_sage->curprint_newline();
  switch (stmt->variantT())
  {
      case V_SgOmpAtomicStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("atomic "));
        break;
      }
      case V_SgOmpSectionStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("section "));
        break;
      }
      case V_SgOmpTaskStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("task "));
        break;
      }
       case V_SgOmpTaskwaitStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("taskwait "));
        break;
      }
     case V_SgOmpFlushStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("flush "));
        break;
      }
      case V_SgOmpThreadprivateStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("threadprivate "));
        break;
      }
     case V_SgOmpBarrierStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("barrier "));
        break;
      }
    case V_SgOmpParallelStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("parallel "));
        break;
      }
    case V_SgOmpTargetStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("target "));
        break;
      }
    case V_SgOmpTargetDataStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("target data "));
        break;
      }
     case V_SgOmpCriticalStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("critical "));
        if (isSgOmpCriticalStatement(stmt)->get_name().getString()!="")
        {
          curprint (string ("("));
          curprint (isSgOmpCriticalStatement(stmt)->get_name().getString());
          curprint (string (")"));
        }
        break;
      }
         case V_SgOmpForStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("for "));
        break;
      }
        case V_SgOmpDoStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("do "));
        break;
      }
       case V_SgOmpMasterStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("master "));
        break;
      }
      case V_SgOmpOrderedStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("ordered "));
        break;
      }
    case V_SgOmpWorkshareStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("workshare "));
        break;
      }
      case V_SgOmpSingleStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("single "));
        break;
      }
      case V_SgOmpSimdStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("simd "));
        break;
      }
     case V_SgOmpSectionsStatement:
      {
        unparseOmpPrefix(info);
        curprint(string ("sections "));
        break;
      }
    default:
      {
        cerr<<"error: unacceptable OpenMP directive type within unparseOmpDirectivePrefixAndName(): "<<stmt->class_name()<<endl;
        ROSE_ASSERT(false);
        break;
      }
  } // end switch
}

// This is necessary since some clauses should only appear with the begin part of a directive
// C/C++ derivation: unparse all clauses attached to the directive
// Fortran derivation: unparse most clauses except a few nowait, copyprivate clauses which should appear with the end directive
void UnparseLanguageIndependentConstructs::unparseOmpBeginDirectiveClauses      (SgStatement* stmt,     SgUnparse_Info& info)
{
  cerr<<"Error: UnparseLanguageIndependentConstructs::unparseOmpBeginDirectiveClauses() should not be called directly"<<endl;
  ROSE_ASSERT (false);
}

// Output the corresponding end directive text for an OpenMP AST nodes for directive
void UnparseLanguageIndependentConstructs::unparseOmpEndDirectivePrefixAndName (SgStatement* stmt,     SgUnparse_Info& info)
{
  ROSE_ASSERT(stmt != NULL);
  // This one should do nothing by default
  // Only Fortran derived implementation should output something there
}

// Default behavior for unparsing clauses appearing with 'end xxx'
void UnparseLanguageIndependentConstructs::unparseOmpEndDirectiveClauses        (SgStatement* stmt,     SgUnparse_Info& info)
{
  // it should not do anything here , and for C/C++ subclass
  // Derived implementation in Fortran should do something.
}

// This is a catch-all helper function 
void UnparseLanguageIndependentConstructs::unparseOmpGenericStatement (SgStatement* stmt,     SgUnparse_Info& info)
{
  ROSE_ASSERT(stmt != NULL);
  // unparse the begin directive
  unparseOmpDirectivePrefixAndName (stmt, info);
  // unparse the begin directive's clauses
  unparseOmpBeginDirectiveClauses(stmt, info);
  unp->u_sage->curprint_newline();

  // unparse the body, if exists. 
  SgOmpBodyStatement* b_stmt = isSgOmpBodyStatement(stmt);
  if (b_stmt)
  {
    SgUnparse_Info ninfo(info);
    unparseStatement(b_stmt->get_body(), ninfo);
  }
  else
 {
   //TODO assertion for must-have bodies
  }

  // unparse the end directive and name 
  unparseOmpEndDirectivePrefixAndName (stmt, info);
  // unparse the end directive's clause
  unparseOmpEndDirectiveClauses(stmt, info);

} // end unparseOmpGenericStatement


PrecedenceSpecifier
UnparseLanguageIndependentConstructs::getPrecedence(SgExpression* expr)
   {
  // DQ (11/24/2007): This is a redundant mechanism for computing the precedence of expressions (NO!)
  // DQ (4/20/2013): Actually, this is the support for operator precedence that is correctly handling
  // overloaded operators to be the precedence of the operators that they are overloading, so this 
  // is an important part of the unparser infrastructure.  There is also a specifictaion of 
  // operator precedence a static data members on each expression IR node, and this function could 
  // and likely should use the values that are set there to avoud some level of redundancy.

#if PRINT_DEVELOPER_WARNINGS
     printf ("This is a redundant mechanism for computing the precedence of expressions \n");
#endif

#if 0
     printf ("In getPrecedence(): expr = %p = %s \n",expr,expr->class_name().c_str());
#endif

  // This call to GetOperatorVariant will map overloaded operators for syntax (e.g. operator+()) 
  // to the associated operators (e.g. +) so that the overloaded operators will have the same 
  // precedence as the operators they are overloading.
     int variant = GetOperatorVariant(expr);

#if 0
     printf ("In getPrecedence(): variant = %d = %s \n",variant,Cxx_GrammarTerminalNames[variant].name.c_str());
#endif

     switch (variant)
        {
          case V_SgExprListExp:
          case V_SgCommaOpExp:       return 1;
          case V_SgAssignOp:         return 2;
       // DQ (2/1/2009): Added precedence for SgPointerAssignOp (Fortran 90)
          case V_SgPointerAssignOp:  return 2;
          case V_SgPlusAssignOp:     return 2;
          case V_SgMinusAssignOp:    return 2;
          case V_SgAndAssignOp:      return 2;
          case V_SgIorAssignOp:      return 2;
          case V_SgMultAssignOp:     return 2;
          case V_SgDivAssignOp:      return 2;
          case V_SgModAssignOp:      return 2;
          case V_SgXorAssignOp:      return 2;
          case V_SgLshiftAssignOp:   return 2;
          case V_SgRshiftAssignOp:   return 2;
          case V_SgConditionalExp:   return 3;
          case V_SgOrOp:             return 4;
          case V_SgAndOp:            return 5;
          case V_SgBitOrOp:          return 6;
          case V_SgBitXorOp:         return 7;
          case V_SgBitAndOp:         return 8;
          case V_SgEqualityOp:       return 9;
          case V_SgNotEqualOp:       return 9;
          case V_SgLessThanOp:       return 10;
          case V_SgGreaterThanOp:    return 10;
          case V_SgLessOrEqualOp:    return 10;
          case V_SgGreaterOrEqualOp: return 10;

       // DQ (1/26/2013): I think this is wrong, "<<" and ">>" have value 7 (lower than "==") (see test2013_42.C).
       // case V_SgLshiftOp:         return 11;
       // case V_SgRshiftOp:         return 11;
          case V_SgLshiftOp:         return 11;
          case V_SgRshiftOp:         return 11;

          case V_SgJavaUnsignedRshiftOp: return 11;
          case V_SgAddOp:            return 12;

       // DQ (2/1/2009): Added operator (which should have been here before)
          case V_SgMinusOp:          return 15;
          case V_SgUnaryAddOp:       return 15;

          case V_SgSubtractOp:       return 12;
          case V_SgMultiplyOp:       return 13;
          case V_SgIntegerDivideOp:
          case V_SgDivideOp:         return 13;
          case V_SgModOp:            return 13;
          case V_SgDotStarOp:        return 14;
          case V_SgArrowStarOp:      return 14;
          case V_SgPlusPlusOp:       return 15;
          case V_SgMinusMinusOp:     return 15;
          case V_SgBitComplementOp:  return 15;
          case V_SgNotOp:            return 15;
          case V_SgPointerDerefExp:
          case V_SgAddressOfOp:
          case V_SgUpcLocalsizeofExpression:   // \pp 03/03/11
          case V_SgSizeOfOp:         return 15;

       // DQ (6/20/2013): Added support for __alignof__ operator.
          case V_SgAlignOfOp:        return 15;

          case V_SgFunctionCallExp:
             {
            // DQ (4/17/2013): If this is an overloaded operator then we can't just treat it like a normal function (must detect if it is an overloaded operator).
               SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(expr);
               ROSE_ASSERT(functionCallExp != NULL);
#if 1
               if (functionCallExp->get_uses_operator_syntax() == true)
                  {
                    printf ("WARNING: In getPrecedence(): case V_SgFunctionCallExp: If this is an overloaded operator then the precedence should be that of the operator being overloaded (not zero). \n");
                    printf ("   --- functionCallExp = %p functionCallExp->get_uses_operator_syntax() = %s \n",functionCallExp,functionCallExp->get_uses_operator_syntax() ? "true" : "false");
                  }
#endif
            // ROSE_ASSERT(functionCallExp->get_uses_operator_syntax() == false);
#if 0
               if (functionCallExp != NULL && functionCallExp->get_uses_operator_syntax() == true)
                  {
                 // This is an overloaded operator and has the precedence of the operator that is being overloaded.

                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
                  }
#endif
               return 16;
             }

          case V_SgPntrArrRefExp:    return 16;
          case V_SgArrowExp:         return 16;
          case V_SgDotExp:           return 16;

          case V_SgImpliedDo:        return 16;

          case V_SgLabelRefExp:      return 16;
          case V_SgActualArgumentExpression: return 16;

       // DQ (2/1/2009): Added support for Fortran operator.
          case V_SgExponentiationOp: return 16;
          case V_SgConcatenationOp:  return 11;
          case V_SgSubscriptExpression:  return 16;  // Make the same as for SgPntrArrRefExp

       // DQ (2/1/2009): This was missing from before.
          case V_SgThisExp:          return 0;

          case V_SgCastExp:
             {
            // DQ (4/17/2013): If this is a compiler generated cast then it will not be output and the precedence should reflect that.
               SgCastExp* castExp = isSgCastExp(expr);
               if (castExp == NULL)
                  {
                 // This is likely the case of an overloaded operator (but verify this).
                    SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(expr);
                    if (functionCallExp != NULL)
                       {
                      // This should be an overloaded cast expression.
                         SgName name;
                         SgExpression* function = functionCallExp->get_function();
                         ROSE_ASSERT(function != NULL);
                         SgBinaryOp* binaryOperator = isSgBinaryOp(function);
                         if (binaryOperator != NULL)
                            {
                              SgExpression* rhs = binaryOperator->get_rhs_operand();
                              ROSE_ASSERT(rhs != NULL);

                           // This could be a member function from a class or a templated class.
                              SgMemberFunctionRefExp* mfunc_ref = isSgMemberFunctionRefExp(rhs);
                              if (mfunc_ref != NULL)
                                 {
                                   name = mfunc_ref->get_symbol()->get_name();
                                 }
                                else
                                 {
                                   SgTemplateMemberFunctionRefExp* template_mfunc_ref = isSgTemplateMemberFunctionRefExp(rhs);
                                   ROSE_ASSERT(template_mfunc_ref != NULL);
                                   name = template_mfunc_ref->get_symbol()->get_name();
                                 }
                            }
                           else
                            {
                           // This is a non-member function reference: SgFunctionRefExp.

                           // This could be a function from a class or a templated class.
                              SgFunctionRefExp* func_ref = isSgFunctionRefExp(function);
                              if (func_ref != NULL)
                                 {
                                   name = func_ref->get_symbol()->get_name();
                                 }
                                else
                                 {
                                   SgTemplateFunctionRefExp* template_func_ref = isSgTemplateFunctionRefExp(function);
                                   ROSE_ASSERT(template_func_ref != NULL);
                                   name = template_func_ref->get_symbol()->get_name();
                                 }
#if 0
                              printf ("ERROR: case V_SgCastExp: functionCallExp = %p associated function was not a SgBinaryOp: function = %p = %s \n",functionCallExp,function,function->class_name().c_str());
                              ROSE_ASSERT(false);
#endif
                            }

                         string func_name = name.str();

                         printf ("case V_SgCastExp: functionCallExp = %p associated function func_name = %s \n",functionCallExp,func_name.c_str());

                         ROSE_ASSERT(func_name.find("operator") != string::npos);

                       }
                      else
                       {
                         printf ("ERROR: case V_SgCastExp: If this is not a SgCastExp (or overloaded cast operator) then what is it: expr = %p = %s = %s \n",expr,expr->class_name().c_str(),SageInterface::get_name(expr).c_str());
                         ROSE_ASSERT(false);
                       }
                  }
                 else
                  {
                 // This is a regular SgCastExp expression.
                  }

            // Since both SgCastExp and overloaded cast operators may be compiler generated we just want to know if this is compiler generated (so use "expr" instead of "castExp" below).
               ROSE_ASSERT(expr->get_startOfConstruct() != NULL);
               if (expr->get_startOfConstruct()->isCompilerGenerated() == true)
                  {
                 // It is a problem to return zero since this causes the calling function to return "true" for needing parenthesis.
                 // So I have returned the value "1".
#if 0
                    printf ("In getPrecedence(): case V_SgCastExp: If this is an overloaded operator then the precedence should be that of the operator being overloaded (not zero). \n");
                    printf ("   --- castExp = %p isCompilerGenerated = true (return precedence = 1) \n",castExp);
#endif
                 // If this is compiler generated thenwe have to look at the precedence of the unary operator's operand.
                 // return 1;
                    if (castExp != NULL)
                       {
                         return getPrecedence(castExp->get_operand());
                       }
                      else
                       {
                      // If this is compiler generated thenwe have to look at the precedence of the unary operator's operand.
                         printf ("WARNING: case of overloaded cast operator: If this is compiler generated thenwe have to look at the precedence of the unary operator's operand (returning 1) \n");
                         return 1;
                       }
                  }

               return 0;
             }

       // DQ (7/13/2013): Added support to support this kind of value (I think this is correct, but not sure).
          case V_SgTemplateParameterVal:   return 0;

          case V_SgBoolValExp:             return 0;
          case V_SgIntVal:                 return 0;
          case V_SgThrowOp:                return 0;
          case V_SgDoubleVal:              return 0;
          case V_SgUnsignedIntVal:         return 0;
          case V_SgAssignInitializer:      return 0;
          case V_SgFloatVal:               return 0;
          case V_SgVarArgOp:               return 0;
          case V_SgLongDoubleVal:          return 0;
          case V_SgLongIntVal:             return 0;
          case V_SgLongLongIntVal:         return 0;
          case V_SgVarArgStartOp:          return 0;
          case V_SgNewExp:                 return 0;
          case V_SgDeleteExp:              return 0;
          case V_SgStringVal:              return 0;
          case V_SgCharVal:                return 0;
          case V_SgUnsignedLongLongIntVal: return 0;
          case V_SgUnsignedLongVal:        return 0;
          case V_SgComplexVal:             return 0;
          case V_SgCAFCoExpression:        return 16;

       // Liao, 7/15/2009, UPC nodes
          case V_SgUpcThreads:             return 0;
          case V_SgUpcMythread:            return 0;
          case V_SgNullExpression:         return 0;
       // TV (04/26/2010): CUDA nodes
          case V_SgCudaKernelExecConfig:   return 0;
          case V_SgCudaKernelCallExp:      return 0;

       // TV (04/24/2011): Add FunctionRefExp to avoid the following Warning. It occurs
       //     after my modification for a more generic support of the original
       //     expression tree field (especially the case of FunctionRefExp used for
       //     function pointers initialisation).
       // case V_SgFunctionRefExp:    return 0;
          case V_SgFunctionRefExp:
             {
#if 0
#if 1
               printf ("In getPrecedence(): case V_SgFunctionRefExp: If this is an overloaded operatro then the precedence should be that of the operator being overloaded (not zero). \n");
#endif
            // DQ (4/17/2013): If this is an overloaded operator then we can't just treat it like a normal function.
               SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(expr);
               ROSE_ASSERT(functionRefExp != NULL);
               ROSE_ASSERT(functionRefExp->get_parent() != NULL);
               SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(functionRefExp->get_parent()->get_parent());
               ROSE_ASSERT(functionCallExp != NULL);

               ROSE_ASSERT(functionCallExp->get_uses_operator_syntax() == false);
#if 0
               if (functionCallExp != NULL && functionCallExp->get_uses_operator_syntax() == true)
                  {
                 // This is an overloaded operator and has the precedence of the operator that is being overloaded.

                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
                  }
#endif
#endif
               return 0;
             }

       // DQ (10/8/2012): Unclear if this is the correct precedence for this GNU specific feature.
       // Note that this setting is equivalent to what was being returned, so I expect it is fine since it represents no change.
          case V_SgStatementExpression:      return 0;

       // DQ (10/8/2012): Unclear if this is the correct precedence for this GNU specific feature.
       // Note that this setting is equivalent to what was being returned, so I expect it is fine since it represents no change.
          case V_SgVarRefExp:                return 0;

       // DQ (7/22/2013): I think this needs to be set so that we never output parenthesis for this case.
       // DQ (10/17/2012): Added support for SgDesignatedInitializer.
       // case V_SgDesignatedInitializer:    return 0;
       // case V_SgDesignatedInitializer:    return 16;
          case V_SgDesignatedInitializer:    return 0;

       // DQ (1/26/2013): This case needs to be supported (see test2013_42.C).
          case V_SgTypeIdOp:                 return 16;

       // DQ (7/13/2013): Added support to type trait builtin functions (not clear if this is the correct value).
       // Make this the same precedence as a SgFunctionCallExp.
          case V_SgTypeTraitBuiltinOperator: return 16;

       // DQ (9/25/2013): Adding support for new IR node (C90 and C++ compound literals).
          case V_SgCompoundLiteralExp: return 0;

       // DQ (9/25/2013): Adding support for Fortran user defined binary operators (however, I am not certain this is the correct precedence).
          case V_SgUserDefinedBinaryOp: return 0;

       // DQ (9/25/2013): Adding support for C/C++ asm operator (however, I am not certain this is the correct precedence).
          case V_SgAsmOp: return 0;

          default:
             {
            // We want this to be a printed warning (so we can catch these missing cases), but it is not worthy of calling an error since the default works fine.
               printf ("Warning: getPrecedence() in unparseLanguageIndependentConstructs.C: Undefined expression variant = %d = %s \n",variant,Cxx_GrammarTerminalNames[variant].name.c_str());
#if 0
            // DQ (9/25/2013): Temporarily added assertion to get rid of warnings (catching them and fixing them).
               printf ("Error: getPrecedence() in unparseLanguageIndependentConstructs.C: Undefined expression variant = %d = %s \n",variant,Cxx_GrammarTerminalNames[variant].name.c_str());
               ROSE_ASSERT(false);
#endif
             }
        }

     return 0;
   }


AssociativitySpecifier
UnparseLanguageIndependentConstructs::getAssociativity(SgExpression* expr) 
   {
  // DQ (7/23/2013): This should match the table in: http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
  // Note also that this table has the precedence in the wrong order compared to how we have listed it in ROSE.

  // I have added the case for SgCastExp, but noticed that there appear to be many incorrect entries for associativity for the 
  // other operators.  This function is called in the evaluation for added "()" using the operator precedence (obtained from
  // the function: getPrecedence()).

  // DQ (9/25/2013): It is an additional issue that some associativity rules are language dependent.  For example, I understand 
  // that Fortran supports A - B - C as A - (B - C) (right associative) where as C and C++ would treat it as (A - B) - C (left 
  // associative).  Currently all associativity is defined in terms of C/C++, this is something to fix for the Fortran.  In 
  // general we add parenthesis to support the explict handling wherever possible (I think). As a rule, Fortran relational 
  // operators are not associative.  The exponentiation operator associates right to left (right associative).  Thus, A**B**C 
  // is equal to A**(B**C) rather than (A**B)**C. All other FORTRAN operators are left to right associative (left associative)
  // (however it appears to contradict the stated rule for minus (above).

     int variant = GetOperatorVariant(expr);
     switch (variant)
        {
       // DQ (7/23/2013): Added cast operator.
          case V_SgCastExp:
             {
               if (expr->get_file_info()->isCompilerGenerated() == true)
                  {
#if 0
                    printf ("WARNING: In getAssociativity(): We should not be calling getAssociativity(SgExpression* expr) if this is a compiler generated (implicit) cast (returing e_assoc_none) \n");
#endif
                    return e_assoc_none;
                  }
                 else
                  {
                 // The cast is right associative.
                    return e_assoc_right;
                  }
             }

          case V_SgPlusPlusOp:
          case V_SgMinusMinusOp:
             {
            // DQ (7/23/2013): The associativity of these operators depends upon if they are pre or post operators (assuming post-fix).
            // Note: post-fix is left associative, and pre-fix is right associative.

               AssociativitySpecifier associativitySpecifier = e_assoc_none;

               SgUnaryOp* unaryOp = isSgUnaryOp(expr);
               if (unaryOp->get_mode() == SgUnaryOp::prefix)
                  {
                    associativitySpecifier = e_assoc_right;
                  }
                 else
                  {
                    ROSE_ASSERT(unaryOp->get_mode() == SgUnaryOp::postfix);
                    associativitySpecifier = e_assoc_left;
                  }

               return associativitySpecifier;
             }
           
          case V_SgNotOp:
             {
#if 0
               printf ("WARNING: In getAssociativity(): I think that the logical not operator should be right associative! \n");
#endif
            // This has forever been marked as left associative in ROSE.
               return e_assoc_left;
             }

          case V_SgAssignOp:
          case V_SgAndAssignOp:
          case V_SgIorAssignOp:
          case V_SgMultAssignOp:
          case V_SgDivAssignOp:
          case V_SgModAssignOp:
          case V_SgXorAssignOp:
          case V_SgLshiftAssignOp:
          case V_SgRshiftAssignOp:
          case V_SgPlusAssignOp:
          case V_SgMinusAssignOp:
          case V_SgConditionalExp:
          case V_SgBitComplementOp:
          case V_SgPointerDerefExp:
          case V_SgAddressOfOp:
          case V_SgSizeOfOp:
              return e_assoc_left;

          case V_SgCommaOpExp:
          case V_SgOrOp:
          case V_SgAndOp:
          case V_SgBitOrOp:
          case V_SgBitXorOp:
          case V_SgBitAndOp:
          case V_SgEqualityOp:
          case V_SgNotEqualOp:
          case V_SgLessThanOp:
          case V_SgGreaterThanOp:
          case V_SgLessOrEqualOp:
          case V_SgGreaterOrEqualOp:
          case V_SgLshiftOp:
          case V_SgRshiftOp:
          case V_SgAddOp:
          case V_SgSubtractOp:
          case V_SgMultiplyOp:
          case V_SgIntegerDivideOp:
          case V_SgDivideOp:
          case V_SgModOp:
          case V_SgDotStarOp:
          case V_SgArrowStarOp:
          case V_SgFunctionCallExp:
          case V_SgPntrArrRefExp:
          case V_SgArrowExp:
          case V_SgDotExp:
              return e_assoc_right;

       // DQ (9/25/2013): The Fortran SgExponentiationOp has right associativity.
           case V_SgExponentiationOp:
              return e_assoc_right;

       // DQ (9/25/2013): I believe that the Fortran SgConcatenationOp has left associativity.
          case V_SgConcatenationOp:
              return e_assoc_left;

       // DQ (1/25/2014): This is not really defined for unary operators, but it does not make sense to output the warning below either.
          case V_SgMinusOp:
          case V_SgUnaryAddOp:
             {
               return e_assoc_none;
             }
          
          default:
             {
            // We want this to be a printed warning (so we can catch these missing cases), but it is not worthy of calling an error since the default works fine.
            // The implementation of this function assumes unhandled cases are not associative.
               printf ("Warning: getAssociativity(): Undefined expression variant = %d = %s (returning e_assoc_none) \n",variant,Cxx_GrammarTerminalNames[variant].name.c_str());
#if 0
            // DQ (9/25/2013): Temporarily added assertion to get rid of warnings (catching them and fixing them).
               printf ("Error: getAssociativity(): Undefined expression variant = %d = %s (returning e_assoc_none) \n",variant,Cxx_GrammarTerminalNames[variant].name.c_str());
               ROSE_ASSERT(false);
#endif
             }
        }

     return e_assoc_none;
   }

bool
UnparseLanguageIndependentConstructs::requiresParentheses(SgExpression* expr, SgUnparse_Info& info) 
   {
     ROSE_ASSERT(expr != NULL);

#if 0
     if (isSgSubscriptExpression(expr) != NULL || isSgDotExp(expr) || isSgCAFCoExpression(expr) || isSgPntrArrRefExp(expr) )
        {
          return false;
        }
#endif

     SgExpression* parentExpr = isSgExpression(expr->get_parent());

#define DEBUG_PARENTHESIS_PLACEMENT 0

#if DEBUG_PARENTHESIS_PLACEMENT
     printf ("\n\n***** In requiresParentheses() \n");
     printf ("In requiresParentheses(): expr = %p = %s need_paren = %s \n",expr,expr->class_name().c_str(),expr->get_need_paren() ? "true" : "false");
     printf ("In requiresParentheses(): isOverloadedArrowOperator(expr) = %s \n",(unp->u_sage->isOverloadedArrowOperator(expr) == true) ? "true" : "false");
     curprint(string("\n /* In requiresParentheses(): expr = ") + StringUtility::numberToString((void*)expr) + " */ \n ");
     curprint(string("/* In requiresParentheses(): expr = ") + expr->class_name() + " */ \n");
  // curprint( "\n /* RECORD_REF = " << RECORD_REF << " expr->variant() = " << expr->variant() << " */ \n");

     if (parentExpr != NULL)
        {
          printf ("In requiresParentheses(): parentExpr = %s \n",parentExpr->sage_class_name());
          printf ("isOverloadedArrowOperator(parentExpr) = %s \n",(unp->u_sage->isOverloadedArrowOperator(parentExpr) == true) ? "true" : "false");
       // curprint( "\n /* parentExpr = " << parentExpr->sage_class_name() << " */ \n");
        }
       else
        {
          printf ("In PrintStartParen(): parentExpr == NULL \n");
        }
#endif

  // DQ (1/26/2013): Moved to be located after the debugging information.
     if (isSgSubscriptExpression(expr) != NULL || isSgDotExp(expr) || isSgCAFCoExpression(expr) || isSgPntrArrRefExp(expr) )
        {
#if DEBUG_PARENTHESIS_PLACEMENT
          printf ("In requiresParentheses(): Case 1: Output false \n");
          curprint("/* In requiresParentheses(): Case 1: Output false */ \n");
#endif
          return false;
        }

     if ( (isSgBinaryOp(expr) != NULL) && (expr->get_need_paren() == true) )
        {
#if DEBUG_PARENTHESIS_PLACEMENT
          printf ("     Special case of expr->get_need_paren(): (return true) \n");
#endif
          return true;
        }

  // DQ (11/9/2009): I think this can no longer be true since we have removed the use of SgExpressionRoot.
     ROSE_ASSERT(parentExpr == NULL || parentExpr->variantT() != V_SgExpressionRoot);

     if ( parentExpr == NULL || parentExpr->variantT() == V_SgExpressionRoot || expr->variantT() == V_SgExprListExp || expr->variantT() == V_SgConstructorInitializer || expr->variantT() == V_SgDesignatedInitializer)
        {
#if DEBUG_PARENTHESIS_PLACEMENT
          printf ("     Special case of parentExpr == NULL || SgExpressionRoot || SgExprListExp || SgConstructorInitializer || SgDesignatedInitializer (return false) \n");
#endif
          return false;
        }

#if 1
    // Liao, 8/27/2008, bug 229
    // A nasty workaround since set_need_paren() has no definite effect
    // SgExprListExp-> SgAssignInitializer -> SgFunctionCallExp:
    // no () is needed for SgAssignInitializer
    // e.g:  int array[] = {func1()}; // int func1();
     SgAssignInitializer* assign_init = isSgAssignInitializer(expr);
     if ((assign_init != NULL) && (isSgExprListExp(parentExpr)))
        {
          SgExpression* operand = assign_init->get_operand();
          if (isSgFunctionCallExp(operand))
             {
#if DEBUG_PARENTHESIS_PLACEMENT
               printf ("In requiresParentheses(): Case 2: Output false \n");
#endif
               return false;
             }
        }
#endif

  // TV (04/24/11): As compiler generated cast are not unparsed they don't need additional parenthesis.
     if (isSgCastExp(expr) && expr->get_startOfConstruct()->isCompilerGenerated())
        {
#if DEBUG_PARENTHESIS_PLACEMENT
          printf ("In requiresParentheses(): Case 3 (compiler generated SgCastExp): Output false \n");
          curprint("/* In requiresParentheses(): Case 3 (compiler generated SgCastExp): Output false */ \n");
#endif
          return false;
        }

  // DQ (8/6/2005): Never output "()" where the parent is a SgAssignInitializer
     if (parentExpr != NULL && parentExpr->variantT() == V_SgAssignInitializer)
        {
#if DEBUG_PARENTHESIS_PLACEMENT
          printf ("     Special case of parentExpr == SgAssignInitializer (return false) \n");
#endif
          return false;
        }

     switch (expr->variant())
        {
       // DQ (11/18/2007): Don't use parens for these cases
          case TEMP_ColonShapeExp:
          case TEMP_AsteriskShapeExp:

       // DQ (12/2/2004): Original cases
          case VAR_REF:
          case CLASSNAME_REF:
          case FUNCTION_REF:
          case MEMBER_FUNCTION_REF:

       // DQ (4/25/2012): Added template support (avoids output of extra "()" see test2012_51.C).
          case TEMPLATE_FUNCTION_REF:
          case TEMPLATE_MEMBER_FUNCTION_REF:

          case PSEUDO_DESTRUCTOR_REF:
          case BOOL_VAL:
          case SHORT_VAL:
          case CHAR_VAL:
          case UNSIGNED_CHAR_VAL:
          case WCHAR_VAL:
          case STRING_VAL:
          case UNSIGNED_SHORT_VAL:
          case ENUM_VAL:
          case INT_VAL:
          case UNSIGNED_INT_VAL:
          case LONG_INT_VAL:
          case LONG_LONG_INT_VAL:
          case UNSIGNED_LONG_LONG_INT_VAL:
          case UNSIGNED_LONG_INT_VAL:
          case FLOAT_VAL:
          case DOUBLE_VAL:
          case LONG_DOUBLE_VAL:
          case AGGREGATE_INIT:
          case SUPER_NODE: // charles4:  This case needed for Java only.
             {
#if DEBUG_PARENTHESIS_PLACEMENT
               printf ("     case statements return false \n");
#endif
               return false;
             }

          default:
             {
               int parentVariant   = GetOperatorVariant(parentExpr);
               SgExpression* first = GetFirstOperand(parentExpr);
               if (parentVariant == V_SgPntrArrRefExp && first != expr)
                  {
                 // This case avoids redundent parenthesis within array substripts.
#if DEBUG_PARENTHESIS_PLACEMENT
                    printf ("     parentVariant  == V_SgPntrArrRefExp && first != expr (return false) \n");
#endif
                    return false;
                  }

               PrecedenceSpecifier parentPrecedence = getPrecedence(parentExpr);

#if DEBUG_PARENTHESIS_PLACEMENT
               printf ("parentVariant = %d  parentPrecedence = %d \n",parentVariant,parentPrecedence);
#endif

            // DQ (7/22/2013): Don't return true if this is a SgDesignatedInitializer.
               if (parentPrecedence == 0 && isSgDesignatedInitializer(parentExpr) != NULL)
                  {
#if DEBUG_PARENTHESIS_PLACEMENT
                    printf ("     case of SgDesignatedInitializer: parentPrecedence == 0 return true \n");
                    curprint(string("/* case of SgDesignatedInitializer parentPrecedence == 0 return false parentExpr = ") + parentExpr->class_name() + " */ \n");
#endif
                    return false;
                  }

               if (parentPrecedence == 0)
                  {
#if DEBUG_PARENTHESIS_PLACEMENT
                    printf ("     parentPrecedence == 0 return true \n");
                    curprint(string("/* parentPrecedence == 0 return true parentExpr = ") + parentExpr->class_name() + " */ \n");
#endif
                    return true;
                  }

            // int exprVariant = GetOperatorVariant(expr);
               PrecedenceSpecifier exprPrecedence = getPrecedence(expr);

#if DEBUG_PARENTHESIS_PLACEMENT
               int exprVariant = GetOperatorVariant(expr);
               printf ("exprVariant = %d  exprPrecedence = %d \n",exprVariant,exprPrecedence);
#endif
               if (exprPrecedence > parentPrecedence)
                  {
#if DEBUG_PARENTHESIS_PLACEMENT
                    printf ("     exprPrecedence > parentPrecedence return false \n");
#endif
                    return false;
                  }
                 else
                  {
                    if (exprPrecedence == parentPrecedence)
                       {
                         if (first == NULL)
                            {
#if DEBUG_PARENTHESIS_PLACEMENT
                              printf ("     exprPrecedence == parentPrecedence return true \n");
#endif
                              return true;
                            }
                         AssociativitySpecifier assoc = getAssociativity(parentExpr);
                         if (assoc == e_assoc_left && first != expr)
                            {
#if DEBUG_PARENTHESIS_PLACEMENT
                              printf ("     assoc > 0 && first != expr return false \n");
#endif
                              return false;
                            }
                         if (assoc == e_assoc_right && first == expr)
                            {
#if DEBUG_PARENTHESIS_PLACEMENT
                              printf ("     assoc < 0 && first == expr return false \n");
#endif
                              return false;
                            }

                      // DQ (7/22/2013): It appears that in many cases this is not handled in the getAssociativity() function.
                         if (assoc == e_assoc_none)
                            {
#if DEBUG_PARENTHESIS_PLACEMENT
                              printf ("WARNING: In requiresParentheses(): assoc == e_assoc_none (not clear what to return, returning true is required to pass regression tests) \n");
#endif
                           // DQ (7/23/2013): This is required to be true for test2012_104.c to pass.
                           // return false;
                              return true;
                            }
                       }
                      else
                       {
#if DEBUG_PARENTHESIS_PLACEMENT
                         printf ("     exprPrecedence != parentPrecedence return true \n");
#endif
                       }
                  }
             }
        }

#if DEBUG_PARENTHESIS_PLACEMENT
     printf ("     base of function return true \n");
#endif

     return true;
   }


