struct auto_any_base
   {
     operator bool() const
        {
          return false;
        }
   };

template<typename T>
struct auto_any : auto_any_base
   {
     auto_any(T const &t) : item(t) {}
     mutable T item;
   };

typedef auto_any_base const & auto_any_t;

void foo()
   {
  // Variable used as for the initialization of any variable of type "auto_any_t".
     auto_any_base aaa;

  // Example of constructing a variable of type "auto_any_t" (which requires an initializer because it is really a reference).
  // auto_any_t xxx = aaa;

  // Note that this will unparse to: "if (struct auto_any_base unknown_condition = aaa)"
  // The bug is that it should unparse to use the type "auto_any_t" instead of unwinding 
  // the typedef to "auto_any_base". But it is interesting that the variable "unknown_condition"
  // is generated by the compiler (I think).
  // Note: the original code is: "if (const auto_any_t xxx = aaa)".
     if (const auto_any_t xxx = aaa)
        {
        }
   }


