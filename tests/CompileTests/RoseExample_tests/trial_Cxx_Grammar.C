// MACHINE GENERATED SOURCE FILE --- DO NOT MODIFY!

#include "sage3basic.h"
#include "sage3.h"

#if 1

#include "AST_FILE_IO.h"


using namespace std;

// Simplify code by using std namespace (never put into header files since it effects users) 
using namespace std;

static struct 
   { 
     Cxx_GrammarVariants variant; 
     std::string name; 
   } Cxx_GrammarTerminalNames[317] = {  
          {ModifierTag, "SgModifier"}, 
          {BitAttributeTag, "SgBitAttribute"}, 
          {AttributeTag, "SgAttribute"}, 
          {GraphNodeTag, "SgGraphNode"}, 
          {GraphEdgeTag, "SgGraphEdge"}, 
          {GraphTag, "SgGraph"}, 
          {SupportTag, "SgSupport"}, 
          {T_PARTIAL_FUNCTION, "SgPartialFunctionType"}, 
          {T_MEMBERFUNCTION, "SgMemberFunctionType"}, 
          {T_FUNCTION, "SgFunctionType"}, 
          {T_POINTER, "SgPointerType"}, 
          {T_NAME, "SgNamedType"}, 
          {TypeTag, "SgType"}, 
          {EXPR_INIT, "SgInitializer"}, 
          {UNARY_EXPRESSION, "SgUnaryOp"}, 
          {BINARY_EXPRESSION, "SgBinaryOp"}, 
          {ValueExpTag, "SgValueExp"}, 
          {ExpressionTag, "SgExpression"}, 
          {FORTRAN_DO, "SgFortranDo"}, 
          {IO_CONTROL_STATEMENT, "SgIOControlStatement"}, 
          {CLASS_DECL_STMT, "SgClassDeclaration"}, 
          {CLASS_DEFN_STMT, "SgClassDefinition"}, 
          {SCOPE_STMT, "SgScopeStatement"}, 
          {MFUNC_DECL_STMT, "SgMemberFunctionDeclaration"}, 
          {FUNC_DECL_STMT, "SgFunctionDeclaration"}, 
          {CPP_DIRECTIVE_STMT, "SgC_PreprocessorDirectiveStatement"}, 
          {C_LINKAGE_DECLARATION_STMT, "SgClinkageDeclarationStatement"}, 
          {DECL_STMT, "SgDeclarationStatement"}, 
          {StatementTag, "SgStatement"}, 
          {FUNCTION_NAME, "SgFunctionSymbol"}, 
          {SymbolTag, "SgSymbol"}, 
          {LocatedNodeTag, "SgLocatedNode"}, 
          {NodeTag, "SgNode"}, 
          {SymbolTableTag, "SgSymbolTable"}, 
          {InitializedNameTag, "SgInitializedName"}, 
          {NameTag, "SgName"}, 
          {PragmaTag, "SgPragma"}, 
          {ModifierNodesTag, "SgModifierNodes"}, 
          {ConstVolatileModifierTag, "SgConstVolatileModifier"}, 
          {StorageModifierTag, "SgStorageModifier"}, 
          {AccessModifierTag, "SgAccessModifier"}, 
          {FunctionModifierTag, "SgFunctionModifier"}, 
          {UPC_AccessModifierTag, "SgUPC_AccessModifier"}, 
          {LinkageModifierTag, "SgLinkageModifier"}, 
          {SpecialFunctionModifierTag, "SgSpecialFunctionModifier"}, 
          {TypeModifierTag, "SgTypeModifier"}, 
          {ElaboratedTypeModifierTag, "SgElaboratedTypeModifier"}, 
          {BaseClassModifierTag, "SgBaseClassModifier"}, 
          {DeclarationModifierTag, "SgDeclarationModifier"}, 
          {_File_InfoTag, "Sg_File_Info"}, 
          {FileTag, "SgFile"}, 
          {FileListTag, "SgFileList"}, 
          {DirectoryTag, "SgDirectory"}, 
          {DirectoryListTag, "SgDirectoryList"}, 
          {ProjectTag, "SgProject"}, 
          {OptionsTag, "SgOptions"}, 
          {Unparse_InfoTag, "SgUnparse_Info"}, 
          {FuncDecl_attrTag, "SgFuncDecl_attr"}, 
          {ClassDecl_attrTag, "SgClassDecl_attr"}, 
          {T_TYPEDEF_SEQ, "SgTypedefSeq"}, 
          {T_FUNCTION_PARAMETER_TYPE_LIST, "SgFunctionParameterTypeList"}, 
          {TemplateParameterTag, "SgTemplateParameter"}, 
          {TemplateArgumentTag, "SgTemplateArgument"}, 
          {TemplateParameterListTag, "SgTemplateParameterList"}, 
          {TemplateArgumentListTag, "SgTemplateArgumentList"}, 
          {BaseClassTag, "SgBaseClass"}, 
          {DirectedGraphTag, "SgDirectedGraph"}, 
          {DirectedGraphNodeTag, "SgDirectedGraphNode"}, 
          {DirectedGraphEdgeTag, "SgDirectedGraphEdge"}, 
          {QualifiedNameTag, "SgQualifiedName"}, 
          {T_UNKNOWN, "SgTypeUnknown"}, 
          {T_CHAR, "SgTypeChar"}, 
          {T_SIGNED_CHAR, "SgTypeSignedChar"}, 
          {T_UNSIGNED_CHAR, "SgTypeUnsignedChar"}, 
          {T_SHORT, "SgTypeShort"}, 
          {T_SIGNED_SHORT, "SgTypeSignedShort"}, 
          {T_UNSIGNED_SHORT, "SgTypeUnsignedShort"}, 
          {T_INT, "SgTypeInt"}, 
          {T_SIGNED_INT, "SgTypeSignedInt"}, 
          {T_UNSIGNED_INT, "SgTypeUnsignedInt"}, 
          {T_LONG, "SgTypeLong"}, 
          {T_SIGNED_LONG, "SgTypeSignedLong"}, 
          {T_UNSIGNED_LONG, "SgTypeUnsignedLong"}, 
          {T_VOID, "SgTypeVoid"}, 
          {T_GLOBAL_VOID, "SgTypeGlobalVoid"}, 
          {T_WCHAR, "SgTypeWchar"}, 
          {T_FLOAT, "SgTypeFloat"}, 
          {T_DOUBLE, "SgTypeDouble"}, 
          {T_LONG_LONG, "SgTypeLongLong"}, 
          {T_UNSIGNED_LONG_LONG, "SgTypeUnsignedLongLong"}, 
          {T_LONG_DOUBLE, "SgTypeLongDouble"}, 
          {T_STRING, "SgTypeString"}, 
          {T_BOOL, "SgTypeBool"}, 
          {T_COMPLEX, "SgTypeComplex"}, 
          {T_IMAGINARY, "SgTypeImaginary"}, 
          {T_DEFAULT, "SgTypeDefault"}, 
          {T_MEMBER_POINTER, "SgPointerMemberType"}, 
          {T_REFERENCE, "SgReferenceType"}, 
          {T_CLASS, "SgClassType"}, 
          {T_TEMPLATE, "SgTemplateType"}, 
          {T_ENUM, "SgEnumType"}, 
          {T_TYPEDEF, "SgTypedefType"}, 
          {T_MODIFIER, "SgModifierType"}, 
          {T_PARTIAL_FUNCTION_MODIFIER, "SgPartialFunctionModifierType"}, 
          {T_ARRAY, "SgArrayType"}, 
          {T_ELLIPSE, "SgTypeEllipse"}, 
          {UnknownMemberFunctionTag, "SgUnknownMemberFunctionType"}, 
          {T_QUALIFIED_NAME, "SgQualifiedNameType"}, 
          {EXPR_LIST, "SgExprListExp"}, 
          {VAR_REF, "SgVarRefExp"}, 
          {CLASSNAME_REF, "SgClassNameRefExp"}, 
          {FUNCTION_REF, "SgFunctionRefExp"}, 
          {MEMBER_FUNCTION_REF, "SgMemberFunctionRefExp"}, 
          {FUNC_CALL, "SgFunctionCallExp"}, 
          {SIZEOF_OP, "SgSizeOfOp"}, 
          {VA_START_OP, "SgVarArgStartOp"}, 
          {VA_START_ONE_OPERAND_OP, "SgVarArgStartOneOperandOp"}, 
          {VA_OP, "SgVarArgOp"}, 
          {VA_END_OP, "SgVarArgEndOp"}, 
          {VA_COPY_OP, "SgVarArgCopyOp"}, 
          {TYPEID_OP, "SgTypeIdOp"}, 
          {EXPR_CONDITIONAL, "SgConditionalExp"}, 
          {NEW_OP, "SgNewExp"}, 
          {DELETE_OP, "SgDeleteExp"}, 
          {THIS_NODE, "SgThisExp"}, 
          {TYPE_REF, "SgRefExp"}, 
          {AGGREGATE_INIT, "SgAggregateInitializer"}, 
          {CONSTRUCTOR_INIT, "SgConstructorInitializer"}, 
          {ASSIGN_INIT, "SgAssignInitializer"}, 
          {EXPRESSION_ROOT, "SgExpressionRoot"}, 
          {UNARY_MINUS_OP, "SgMinusOp"}, 
          {UNARY_ADD_OP, "SgUnaryAddOp"}, 
          {NOT_OP, "SgNotOp"}, 
          {DEREF_OP, "SgPointerDerefExp"}, 
          {ADDRESS_OP, "SgAddressOfOp"}, 
          {MINUSMINUS_OP, "SgMinusMinusOp"}, 
          {PLUSPLUS_OP, "SgPlusPlusOp"}, 
          {BIT_COMPLEMENT_OP, "SgBitComplementOp"}, 
          {CAST_OP, "SgCastExp"}, 
          {THROW_OP, "SgThrowOp"}, 
          {POINTST_OP, "SgArrowExp"}, 
          {RECORD_REF, "SgDotExp"}, 
          {DOTSTAR_OP, "SgDotStarOp"}, 
          {ARROWSTAR_OP, "SgArrowStarOp"}, 
          {EQ_OP, "SgEqualityOp"}, 
          {LT_OP, "SgLessThanOp"}, 
          {GT_OP, "SgGreaterThanOp"}, 
          {NE_OP, "SgNotEqualOp"}, 
          {LE_OP, "SgLessOrEqualOp"}, 
          {GE_OP, "SgGreaterOrEqualOp"}, 
          {ADD_OP, "SgAddOp"}, 
          {SUBT_OP, "SgSubtractOp"}, 
          {MULT_OP, "SgMultiplyOp"}, 
          {DIV_OP, "SgDivideOp"}, 
          {INTEGER_DIV_OP, "SgIntegerDivideOp"}, 
          {MOD_OP, "SgModOp"}, 
          {AND_OP, "SgAndOp"}, 
          {OR_OP, "SgOrOp"}, 
          {BITXOR_OP, "SgBitXorOp"}, 
          {BITAND_OP, "SgBitAndOp"}, 
          {BITOR_OP, "SgBitOrOp"}, 
          {COMMA_OP, "SgCommaOpExp"}, 
          {LSHIFT_OP, "SgLshiftOp"}, 
          {RSHIFT_OP, "SgRshiftOp"}, 
          {ARRAY_OP, "SgPntrArrRefExp"}, 
          {SCOPE_OP, "SgScopeOp"}, 
          {ASSIGN_OP, "SgAssignOp"}, 
          {PLUS_ASSIGN_OP, "SgPlusAssignOp"}, 
          {MINUS_ASSIGN_OP, "SgMinusAssignOp"}, 
          {AND_ASSIGN_OP, "SgAndAssignOp"}, 
          {IOR_ASSIGN_OP, "SgIorAssignOp"}, 
          {MULT_ASSIGN_OP, "SgMultAssignOp"}, 
          {DIV_ASSIGN_OP, "SgDivAssignOp"}, 
          {MOD_ASSIGN_OP, "SgModAssignOp"}, 
          {XOR_ASSIGN_OP, "SgXorAssignOp"}, 
          {LSHIFT_ASSIGN_OP, "SgLshiftAssignOp"}, 
          {RSHIFT_ASSIGN_OP, "SgRshiftAssignOp"}, 
          {BOOL_VAL, "SgBoolValExp"}, 
          {STRING_VAL, "SgStringVal"}, 
          {SHORT_VAL, "SgShortVal"}, 
          {CHAR_VAL, "SgCharVal"}, 
          {UNSIGNED_CHAR_VAL, "SgUnsignedCharVal"}, 
          {WCHAR_VAL, "SgWcharVal"}, 
          {UNSIGNED_SHORT_VAL, "SgUnsignedShortVal"}, 
          {INT_VAL, "SgIntVal"}, 
          {ENUM_VAL, "SgEnumVal"}, 
          {UNSIGNED_INT_VAL, "SgUnsignedIntVal"}, 
          {LONG_INT_VAL, "SgLongIntVal"}, 
          {LONG_LONG_INT_VAL, "SgLongLongIntVal"}, 
          {UNSIGNED_LONG_LONG_INT_VAL, "SgUnsignedLongLongIntVal"}, 
          {UNSIGNED_LONG_INT_VAL, "SgUnsignedLongVal"}, 
          {FLOAT_VAL, "SgFloatVal"}, 
          {DOUBLE_VAL, "SgDoubleVal"}, 
          {LONG_DOUBLE_VAL, "SgLongDoubleVal"}, 
          {COMPLEX_VAL, "SgComplexVal"}, 
          {NULL_EXPR, "SgNullExpression"}, 
          {VARIANT_EXPR, "SgVariantExpression"}, 
          {STMT_EXPR, "SgStatementExpression"}, 
          {ASM_OP, "SgAsmOp"}, 
          {INTRINSICFN, "SgIntrinsicFn"}, 
          {SUBSCRIPT_EXPR, "SgSubscriptExpression"}, 
          {SUBSCRIPT_COLON, "SgSubscriptColon"}, 
          {COLON, "SgColon"}, 
          {SUBSCRIPT_ASTERISK, "SgSubscriptAsterisk"}, 
          {USE_ONLY_EXPR, "SgUseOnlyExpression"}, 
          {USE_RENAME_EXPR, "SgUseRenameExpression"}, 
          {IO_ITEM_EXPR, "SgIOItemExpression"}, 
          {IO_IMPLIED_DO, "SgIOImpliedDo"}, 
          {EXPONENTIATION_OP, "SgExponentiationOp"}, 
          {FOR_STMT, "SgForStatement"}, 
          {FOR_INIT_STMT, "SgForInitStatement"}, 
          {CATCH_STATEMENT_SEQ, "SgCatchStatementSeq"}, 
          {FUNCTION_PARAMETER_LIST, "SgFunctionParameterList"}, 
          {CTOR_INITIALIZER_LIST, "SgCtorInitializerList"}, 
          {BASIC_BLOCK_STMT, "SgBasicBlock"}, 
          {GLOBAL_STMT, "SgGlobal"}, 
          {IF_STMT, "SgIfStmt"}, 
          {FUNC_DEFN_STMT, "SgFunctionDefinition"}, 
          {WHILE_STMT, "SgWhileStmt"}, 
          {DO_WHILE_STMT, "SgDoWhileStmt"}, 
          {SWITCH_STMT, "SgSwitchStatement"}, 
          {CATCH_STMT, "SgCatchOptionStmt"}, 
          {VAR_DECL_STMT, "SgVariableDeclaration"}, 
          {VAR_DEFN_STMT, "SgVariableDefinition"}, 
          {ENUM_DECL_STMT, "SgEnumDeclaration"}, 
          {ASM_STMT, "SgAsmStmt"}, 
          {TYPEDEF_STMT, "SgTypedefDeclaration"}, 
          {FUNC_TBL_STMT, "SgFunctionTypeTable"}, 
          {EXPR_STMT, "SgExprStatement"}, 
          {LABEL_STMT, "SgLabelStatement"}, 
          {CASE_STMT, "SgCaseOptionStmt"}, 
          {TRY_STMT, "SgTryStmt"}, 
          {DEFAULT_STMT, "SgDefaultOptionStmt"}, 
          {BREAK_STMT, "SgBreakStmt"}, 
          {CONTINUE_STMT, "SgContinueStmt"}, 
          {RETURN_STMT, "SgReturnStmt"}, 
          {GOTO_STMT, "SgGotoStatement"}, 
          {SPAWN_STMT, "SgSpawnStmt"}, 
          {NULL_STMT, "SgNullStatement"}, 
          {VARIANT_STMT, "SgVariantStatement"}, 
          {PRAGMA_DECL, "SgPragmaDeclaration"}, 
          {TEMPLATE_DECL_STMT, "SgTemplateDeclaration"}, 
          {TEMPLATE_INST_DECL_STMT, "SgTemplateInstantiationDecl"}, 
          {TEMPLATE_INST_DEFN_STMT, "SgTemplateInstantiationDefn"}, 
          {TEMPLATE_INST_FUNCTION_DECL_STMT, "SgTemplateInstantiationFunctionDecl"}, 
          {TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT, "SgTemplateInstantiationMemberFunctionDecl"}, 
          {PROGRAM_HEADER_STMT, "SgProgramHeaderStatement"}, 
          {PROCEDURE_HEADER_STMT, "SgProcedureHeaderStatement"}, 
          {FORTRAN_NONBLOCKED_DO, "SgFortranNonblockedDo"}, 
          {INTERFACE_STATEMENT, "SgInterfaceStatement"}, 
          {PARAMETER_STATEMENT, "SgParameterStatement"}, 
          {COMMON_BLOCK, "SgCommonBlock"}, 
          {MODULE_STATEMENT, "SgModuleStatement"}, 
          {USE_STATEMENT, "SgUseStatement"}, 
          {STOP_OR_PAUSE_STATEMENT, "SgStopOrPauseStatement"}, 
          {IO_STATEMENT, "SgIOStatement"}, 
          {INPUT_OUTPUT_STATEMENT, "SgInputOutputStatement"}, 
          {OPEN_STATEMENT, "SgOpenStatement"}, 
          {CLOSE_STATEMENT, "SgCloseStatement"}, 
          {INQUIRE_STATEMENT, "SgInquireStatement"}, 
          {IO_FILE_CONTROL_STMT, "SgIOFileControlStmt"}, 
          {TEMP_Block_Data_Statement, "SgBlockDataStatement"}, 
          {TEMP_Implicit_Statement, "SgImplicitStatement"}, 
          {TEMP_Statement_Function_Statement, "SgStatementFunctionStatement"}, 
          {TEMP_Where_Statement, "SgWhereStatement"}, 
          {TEMP_Nullify_Statement, "SgNullifyStatement"}, 
          {TEMP_Equivalence_Statement, "SgEquivalenceStatement"}, 
          {TEMP_Derived_Type_Statement, "SgDerivedTypeStatement"}, 
          {TEMP_Attribute_Specification_Statement, "SgAttributeSpecificationStatement"}, 
          {TEMP_Allocate_Statement, "SgAllocateStatement"}, 
          {TEMP_Deallocate_Statement, "SgDeallocateStatement"}, 
          {TEMP_Contains_Statement, "SgContainsStatement"}, 
          {TEMP_Sequence_Statement, "SgSequenceStatement"}, 
          {TEMP_Else_Where_Statement, "SgElseWhereStatement"}, 
          {TEMP_Arithmetic_If_Statement, "SgArithmeticIfStatement"}, 
          {TEMP_Assign_Statement, "SgAssignStatement"}, 
          {TEMP_Computed_Goto_Statement, "SgComputedGotoStatement"}, 
          {TEMP_Assigned_Goto_Statement, "SgAssignedGotoStatement"}, 
          {NAMESPACE_DECLARATION_STMT, "SgNamespaceDeclarationStatement"}, 
          {NAMESPACE_ALIAS_DECLARATION_STMT, "SgNamespaceAliasDeclarationStatement"}, 
          {NAMESPACE_DEFINITION_STMT, "SgNamespaceDefinitionStatement"}, 
          {USING_DECLARATION_STMT, "SgUsingDeclarationStatement"}, 
          {USING_DIRECTIVE_STMT, "SgUsingDirectiveStatement"}, 
          {TEMPLATE_INST_DIRECTIVE_STMT, "SgTemplateInstantiationDirectiveStatement"}, 
          {INCLUDE_DIRECTIVE_STMT, "SgIncludeDirectiveStatement"}, 
          {DEFINE_DIRECTIVE_STMT, "SgDefineDirectiveStatement"}, 
          {UNDEF_DIRECTIVE_STMT, "SgUndefDirectiveStatement"}, 
          {IFDEF_DIRECTIVE_STMT, "SgIfdefDirectiveStatement"}, 
          {IFNDEF_DIRECTIVE_STMT, "SgIfndefDirectiveStatement"}, 
          {IF_DIRECTIVE_STMT, "SgIfDirectiveStatement"}, 
          {DEAD_IF_DIRECTIVE_STMT, "SgDeadIfDirectiveStatement"}, 
          {ELSE_DIRECTIVE_STMT, "SgElseDirectiveStatement"}, 
          {ELSEIF_DIRECTIVE_STMT, "SgElseifDirectiveStatement"}, 
          {ENDIF_DIRECTIVE_STMT, "SgEndifDirectiveStatement"}, 
          {LINE_DIRECTIVE_STMT, "SgLineDirectiveStatement"}, 
          {WARNING_DIRECTIVE_STMT, "SgWarningDirectiveStatement"}, 
          {ERROR_DIRECTIVE_STMT, "SgErrorDirectiveStatement"}, 
          {EMPTY_DIRECTIVE_STMT, "SgEmptyDirectiveStatement"}, 
          {C_LINKAGE_START_STMT, "SgClinkageStartStatement"}, 
          {C_LINKAGE_END_STMT, "SgClinkageEndStatement"}, 
          {VARIABLE_NAME, "SgVariableSymbol"}, 
          {FUNCTYPE_NAME, "SgFunctionTypeSymbol"}, 
          {CLASS_NAME, "SgClassSymbol"}, 
          {TEMPLATE_NAME, "SgTemplateSymbol"}, 
          {ENUM_NAME, "SgEnumSymbol"}, 
          {FIELD_NAME, "SgEnumFieldSymbol"}, 
          {TYPEDEF_NAME, "SgTypedefSymbol"}, 
          {MEMBER_FUNC_NAME, "SgMemberFunctionSymbol"}, 
          {LABEL_NAME, "SgLabelSymbol"}, 
          {DEFAULT_NAME, "SgDefaultSymbol"}, 
          {NAMESPACE_NAME, "SgNamespaceSymbol"}, 
          {INTRINSIC_SYMBOL, "SgIntrinsicSymbol"}, 
          {MODULE_SYMBOL, "SgModuleSymbol"}, 
          {INTERFACE_SYMBOL, "SgInterfaceSymbol"}, 
          {COMMON_SYMBOL, "SgCommonSymbol"}, 
          {TOKEN, "SgToken"}, 
          {Cxx_Grammar_LAST_TAG, "last tag" } 
   }; 


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNode* 
SgNode::get_freepointer () const
   {
     assert (this != NULL);
     return p_freepointer;
   }

void
SgNode::set_freepointer ( SgNode* freepointer )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_freepointer != NULL && freepointer != NULL && p_freepointer != freepointer)
        {
          printf ("Warning: freepointer = %p overwriting valid pointer p_freepointer = %p \n",freepointer,p_freepointer);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_freepointer != NULL && freepointer != NULL && p_freepointer != freepointer) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_freepointer = freepointer;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNode::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNode::variantT() const {
  return V_SgNode;
}

#if 0
int
SgNode::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NodeTag;
   }
#endif

const char*
SgNode::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNode";  
   }

std::string
SgNode::class_name() const
   {
     assert(this != NULL);
     return "SgNode";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNode::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 769 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


// ########################################
// Some global variables used within SAGE 3
// ########################################

// declaration of variable to control internal output of debuging information
int SAGE_DEBUG = 0;  // default value is zero

// JJW (1/19/2007): Added global variable for whether virtual CFG is
// interprocedural
bool interproceduralControlFlowGraph = false;

// ###############################
// Start of source code for SgNode
// ###############################

// Support for global function type symbol table (moved to be static data pointer)
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgFunctionTypeTable* SgNode::Sgfunc_type_table = new SgFunctionTypeTable();
// SgFunctionTypeTable* SgNode::p_globalFunctionTypeTable = new SgFunctionTypeTable();
SgFunctionTypeTable* SgNode::p_globalFunctionTypeTable = NULL;

// DQ (3/12/2007): Added mangled name map to improve performance of generating mangled names
std::map<SgNode*,std::string> SgNode::p_globalMangledNameMap;
std::map<std::string,int> SgNode::p_shortMangledNameCache;


// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgNode::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
   }


// DQ (1/31/2006): We might want this function to be automaticaly generated
// except that then we could not support the assertion.  Also we
// don't have to set this function, though perhaps the interface function
// should be implemented to set it just on general principles.
SgFunctionTypeTable*
SgNode::get_globalFunctionTypeTable()
   {
  // DQ (1/31/2006): If there is no global function type symbol table then build one
     if (p_globalFunctionTypeTable == NULL)
        {
       // printf ("In SgNode::get_globalFunctionTypeTable(): p_globalFunctionTypeTable == NULL (allocating the global function type symbol table) \n");
          p_globalFunctionTypeTable = new SgFunctionTypeTable();
          ROSE_ASSERT(p_globalFunctionTypeTable != NULL);
       // p_globalFunctionTypeTable->set_parent(???);
        }

     ROSE_ASSERT(p_globalFunctionTypeTable != NULL);
     return p_globalFunctionTypeTable;
   }

void
SgNode::set_globalFunctionTypeTable ( SgFunctionTypeTable* globalFunctionTypeTable )
   {
     p_globalFunctionTypeTable = globalFunctionTypeTable;
   }

// DQ (3/17/2007): return reference to the global mangled name map (the use
// of this map is a performance optimization).
std::map<SgNode*,std::string> &
SgNode::get_globalMangledNameMap()
   {
     return p_globalMangledNameMap;
   }
#if 0
std::map<SgNode*,std::string> &
SgNode:: get_mangledNameCache()
   {
     return p_mangledNameCache;
   }
#endif
std::map<std::string, int> &
SgNode:: get_shortMangledNameCache()
   {
     return p_shortMangledNameCache;
   }

// DQ (3/17/2007): return reference to the global mangled name map (the use
// of this map is a performance optimization).
void
SgNode::clearGlobalMangledNameMap()
   {
  // Remove all elements from the globalMangledNameMap
  // p_globalMangledNameMap.erase(p_globalMangledNameMap.begin(),p_globalMangledNameMap.end());
     p_globalMangledNameMap.clear();

  // DQ (6/26/2007): The function types require the same mangled names be generated across 
  // clears of the p_globalMangledNameMap cache. Clearing the short name map breaks this.
  // It might be that we don't want to clear the short name map to permit the same mangled 
  // names to be regenerated. However, for the purposes of AST merge this is not a problem.
  // p_shortMangledNameCache.clear();
   }

#if 0
// DQ (3/12/2007): Not clear how to do this!
SgName
SgNode::lookupMangledName(const SgNode* node) const
   {
     string returnString;

  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     const SgName name = "__global__";
     SgGlobal* global = const_cast<SgGlobal*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(global);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
       else
        {
          p_globalMangledNameMap[global] = name;
          return name;
        }

     return SgName(returnString);
   }
#endif

// DQ (4/10/2006): These are the default virtual function definitions (each returns an error)
void
SgNode::addNewAttribute( std::string s, AstAttribute* a )
   {
     printf ("Error: calling SgNode::addNewAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

void
SgNode::setAttribute( std::string s, AstAttribute* a )
   {
     printf ("Error: calling SgNode::setAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

AstAttribute*
SgNode::getAttribute(std::string s) const
   {
     printf ("Error: calling SgNode::getAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);

     return NULL;
   }

void
SgNode::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     printf ("Error: calling SgNode::updateAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

void
SgNode::removeAttribute(std::string s)
   {
     printf ("Error: calling SgNode::removeAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

bool
SgNode::attributeExists(std::string s) const
   {
     printf ("Error: calling SgNode::attributeExists(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

int
SgNode::numberOfAttributes() const
   {
     int returnValue = 0;
     return returnValue;
   }

AstAttributeMechanism*
SgNode::get_attributeMechanism() const
   {
  // DQ (4/10/2006): virtual function defined at the SgNode and redefined whereever there is 
  // an AstAttributeMechanism defined!  Note that there is no set function defined.
     return NULL;
   }

void
SgNode::set_attributeMechanism(AstAttributeMechanism* a)
   {
  // Nothing to do here, but we need this virtual function so that the correct access 
  // function will be call on IR nodes where the AstAttributeMechanism is defined as 
  // a data member.

     printf ("Error: SgNode::set_attributeMechanism(AstAttributeMechanism* a) has been called \n");
     ROSE_ASSERT(false);
   }

#if 0
void 
SgNode::print( std::ostream* os,   /* 0 uses the default */
	       int maxdepth)  /* controlling function*/
   {
     Sg_print_info().reset(os, maxdepth); 
     this->_print(0); 
   }

bool 
SgNode::_print(int depth) const
   {
     return Sg_print_info().output_class(this,sage_class_name(), depth + 1);
   }
#endif

#if 0
//! implementation in base class - overridden by SgLocatedNode::directives(ostream&)
void
SgNode::directives(std::ostream& os)
   {
  // to be overridden by SgLocatedNode::directives(ostream&)
   }
#endif

#if 0
void
SgNode::unparse(SgUnparse_Info& info, std::ostream& os)
   {
  /* nothing to be done in general: only comments for statements*/
     directives(os);
     logical_unparse(info,os);
   }

void
SgNode::unparse_helper(SgUnparse_Info& info, std::ostream& os)
   {
   }

void 
SgNode::logical_unparse(SgUnparse_Info& info, std::ostream& os)
   {
   }
#endif

void
SgNode::post_construction_initialization()
   {
  // default implementation does nothing!
   }

// DQ (7/23/2005): Let these be automatically generated by ROSETTA!
// See note above where these are proptotyped, they have to be defined 
// explicitly to avoid endless recursion!

void
SgNode::set_isModified ( bool isModified)
   {
     p_isModified = isModified;
   }
                                                                                                   
bool
SgNode::get_isModified () const
   {
     return p_isModified; 
   }
                                                                                                   

bool 
SgNode::get_isVisited () const
   {
  // The p_isVisited flag has been removed, it is an error to call this function.

     assert (this != NULL);

     printf ("Error: The p_isVisited flag has been removed, it is an error to call this function (get_isVisited). \n");
     ROSE_ASSERT(false);

     return true;
   }

void
SgNode::set_isVisited ( bool isVisited )
   {
  // The p_isVisited flag has been removed, it is an error to call this function.

     assert (this != NULL);

     printf ("Error: The p_isVisited flag has been removed, it is an error to call this function (set_isVisited). \n");
     ROSE_ASSERT(false);

     set_isModified(true);
  // p_isVisited = isVisited;
     /*  */
   }


//  ! Permits specification of parent node (connects the AST tree)
/*  ! This function is called internally to connect the elements of the grammar to form the AST.
 */
void
SgNode::set_parent ( SgNode* parent )
   {
  // ROSE_ASSERT (parent != NULL);  // QY: should allow setting parent to NULL when detaching SgNodes
  // DQ (9/24/2004): Enforce this simple rule!
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this != parent);

  // printf ("In SgNode::set_parent(): Setting parent of %p = %s to %p = %s \n",this,class_name().c_str(),parent,parent->class_name().c_str());

     p_parent = parent;

  // ROSE_ASSERT( ( this != (SgNode*)(0xb484411c) ) || ( parent != (SgNode*)(0xb46fe008) ) );

  // I think this should be always be true, so let's inforce it (this happends for test2005_64.C)
     if ( ( variantT() == V_SgClassDeclaration ) && ( parent->variantT() == V_SgFunctionParameterList ) )
        {
          printf ("Warning: Found case in set_parent() where this is a SgClassDeclaration and parent is a SgFunctionParameterList \n");
       // get_file_info()->display("Warning: Found case in set_parent() where this is a SgClassDeclaration and parent is a SgFunctionParameterList");
        }
  // ROSE_ASSERT( ( variantT() != V_SgClassDeclaration ) || ( parent->variantT() != V_SgFunctionParameterList ) );

  // We should not be setting the parent on SgType IR nodes
     ROSE_ASSERT( isSgType(this) == NULL );
   }

/*! \brief Set the parent node.
    This function is called internally to connect the elements of the grammar to form the
    AST.  This is the backward reference up the tree.

    \internal We can't have ROSETTA build these access functions since we want specific
    checking of values for NULL pointers (parent point is NULL only for SgProject)
 */
SgNode*
SgNode::get_parent () const
   {
     ROSE_ASSERT(this != NULL);

     SgNode* returnNode = p_parent;

  // DQ (5/24/2006): I would like to allow SgSymbols to have a valid parent pointer since it can be used to reference
  // the symbol table as a way to support better debugging within the AST merge mechanims.
  // Sage II semantics: Types and Symbols always have a NULL parent (This is the way it is implemented (from Sage II))
  // if ( (isSgType( const_cast<SgNode*>(this) ) != NULL) || (isSgSymbol( const_cast<SgNode*>(this) ) != NULL) )
     if ( isSgType( const_cast<SgNode*>(this) ) != NULL )
          returnNode = NULL;

     return returnNode;
   }

// DQ (3/8/2007): Added more efficent implementation to support AST consitency tests and other work.
//! Query function for if the input IR nodes is a child of the current IR node.
bool
SgNode::isChild ( SgNode* node ) const
   {
     return (getChildIndex(node) != -1);
   }


vector<string>
SgNode::buildCommandLineToSubstituteTransformationFile( const vector<string>& argv, std::string newFileName )
   {
     int fileNameCounter  = 0;
     int fileNameLocation = 0;

  // return a copy of the commandline input to this function
     vector<string> transformation_argv(argv.size());

  // printf ("In buildCommandLineToSubstituteTransformationFile(): argc = %d \n",argc);

  // copy all the entries in the command line.
     for (unsigned int i=0; i < argv.size(); i++)
        {
       // Count up the number of filenames (if it is ZERO then this is likely a link line called 
       // using the compiler (required for template processing in C++ with most compilers) if there
       // is ONE then this is the source file.  Currently their can only be ONE source file specified.

       // most options appear as -<option>
       // have to process +w2 (warnings option) on some compilers so include +<option>
          if ( argv[i].size() < 1 || (argv[i][0] != '-') || (argv[i][0] != '+') )
             {
	       unsigned int length = argv[i].size();
            // printf ("Look for file names:  argv[%d] = %s length = %d \n",i,argv[i],length);

            // look only for .c and .C files (source code files)
            // The length has to be greater then 2 or else we will generate a purify error!
               if ( (length > 2) && (argv[i][length-2] == '.') && ( (argv[i][length-1] == 'c') || (argv[i][length-1] == 'C') ) )
                  {
                 // printf ("Found a filename = %s \n",argv[i]);
                 // ROSE::sourceFileNamesWithPath    [fileNameCounter] = strdup(argv[i]);
                 // ROSE::sourceFileNamesWithoutPath [fileNameCounter] = strdup(argv[i]);
                 // argv[i] = "rose_transformation.C";
                 // transformation_argv[i] = "rose_transformation.C";
                    transformation_argv[i] = strdup(newFileName.c_str());

                 // record the location of the filename in the command line and the number of filenames
                    fileNameLocation = i;
                    fileNameCounter++;
                  }
                 else
                  {
                    transformation_argv [i] = argv[i];
                  }
             }
            else
             {
               transformation_argv [i] = argv[i];
             }

       // printf ("In loop: i = %d \n",i);
	}

  // For now ets only debug the case of a single file specified on the command line
     ROSE_ASSERT (fileNameCounter == 1);
     ROSE_ASSERT (fileNameLocation > 0);

  // We have found the location of the filename in the command line (now modify it)

  // now delete the original file name
  // delete argv[fileNameLocation];
  // argv[fileNameLocation] = "rose_transformation.C";
  // argv[fileNameLocation] = "/home/dquinlan/ROSE/NEW_ROSE/TransformationSpecification/rose_transformation.C";
  // argv[fileNameLocation] = "/home/dquinlan2/ROSE/SUN_CC_NOPURIFY/TransformationSpecification/rose_transformation.C";
  // argv[fileNameLocation] = "rose_transformation.C";

#if 0
  // This is not longer required (EDG sets its 
  // primary_source_file_name internally from the 
  // command line directly).

  // Since it is a problem to call EDG more than once with 
  // (EDG comand line processing can only be called once)
  // the easiest thing to do is change the name of the primary 
  // source file.  See notes in the TODO document.
     EDG_secondarySourceFile = argv[fileNameLocation];
#endif

  // printf ("Command line modified to include \"rose_transformation.C\"! \n");

     return transformation_argv;
   }

std::string
SgNode::unparseToString(SgUnparse_Info* info) const
   {
  // DQ (4/4/2006): Added optional parameter to customize unparsing
  // Generate the string (don't pass a SgUnparse_Info object so that we can use the
  // default settings).
     std::string outputString = globalUnparseToString(this,info);
     return outputString;
   }

std::string
SgNode::unparseToCompleteString()
   {
     // Generate the string (pass a SgUnparse_Info object)
     SgUnparse_Info* inputUnparseInfoPointer = new SgUnparse_Info();
     inputUnparseInfoPointer->unset_SkipComments();    // generate comments
     inputUnparseInfoPointer->unset_SkipWhitespaces(); // generate all whitespaces to format the code
     std::string outputString = globalUnparseToString(this,inputUnparseInfoPointer);
     return outputString;
   }

// DQ (10/8/2007): I would like to get rid of this mechanism in the future.
SgShallowCopy *SgShallowCopy::p_static_instance = NULL;
SgTreeCopy    *SgTreeCopy   ::p_static_instance = NULL;



void
SgCopyHelp::insertCopiedNodePair( const SgNode* key, SgNode* value )
   {
  // DQ (10/8/2007): This function support the saving of state used to associated original IR nodes with the copies made of them so that symbols can be updated.

     if (copiedNodeMap.find(key) == copiedNodeMap.end())
        {
       // Add the node to the map...
          copiedNodeMap[key] = value; 
        }
   }


SgNode*
SgTreeCopy::copyAst( const SgNode *n )
   {
#if 0
     if (isSgType( const_cast<SgNode*>(n) ) != NULL)
        {
          return const_cast<SgNode *>(n);
        }

     SgNode *nCopy = n->copy(*this);
     nCopy->set_parent(NULL);
     return nCopy;
#else
  // DQ (10/8/2007): I have modified this function to have a single return.
  // This function is called by the copy mechanism to copy AST child trees.

     SgNode *nCopy = NULL;

  // If this is a SgType, then force it to be shared, since all SgTypes are shared.
  // if (isSgType( const_cast<SgNode*>(n) ) != NULL)
     if (isSgType(n) != NULL)
        {
       // Share the reference to the IR node.
          nCopy = const_cast<SgNode *>(n);
        }
       else
        {
       // If this is a class definition then only do a deep copy if it is from a defining class declaration.
          const SgClassDefinition* classDefinition = isSgClassDefinition(n);
          if (classDefinition != NULL)
             {
               ROSE_ASSERT(classDefinition->get_parent() != NULL);
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classDefinition->get_parent());
               if (classDeclaration == classDeclaration->get_definingDeclaration())
                  {
                 // Do a deep copy on this IR node.
                    nCopy = n->copy(*this);
                  }
                 else
                  {
                 // Share the reference to the IR node.
                    nCopy = const_cast<SgNode *>(n);
                  }
             }
            else
             {
            // Do a deep copy on this IR node.
               nCopy = n->copy(*this);
             }

       // Set the parent to NULL, the copy mechanism we set it correctly ...
          nCopy->set_parent(NULL);
        }

     return nCopy;
#endif
   }

#if 0
bool SgTreeCopy :: clone_node( const SgNode *n ) const
   {
     if (isSgType( const_cast<SgNode*>(n) ) != 0)
          return false;
     return true;
   }
#endif



unsigned int
SgNode::cfgIndexForEnd() const {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return 0;
}

bool
SgNode::cfgIsIndexInteresting(unsigned int) const {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return false;
}

unsigned int
SgNode::cfgFindChildIndex(SgNode*) {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return 0;
}

unsigned int
SgNode::cfgFindNextChildIndex(SgNode*) {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return 0;
}

std::vector<VirtualCFG::CFGEdge>
SgNode::cfgOutEdges(unsigned int) {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return std::vector<VirtualCFG::CFGEdge>();
}

std::vector<VirtualCFG::CFGEdge>
SgNode::cfgInEdges(unsigned int) {
  ROSE_ASSERT (!"CFG functions only work on SgExpression, SgStatement, and SgInitializedName");
  return std::vector<VirtualCFG::CFGEdge>();
}
 


// End of memberFunctionString
// Start of memberFunctionString
#line 1362 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
bool SgNode::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NodeTag)
        {
          printf ("Error in SgNode::error(): SgNode object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNode::error() \n");
          ROSE_ABORT();
        }

  // ROSE_ASSERT (getVariant() == SgNodeTag);
     ROSE_ASSERT (getVariant() == NodeTag);
     return false;  // //::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNode::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNode::variant() const \n");
#endif
     assert(this != NULL);
     return NodeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNode* isSgNode ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNode*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNode* isSgNode ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNode*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNode::~SgNode ()
   {
#if 0
  // debugging information!
     printf ("In SgNode::~SgNode (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for parent
     p_parent = NULL; // non list case 
  // case: not a listType for isModified
     p_isModified = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNode::SgNode (  )
   
   {
#ifdef DEBUG
  // printf ("In SgNode::SgNode () sage_class_name() = %s \n",sage_class_name());
#endif

     p_parent = NULL;
     p_isModified = false;
     p_freepointer = AST_FileIO::IS_VALID_POINTER();

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NodeTag == variant());
     post_construction_initialization();

  // Test the isSgNode() function since it has been problematic
     assert(isSgNode(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3893 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

  // No functions defined for the GrammarSource


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSupport::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSupport::variantT() const {
  return V_SgSupport;
}

#if 0
int
SgSupport::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SupportTag;
   }
#endif

const char*
SgSupport::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSupport";  
   }

std::string
SgSupport::class_name() const
   {
     assert(this != NULL);
     return "SgSupport";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSupport::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSupport::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SupportTag)
        {
          printf ("Error in SgSupport::error(): SgSupport object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSupport::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SupportTag);
     return SgNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSupport::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSupport::variant() const \n");
#endif
     assert(this != NULL);
     return SupportTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSupport* isSgSupport ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSupport*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSupport* isSgSupport ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSupport*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSupport::~SgSupport ()
   {
#if 0
  // debugging information!
     printf ("In SgSupport::~SgSupport (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSupport::SgSupport (  )
   : SgNode()
   {
#ifdef DEBUG
  // printf ("In SgSupport::SgSupport () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(SupportTag == variant());
     post_construction_initialization();

  // Test the isSgSupport() function since it has been problematic
     assert(isSgSupport(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 7362 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Added to support assignments to string variables.
SgName::operator std::string () const
   {
     return p_char;
   }

// DQ (10/5/2007): We no longer need this!
// Definition of defaultName (use a default parameter)
// const SgName SgdefaultName("defaultName");

SgName::SgName()
   : p_char("")
   { }

unsigned int
SgName::get_length() const
   {
     ROSE_ASSERT(this != NULL);
     return p_char.size();
   }

SgName::SgName(const char * str): p_char(str ? str : "") {}

// DQ (9/9/2004): Added support for conversion of strings to SgName
// I always wanted this and it was a pain that it didn't exist previously!
SgName::SgName(const std::string & str): p_char(str) {}

SgName::SgName(const SgName& n): p_char(n.p_char) {}

// SgName::SgName(const char *str, int n): p_char(str, n) {} // get first n chars in the string

int
SgName::operator!=(const SgName& n1) const 
   {
     ROSE_ASSERT(this != NULL);
     return p_char != n1.p_char;
   }

int
SgName::operator==(const SgName& n1) const
   {
     ROSE_ASSERT(this != NULL);

     return p_char == n1.p_char;
   }

int
SgName::operator<(const SgName& n1) const
   {
     ROSE_ASSERT(this != NULL);

     return p_char < n1.p_char;
   }

int
SgName::is_null(void) const
   {
     ROSE_ASSERT(this != NULL);
     return p_char.empty();
   }

void
SgName::replace_space(char t)
   {
     ROSE_ASSERT(this != NULL);

     int len = p_char.size();
     for(int i=0; i < len; i++)
        {
       // if last one
          if(p_char[i]==' ') 
             {
               if(i==len-1) 
                    p_char.resize(p_char.size() - 1);
                 else 
                    p_char[i]=t;
             }
        }
   }

SgName&
SgName::operator<<(const std::string& str)
   {
     ROSE_ASSERT (this != NULL);

     p_char += str;
     return *this;
   }

SgName
SgName::itoname(int val)
   {
     std::ostringstream os;
     os << val;
     return SgName(os.str());
   }

SgName&
SgName::operator<<(int val)
   {
     ROSE_ASSERT(this != NULL);

     SgName str = itoname(val);
     p_char += str.p_char;
     return *this;
   }

SgName&
SgName::operator=(const SgName& n1)
   { 
     ROSE_ASSERT(this != NULL);
     this->p_char = n1.p_char;
     return *this;
   }

SgName&
SgName::tail(int n) // keep string after n
   {
     ROSE_ASSERT(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? "" : p_char.substr(n);
     return *this;
   }

SgName&
SgName::head(int n) // keep first n chars
   {
     ROSE_ASSERT(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? p_char : p_char.substr(0, n);
     return *this;
   }

const char* SgName::str() const {
     ROSE_ASSERT(this != NULL);
  return p_char.c_str();
}

std::string&
SgName::getString()
   {
     ROSE_ASSERT(this != NULL);
     return p_char;
   }

const std::string&
SgName::getString() const
   {
     ROSE_ASSERT(this != NULL);
     return p_char;
   }

#if 0
// Removed to prevent confusion about it's used (really should not be a const function)
SgName::operator char*() const
   {
     return p_char;
   }
#endif

// default name to use within initializers for SgName objects
// const SgName defaultName;


void SgName::display( const std::string& label ) const
   {
     ROSE_ASSERT(this != NULL);

     std::cout << label << ": " << p_char << "\n";
   }

// DQ (9/9/2004): friend function
SgName
operator+(const SgName & n1, const SgName & n2)
   {
     return SgName(n1.p_char + n2.p_char);
   }

// DQ (11/15/2004): Added to support general string operations (first used in the unparser)
SgName & 
SgName::operator+= (const SgName & n1)
   {
     ROSE_ASSERT(this != NULL);
     p_char += n1.p_char;
     return *this;
   }

SgName
SgName::assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName)
   {
  // DQ (22/2005): Neede to add global scope specifier to handle some pathological cases (see test2005_144.C).
  // DQ (9/9/2004): Supporting function for building qualified names (specialied string concatination)
  // Previous code caused "::" to be inserted too often (e.g. where scope->get_qualified_name() was empty, as in global scope)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();

  // DQ (9/9/2004): We can't assert this since "" evaluates to is_null() being true!
  // ROSE_ASSERT(scopeQualifiedName.is_null() == false);

     SgName returnName;
  // DQ (9/9/2004): So these are redundent tests! (which was pleasant news to me!)
  // if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName == "") )
     if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName.getString() == "") )
        {
          returnName = localName;
#if 0
       // DQ (11/29/2004): It seems that any assignment of "" to a SgName forces it to be evaluated so that is_null() == true
       // DQ (11/29/2004): Added checking for is_null() so that returnName would always be a valid name
          if (localName.is_null() == true)
               returnName = "";
            else
               returnName = localName;
#endif
        }
       else 
        {
       // Trap out the case of global scope to avoid building "::::"
          if ( scopeQualifiedName == "::" )
             {
            // Avoid building "::::"
               returnName = scopeQualifiedName.getString() + localName.getString();
             }
            else
             {
               returnName = scopeQualifiedName.getString() + "::" + localName.getString();
             }
        }

  // returnName = scopeQualifiedName << "::" << localName.str();
  // ROSE_ASSERT(returnName.is_null() == false);
      
     return returnName;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgName::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgName::variantT() const {
  return V_SgName;
}

#if 0
int
SgName::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NameTag;
   }
#endif

const char*
SgName::sage_class_name() const
   {
     assert(this != NULL);
     return "SgName";  
   }

std::string
SgName::class_name() const
   {
     assert(this != NULL);
     return "SgName";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgName::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgName::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NameTag)
        {
          printf ("Error in SgName::error(): SgName object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgName::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NameTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgName::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgName::variant() const \n");
#endif
     assert(this != NULL);
     return NameTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgName* isSgName ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgName*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgName* isSgName ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgName*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgName::~SgName ()
   {
#if 0
  // debugging information!
     printf ("In SgName::~SgName (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for char
     p_char = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgSymbolTable::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgSymbolTable::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgSymbolTable::get_no_name () const
   {
     assert (this != NULL);
     return p_no_name;
   }

void
SgSymbolTable::set_no_name ( bool no_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_no_name = no_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

 rose_hash_multimap* 
SgSymbolTable::get_table () const
   {
     assert (this != NULL);
     return p_table;
   }

void
SgSymbolTable::set_table (  rose_hash_multimap* table )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_table != NULL && table != NULL && p_table != table)
        {
          printf ("Warning: table = %p overwriting valid pointer p_table = %p \n",table,p_table);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_table != NULL && table != NULL && p_table != table) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_table = table;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNodeSet 
SgSymbolTable::get_symbolSet () const
   {
     assert (this != NULL);
     return p_symbolSet;
   }

void
SgSymbolTable::set_symbolSet ( SgNodeSet symbolSet )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_symbolSet = symbolSet;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3898 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// DQ (2/19/2007): Added mechanism to turn off expensive error checking!
#define SYMBOL_TABLE_ERROR_CHECKING 1

// DQ (7/24/2005): Make this a constant in the function if it is not used elsewhere!
// #define SYMTBL_INIT_SZ 16

SgSymbolTable::SgSymbolTable()
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!
     int symbolTableSize = 17;
     p_table = new BaseHashType(symbolTableSize);
     ROSE_ASSERT (p_table != NULL);
   }

// DQ (2/19/2007): I have put it back into use as a way of 
// customizing the size of the underlying hash tables to be
// larger for certain scopes (e.g global scope usually has a 
// lot more symbols.

// DQ (1/31/2007): This function is not used!
SgSymbolTable::SgSymbolTable(int symbolTableSize)
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!

  // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
  // p_table = new SgSymbolHashMultiMap(sz);

     p_table = new BaseHashType(symbolTableSize);
     ROSE_ASSERT (p_table != NULL);
   }

std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it )
   {
  // DQ (1/19/2006): Error reported by Michelle Strout when compiled with g++ 4.0.2 on 64 bit machines
  // os << " pair (" << (*rhm_it).first.str() << "," << (int)((*rhm_it).second) << ")";
     os << " pair (" << (*rhm_it).first.str() << "," << ((*rhm_it).second) << ")";
     return os;
   }

SgName
SgSymbolTable::get_name( const SgNode* node) const
   {
  // DQ (2/20/2007): This function is used to get the name for the different types of declarations used to build symbols.

     SgName name;

     switch (node->variantT())
        {
       // We could implement a function on the selective nodes that generated the symbol 
       // name (the name used for the input of associated symbols in the symbol table).
          case V_SgLabelStatement:
             {
               const SgLabelStatement* labelStatement = isSgLabelStatement(node); 
               name = labelStatement->get_label();
               break;
             }

          case V_SgClassDeclaration:
          case V_SgDerivedTypeStatement:
             {
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);
               name = classDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               const SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(node);
            // Note that get_name() returns a name with arguments such as "class_template<int>" while get_templateName() returns the template name withouth arguments.
            // name = templateInstantiationDeclaration->get_templateName();
            // printf ("In SgSymbolTable::find(const SgStatement*): case V_SgTemplateInstantiationDecl, using get_name() = %s instead of get_templateName() = %s \n",
            //      templateInstantiationDeclaration->get_name().str(),templateInstantiationDeclaration->get_templateName().str());
            // printf ("Base class get_name() = %s \n",templateInstantiationDeclaration->SgClassDeclaration::get_name().str());
               name = templateInstantiationDeclaration->get_name();
               break;
             }

          case V_SgEnumDeclaration:
             {
               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(node); 
               name = enumDeclaration->get_name();
               break;
             }

          case V_SgFunctionDeclaration:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgMemberFunctionDeclaration:
             {
               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               
               name = functionDeclaration->get_name();
               break;
             }

       // DQ (2/14/2007): Note that for template-based declarations there is a process where within the post-processing of 
       // the AST the names are updated from the EDG form (e.g. "template_name___Lnnn"), to the template specialization 
       // form (e.g. "template_name<int>"). Since the symbol references only one of the declarations, if there are defining 
       // declarations and non-defining declarations, the name can be changed in the declaration but not in the associated symbol.
       // Details of this situation require more clarification.
          case V_SgTemplateInstantiationFunctionDecl:
             {
               const SgTemplateInstantiationFunctionDecl* functionDeclaration = isSgTemplateInstantiationFunctionDecl(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               const SgTemplateInstantiationMemberFunctionDecl* functionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(), 
            // get_templateName returns the name of the template which is required for code generation (where for 
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgNamespaceDeclarationStatement:
             {
               const SgNamespaceDeclarationStatement* namespaceDeclarationStatement = isSgNamespaceDeclarationStatement(node); 
               name = namespaceDeclarationStatement->get_name();
               break;
             }

          case V_SgTemplateDeclaration:
             {
               const SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
               const SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);
               name = typedefDeclaration->get_name();
               break;
             }

          case V_SgFunctionType:
             {
               const SgFunctionType* functionType = isSgFunctionType(node);
               name = functionType->get_mangled();
               break;
             }

          case V_SgInitializedName:
             {
               const SgInitializedName* initializedName = isSgInitializedName(node);
               name = initializedName->get_name();
               break;
             }

          default:
             {
               printf ("SgSymbolTable::get_name(SgNode*) undefined for %s \n",node->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return name;
   }

#if 0
// DQ (3/10/2007): This approach in the end, didn't work.  So I think this can be removed!

// What about the variations for defining vs. first non-defining declarations
// we could match up the different types of declarations!
unsigned int
SgSymbolTable::generateUniqueNumberForMatchingSymbol( SgDeclarationStatement* symbolBasis ) const
   {
  // DQ (2/20/2007): This function supports the AST merge mechansim, but is general 
  // and may be useful for the mangled name generation in the future.  For symbols
  // in the symbol table for a specific scope that have matching names (typically 
  // originating as un-named structs or enums) this function requires a unique number 
  // for each instance.

#if 1
     printf ("In SgSymbolTable::generateUniqueNumberForMatchingSymbol() symbolBasis = %p \n",symbolBasis);
#endif

     ROSE_ASSERT(p_table != NULL);

     SgName nm = get_name(symbolBasis);

     unsigned int counter = 0;
     hash_iterator p_iterator = p_table->find(nm);

     ROSE_ASSERT(symbolBasis != NULL);
     SgDeclarationStatement* symbolBasisDefiningDeclaration    = symbolBasis->get_definingDeclaration();
     SgDeclarationStatement* symbolBasisNondefiningDeclaration = symbolBasis->get_firstNondefiningDeclaration();
     ROSE_ASSERT(symbolBasisDefiningDeclaration != NULL);
     ROSE_ASSERT(symbolBasisNondefiningDeclaration != NULL);

  // loop over all symbols of the same name
     while (p_iterator != p_table->end() && p_iterator->first == nm)
        {
       // only count matching symbol types (with the same name)
          if ( p_iterator->second->get_symbol_basis()->variantT() == symbolBasis->variantT() )
             {
            // return the count when we have found the symbol basis (or matching of it's defining or nondefining declarations)
               SgDeclarationStatement* tmp_symbolBasis = isSgDeclarationStatement(p_iterator->second->get_symbol_basis());
               ROSE_ASSERT(tmp_symbolBasis != NULL);

            // Exit loop on condition of definingDeclaration
               if (symbolBasisDefiningDeclaration != NULL)
                  {
                    SgDeclarationStatement* tmp_symbolBasisDefiningDeclaration = tmp_symbolBasis->get_definingDeclaration();
                    ROSE_ASSERT(tmp_symbolBasisDefiningDeclaration != NULL);
                    if (symbolBasisDefiningDeclaration == tmp_symbolBasisDefiningDeclaration)
                         break;
                  }

            // Exit loop on condition of firstNondefiningDeclaration
               if (symbolBasisNondefiningDeclaration != NULL)
                  {
                    SgDeclarationStatement* tmp_symbolBasisNondefiningDeclaration = tmp_symbolBasis->get_firstNondefiningDeclaration();
                    ROSE_ASSERT(tmp_symbolBasisNondefiningDeclaration != NULL);
                    if (symbolBasisNondefiningDeclaration == tmp_symbolBasisNondefiningDeclaration)
                         break;
                  }
             }

          counter++;
          p_iterator++;
        }

#if 1
     printf ("Leaving SgSymbolTable::generateUniqueNumberForMatchingSymbol() = %d \n",counter);
#endif

     return counter;
   }
#endif

/* ************************************************************************
                               INSERT FUNCTIONS
   ************************************************************************/

void
SgSymbolTable::insert ( const SgName & nm , SgSymbol *sp )
   {
  // DQ (2/14/2007): Added assertion!
     ROSE_ASSERT(this != NULL);

  // DQ (2/19/2007): Added additional assertion!
     ROSE_ASSERT (p_table != NULL);

  // DQ (2/14/2007): Added assertion!
     ROSE_ASSERT (sp != NULL);

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // SgFunctionTypeSymbol does not have a valid get_symbol_basis(), so skip this case!
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
          if (sp->get_symbol_basis() == NULL)
             {
               printf ("Error (sp->get_symbol_basis() == NULL): name = %s sp = %p = %s \n",nm.str(),sp,sp->class_name().c_str());
             }
          ROSE_ASSERT(sp->get_symbol_basis() != NULL);
#if 0
       // This outputs a message for every use of the insert function (for non function type symbols) useful for tracing through bugs
          printf ("In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s \n",
             nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
             sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
#endif
        }
#endif

  // DQ (3/10/2007): This is a simpler assertion equivalent to the one above but without generating any error output 
     ROSE_ASSERT(isSgFunctionTypeSymbol(sp) != NULL || sp->get_symbol_basis() != NULL);

  // DQ (3/10/2007): Test for if the symbol exists
     ROSE_ASSERT (p_symbolSet.find(sp) == p_symbolSet.end());

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/19/2007): These is no need to do both of these since exists(sp) is more complete test!
  // DQ (2/25/2007): except that it is helpful to know which one fails.
     ROSE_ASSERT(exists(nm,sp) == false);
     ROSE_ASSERT(exists(sp)    == false);

  // DQ (2/14/2007): error checking (make sure that no two symbols are represented by the same basis declaration). 
  // But skip such tests on the SgFunctionTypeSymbol (only used for the function type table)
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
       // set<SgNode*> existingSymbolBasisDeclarations;
          map<SgNode*, hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator > existingSymbolBasisDeclarations;

          SgNode* sp_associatedDeclaration = sp->get_symbol_basis();
          ROSE_ASSERT(sp_associatedDeclaration != NULL);

          hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator i = get_table()->begin();
          while (i != get_table()->end())
             {
            // test if symbol is in set
               SgNode* associatedDeclaration = i->second->get_symbol_basis();
               ROSE_ASSERT(associatedDeclaration != NULL);

            // Check if this declaration has previously been used with another symbol!
               if (existingSymbolBasisDeclarations.find( sp_associatedDeclaration ) == existingSymbolBasisDeclarations.end())
                  {
                 // Add this declaration to the list associated with symbols in the table
                 // existingSymbolBasisDeclarations.insert( associatedDeclaration );
                    existingSymbolBasisDeclarations[associatedDeclaration] = i;
                  }
                 else
                  {
                    printf ("Error in symbol table located in parent = %p = %s \n",get_parent(),get_parent()->class_name().c_str());
                    ROSE_ASSERT(get_parent() != NULL);
                    get_parent()->get_file_info()->display("Error in symbol table");

                    string associatedDeclarationName = SageInterface::get_name(sp_associatedDeclaration);

                 // DQ (2/15/2007): Output the name of the symbol being inserted, the declaration associated with it, 
                 // and the name of the symbol previously inserted with the same associated declaration.
                    printf ("Symbol sp = %p = %s already associated with declaration = %p = %s (name = %s) in symbol table i = %p = %s \n",
                         sp,sp->class_name().c_str(),sp_associatedDeclaration,sp_associatedDeclaration->class_name().c_str(),
                         associatedDeclarationName.c_str(),existingSymbolBasisDeclarations[sp_associatedDeclaration]->second,existingSymbolBasisDeclarations[sp_associatedDeclaration]->second->class_name().c_str());
                    associatedDeclaration->get_file_info()->display("Dual use of associatedDeclaration in source: debug");

                    printf ("existingSymbolBasisDeclarations[sp_associatedDeclaration]->first = %s second = %p \n",
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->first.str(),
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->second);
                    ROSE_ASSERT(false);
                  }

               i++;
             }
        }
#endif

  // Now, finally insert it into the symbol table
  // std::pair<const SgName,SgSymbol*>  npair(nm,sp);
  // p_table->insert(npair);
     p_table->insert(std::pair<const SgName,SgSymbol*>(nm,sp));

  // DQ (5/11/2006): set the parent to avoid NULL pointers
     sp->set_parent(this);

  // DQ (3/10/2007): Insert this symbol into p_symbolSet which we use for fast tests of existance in the 
  // symbol table when we don't use the name.  This helps detect where symbols have been entered using one 
  // name and either reentered using an second name or the name changed and the symbol had not been properly 
  // unloaded and reloaded into the symbol table.  Since the names are not stored in the symbol, but computed 
  // from associated declaration this is an easy error to make and we detect this by backing up the test for 
  // if a symbol exists using a name with a test for if the symbol exists using ANY possible name (a search 
  // for the symbol independent of the name).  To avoid this being a linear search of the symbol table (too 
  // slow) we implement a set of symbols to permit fast tests for existence.
     p_symbolSet.insert(sp);

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // Error checking
     ROSE_ASSERT(exists(nm)    == true);
     ROSE_ASSERT(exists(nm,sp) == true);
     ROSE_ASSERT(exists(sp)    == true);
#endif

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/14/2007): Added error checking!
     if (nm != sp->get_name())
        {
          printf ("Warning: symbol name does not match name used to input associated symbol into symbol table! sp = %p = %s nm = \"%s\" sp->get_name() = \"%s\" \n",sp,sp->class_name().c_str(),nm.str(),sp->get_name().str());

          ROSE_ASSERT(sp->get_symbol_basis() != NULL);
          ROSE_ASSERT(sp->get_symbol_basis()->get_file_info() != NULL);

          sp->get_symbol_basis()->get_file_info()->display("Error in source: debug");
          ROSE_ASSERT(false);
        }
#endif


#if 0
  // We can't test this because where symbols are inserted (EDG/SageIII translation) the scopes are not set yet (done in AST post-processing).
  // DQ (2/14/2007): Added error checking!
     SgStatement* statement = isSgStatement(sp->get_symbol_basis());
     if (statement != NULL)
        {
       // printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
       // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
          SgSymbol* symbolFromTable = statement->get_symbol_from_symbol_table();
          ROSE_ASSERT(symbolFromTable != NULL);
          ROSE_ASSERT(symbolFromTable == sp);
        }
       else
        {
          SgInitializedName* initializedName = isSgInitializedName(sp->get_symbol_basis());
          if (initializedName != NULL)
             {
            // printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
            // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
               SgSymbol* symbolFromTable = initializedName->get_symbol_from_symbol_table();
               ROSE_ASSERT(symbolFromTable != NULL);
               ROSE_ASSERT(symbolFromTable == sp);
             }
            else
             {
               printf ("Unknown symbol_base for input symbol sp = %p = %s sp->get_symbol_basis() = %p = %s \n",sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }
#endif
   }


/* ************************************************************************
                               REMOVE FUNCTIONS
   ************************************************************************/

// DQ (2/6/2007): This is too dangerous for use in ROSE (deletes all 
// possible SgSymbols that match the input name independent of type).
// It is however currently used in the global function type symbol table
// so we have named this function to make its purpose more clear.
// This function is not likely called except where complex function type 
// symbol table editing is required.  Since SgFunctionTypeSymbols are
// shared removing such symbols is a rather dangerous actvity!
void
SgSymbolTable::remove_function_type( const SgName & name )
   {
  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     ROSE_ASSERT (p_table != NULL);

     list<hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator it = get_table()->find(name);
     while (it != get_table()->end() && (*it).first == name)
        {
          ROSE_ASSERT(it->second->variantT() == V_SgFunctionTypeSymbol);

          deleteList.push_back(it);
          it++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase((*i)->second);"
       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // printf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
       // get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase((*i)->second);

       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // printf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
          get_table()->erase(*i);

          i++;
        }
   }


SgSymbol*
SgSymbolTable::find( const SgInitializedName* initializedName)
   {
     ROSE_ASSERT(p_table != NULL);
     ROSE_ASSERT(initializedName != NULL);

  // printf ("Inside of SgSymbolTable::find( const SgInitializedName* ): initializedName = %p = %s \n",initializedName,SageInterface::get_name(initializedName).c_str());

     SgSymbol* returnSymbol = NULL;

     SgName name = initializedName->get_name();

  // printf ("Inside of SgSymbolTable::find( const SgInitializedName* ): name = %s \n",name.str());

     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          ROSE_ASSERT(p_iterator->second != NULL);
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
       // printf ("In loop: p_iterator->second = %p symbolBasis = %p initializedName = %p \n",p_iterator->second,symbolBasis,initializedName);
       // printf ("In loop: symbolBasis->variantT() = %d statement->variantT() = %d \n",symbolBasis->variantT(),initializedName->variantT());
          ROSE_ASSERT(symbolBasis != NULL);
          if (isSgInitializedName(symbolBasis) != NULL)
             {
            // printf ("found a SgInitializedName \n");

               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == initializedName)
                  {
                 // printf ("returnSymbol->get_symbol_basis() == initializedName returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
                    return returnSymbol;
                  }
                 else
                  {
                 // printf ("returnSymbol->get_symbol_basis() != initializedName \n");
                  }
             }
            else
             {
            // printf ("Some other symbol was found (no matching variants) \n");
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgFunctionType* functionType)
   {
     ROSE_ASSERT(p_table != NULL);
     ROSE_ASSERT(functionType != NULL);

  // printf ("Inside of SgSymbolTable::find( const SgFunctionType* ): functionType = %p = %s \n",functionType,SageInterface::get_name(functionType).c_str());

     SgSymbol* returnSymbol = NULL;

     SgName name = functionType->get_mangled();

     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgSymbol((*p_iterator).second)->variantT() == functionType->variantT())
             {
               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == functionType)
                    return returnSymbol;
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgStatement* statement)
   {
     ROSE_ASSERT(p_table != NULL);
     ROSE_ASSERT(statement != NULL);

  // printf ("Inside of SgSymbolTable::find( const SgStatement* ): statement = %p = %s = %s \n",statement,statement->class_name().c_str(),SageInterface::get_name(statement).c_str());

     SgSymbol* returnSymbol = NULL;

     SgName name = get_name(statement);

#if 0
  // This code is replaced by the SgSymbolTable::get_name() function.
     switch (statement->variantT())
        {
       // We could implement a function on the selective statements that generated the symbol 
       // name (the name used for the input of associated symbols in the symbol table).
          case V_SgLabelStatement:
             {
               const SgLabelStatement* labelStatement = isSgLabelStatement(statement); 
               name = labelStatement->get_label();
               break;
             }

          case V_SgClassDeclaration:
             {
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(statement);
               name = classDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               const SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(statement);
            // Note that get_name() returns a name with arguments such as "class_template<int>" while get_templateName() returns the template name withouth arguments.
            // name = templateInstantiationDeclaration->get_templateName();
            // printf ("In SgSymbolTable::find(const SgStatement*): case V_SgTemplateInstantiationDecl, using get_name() = %s instead of get_templateName() = %s \n",
            //      templateInstantiationDeclaration->get_name().str(),templateInstantiationDeclaration->get_templateName().str());
            // printf ("Base class get_name() = %s \n",templateInstantiationDeclaration->SgClassDeclaration::get_name().str());
               name = templateInstantiationDeclaration->get_name();
               break;
             }

          case V_SgEnumDeclaration:
             {
               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(statement); 
               name = enumDeclaration->get_name();
               break;
             }

          case V_SgFunctionDeclaration:
          case V_SgMemberFunctionDeclaration:
             {
               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(statement);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               
               name = functionDeclaration->get_name();
               break;
             }

       // DQ (2/14/2007): Note that for template-based declarations there is a process where within the post-processing of 
       // the AST the names are updated from the EDG form (e.g. "template_name___Lnnn"), to the template specialization 
       // form (e.g. "template_name<int>"). Since the symbol references only one of the declarations, if there are defining 
       // declarations and non-defining declarations, the name can be changed in the declaration but not in the associated symbol.
       // Details of this situation require more clarification.
          case V_SgTemplateInstantiationFunctionDecl:
             {
               const SgTemplateInstantiationFunctionDecl* functionDeclaration = isSgTemplateInstantiationFunctionDecl(statement);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               const SgTemplateInstantiationMemberFunctionDecl* functionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(statement);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(), 
            // get_templateName returns the name of the template which is required for code generation (where for 
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgNamespaceDeclarationStatement:
             {
               const SgNamespaceDeclarationStatement* namespaceDeclarationStatement = isSgNamespaceDeclarationStatement(statement); 
               name = namespaceDeclarationStatement->get_name();
               break;
             }

          case V_SgTemplateDeclaration:
             {
               const SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(statement); 
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
               const SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(statement);
               name = typedefDeclaration->get_name();
               break;
             }

          default:
             {
               printf ("SgSymbolTable::find(SgStatement*) undefined for %s \n",statement->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }
#endif

  // printf ("Inside of SgSymbolTable::find( const SgStatement* ): name = %s \n",name.str());

  // Get a quick pointer into the symbol table using the name (log n complexity)
     p_iterator = p_table->find(name);

  // Once we have p_iterator set via the name we don't typically have more than one iteration
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          ROSE_ASSERT(p_iterator->second != NULL);
#if 0
          printf ("In loop: p_iterator->second = %p statement = %p \n",p_iterator->second,statement);
          printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
#endif

       // This is a virtual function call (not defined for function type symbols)
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
#if 0
          printf ("In loop: symbolBasis->variantT() = %d = %s statement->variantT() = %d = %s \n",
               symbolBasis->variantT(),Cxx_GrammarTerminalNames[symbolBasis->variantT()].name,
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name);
#endif
          ROSE_ASSERT(symbolBasis != NULL);

          if (symbolBasis->variantT() == statement->variantT())
             {
            // printf ("matching variants \n");
               returnSymbol = p_iterator->second;

            // This is a very presice test which might be a problem because of defining and non-defining versions 
            // of declarations (we might be able to always use the non-defining declaration in these cases.  The 
            // switch which computes the names could normalize this aspect.
               if (returnSymbol->get_symbol_basis() == statement)
                  {
                 // printf ("returnSymbol->get_symbol_basis() == statement returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
                    return returnSymbol;
                  }
                 else
                  {
                 // printf ("returnSymbol->get_symbol_basis() != statement \n");
                  }
             }
            else
             {
            // printf ("Some other symbol was found (no matching variants) \n");
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }


void
SgSymbolTable::remove( const SgSymbol* symbol )
   {
  // This is used for the handled of non function type symbol tables, and is more useful when the 
  // symbols don't have unique names.

  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     ROSE_ASSERT (p_table != NULL);

#if 1
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // This is an expensive linear time search of the symbol table!
     ROSE_ASSERT(exists(symbol) == true);
#endif

  // This is a virtual function call
     SgName name = symbol->get_name();
#if 0
  // printf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) from SgSymbolTable = %p \n",symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),this);
     SgNode* symbolBasis = symbol->get_symbol_basis();
     ROSE_ASSERT(symbolBasis != NULL);
     printf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) symbol_basis = %p = %s = %s from SgSymbolTable = %p \n",
          symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),
          symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str(),this);
#endif
     hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator elementToDelete = get_table()->end();
     hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator it = get_table()->find(name);
     while ( (it != get_table()->end()) && (elementToDelete == get_table()->end()) && ((*it).first == name) )
        {
       // printf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
       // Make sure that we find the correct element
          if (it->second == symbol)
             {
            // printf ("Found iterator for symbol = %p \n",symbol);
               elementToDelete = it;
             }
          it++;
        }
#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/11/2007): This is part of making the symbol table use more precise.
     if (elementToDelete == get_table()->end())
        {
          printf ("Error: could not find symbol name = %s in symbol table (restart search using symbol pointer) \n",name.str());

       // DQ (2/19/2007): Added assertion to exit on error!  Enforcing this allows us to
       // make sure that the complexity is not linear in the size of the symbol table!
          ROSE_ASSERT(false);

          hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator i = get_table()->begin();
          while ( (i != get_table()->end()) && (elementToDelete == get_table()->end()) )
             {
            // printf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
            // Make sure that we find the correct element
               if (i->second == symbol)
                  {
                 // printf ("Found iterator for symbol = %p \n",symbol);
                    elementToDelete = i;
                  }
               i++;
             }

          if (elementToDelete != get_table()->end())
             {
               printf ("Warning: found symbol = %p = %s stored under a different name = %s \n",symbol,symbol->class_name().c_str(),elementToDelete->first.str());
               printf ("Location of problem in source code: \n");
               SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(symbol->get_symbol_basis());
               if (declarationStatement != NULL)
                  {
                    printf ("declarationStatement = %p = %s \n",declarationStatement,declarationStatement->class_name().c_str());
                    declarationStatement->get_startOfConstruct()->display("location of problem: debug");
                  }
               ROSE_ASSERT(false);
             }
        }
#endif

#if 0
  // DQ (2/13/2007): Now we really have an error to report
  // Make sure we found the input element to be removed!
     if (elementToDelete == get_table()->end())
        {
          printf ("Error: could not find symbol = %p name = %s in symbol table (failed to find symbol pointer under any name) \n",symbol,name.str());
          ROSE_ASSERT(false);
        }
#endif
     ROSE_ASSERT(elementToDelete != get_table()->end());

  // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase(elementToDelete->second);"
  // get_table()->erase(elementToDelete);

  // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
  // p_symbolSet.erase(symbol);
     p_symbolSet.erase(elementToDelete->second);

     get_table()->erase(elementToDelete);
   }



#if 0
// *****************************************************************
// DQ (2/6/2007): These are just too dangerous to use directly.
// Use the versions which take a declaration or a symbol explicitly.
// *****************************************************************

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      void remove_function      ( const SgName & );
      void remove_class         ( const SgName & );
      void remove_enum          ( const SgName & );
      void remove_typedef       ( const SgName & );
      void remove_label         ( const SgName & );
      void remove_var           ( const SgName & );
      void remove_enum_field    ( const SgName & );
      void remove_function_type ( const SgName & );
      void remove_namespace     ( const SgName & );
*/

#error "DEAD CODE!"

void
SgSymbolTable::remove_function( const SgName & name )
   {
     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgFunctionSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_class( const SgName & name )
   {
     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgClassSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase(i->second);"
       // get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          get_table()->erase(*i);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_enum( const SgName & name )
   {
     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_label( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     ROSE_ASSERT(false);

     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_var( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     ROSE_ASSERT(false);

     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_function_type( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     ROSE_ASSERT(false);

     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_namespace( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     ROSE_ASSERT(false);

     ROSE_ASSERT(p_table != NULL);

     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<hash_multimap<const SgName, SgSymbol*, hash_Name, eqstr>::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

#endif

/* ************************************************************************
                               FIND FUNCTIONS
   ************************************************************************/

// DQ (2/10/2007): This is a depricated function
int
SgSymbolTable::find(const SgName & nm, SgSymbol *sp)
   {
     ROSE_ASSERT(p_table != NULL);

  // if(!p_table)
  //      return NULL;

  // DQ (5/22/2006): Made this a local variable
  // hash_iterator p_iterator = p_table->find(nm);
     p_iterator = p_table->find(nm);
  // while (p_iterator != p_table->end() && (*p_iterator).first == nm)
     while (p_iterator != p_table->end() && p_iterator->first == nm)
        {
          p_name    = nm;
          p_no_name = false;
       // if( ((SgSymbol *)(*p_iterator).second) == sp )
          if( p_iterator->second == sp )
               return true;
          p_iterator++;
        }

     return false;
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm ) const
   {
     ROSE_ASSERT(p_table != NULL);
     return p_table->find(nm) != p_table->end();
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgSymbol *sp ) const
   {
#if 0
// DQ (2/19/2007): Make sure that this sort of expensive symbol table is not called if SYMBOL_TABLE_ERROR_CHECKING  is not active
#if SYMBOL_TABLE_ERROR_CHECKING == 0
     printf ("Error: Expensive symbol table tests being called while SYMBOL_TABLE_ERROR_CHECKING == 0 \n");
     ROSE_ASSERT(false);
#endif


  // This is the more expensive implementation but more useful for error checking!
     bool returnValue = false;

     ROSE_ASSERT(p_table != NULL);
     hash_iterator i = p_table->begin();
     while ( returnValue == false && i != p_table->end() )
        {
       // if ((SgSymbol *)(i->second) == sp )
          if ( i->second == sp )
               returnValue = true;
          i++;
        }
     return returnValue;
#else
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // return p_symbolSet.find(sp) != p_symbolSet.end();
     return p_symbolSet.find(const_cast<SgSymbol*>(sp)) != p_symbolSet.end();
#endif
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm, SgSymbol *sp ) const
   {
#if 0
     bool returnValue = false;
     ROSE_ASSERT(p_table != NULL);
     hash_iterator i = p_table->find(nm);
     while ( returnValue == false && i != p_table->end() && i->first == nm )
        {
          if ( i->second == sp )
               returnValue = true;
          i++;
        }

     return returnValue;
#else
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // Since we if we find the symbol it exists, we can test the name separately
  // bool returnValue = false;

  // Test if the symbol is in the set, else the name is not relavant to the existence
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
       // Now look to make sure that we have an entry with the correct name (and pointer value)
          hash_iterator p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && p_iterator->first == nm)
             {
               if ( p_iterator->second == sp )
                  {
                 // This allows us to short-circuit the rest of the iterations
                    return true;
                  }

               p_iterator++;
             }
        }

     return false;
#endif
   }

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any(const SgName &);
      SgVariableSymbol*  find_variable(const SgName &);
      SgClassSymbol*     find_class(const SgName &);
      SgFunctionSymbol*  find_function(const SgName&);
      SgFunctionSymbol*  find_function_type(const SgName&, const SgType*);
      SgTypedefSymbol*   find_typedef(const SgName &);
      SgEnumSymbol*      find_enum(const SgName &);
      SgEnumFieldSymbol* find_enum_field(const SgName &);
      SgLabelSymbol*     find_label(const SgName &) const;
      SgNamespaceSymbol* find_namespace(const SgName &);
*/

SgSymbol*
SgSymbolTable::findany(const SgName &nm)
   {
     return find_any(nm);
   }
SgSymbol*
SgSymbolTable::find_any(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
       // DQ (5/22/2006): Made this a local variable
       // hash_iterator p_iterator = p_table->find(nm);
          p_iterator = p_table->find(nm);
          if (p_iterator != p_table->end() && p_iterator->first == nm)
             {
               p_name    = nm; 
               p_no_name = false;
               return (SgSymbol *) p_iterator->second;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgTypedefSymbol*
SgSymbolTable::find_typedef(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && p_iterator->first == nm)
             {
            // if(isSgTypedefSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgTypedefSymbol)
                  {
                    p_name=nm;
                    p_no_name = false;
                    return (SgTypedefSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumSymbol*
SgSymbolTable::find_enum(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table != NULL)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgEnumSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgEnumSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgEnumSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumFieldSymbol*
SgSymbolTable::find_enum_field(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && p_iterator->first == nm)
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgEnumFieldSymbol)
                  {
                    p_name=nm;
                    p_no_name = false;
                    return (SgEnumFieldSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgVariableSymbol*
SgSymbolTable::findvar(const SgName &nm)
   {
     return find_variable(nm);
   }
SgVariableSymbol*
SgSymbolTable::find_variable(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && (*p_iterator).first==nm)
             {
            // if(isSgVariableSymbol((*p_iterator).second)) 
               if ( p_iterator->second->variantT() == V_SgVariableSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgVariableSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgClassSymbol*
SgSymbolTable::findclass(const SgName &nm)
   {
     return find_class(nm);
   }
SgClassSymbol*
SgSymbolTable::find_class(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator=p_table->find(nm);
          while (p_iterator != p_table->end() && (*p_iterator).first==nm)
             { 
            // if (isSgClassSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgClassSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgClassSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgFunctionTypeSymbol*
SgSymbolTable::findfunctype(const SgName &nm)
   {
     return find_function_type(nm);
   }
SgFunctionTypeSymbol*
SgSymbolTable::find_function_type(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     SgFunctionTypeSymbol* returnFunctionType = NULL;

     hash_iterator i = p_table->find(nm);
  // if (i != p_table->end() && isSgFunctionTypeSymbol((*i).second))
     if (i != p_table->end() && i->second->variantT() == V_SgFunctionTypeSymbol)
        {
       // return (SgFunctionTypeSymbol *) i->second;
          returnFunctionType = (SgFunctionTypeSymbol *) i->second;
        }

  // return NULL;
     return returnFunctionType;
   }

SgLabelSymbol*
SgSymbolTable::find_label(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgNamespaceSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgLabelSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgLabelSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgNamespaceSymbol* 
SgSymbolTable::find_namespace ( const SgName & nm )
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgNamespaceSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgNamespaceSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgNamespaceSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName &nm, const SgType* t)
   {
     return find_function(nm,t);
   }
SgFunctionSymbol*
SgSymbolTable::find_function (const SgName &nm, const SgType* t)
   {
  // AS (083006): cleaned up logic so that the function only have one return statement.
     SgFunctionSymbol *s = NULL;
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i=p_table->find(nm);
       // JW and AS (08/30/06) changed to use equal range rather than find and
       //    iterating through the hash table. This is an optimization.
          std::pair<hash_iterator, hash_iterator> range = p_table->equal_range(nm);
          for (hash_iterator i = range.first; i != range.second; ++i)
             {
            // s = isSgFunctionSymbol((*i).second);
               s = isSgFunctionSymbol(i->second);
               if ( (s != NULL) && (s->get_declaration()->get_type() == t))
                  {
                    p_name    = nm;
                    p_no_name = false;
                 // return ((SgFunctionSymbol *)(*i).second);
                    break;
                  }
             }
        }

     return s;
   }

SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName &nm)
   {
     return find_function(nm);
   }
SgFunctionSymbol*
SgSymbolTable::find_function(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator =p_table->find(nm);
          while(p_iterator != p_table->end())
             {
            // if(isSgFunctionSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgFunctionSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgFunctionSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template(const SgName &nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator =p_table->find(nm);
          while(p_iterator != p_table->end())
             {
            // if(isSgTemplateSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgTemplateSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgTemplateSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any();
      SgVariableSymbol*  find_variable();
      SgClassSymbol*     find_class();
      SgFunctionSymbol*  find_function();
      SgFunctionSymbol*  find_function_type();
      SgTypedefSymbol*   find_typedef();
      SgEnumSymbol*      find_enum();
      SgEnumFieldSymbol* find_enum_field();
      SgLabelSymbol*     find_label();
      SgNamespaceSymbol* find_namespace();
*/

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::findfirstany()
   {
     return find_any();
   }
SgSymbol*
SgSymbolTable::find_any()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true; 
          if(p_iterator != p_table->end())
            // return ((SgSymbol *) (*p_iterator).second);
               return (SgSymbol *) p_iterator->second;
        }

     return NULL;
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::findfirstvar()
   {
     return find_variable();
   }
SgVariableSymbol*
SgSymbolTable::find_variable()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;   
          while(p_iterator != p_table->end()) 
             {
            // if(isSgVariableSymbol((*p_iterator).second)) 
            //      return ((SgVariableSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgVariableSymbol) 
                    return (SgVariableSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::findfirstclass()
   {
     return find_class();
   }
SgClassSymbol*
SgSymbolTable::find_class()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgClassSymbol((*p_iterator).second)) 
            //      return ((SgClassSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgClassSymbol) 
                    return (SgClassSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::findfirstfunction()
   {
     return find_function();
   }
SgFunctionSymbol*
SgSymbolTable::find_function()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionSymbol) 
                    return (SgFunctionSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (1/30/2007): Added to make the interface consistant
// This function is not requires since SgFunctionTypeSymbols
// are stored into their own function table.  So this is 
// equivalent to STL function "begin()".
SgFunctionSymbol*
SgSymbolTable::find_function_type()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionTypeSymbol) 
                    return (SgFunctionTypeSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }
#endif

SgTypedefSymbol*
SgSymbolTable::find_typedef()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTypedefSymbol((*p_iterator).second)) 
            //      return ((SgTypedefSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTypedefSymbol) 
                    return (SgTypedefSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumSymbol*
SgSymbolTable::find_enum()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumSymbol((*p_iterator).second)) 
            //      return ((SgEnumSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumSymbol) 
                    return (SgEnumSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumFieldSymbol*
SgSymbolTable::find_enum_field()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second)) 
            //      return ((SgEnumFieldSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumFieldSymbol) 
                    return (SgEnumFieldSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::find_label()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgLabelSymbol((*p_iterator).second)) 
            //      return ((SgLabelSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgLabelSymbol) 
                    return (SgLabelSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::find_namespace()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgNamespaceSymbol((*p_iterator).second)) 
            //      return ((SgNamespaceSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgNamespaceSymbol) 
                    return (SgNamespaceSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTemplateSymbol((*p_iterator).second))
            //      return ((SgTemplateSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTemplateSymbol)
                    return (SgTemplateSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }




/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          next_any();
      SgVariableSymbol*  next_variable();
      SgClassSymbol*     next_class();
      SgFunctionSymbol*  next_function();
      SgTypedefSymbol*   next_typedef();
      SgEnumSymbol*      next_enum();
      SgEnumFieldSymbol* next_enum_field();
      SgLabelSymbol*     next_label();
      SgNamespaceSymbol* next_namespace();
*/

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::nextany()
   {
     return next_any();
   }
SgSymbol*
SgSymbolTable::next_any()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() )
             {
               if( p_no_name || (*p_iterator).first == p_name )
                    return (SgSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::nextvar()
   {
     return next_variable();
   }
SgVariableSymbol*
SgSymbolTable::next_variable()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgVariableSymbol((*p_iterator).second))
                    return ((SgVariableSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::nextclass()
   {
     return next_class();
   }
SgClassSymbol*
SgSymbolTable::next_class()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator++; // go to next one

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgClassSymbol((*p_iterator).second))
                    return ((SgClassSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::nextfunc()
   {
     return next_function();
   }
SgFunctionSymbol*
SgSymbolTable::next_function()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgFunctionSymbol((*p_iterator).second))
                    return ((SgFunctionSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTypedefSymbol*
SgSymbolTable::next_typedef()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgTypedefSymbol((*p_iterator).second))
                    return ((SgTypedefSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }


// DQ (1/30/2007): Added this as a new member function.
SgEnumSymbol*
SgSymbolTable::next_enum()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgEnumSymbol((*p_iterator).second))
                    return ((SgEnumSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added this as a new member function.
SgEnumFieldSymbol*
SgSymbolTable::next_enum_field()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgEnumFieldSymbol((*p_iterator).second))
                    return ((SgEnumFieldSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::next_label()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgLabelSymbol((*p_iterator).second))
                    return ((SgLabelSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::next_namespace()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgNamespaceSymbol((*p_iterator).second))
                    return ((SgNamespaceSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::next_template()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgTemplateSymbol((*p_iterator).second))
                    return ((SgTemplateSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }



#if 1
// DQ (1/30/2007): Added these back into ROSE.
SgSymbol*
SgSymbolTable::operator[](const SgName & nm)
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i=p_table->find(nm);
          hash_iterator i=p_table->find(nm);
          if (i != p_table->end())
               return (*i).second;
        }

     return NULL;
   }
#endif

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::size() const
   {
     ROSE_ASSERT(p_table != NULL);
     return p_table->size();
   }

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::count(const SgName &nm) const
   {
  // DQ (1/30/2007): assertion added
     ROSE_ASSERT(p_table != NULL);
     return p_table->count(nm);
   }

void
SgSymbolTable::print(std::ostream& os)
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
#if 0
          SgSymbolHashBase::iterator i=p_table->begin();
          int idx = 0;
          while (i != p_table->end())
             {
               os << "[" << idx << "] " << (*i).first << "--";
               SgFunctionTypeSymbol *f=isSgFunctionTypeSymbol((*i).second);
               if (f)
                  {
                    isSgFunctionType(f->get_type())->sym_print(os);
                  }
               SgFunctionSymbol *ft = isSgFunctionSymbol((*i).second);
               if (ft)
                  {
                    isSgFunctionType(ft->get_declaration()->get_type())->sym_print(os); 
                  }
               os << count((*i).first) << endl;
               i++; idx++;
             }
#else
          printf ("ERROR: sym_print function not implemented in SAGE3! \n");
          ROSE_ABORT();
#endif
        }
       else
        {
          os << "Pointer to symbol table is NULL \n";
        }
   }

void
SgSymbolTable::print( std::string label, VariantT nodeType )
   {
     printf ("Printing out the data within the symbol table (p_table = %p,label = %s size = %zu): \n",p_table,label.c_str(),size());

     printf ("Internal static data: p_no_name: %s p_name = %s \n",(p_no_name == true) ? "true" : "false",p_name.str());

  // These are just static data used internally for some of the symbol lookup functions (symbol tables are not given names).
  // printf ("SymbolTable has a name: %s \n",(p_no_name == true) ? "NO: it has no name" : "YES: it does have a name");
  // if (p_no_name == false)
  //      printf ("SymbolTable name = %s \n",p_name.str());

  // DQ (2/16/2006): This is a SgScopeStatement except for the SgSymbolTable used in the global function type symbol table
  // SgScopeStatement* parentNode = isSgScopeStatement(get_parent());
     SgNode* parentNode = get_parent();
     ROSE_ASSERT(parentNode != NULL);
     printf ("Symbol table has parent = %p = %s \n",parentNode,parentNode->class_name().c_str());

  // DQ (6/23/2005): It is not a problem for the global function table to not have a name!
  //   else
  //      ROSE_ASSERT (p_name.str() == NULL);

     ROSE_ASSERT(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i = p_table->begin();
          hash_iterator i = p_table->begin();

          int idx = 0;
          while (i != p_table->end())
             {
            // DQ: removed SgName casting operator to char*
            // cout << "[" << idx << "] " << (*i).first;
            // cout << "[" << idx << "] " << (*i).first.str();
               ROSE_ASSERT ( isSgSymbol( (*i).second ) != NULL );

            // printf ("Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) sage_class_name() = %s \n",
            //      idx,(*i).first.str(),(*i).second->sage_class_name());

               SgSymbol* symbol = isSgSymbol((*i).second);
               ROSE_ASSERT ( symbol != NULL );
               SgType* type = symbol->get_type();

            // DQ (5/7/2004): modified to allow for get_type() to return NULL
            // ROSE_ASSERT ( type != NULL );

               SgNamedType* namedType = isSgNamedType(type);
               SgName nameOfType;
               if (namedType != NULL)
                  {
                    nameOfType = namedType->get_name();
                 // char* nameString = namedType->get_name().str();
                 // printf ("Type is: (named type) = %s \n",nameString);
                  }
                 else
                  {
                 // DQ (5/7/2004): modified to allow for get_type() to return NULL
                    if (type != NULL)
                       {
                      // printf ("Type is: type->sage_class_name() = %s \n",type->sage_class_name());
                         nameOfType = type->sage_class_name();
                       }
                      else
                       {
                      // printf ("Type is: No type found in symbol (likely a possible error!) \n");
                         switch(symbol->variantT())
                            {
                              case V_SgNamespaceSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgNamespaceSymbol)";
                                   break;
                                 }

                              case V_SgTemplateSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgTemplateSymbol)";
                                   break;
                                 }

                              default:
                                 {
                                // This is likely an error, I think
                                   nameOfType = "unkown type name (likely a possible error!)";
                                   break;
                                 }
                            }
                       }
                  }

               bool outputSymbolInfo = (nodeType == V_SgSymbol) || (symbol->variantT() == nodeType);

            // Output of symbol information
               SgNode* symbolBasis = i->second->get_symbol_basis();
               if (symbolBasis != NULL)
                  {
                    ROSE_ASSERT(symbolBasis != NULL);

                    if (outputSymbolInfo == true)
                       {
                         printf ("Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());
                       }
                  }
                 else
                  {
                    if (outputSymbolInfo == true)
                       {
                         printf ("Warning Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = NULL \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str());
                       }
                  }

               SgName mangledName;
               SgSymbol* symbolFromTable = (*i).second;
               ROSE_ASSERT(symbolFromTable != NULL);
               switch(symbolFromTable->variantT())
                  {
                    case V_SgFunctionSymbol:
                       {
                         SgFunctionSymbol* symbol = isSgFunctionSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgMemberFunctionSymbol:
                       {
                         SgMemberFunctionSymbol* symbol = isSgMemberFunctionSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgClassSymbol:
                       {
                         SgClassSymbol* symbol = isSgClassSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgClassDeclaration* classDeclaration = symbol->get_declaration();
                         mangledName = classDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgEnumFieldSymbol:
                       {
                         SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgInitializedName* enumFieldName = symbol->get_declaration();
                         mangledName = enumFieldName->get_mangled_name();
                         break;
                       }
                    case V_SgEnumSymbol:
                       {
                         SgEnumSymbol* symbol = isSgEnumSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgEnumDeclaration* enumDeclaration = symbol->get_declaration();
                         mangledName = enumDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgFunctionTypeSymbol:
                       {
                         SgFunctionTypeSymbol* symbol = isSgFunctionTypeSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         mangledName = symbol->get_name();
                         printf ("A SgFunctionTypeSymbol also has a pointer to a SgType = %p \n",symbol->get_type());
                         break;
                       }
                    case V_SgLabelSymbol:
                       {
                         SgLabelSymbol* symbol = isSgLabelSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgLabelStatement* labelStatement = symbol->get_declaration();
                         mangledName = labelStatement->get_label();
                         break;
                       }
                    case V_SgNamespaceSymbol:
                       {
                         SgNamespaceSymbol* symbol = isSgNamespaceSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
                         mangledName = namespaceDeclaration->get_mangled_name();
                         printf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
                         break;
                       }
                    case V_SgTemplateSymbol:
                       {
                         SgTemplateSymbol* symbol = isSgTemplateSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgTemplateDeclaration* templateDeclaration = symbol->get_declaration();
                         mangledName = templateDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgTypedefSymbol:
                       {
                         SgTypedefSymbol* symbol = isSgTypedefSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgTypedefDeclaration* typedefDeclaration = symbol->get_declaration();
                         mangledName = typedefDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgVariableSymbol:
                       {
                         SgVariableSymbol* symbol = isSgVariableSymbol(symbolFromTable);
                         ROSE_ASSERT(symbol != NULL);
                         SgInitializedName* initializedName = symbol->get_declaration();
                         mangledName = initializedName->get_mangled_name();
                         break;
                       }
                     
                    default:
                       {
                         mangledName = "unknown mangled name";
                         printf ("Error: SgSymbol not handled (%s) \n",symbolFromTable->class_name().c_str());

                      // DQ (6/8/2007): Make this case fail so we can detect this error.
                         ROSE_ASSERT(false);
                       }
                  }

               if (outputSymbolInfo == true)
                  {
                    printf ("   Symbol's associated mangled name = %s \n",mangledName.str());

                 // This is useful for the output of the function types when the global function type symbol table is output.
                 // handle case of function symbol (unparse the funtion type)
                    SgFunctionTypeSymbol *f = isSgFunctionTypeSymbol((*i).second);
                    if (f != NULL)
                       {
#if 1
                      // f->get_type()->unparse(); cout << endl;
                         std::cout << "     function: " << f->get_type()->unparseToString() << endl;
#else
                      // printf ("ERROR: unparse function for symbol type not implemented in SAGE3! \n");
                      // ROSE_ABORT();
#endif
                       }
                  }

            // Increment the symbol table's symble iterator
               i++;

            // Increment the symbol counter (used for output)
               idx++;
             }
        }
       else
        {
       // DQ (6/27/2005): I think this is an error (we should always have a valid symbol table)
          printf ("Pointer to symbol table is NULL \n");
          ROSE_ASSERT(false);
        }
   }


set<SgNode*>
SgSymbolTable::get_symbols() const
   {
  // DQ (2/15/2007): generate a set of SgNode* so that we can use them for set difference against the delete list in AST merge.
     set<SgNode*> returnSet;

     ROSE_ASSERT(p_table != NULL);
     hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator i = get_table()->begin();
     while (i != p_table->end())
        {
          ROSE_ASSERT(i->second != NULL);
          returnSet.insert(i->second);

          i++;
        }

     return returnSet;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSymbolTable::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSymbolTable::variantT() const {
  return V_SgSymbolTable;
}

#if 0
int
SgSymbolTable::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SymbolTableTag;
   }
#endif

const char*
SgSymbolTable::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSymbolTable";  
   }

std::string
SgSymbolTable::class_name() const
   {
     assert(this != NULL);
     return "SgSymbolTable";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSymbolTable::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSymbolTable::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SymbolTableTag)
        {
          printf ("Error in SgSymbolTable::error(): SgSymbolTable object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSymbolTable::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SymbolTableTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSymbolTable::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSymbolTable::variant() const \n");
#endif
     assert(this != NULL);
     return SymbolTableTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSymbolTable* isSgSymbolTable ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSymbolTable*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSymbolTable* isSgSymbolTable ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSymbolTable*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSymbolTable::~SgSymbolTable ()
   {
#if 0
  // debugging information!
     printf ("In SgSymbolTable::~SgSymbolTable (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_table;

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for no_name
     p_no_name = false; // non list case 
  // case: not a listType for table
     p_table = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgInitializedName::get_startOfConstruct () const
   {
     assert (this != NULL);
     return p_startOfConstruct;
   }

void
SgInitializedName::set_startOfConstruct ( Sg_File_Info* startOfConstruct )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct)
        {
          printf ("Warning: startOfConstruct = %p overwriting valid pointer p_startOfConstruct = %p \n",startOfConstruct,p_startOfConstruct);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_startOfConstruct = startOfConstruct;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgInitializedName::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgInitializedName::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgInitializedName::get_typeptr () const
   {
     assert (this != NULL);
     return p_typeptr;
   }

void
SgInitializedName::set_typeptr ( SgType* typeptr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_typeptr != NULL && typeptr != NULL && p_typeptr != typeptr)
        {
          printf ("Warning: typeptr = %p overwriting valid pointer p_typeptr = %p \n",typeptr,p_typeptr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_typeptr != NULL && typeptr != NULL && p_typeptr != typeptr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_typeptr = typeptr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializer* 
SgInitializedName::get_initptr () const
   {
     assert (this != NULL);
     return p_initptr;
   }

void
SgInitializedName::set_initptr ( SgInitializer* initptr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_initptr != NULL && initptr != NULL && p_initptr != initptr)
        {
          printf ("Warning: initptr = %p overwriting valid pointer p_initptr = %p \n",initptr,p_initptr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_initptr != NULL && initptr != NULL && p_initptr != initptr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_initptr = initptr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgInitializedName::get_prev_decl_item () const
   {
     assert (this != NULL);
     return p_prev_decl_item;
   }

void
SgInitializedName::set_prev_decl_item ( SgInitializedName* prev_decl_item )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_prev_decl_item != NULL && prev_decl_item != NULL && p_prev_decl_item != prev_decl_item)
        {
          printf ("Warning: prev_decl_item = %p overwriting valid pointer p_prev_decl_item = %p \n",prev_decl_item,p_prev_decl_item);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_prev_decl_item != NULL && prev_decl_item != NULL && p_prev_decl_item != prev_decl_item) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_prev_decl_item = prev_decl_item;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgInitializedName::get_declptr () const
   {
     assert (this != NULL);
     return p_declptr;
   }

void
SgInitializedName::set_declptr ( SgDeclarationStatement* declptr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declptr != NULL && declptr != NULL && p_declptr != declptr)
        {
          printf ("Warning: declptr = %p overwriting valid pointer p_declptr = %p \n",declptr,p_declptr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declptr != NULL && declptr != NULL && p_declptr != declptr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declptr = declptr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgInitializedName::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgInitializedName::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName::preinitialization_enum 
SgInitializedName::get_preinitialization () const
   {
     assert (this != NULL);
     return p_preinitialization;
   }

void
SgInitializedName::set_preinitialization ( SgInitializedName::preinitialization_enum preinitialization )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_preinitialization = preinitialization;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgInitializedName::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgInitializedName::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgInitializedName::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgInitializedName::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgInitializedName::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgInitializedName::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgInitializedName::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgInitializedName::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgInitializedName::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgInitializedName::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName::asm_register_name_enum 
SgInitializedName::get_register_name_code () const
   {
     assert (this != NULL);
     return p_register_name_code;
   }

void
SgInitializedName::set_register_name_code ( SgInitializedName::asm_register_name_enum register_name_code )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_register_name_code = register_name_code;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgInitializedName::get_register_name_string () const
   {
     assert (this != NULL);
     return p_register_name_string;
   }

void
SgInitializedName::set_register_name_string ( std::string register_name_string )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_register_name_string = register_name_string;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgInitializedName::get_requiresGlobalNameQualificationOnType () const
   {
     assert (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgInitializedName::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 6420 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgInitializedName::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

#if 0
SgInitializedName::~SgInitializedName() 
   {
   /*delete p_ptr;*/
   }

SgInitializedName::SgInitializedName()
   : p_typeptr(0), p_initptr(0), p_declptr(0),
    // p_itemptr(0), p_prev_itemptr(0), 
     p_is_initializer(1)
   {
   }
#endif


Sg_File_Info*
SgInitializedName::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgInitializedName::set_file_info(Sg_File_Info* X)
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode 
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return set_startOfConstruct(X);
   }

SgStorageModifier &
SgInitializedName::get_storageModifier()
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_storageModifier != NULL);
     return *p_storageModifier;
   }

SgName
SgInitializedName::get_qualified_name() const
   {
  // DQ (8/22/2005): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgInitializedName::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgInitializedName::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

void
SgInitializedName::post_construction_initialization()
   {
  // printf ("In SgInitializedName::post_construction_initialization() this = %p \n",this);

     p_storageModifier = new SgStorageModifier();
     ROSE_ASSERT (p_storageModifier != NULL);
     p_storageModifier->setDefault();

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism = NULL;

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope = NULL;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
       // printf ("In SgInitializedName::post_construction_initialization(): resetting parent of valid initializer (p_initptr = %p) \n",p_initptr);
          p_initptr->set_parent(this);
        }
   }

// This constructor is specific to the creation of SgInitializedName objects used as initializers
SgInitializedName::SgInitializedName
   ( const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgDeclarationStatement *declptr, 
    // QY:11/2/04 remove itemptr 
    // SgInitializedName *itemptr,
     SgInitializedName *prev_itemptr ) ROSE_DEPRECATED_FUNCTION
  // DQ (1/18/2006): name change to make consistant with virtual SgNode::get_file_info() 
  // DQ (11/20/2004): Reodered elements of pre-initialization list to avoid compiler warnings
  // : p_file_info(NULL), // Note that file_info is a new data member and is set explicitly after construction
   : p_startOfConstruct(NULL), // Note that file_info is a new data member and is set explicitly after construction
     p_name(name), 
     p_typeptr(typeptr),
  // p_itemptr(itemptr), Removed constructor parameter list
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
  // DQ (6/18/2006): declptr was not being used to set the internal p_declptr data member.
  // p_declptr(NULL),
     p_declptr(declptr),
  // DQ (11/20/2004): Added additional initialization of remaining data members
     p_storageModifier(NULL),
     p_scope(NULL),
  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization(e_unknown_preinitialization),
  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes (Added initialization to prevent valgrind warning)
     p_attributeMechanism(NULL),
  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code(SgInitializedName::e_invalid_register),
  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
     p_register_name_string(""),
  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType(false)
   {
     post_construction_initialization();
   }

// DQ (8/4/2006): This constructor adds the newer fileInfo data member to the constructor parameter list.
// We might soon depricate the older constructor.
SgInitializedName::SgInitializedName
   ( Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr, 
     SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr )
   // : p_file_info(fileInfo), // Note that file_info is a new data member and is set explicitly after construction
   : p_startOfConstruct(fileInfo), // Note that file_info is a new data member and is set explicitly after construction
     p_name(name), 
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_attributeMechanism(NULL),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_register_name_string(""),
  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType(false)
   {
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName (const SgInitializedName& ptr)
   {
     p_name           = ptr.p_name;

     p_typeptr        = ptr.p_typeptr;
     p_initptr        = ptr.p_initptr;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
          printf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in copy constructor) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // p_prev_itemptr   = ptr.p_prev_itemptr; 
     p_is_initializer = ptr.p_is_initializer;
     p_declptr        = ptr.p_declptr;
  // p_itemptr        = ptr.p_itemptr;

  // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
  // p_fileInfo       = ptr.p_fileInfo;
  // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;

  // DQ (12/17/2006): See if we can enforce this!
  // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
     ROSE_ASSERT(ptr.p_startOfConstruct != NULL);
     p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
     ROSE_ASSERT(p_startOfConstruct != NULL);

  // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
     p_startOfConstruct->set_parent(this);

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope          = ptr.p_scope;

  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization = ptr.p_preinitialization;

  // DQ (4/28/2004): Added storage modifier support (replacing the old interface)
     ROSE_ASSERT (ptr.p_storageModifier != NULL);
     p_storageModifier = new SgStorageModifier ( *(ptr.p_storageModifier) );
     ROSE_ASSERT (p_storageModifier != NULL);

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
     p_attributeMechanism = NULL;

  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code = SgInitializedName::e_invalid_register;

  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
  // Note: don't copy the register string (I think this is best, but it is debatable)
     p_register_name_string = "";

  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;
   }

SgInitializedName&
SgInitializedName::operator= (const SgInitializedName& ptr) 
   {
     ROSE_ASSERT(this != NULL);

  /* check they are not the same name */
     if (this != &ptr)
        {
          p_name = ptr.p_name;

          p_typeptr        = ptr.p_typeptr;
          p_initptr        = ptr.p_initptr;

       // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
          if (p_initptr != NULL)
             {
            // printf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in operator=) \n",p_initptr);
#if 0
            // DQ (12/22/2006): Don't allow the parent of the input SgInitializedName to be modified, but make sure that it is set!
            // p_initptr->set_parent(this);
               if (p_initptr->get_parent() == NULL)
                  {
                    p_initptr->set_parent(this);
                  }
#else
            // DQ (12/22/2006): Interestingly, the inliner is dependent upon this working this way!  We should maybe look into this later.
               p_initptr->set_parent(this);
#endif
               ROSE_ASSERT(p_initptr->get_parent() != NULL);

            // printf ("Exiting as a test! operator= \n");
            // ROSE_ASSERT(false);
             }

       // p_prev_itemptr   = ptr.p_prev_itemptr;
          p_is_initializer = ptr.p_is_initializer;
          p_declptr        = ptr.p_declptr;
       // p_itemptr        = ptr.p_itemptr; 

       // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
       // p_fileInfo       = ptr.p_fileInfo;

       // DQ (6/23/2006): Added assertion to detect errors
       // ROSE_ASSERT(ptr.p_file_info != NULL);
       // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;
       // ROSE_ASSERT(p_file_info != NULL);
          ROSE_ASSERT(ptr.p_startOfConstruct != NULL);
       // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
          p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
          ROSE_ASSERT(p_startOfConstruct != NULL);

       // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
          p_startOfConstruct->set_parent(this);

       // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
          p_scope          = ptr.p_scope;

       // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
          p_preinitialization = ptr.p_preinitialization;

          ROSE_ASSERT (p_storageModifier != NULL);
          *p_storageModifier = *(ptr.p_storageModifier);

       // DQ (4/10/2006): Removed in favor of implementation at SgNode using
       // a pointer and the interface represented directly at the SgNode
       // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
          p_attributeMechanism = NULL;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_code = ptr.p_register_name_code;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_string = ptr.p_register_name_string;

       // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
          p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;
        }
       else
        {
       // DQ (6/23/2006): Added debugging message to track this issue.
          printf ("SgInitializedName::operator=(): Attempt to copy self to self \n");
        }

  // ROSE_ASSERT(p_file_info != NULL);
     ROSE_ASSERT(p_startOfConstruct != NULL);

     return *this;
   }

bool
SgInitializedName::operator== (const SgInitializedName& ) const
   { return false; }

bool
SgInitializedName::operator< (const SgInitializedName&) const
   { return false; }

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (12/9/2004): This is how an automatically generated function!
SgName
SgInitializedName::get_name() const
   {
     assert (this != NULL);
     return p_name;
   }
#endif

#if 0
void
SgInitializedName::set_name ( SgName name )
   {
     assert (this != NULL);
     
     p_name = name;
   }
#endif

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (10/5/2007): This was a mistake to comment out, we want this functionality.  It is likely that
// similar function ality should be provided for all other names declarations that generate symbols
// for the symbol table.
// DQ (12/9/2004): This is now an automatically generated function!
// AJ (10/21/2004): Added support for changing the symbol name associated with an SgInitializedName
// by updating the symbol table
int
SgInitializedName::set_name(SgName new_name) 
   {
  // This function could likely be simpler now that we have better symbol table support.

     set_isModified(true);

  // find the appropriate symbol table.
     SgNode * node = this;

  // DQ (12/9/2004): This should likely call the get_scope function (which is more robust than traversing 
  // parents, there is a reason why we are forced to include the scope explicitly on some IR nodes, 
  // see test2004_133.C for details).
     while((node!=NULL) && ( isSgScopeStatement(node)==NULL))
          node = node->get_parent();

     ROSE_ASSERT(node!=NULL);

     SgScopeStatement * scope_stmt = isSgScopeStatement(node);

     ROSE_ASSERT(scope_stmt != NULL);
     ROSE_ASSERT(scope_stmt->get_symbol_table() != NULL);
     ROSE_ASSERT(scope_stmt->get_symbol_table()->get_table() != NULL);

     SgDeclarationStatement * parent_declaration = get_declaration();

     ROSE_ASSERT(parent_declaration != NULL);

  // Find the symbols associated with p_name 
     std::pair<SgSymbolTable::hash_iterator,SgSymbolTable::hash_iterator> pair_it = 
          scope_stmt->get_symbol_table()->get_table()->equal_range(p_name);

     SgSymbolTable::hash_iterator found_it=scope_stmt->get_symbol_table()->get_table()->end();

     for(SgSymbolTable::hash_iterator it = pair_it.first; it != pair_it.second; ++it)
        {
          switch(parent_declaration->getVariant())
             {
               case V_SgVariableDeclaration:
                  {
                    if (isSgVariableSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgClassDeclaration:
                  {
                    if (isSgClassSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgFunctionDeclaration:
                  {
                    if (isSgFunctionSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               default:
                  {
                  }
             };
        }

  // there is no Variable,Class or Function symbol associated with p_name 
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: There is no Variable,Class or Function symbol associated with p_name \n");
          return 0;
        }

     SgSymbol * associated_symbol = (*found_it).second;

  // erase the name from there
     scope_stmt->get_symbol_table()->get_table()->erase(found_it);

  // insert the new_name in the symbol table
     found_it = scope_stmt->get_symbol_table()->get_table()->insert(pair<SgName,SgSymbol*> ( new_name,associated_symbol));

  // if insertion failed
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: insertion of new symbol failed \n");
          return 0;
        }

  // Set the p_name to the new_name
     printf ("Reset p_name = %s to new_name = %s \n",p_name.str(),new_name.str());
     p_name = new_name;

  // Invalidate the p_iterator, p_no_name and p_name data members in the Symbol table

     return 1;
   }
#endif

SgType*
SgInitializedName::get_type() const
   {
     ROSE_ASSERT(this != NULL);
     return p_typeptr;
   }

void
SgInitializedName::set_type(SgType *t)
   {
     ROSE_ASSERT(this != NULL);
     p_typeptr = t;
   }

SgInitializer*
SgInitializedName::get_initializer() const 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     ROSE_ASSERT(this != NULL);
     if (p_is_initializer)
          return p_initptr;
       else
          return NULL;
   }

void
SgInitializedName::set_initializer(SgInitializer* i) 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     ROSE_ASSERT(this != NULL);
     p_initptr        = i;
     p_is_initializer = 1;
   }

#if 0
// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgInitializedName::get_mangled_name(void) const
   {
  // printf ("In SgInitializedName::get_mangled_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName mangleScopeName;
     switch (scope->variantT())
        {
       // These are all of the SgDefinitionStatement IR nodes for which a mangled name can be generated
          case V_SgFunctionDefinition:
             {
               SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(scope);
               ROSE_ASSERT(functionDefinition != NULL);
               mangleScopeName = functionDefinition->get_mangled_name();
               break;
             }
          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* namespaceDefinition = isSgNamespaceDefinitionStatement(scope);
               ROSE_ASSERT(namespaceDefinition != NULL);
               mangleScopeName = namespaceDefinition->get_mangled_name();
               break;
             }
          case V_SgClassDefinition:
             {
               SgClassDefinition* classDefinition = isSgClassDefinition(scope);
               ROSE_ASSERT(classDefinition != NULL);
               mangleScopeName = classDefinition->get_mangled_name();
               break;
             }

          default:
             {
            // Nothing to do here!

            // This permits error checking, is it a good idea?
            // ROSE_ASSERT(scope->hasMangledName() == false);
             }
        }

  // DQ (2/18/2006): Not sure if adding "_variable_" really helps
     returnName = mangleScopeName + SgName("_variable_") + get_name();

  // printf ("In SgInitializedName::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }
#endif

#if 0
// DQ (3/31/2006): Commented out this older version (replaced with newer version).
SgName
SgInitializedName::get_mangled_name (void) const
{
 SgName mangled_name; // return value
 SgName name = get_name ();
 SgScopeStatement* scope = get_scope ();
 ROSE_ASSERT (scope);

 if (name.get_length ()) // not empty
   {
     SgName qual_name = mangleQualifiers (scope);
     mangled_name = joinMangledQualifiers (qual_name, get_name ());
   }
 else // name is empty -- may be an anonymous (unnamed) function arg
   {
     const SgFunctionDefinition* func_def = isSgFunctionDefinition (scope);
     const SgFunctionParameterList* func_params =
       isSgFunctionParameterList (get_declaration ());

     if (func_def && func_params)
       {
         const SgInitializedNamePtrList& func_args = func_params->get_args ();

         // Find position (parameter number) in parameter list
         SgInitializedNamePtrList::const_iterator i;
         size_t param_num = 0;
         for (i = func_args.begin (); i != func_args.end (); ++i)
           {
             param_num++;
             if ((*i) == this)
               break;
           }
         if (i != func_args.end ()) // found position
           {
             ostringstream s;
             s << func_def->get_mangled_name ().str ()
               << "__ARG" << param_num;
             mangled_name = SgName (s.str ());
           }
       }
   }

 if (!mangled_name.get_length ()) // Could not come up with a name?
   {
     printf ("Error in SgInitializedName::get_mangled_name(void): zero length mangled name generated (see if this is realistic) \n");
     ROSE_ASSERT(false);

  // Default: Use pointer value to at least get a unique name
     ostringstream s;
     s << class_name () << "__" << (void *)(this);
     mangled_name = SgName (s.str ().c_str ());
   }

 return mangled_name;
}
#endif

// DQ (3/31/2006): New version from Rich (fixes bug where empty mangled name was generated)
SgName
SgInitializedName::get_mangled_name (void) const
   {
     SgName mangled_name; // return value

  // Case 1: Function parameters.
  // Generate names for parameters such that
  //   int foo (int x, int y) { return x + y; }
  //   int foo (int, int);
  //   int foo (int a, int b);
  // all generate the same unique names for equivalent parameters.
     const SgFunctionParameterList* func_params = isSgFunctionParameterList (get_declaration ());
     if (func_params)
        {
       // Find position (parameter number) in parameter list
          const SgInitializedNamePtrList& func_args = func_params->get_args ();
          SgInitializedNamePtrList::const_iterator i;
          size_t param_num = 0;
          for (i = func_args.begin (); i != func_args.end () && *i != this; ++i)
               param_num++;
          if (i != func_args.end ()) // found position
             {
            // Compute a mangled prefix from the function declaration.
               ostringstream s;
               const SgFunctionDeclaration* func_decl = isSgFunctionDeclaration (func_params->get_parent ());
               if (func_decl)
                    s << func_decl->get_mangled_name ().str ();
               s << "__ARG" << param_num+1;  // Append argument number (1-based)
               mangled_name = SgName (s.str ());
             }
         // else, an error (see below).
        }
       else // Case 2: Not a function parameter
        {
          SgScopeStatement* scope = get_scope ();
          if (scope == NULL)
             {
               printf ("SgInitializedName = %p = %s \n",this,get_name().str());
               get_file_info()->display("Error scope of SgInitializedName == NULL");
             }
          ROSE_ASSERT (scope != NULL);

          SgName qual_name = mangleQualifiers (scope);

          SgName name = get_name();
          if (name.get_length() > 0) // not empty
             {
               mangled_name = joinMangledQualifiers (qual_name, get_name ());
             }
            else
             {
            // name is empty
               if (isSgCatchOptionStmt (scope)) // e.g., 'try {...} catch (int) {...}
                  {
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("CATCHARG"));
                  }
                 else
                  {
                 // printf ("Must be a padding declaration (e.g. int:16) \n");
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("PADDING_VARIABLE"));
                  }
             }
        }

     if (!mangled_name.get_length ()) // Error: could not come up with a name.
        {
          printf ("Error in SgInitializedName::get_mangled_name(void): zero length mangled name generated (see if this is realistic)\n");
          SgScopeStatement* scope = get_scope ();
          ROSE_ASSERT (scope);
          printf ("  Surrounding scope is '%s'\n", scope->sage_class_name ());
          const SgDeclarationStatement* decl = get_declaration ();
          printf ("  Decl is '%s'\n", decl ? decl->sage_class_name () : "(none)");
          const SgDeclarationStatement* def = get_definition ();
          printf ("  Def is '%s'\n", def ? def->sage_class_name () : "(none)");
          const SgNode* par = decl ? decl->get_parent () : 0;
          printf ("  Parent(decl) is '%s'\n", par ? par->sage_class_name () : "(none)");

       // DQ (2/21/2007): I think this is OK for un-named function parameters, leave as a warning for now!.
       // ROSE_ASSERT(false);
       }

     return mangled_name;
   }


// QY 11/3/04
SgDeclarationStatement*
SgInitializedName::get_declaration() const
   {
  // DQ (6/13/2005): This function assumes that the parents have been set!
  // so it should not be used in the EDG/Sage translation!
  // ROSE_ASSERT(get_parent() != NULL);

#if 1
  // DQ (6/21/2006): Return to using this version of the code
  // DQ (6/21/2005): This is trying to traverse back through the scopes which might not make sense
     for (SgNode* r = get_parent(); r != NULL; r = r->get_parent())
        {
          SgDeclarationStatement* d = isSgDeclarationStatement(r);

       // DQ (6/21/2005): I think this should always be true!
       // ROSE_ASSERT(d != NULL);

          if (d != NULL) {
               return d;
        }
        }

     return NULL;
#else
  // DQ (6/18/2006): Since we store the declaration we should use the explictly stored 
  // value instead of anything generated from parents (structure can be problematic for C++).
     return get_declptr();
#endif
   }

SgDeclarationStatement*
SgInitializedName::get_definition() const
   {
  // printf ("Why does SgInitializedName::get_definition() return a declaration! \n");
  // DQ (6/21/2005): Because the SgVariableDefinition is derived from a SgDeclarationStatement 
  // and we return a SgVariableDefinition

  // DQ (6/21/2005): Is this always true? NO!
  // ROSE_ASSERT(isSgVariableDefinition(get_declptr()) != NULL);

     return get_declptr(); 
   }

/*
void
SgInitializedName::set_declaration(SgDeclarationStatement * decl)
   { 
     //p_declptr = decl; 
     set_parent(decl);
   }
*/

void
SgInitializedName::set_definition(SgDeclarationStatement * def)
   { 
#if DEBUG_SAGE_ACCESS_FUNCTIONS
  // DQ (6/12/2007): New access function tests using DEBUG_SAGE_ACCESS_FUNCTIONS and 
  // DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION in sage3.h indicate this is required.
     if (get_declptr() != NULL)
        {
          printf ("Note: overwriting SgInitializedName::get_declptr() = %p with NULL before assignment to def = %p \n",get_declptr(),def);
          set_declptr(NULL);
        }
#endif

     set_declptr(def);
   }
#if 0
SgInitializedName*
SgInitializedName::get_prev_decl_item() const 
   { if(p_is_initializer) return 0; else  return p_prev_itemptr; }

void
SgInitializedName::set_prev_decl_item(SgInitializedName * item) 
   { p_prev_itemptr=item; p_is_initializer=0; }

SgInitializedName*
SgInitializedName::get_named_item() const
   { return p_itemptr; }

void
SgInitializedName::set_named_item(SgInitializedName* item)
   { p_itemptr=item; }

#endif 

#if 0
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgInitializedName::get_file_info(void) const
   {
  // DQ (8/2/2004): Force an explicit function matching the virtual function defined in SgNode
  // but use the new name internally
  // ROSE_ASSERT ( p_fileInfo != NULL);
     return p_fileInfo;
   }
#endif

#if 0
// DQ (4/3/2004): Added support for storage class attributes
int 
SgInitializedName::checkBit(unsigned int bit) const
   { if (p_storage_class_attributes & bit) return 1; else return 0; }

void
SgInitializedName::setBit(unsigned int bit) 
   { p_storage_class_attributes |= bit; }

void
SgInitializedName::unsetBit(unsigned int bit) 
   { p_storage_class_attributes &= ~bit; }

int
SgInitializedName::isExtern() const 
   { return checkBit(e_extern); }

void
SgInitializedName::setExtern() 
   { setBit(e_extern); }

void
SgInitializedName::unsetExtern() 
   { unsetBit(e_extern); }

int
SgInitializedName::isStatic() const 
   { return checkBit(e_static); }

void
SgInitializedName::setStatic() 
   { setBit(e_static); }

void
SgInitializedName::unsetStatic() 
   { unsetBit(e_static); }

int
SgInitializedName::isAuto() const 
   { return checkBit(e_auto); }

void
SgInitializedName::setAuto() 
   { setBit(e_auto); }

void
SgInitializedName::unsetAuto() 
   { unsetBit(e_auto); }

int
SgInitializedName::isRegister() const 
   { return checkBit(e_register); }

void
SgInitializedName::setRegister() 
   { setBit(e_register); }

void
SgInitializedName::unsetRegister() 
   { unsetBit(e_register); }

int
SgInitializedName::isAsm() const 
   { return checkBit(e_asm); }

void
SgInitializedName::setAsm() 
   { setBit(e_asm); }

void
SgInitializedName::unsetAsm() 
   { unsetBit(e_asm); }
#endif

unsigned int
SgInitializedName::cfgIndexForEnd() const {
  return this->get_initializer() ? 1 : 0;
}

bool
SgInitializedName::cfgIsIndexInteresting(unsigned int idx) const {
  return true;
}

unsigned int
SgInitializedName::cfgFindChildIndex(SgNode* n)
   {
// This function could be rewritten to be:
// Check for inappropriate child in initialized name
// ROSE_ASSERT(n == this->get_initializer());
// return 0;

     if (n == this->get_initializer())
        {
          return 0;
        }
       else
          ROSE_ASSERT (!"Bad child in initialized name");

  // DQ (8/24/2006): Added return to avoid compiler warning!
     return 0;
   }

unsigned int
SgInitializedName::cfgFindNextChildIndex(SgNode* n) {
  return this->cfgFindChildIndex(n) + 1;
}

std::vector<VirtualCFG::CFGEdge>
SgInitializedName::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0:
    if (this->get_initializer()) {
      makeEdge(VirtualCFG::CFGNode(this, idx), this->get_initializer()->cfgForBeginning(),
	       result);
    } else {
      makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
    }
    break;

    case 1:
    ROSE_ASSERT (this->get_initializer());
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
    break;

    default: ROSE_ASSERT (!"Bad index in SgInitializedName");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge>
SgInitializedName::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0:
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
    break;

    case 1:
    ROSE_ASSERT (this->get_initializer());
    makeEdge(this->get_initializer()->cfgForEnd(),
	     VirtualCFG::CFGNode(this, idx), result);
    break;

    default: ROSE_ASSERT (!"Bad index in SgInitializedName");
  }
  return result;
}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInitializedName::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInitializedName::variantT() const {
  return V_SgInitializedName;
}

#if 0
int
SgInitializedName::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return InitializedNameTag;
   }
#endif

const char*
SgInitializedName::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInitializedName";  
   }

std::string
SgInitializedName::class_name() const
   {
     assert(this != NULL);
     return "SgInitializedName";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInitializedName::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInitializedName::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != InitializedNameTag)
        {
          printf ("Error in SgInitializedName::error(): SgInitializedName object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInitializedName::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == InitializedNameTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInitializedName::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInitializedName::variant() const \n");
#endif
     assert(this != NULL);
     return InitializedNameTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInitializedName* isSgInitializedName ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInitializedName*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInitializedName* isSgInitializedName ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInitializedName*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInitializedName::~SgInitializedName ()
   {
#if 0
  // debugging information!
     printf ("In SgInitializedName::~SgInitializedName (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_startOfConstruct;
     delete p_storageModifier;

  // case: not a listType for startOfConstruct
     p_startOfConstruct = NULL; // non list case 
  // case: not a listType for name
     p_name = NULL; // non list case 
  // case: not a listType for typeptr
     p_typeptr = NULL; // non list case 
  // case: not a listType for initptr
     p_initptr = NULL; // non list case 
  // case: not a listType for prev_decl_item
     p_prev_decl_item = NULL; // non list case 
  // case: not a listType for is_initializer
     p_is_initializer = false; // non list case 
  // case: not a listType for declptr
     p_declptr = NULL; // non list case 
  // case: not a listType for storageModifier
     p_storageModifier = NULL; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for preinitialization
     p_preinitialization = e_unknown_preinitialization; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 
  // case: not a listType for register_name_code
     p_register_name_code = SgInitializedName::e_invalid_register; // non list case 
  // case: not a listType for register_name_string
     p_register_name_string = ""; // non list case 
  // case: not a listType for requiresGlobalNameQualificationOnType
     p_requiresGlobalNameQualificationOnType = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInitializedName::SgInitializedName (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgInitializedName::SgInitializedName () sage_class_name() = %s \n",sage_class_name());
#endif

     p_startOfConstruct = NULL;
     p_name = NULL;
     p_typeptr = NULL;
     p_initptr = NULL;
     p_prev_decl_item = NULL;
     p_is_initializer = false;
     p_declptr = NULL;
     p_storageModifier = NULL;
     p_scope = NULL;
     p_preinitialization = e_unknown_preinitialization;
     p_attributeMechanism = NULL;
     p_register_name_code = SgInitializedName::e_invalid_register;
     p_register_name_string = "";
     p_requiresGlobalNameQualificationOnType = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(InitializedNameTag == variant());
     post_construction_initialization();

  // Test the isSgInitializedName() function since it has been problematic
     assert(isSgInitializedName(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
Sg_File_Info::get_file_id () const
   {
     assert (this != NULL);
     return p_file_id;
   }

void
Sg_File_Info::set_file_id ( int file_id )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_file_id = file_id;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFileIdList 
Sg_File_Info::get_fileIDsToUnparse () const
   {
     assert (this != NULL);
     return p_fileIDsToUnparse;
   }

void
Sg_File_Info::set_fileIDsToUnparse ( SgFileIdList fileIDsToUnparse )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fileIDsToUnparse = fileIDsToUnparse;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
Sg_File_Info::get_fileidtoname_map () const
   {
     assert (this != NULL);
     return p_fileidtoname_map;
   }

void
Sg_File_Info::set_fileidtoname_map ( std::map<int, std::string> fileidtoname_map )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fileidtoname_map = fileidtoname_map;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<std::string, int> 
Sg_File_Info::get_nametofileid_map () const
   {
     assert (this != NULL);
     return p_nametofileid_map;
   }

void
Sg_File_Info::set_nametofileid_map ( std::map<std::string, int> nametofileid_map )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nametofileid_map = nametofileid_map;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
Sg_File_Info::get_max_file_id () const
   {
     assert (this != NULL);
     return p_max_file_id;
   }

void
Sg_File_Info::set_max_file_id ( int max_file_id )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_max_file_id = max_file_id;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7784 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


int Sg_File_Info::p_cur_line ROSE_DEPRECATED_VARIABLE  = 0;
std::string Sg_File_Info::p_cur_file  ROSE_DEPRECATED_VARIABLE = "";

// MK (7/22/05) : Added support for file ids. Here we initialize the static file maps, etc
int Sg_File_Info::p_max_file_id = 0;
std::map<std::string, int> Sg_File_Info::p_nametofileid_map;
std::map<int, std::string> Sg_File_Info::p_fileidtoname_map;

// DQ (7/4/2005): Added to test internal consistancy
bool
Sg_File_Info::ok() const
   {
     ROSE_ASSERT(this != NULL);

     bool lineNumberOK      = p_line > 0;
     bool columnNumberOK    = p_col  > 0;

  // MK (7/22/05) We compare using p_fileid instead of p_filename now
  // bool filenameOK        = p_filename != NULL;
     bool filenameOK        = p_file_id != NULL_FILE_ID;

  // A compiler generated node has no defined association with a file, line number, or column number.
     bool compilerGenerated = isCompilerGenerated();

  // DQ (11/22/2006): Some nodes have no source position information and we have the live with this at points in the processing.
  // A node which was explicitly marked as a sourcePositionUnavailableInFrontendcompiler has no defined association with a file, line number, or column number.
     bool sourcePositionUnavailableInFrontend = isSourcePositionUnavailableInFrontend();

  // DQ (12/23/2006): If this is part of a transformation then it is OK by definition.
  // A node introduced as part of a transformation has no defined association with a file, line number, or column number.
     bool transformation  = isTransformation();

  // return  compilerGenerated || (lineNumberOK && filenameOK);
  // return  sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && filenameOK);
  // return  transformation || sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && columnNumberOK && filenameOK);
     return  (lineNumberOK && columnNumberOK && filenameOK) || compilerGenerated || sourcePositionUnavailableInFrontend || transformation;
   }

void
Sg_File_Info::updateSourcePosition ( Sg_File_Info* update )
   {
  // DQ (12/22/2006): This copies the line number and column number information and verifies that 
  // the file name is the same (it does not reset any fo the classification flags).  This is more
  // useful than the assignment operator for updating information and is used in the file:
  // fixupSourcePositionInformation.C.

     ROSE_ASSERT(update != NULL);

  // Must have matching file name (only have to compare file_id's)
     ROSE_ASSERT(p_file_id == update->p_file_id);

  // Update only the line number and column number after verifying that the filenames are the same.
     p_line = update->p_line;
     p_col  = update->p_col;
   }


// DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
// Static function to return new Sg_File_Info object set to default values
Sg_File_Info* Sg_File_Info::generateDefaultFileInfo()
   {
     Sg_File_Info* returnValue = new Sg_File_Info("NULL_FILE",0,0);
     ROSE_ASSERT(returnValue != NULL);

  // DQ (6/7/2007): This causes "NULL_FILE" filenames to be introduced into the AST.
  // Gergo pointed out this problems and removing such entries will simplify the tests
  // that are done in the traverseInputFile traversal.
  // printf ("Sg_File_Info::generateDefaultFileInfo(): This function is depricated and is an error to call! \n");
  // ROSE_ASSERT(false);

  // printf ("Calling Sg_File_Info::generateDefaultFileInfo(): returnValue = %p \n",returnValue);

     return returnValue;
   }

// Static function to return new Sg_File_Info object set to default values appropriate for transformations
// static Sg_File_Info* generateTransformationDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForTransformationNode()
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setTransformation();

  // DQ (1/11/2006): Added call to setOutputInCodeGeneration() because the default 
  // behavior is to output all transformations.  Other functions allow transformations 
  // to be specified that would not be output (useful for when including new header files).
     returnValue->setOutputInCodeGeneration();

     returnValue->set_file_id( TRANSFORMATION_FILE_ID );

     return returnValue;
   }

// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( int file_id )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_file_id( file_id );

     return returnValue;
   }

// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( string filename )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_filenameString( filename );

     return returnValue;
   }

// Static function to return new Sg_File_Info object set to default values appropriate for compiler generated code
// static Sg_File_Info* generateCompilerGeneratedDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode()
   {
  // IR nodes using this function's return value will be marked as compiler generated (but not output, unless also marked as such)
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setCompilerGenerated();

     returnValue->set_file_id( COMPILER_GENERATED_FILE_ID );

     return returnValue;
   }

// DQ (11/2/2006): Added operator= member function to simple assignment (used in fixupSourcePositionInformation.C
// to modify Sg_File_Info objects so that they better reflect the original source code).
Sg_File_Info &
Sg_File_Info::operator= ( const Sg_File_Info & X )
   {
     p_file_id                = X.p_file_id;
     p_line                   = X.p_line;
     p_col                    = X.p_col;
     p_classificationBitField = X.p_classificationBitField;
     p_fileIDsToUnparse       = X.p_fileIDsToUnparse;

  // Record that this source position information was updated.
     set_isModified(true);

     return *this;
   }

// DQ (9/26/2004): Added operator== friend function to permit testing of reused definitions of defining declarations!
bool
operator== ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool returnValue = false;

  // Make this most efficent by putting the least likely match first 
  // (col, line, file) and the most expensive test (file) last.
     if (X.get_col() == Y.get_col())
        {
          if (X.get_line() == Y.get_line())
             {
	       // MK (7/22/05) : Replaced string comparisons with file_id comparisons
	       /*
               if ( string(X.get_filename()) == string(Y.get_filename()))
                  {
                    returnValue = true;
                  }
	       */
               if (X.p_file_id == Y.p_file_id)
                  {
                    returnValue = true;
                  }
             }
        }

     return returnValue;
   }


// DQ (10/6/2004): Added operator!= friend function to permit testing of reused definitions of defining declarations!
bool
operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     return operator==(X,Y) ? false : true;
   }

// DQ (10/25/2004): Added relational operators to permit testing of strting vs. ending file info object (assert starting < ending)
bool
operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // printf ("In operator > (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // printf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // printf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
          if (X.p_line > Y.p_line)
             {
            // printf ("TRUE: X.p_line = %d > X.p_line = %d \n",X.p_line,X.p_line);
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col > Y.p_col)
                       {
                      // printf ("TRUE: X.p_col = %d > Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // printf ("Sorry operator> (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // ROSE_ASSERT(false);
  // return true;

     return result;
   }

bool
operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // printf ("In operator < (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // printf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // printf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
          if (X.p_line < Y.p_line)
             {
            // printf ("TRUE: X.p_line = %d < Y.p_line = %d \n",X.p_line,Y.p_line);
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col < Y.p_col)
                       {
                      // printf ("TRUE: X.p_col = %d < Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // printf ("Sorry operator< (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // ROSE_ASSERT(false);
  // return true;

     return result;
   }

bool
operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
          if (X.p_line > Y.p_line)
             {
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col >= Y.p_col)
                         result = true;
                  }
             }
        }

  // printf ("Sorry operator>= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // ROSE_ASSERT(false);
  // return true;

     return result;
   }

bool
operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
          if (X.p_line < Y.p_line)
             {
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col <= Y.p_col)
                         result = true;
                  }
             }
        }

  // printf ("Sorry operator<= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // ROSE_ASSERT(false);
  // return true;

     return result;
   }

void
Sg_File_Info::display( const std::string label ) const
   {
     ROSE_ASSERT(this != NULL);

     printf ("Inside of Sg_File_Info::display(%s) \n",label.c_str());
     printf ("     isTransformation                      = %s \n",isTransformation()    == true ? "true (part of a transformation)" : "false");
     printf ("     isCompilerGenerated                   = %s \n",isCompilerGenerated() == true ? "true (no position information)" : "false");
     printf ("     isOutputInCodeGeneration              = %s \n",isOutputInCodeGeneration() == true ? "true (output in code generator)" : "false");
     printf ("     isShared                              = %s \n",isShared() == true ? "true (shared within merged AST)" : "false");
     printf ("     isFrontendSpecific                    = %s \n",isFrontendSpecific() == true ? "true (part of ROSE support for gnu compatability)" : "false");
     printf ("     isSourcePositionUnavailableInFrontend = %s \n",isSourcePositionUnavailableInFrontend() == true ? "true (source position unavailable in frontend)" : "false");
     printf ("     isCommentOrDirective                  = %s \n",isCommentOrDirective() == true ? "true (this is a comment or CPP directive)" : "false");
     printf ("     isToken                               = %s \n",isToken() == true ? "true (this is from the token stream woven into the AST)" : "false");

  // if (isCompilerGenerated() == false)
     if (!isTransformation() && !isCompilerGenerated())
        {
          printf ("     filename = %s \n",get_filename());
          printf ("     line     = %d  column = %d \n",get_line(),get_col());
        }

  // DQ (6/17/2005): Way to get extra debugging information, if the
  // substring "debug" is found then extra information is output
  // if (label == "debug")
     if (label.find("debug") != std::string::npos)
        {
          printf ("     file_id  = %d \n",get_file_id());
          printf ("     filename = %s \n",get_raw_filename().c_str());
          printf ("     line     = %d  column   = %d \n",p_line,p_col);
        }

  // DQ (5/16/2005): output these values, but I think they might be removed 
  // later since I don't see the point of storing this information!
  // printf ("     isDeclaration    = %s \n",isDeclaration()    == true ? "true" : "false");
  // printf ("     isInitialization = %s \n",isInitialization() == true ? "true" : "false");
   }

string
Sg_File_Info::displayString(const std::string & label ) const
   {
     ROSE_ASSERT(this != NULL);

     std::string s;
     s += std::string("Inside of Sg_File_Info::displayString(") + label + std::string (") \n");
     s += std::string("isTransformation    = ") + std::string(isTransformation()    ? "true" : "false") + std::string(" ");
     s += std::string("isCompilerGenerated = ") + std::string(isCompilerGenerated() ? "true" : "false") + std::string(" ");
     if (!isTransformation() && !isCompilerGenerated())
        {
          s += std::string("line number = ")   + StringUtility::numberToString(get_line()) + std::string(" ");
          s += std::string("column number = ") + StringUtility::numberToString(get_col())  + std::string(" ");
          s += std::string("filename = ")      + std::string(get_filename()) + std::string(" ");
        }

     return s;
   }

void
Sg_File_Info::display_static_data( const std::string label )
   {
  // DQ (6/11/2007): output static data for debugging

     printf ("Inside of Sg_File_Info::display_static_data(%s) \n",label.c_str());

     printf ("p_cur_line = %d \n",p_cur_line);
     printf ("p_cur_file = %s \n",p_cur_file.c_str());

     printf ("p_max_file_id = %d \n",p_max_file_id);

     printf ("p_nametofileid_map: \n");
     for (std::map<std::string,int>::iterator i = p_nametofileid_map.begin(); i != p_nametofileid_map.end(); i++)
        {
          printf ("name = %s id = %d \n",i->first.c_str(),i->second);
        }

     printf ("p_fileidtoname_map: \n");
     for (std::map<int,std::string>::iterator i = p_fileidtoname_map.begin(); i != p_fileidtoname_map.end(); i++)
        {
          printf ("id = %d name = %s \n",i->first,i->second.c_str());
        }
   }

// Since we make the arguments in the other constructor 
// have default values this constructor is redundant/ambiguous
// Sg_File_Info::Sg_File_Info() {}

Sg_File_Info::Sg_File_Info ()
   {
     ROSE_ASSERT(this != NULL);

  // Default constructor used for making copies of subtrees
     p_line                   = 0;
     p_col                    = 0;
     p_classificationBitField = 0;

  // MK (7/22/05) : Initialize p_file_id to inidicate a copy
     p_file_id = COPY_FILE_ID;

#if 0
     printf ("Sg_File_Info default constructor = %p \n",this);
  // display("In constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

// DQ (4/19/2006): Added constructor to take std::string as part of move
// away from C style strings to C++ style strings.
Sg_File_Info::Sg_File_Info ( const std::string & filename, int line, int col )
   : p_line(line), p_col(col)
   {
     ROSE_ASSERT(this != NULL);

  // DQ (5/11/2006): Allow "NULL_FILE" as a name (used within ROSE) to map to the NULL_FILE_ID 
  // if (filename.empty() == true)
     if (filename.empty() == true || filename == "NULL_FILE")
        {
          p_file_id = NULL_FILE_ID;
        }
       else 
        {
       // DQ (7/25/2005): Refactored to use set_filename()
          set_filenameString(filename);
        }

     p_classificationBitField = 0;

     ROSE_ASSERT (p_col >= 0);

#if 0
     printf ("Sg_File_Info constructor(const std::string,int,int) = %p \n",this);
  // display("In constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

// DQ (2/15/2003): added copy constructor
Sg_File_Info::Sg_File_Info(const Sg_File_Info & X)
   : p_file_id(X.p_file_id),
     p_line(X.p_line), p_col(X.p_col),
  // DQ (7/29/2005): Preserve IR node classification within copy constructor
  // p_classificationBitField(0)
     p_classificationBitField(X.p_classificationBitField),
     p_fileIDsToUnparse(X.p_fileIDsToUnparse)
   {
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT (p_col >= 0);

#if 0
     printf ("Sg_File_Info copy constructor(const Sg_File_Info) = %p \n",this);
  // display("In copy constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

#if 0
// This is now removed but saved becuase it might be that it should be depricated for a while
Sg_File_Info::Sg_File_Info ( const char* filename, int line, int col )
   : p_line(line), p_col(col) // , p_isPartOfTransformation(false)
   {
     ROSE_ASSERT(this != NULL);

     if (!filename) {
          p_file_id = NULL_FILE_ID;
        }
       else 
        {
       // DQ (7/25/2005): Refactored to use set_filename()
          set_filename(filename);
        }

     p_classificationBitField = 0;

     if (p_col < 0)
        {
          printf ("Error p_col = %d \n",p_col);
        }
     ROSE_ASSERT (p_col >= 0);

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }
#endif

void
Sg_File_Info::post_construction_initialization()
   {
     ROSE_ASSERT (this != NULL);

  // ROSE_ASSERT(this != (Sg_File_Info*) 0x5231b0);
   }

void
Sg_File_Info::set_line(int line)
   {
     ROSE_ASSERT (this != NULL);
     p_line = line;
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filename(const char* filename)
Sg_File_Info::set_filenameString ( const std::string & filename )
   {
     ROSE_ASSERT (this != NULL);

     if (p_nametofileid_map.count(filename) == 0)
        {
          p_file_id = p_max_file_id++;
          p_nametofileid_map[filename]  = p_file_id;
          p_fileidtoname_map[p_file_id] = filename;
        }
       else
        {
          p_file_id = p_nametofileid_map[filename];
        }

  // DQ (8/31/2006): We can't enforce that this is an absolute path (test2001_04.C and test2004_60.C demonstrate why).
  // DQ (8/31/2006): Verify that this is a absolute path
  // string targetSubstring = "/";
  // string filenameString  = filename;
  // if (filenameString.substr(0,targetSubstring.size()) != targetSubstring)
  //      printf ("@@@@@@@@@@@@@@@@@@@@ In Sg_File_Info::Sg_File_Info(string,int,int): filename = %s @@@@@@@@@@@@@@@@@@@@\n",filenameString.c_str());
  // ROSE_ASSERT(filenameString.substr(0,targetSubstring.size()) == targetSubstring);

  // Detect use of AST Rewrite intermediate files (need to make sure they get absolute paths)
  // string targetSubstring2 = "rose_";
  // ROSE_ASSERT(filenameString.substr(0,targetSubstring2.size()) != targetSubstring2);
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filenameString ( const std::string & filename )
Sg_File_Info::set_filename(const char* filename)
   {
  // DQ (9/5/2006): Modified implementation
  // set_filename(filename.c_str());
     ROSE_ASSERT(filename != NULL);
     set_filenameString(filename);
   }

const std::string&
Sg_File_Info::get_filenameString() const
   {
     ROSE_ASSERT (this != NULL);
  // return p_filename;

     const std::string* returnString = NULL;
     if (isTransformation() == true)
        {
#if PRINT_DEVELOPER_WARNINGS
       // DQ (2/25/2006): Unclear how often we want to have this output, it is sometimes useful and sometime annoying.
          printf ("Sg_File_Info::get_filename called for transformation IR node \n");
#endif
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
      else if(isCompilerGenerated() == true)
        {
       // DQ (8/17/2005): only "compilergenerated" when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
            // printf ("Sg_File_Info::get_filename called for compiler generated IR node \n");
               static const std::string compilerGenerated_string = "compilerGenerated";
               returnString = &compilerGenerated_string;
      }else {
	  #if 0
          const char * tmp = getFilenameFromID(p_file_id).c_str();
          int length = strlen(tmp) + 1;
          returnString = new char[length];
          strncpy(returnString, tmp, length);
	  #endif
	  returnString = &getFilenameFromID(p_file_id);
        }

     ROSE_ASSERT (returnString != NULL);
     return *returnString;
   }

const char*
Sg_File_Info::get_filename() const
   {
  // DQ (10/15/2005): This function is the C++ string version of the get_filename() 
  // function which has been depricated. At some point the get_filename() function 
  // will be eliminated and later reinfroduced as get_filename() (finally returning 
  // a C++ string instead of a char* (C style string)).
     return get_filenameString().c_str();
   }

string
Sg_File_Info::get_raw_filename() const
   {
     ROSE_ASSERT (this != NULL);

  // return whatever name is in the map
     return getFilenameFromID(p_file_id);
   }

int
Sg_File_Info::get_line() const
   { 
     ROSE_ASSERT (this != NULL);
  // return p_line;
  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // printf ("Sg_File_Info::get_line called for transformation IR node (p_line = %d) \n",p_line);
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // printf ("Sg_File_Info::get_line called for compiler generated IR node (p_line = %d) \n",p_line);

            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
            // returnValue = undefinedValue;
            // returnValue = p_line;
               returnValue = undefinedValue;
             }
            else
             {
               returnValue = p_line;
             }
        }

     ROSE_ASSERT (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_line() const
   { 
     ROSE_ASSERT (this != NULL);
     return p_line;
   }

int
Sg_File_Info::get_col() const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_col >= 0);
  // return p_col;

  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // printf ("Sg_File_Info::get_col called for transformation IR node \n");
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // printf ("Sg_File_Info::get_col called for compiler generated IR node \n");
               returnValue = undefinedValue;
             }
            else
             {
               returnValue = p_col;
             }
        }

     ROSE_ASSERT (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_col() const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_col >= 0);
     return p_col;
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
void
Sg_File_Info::set_isPartOfTransformation( bool isPartOfTransformation )
   {
     ROSE_ASSERT (this != NULL);
  // p_isPartOfTransformation = isPartOfTransformation;

     if (isPartOfTransformation == true)
          setTransformation();
       else
          unsetTransformation();
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
bool
Sg_File_Info::get_isPartOfTransformation()
   {
     ROSE_ASSERT (this != NULL);
  // return p_isPartOfTransformation;
     return isTransformation();
   }

void
Sg_File_Info::register_node(SgLocatedNode* node)
   {} /* register interest */

void
Sg_File_Info::deregister_node(SgLocatedNode* node)
   {}

// functions added by Dan Quinlan (suggested by Gary Lee)
void
Sg_File_Info::set_col( int n )
   {
     ROSE_ASSERT (this != NULL);
     p_col = n;
     ROSE_ASSERT (p_col >= 0);
   }

int
Sg_File_Info::getCurrentLine () const
   { 
     ROSE_ASSERT (this != NULL);
     printf ("This is a depricated function: char* Sg_File_Info::getCurrentLine() const \n");
     return p_cur_line;
   }

std::string
Sg_File_Info::getCurrentFilename () const
   {
     ROSE_ASSERT (this != NULL);
     printf ("This is a depricated function: char* Sg_File_Info::getCurrentFilename() const \n");
     return p_cur_file;
   }

bool
Sg_File_Info::hasPositionInSource() const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (1/11/2006): Modified to not use the output function which mixed 
  // concepts of compiler generated with output (deprecated function).
  // bool result = ( ! ( isTransformation() || isCompilerGenerated() || isCompilerGeneratedNodeToBeUnparsed() ) );
     bool result = ( ! ( isTransformation() || isCompilerGenerated() || isOutputInCodeGeneration() ) );
     return result;
   }

bool
Sg_File_Info::isSameFile(SgFile* file) const
   {
  // DQ (6/21/2005): check if this file info object is from the same file

  // This function abstracts the mechanism of comparing if a file info object is associated with a specific SgFile.
  // this function will be made more efficient later when we can abstract out the string comparision from the test.
  // Later we will implement a map from filename to unique "file number identifiers", this will permit significant
  // spaces saving in the IR by avoiding redundant storage of filename strings and also improve the efficiency of 
  // testing if two file info objects represent the same file (an integer equality test instead of string comparision).
  // File names are particularly long (since they include full path), so this will allow us to save a lot of space.

     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(file != NULL);

  // MK (7/22/05) : removing use of p_filename in favor of p_file_id
  // Generate names of the files 
     /*
     string inputFilename = file->getFileName();
     string currentFilename = get_filename();

     bool result = (currentFilename == inputFilename);
     */

     SgScopeStatement * globalScope = (SgScopeStatement *)(file->get_root());
     ROSE_ASSERT(globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
     ROSE_ASSERT(fileInfo != NULL);

     bool result = (p_file_id == fileInfo->get_file_id());
     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(Sg_File_Info* fileInfo) const
   {
     ROSE_ASSERT(fileInfo != NULL);
     bool result = (p_file_id == fileInfo->get_file_id());
     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(const Sg_File_Info & fileInfo) const
   {
     bool result = (p_file_id == fileInfo.get_file_id());
     return result;
   }

//! Access functions for classification of File_Info objects
bool
Sg_File_Info::isTransformation() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_transformation);
   }

void
Sg_File_Info::setTransformation()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_transformation;
   }

void
Sg_File_Info::unsetTransformation()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_transformation;
   }

bool
Sg_File_Info::isCompilerGenerated() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_compiler_generated);
   }

void
Sg_File_Info::setCompilerGenerated()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_compiler_generated;
   }

void
Sg_File_Info::unsetCompilerGenerated()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_compiler_generated;
   }

// bool isCompilerGeneratedNodeToBeUnparsed() const;
bool
Sg_File_Info::isCompilerGeneratedNodeToBeUnparsed() const
   {
  // Make sure that both bits are set!
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);

#if 0
  // DQ (6/17/2005): Allow these to be set separately so that setting a whole function to 
  // be unparsed will not make any expecific casts as compiler generated and not required!
  // If casts are the only issue then perhaps they should be marked explicitly as implicit 
  // or explicit (rather than compiler generated).
     bool result = (p_classificationBitField & e_output_in_code_generation);

  // error checking: if e_compiler_generated_node_to_be_unparsed then also e_compiler_generated
     if (result == true)
          ROSE_ASSERT(isCompilerGenerated() == true);

     return result;
#endif
   }

void
Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetCompilerGeneratedNodeToBeUnparsed()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation; 
   }

bool
Sg_File_Info::isOutputInCodeGeneration() const
   {
  // Make sure that both bits are set!
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);
   }

void
Sg_File_Info::setOutputInCodeGeneration()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetOutputInCodeGeneration()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation;
   }

bool
Sg_File_Info::isShared() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_shared);
   }

void
Sg_File_Info::setShared()
   {
  // MK (8/3/05) : We always want to unparse the current file (this is a performance issue)
     ROSE_ASSERT(this != NULL);
     if (isShared() == false)
          p_fileIDsToUnparse.insert(p_file_id);

     p_classificationBitField |= e_shared;
   }

void
Sg_File_Info::unsetShared()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_shared;

  // MK (8/2/05) : Initialize the fileid set
     p_fileIDsToUnparse.clear();
   }

bool
Sg_File_Info::isFrontendSpecific() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_frontend_specific);
   }

void
Sg_File_Info::setFrontendSpecific()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_frontend_specific;
   }

void
Sg_File_Info::unsetFrontendSpecific()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_frontend_specific;
   }

bool
Sg_File_Info::isSourcePositionUnavailableInFrontend() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_source_position_unavailable_in_frontend);
   }

void
Sg_File_Info::setSourcePositionUnavailableInFrontend()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_source_position_unavailable_in_frontend;
   }

void
Sg_File_Info::unsetSourcePositionUnavailableInFrontend()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_source_position_unavailable_in_frontend;
   }

bool
Sg_File_Info::isCommentOrDirective() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_comment_or_directive);
   }

void
Sg_File_Info::setCommentOrDirective()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_comment_or_directive;
   }

void
Sg_File_Info::unsetCommentOrDirective()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_comment_or_directive;
   }

bool
Sg_File_Info::isToken() const
   {
     ROSE_ASSERT(this != NULL);
     return (p_classificationBitField & e_token);
   }

void
Sg_File_Info::setToken()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField |= e_token;
   }

void
Sg_File_Info::unsetToken()
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField &= ~e_token;
   }

// MK (8/2/05) : Implementation for function to handle unparsing of particular files
void
Sg_File_Info::addFileToUnparse(int file_id)
   { 
     ROSE_ASSERT(this != NULL);
     p_fileIDsToUnparse.insert(file_id);
   }

bool
Sg_File_Info::shouldUnparse(int file_id)
   {
     ROSE_ASSERT(this != NULL);
     return p_fileIDsToUnparse.count(file_id) != 0;
   }

// DQ (6/17/2005): Removed function (not used and not important to support)
// bool
// Sg_File_Info::isDeclaration() const
//   { return (p_classificationBitField & e_declaration); }

// DQ (6/17/2005): Removed function (not used and not important to support)
// void
// Sg_File_Info::setDeclaration()
//    {
//      unsetInitialization();
//      p_classificationBitField |= e_declaration;
//    }

// DQ (6/17/2005): Removed function (not used and not important to support)
// void
// Sg_File_Info::unsetDeclaration()
//    { p_classificationBitField &= ~e_declaration; }

// DQ (6/17/2005): Removed function (not used and not important to support)
// bool
// Sg_File_Info::isInitialization() const
//    { return (p_classificationBitField & e_initialization); }

// DQ (6/17/2005): Removed function (not used and not important to support)
// void
// Sg_File_Info::setInitialization()
//    {
//      unsetDeclaration();
//      p_classificationBitField |= e_initialization;
//    }

// DQ (6/17/2005): Removed function (not used and not important to support)
// void
// Sg_File_Info::unsetInitialization()
//    { p_classificationBitField &= ~e_initialization; }

unsigned int
Sg_File_Info::get_classificationBitField(void) const
   {
     ROSE_ASSERT(this != NULL);
     return p_classificationBitField;
   }

void
Sg_File_Info::set_classificationBitField( unsigned int bitflags )
   {
     ROSE_ASSERT(this != NULL);
     p_classificationBitField = bitflags;
   }

// MK (8/2/05): Added implementations for static functions to support interface to fileid maps
const string&
Sg_File_Info::getFilenameFromID(int id)
   {
  // This is a static function

     const std::string* name = NULL;
     switch(id)
        {
       // special cases
          case NULL_FILE_ID:
             {
               static const std::string null_file_string =  "NULL_FILE";
               name = &null_file_string;
               break;
             }
          case COPY_FILE_ID:
             {
               static const std::string copy_file_string  = "COPY";
               name = &copy_file_string;
               break;
             }
          case TRANSFORMATION_FILE_ID:
             {
               static const std::string transformation_string = "transformation";
               name = &transformation_string;
               break;
             }
          case COMPILER_GENERATED_FILE_ID:
             {
               static const std::string compilerGenerated_string = "compilerGenerated";
               name = &compilerGenerated_string;
               break;
             }
          case COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID:
             {
            // name = "compilerGenerated";
               printf ("The concept of COMPILER_GENERATED and OUTPUT are now decoupled, so make this an error \n");
               ROSE_ASSERT(false);
               break;
             }
          case BAD_FILE_ID:
             {
               static const std::string badfile_string = "badfile";
               name = &badfile_string;
               break;
             }

       // normal case
          default:
             {
            // assert that the id is present in the map (else error)
            // ROSE_ASSERT(p_fileidtoname_map.count(id) != 0);
               bool failure = (p_fileidtoname_map.count(id) == 0);
               if (failure == true)
                  {
                    printf ("Error: bad id number for file id (id = %d) \n",id);

                    display_static_data("error in getFilenameFromID");

                 // Note: this causes an empty entry to be generated in p_fileidtoname_map for the id == p_max_file_id (value of max map size)
                 // std::cout << p_fileidtoname_map[id] << std::endl;
                 // printf ("Error: bad id number for file id (id = %d) \n",id);
                  }
               ROSE_ASSERT(failure == false);

            // get the filename from the map using the valid id
               name = &p_fileidtoname_map[id];
             }
        }

     return *name;
   }

int
Sg_File_Info::getIDFromFilename( std::string filename )
   {
  // This is a static function

     if (p_nametofileid_map.count(filename) == 0)
        {
          return BAD_FILE_ID;
        }

     return p_nametofileid_map[filename];
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
Sg_File_Info::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
Sg_File_Info::variantT() const {
  return V_Sg_File_Info;
}

#if 0
int
Sg_File_Info::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return _File_InfoTag;
   }
#endif

const char*
Sg_File_Info::sage_class_name() const
   {
     assert(this != NULL);
     return "Sg_File_Info";  
   }

std::string
Sg_File_Info::class_name() const
   {
     assert(this != NULL);
     return "Sg_File_Info";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
Sg_File_Info::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
Sg_File_Info::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != _File_InfoTag)
        {
          printf ("Error in Sg_File_Info::error(): Sg_File_Info object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in Sg_File_Info::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == _File_InfoTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
Sg_File_Info::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In Sg_File_Info::variant() const \n");
#endif
     assert(this != NULL);
     return _File_InfoTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

Sg_File_Info* isSg_File_Info ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<Sg_File_Info*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const Sg_File_Info* isSg_File_Info ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const Sg_File_Info*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
Sg_File_Info::~Sg_File_Info ()
   {
#if 0
  // debugging information!
     printf ("In Sg_File_Info::~Sg_File_Info (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for file_id
     p_file_id = NULL_FILE_ID; // non list case 
  // case: not a listType for line
     p_line = 0; // non list case 
  // case: not a listType for col
     p_col = 0; // non list case 
  // case: not a listType for classificationBitField
     p_classificationBitField = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgFile::get_startOfConstruct () const
   {
     assert (this != NULL);
     return p_startOfConstruct;
   }

void
SgFile::set_startOfConstruct ( Sg_File_Info* startOfConstruct )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct)
        {
          printf ("Warning: startOfConstruct = %p overwriting valid pointer p_startOfConstruct = %p \n",startOfConstruct,p_startOfConstruct);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_startOfConstruct = startOfConstruct;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgGlobal* 
SgFile::get_root () const
   {
     assert (this != NULL);
     return p_root;
   }

void
SgFile::set_root ( SgGlobal* root )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_root != NULL && root != NULL && p_root != root)
        {
          printf ("Warning: root = %p overwriting valid pointer p_root = %p \n",root,p_root);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_root != NULL && root != NULL && p_root != root) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_root = root;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgFile::get_originalCommandLineArgumentList () const
   {
     assert (this != NULL);
     return p_originalCommandLineArgumentList;
   }

void
SgFile::set_originalCommandLineArgumentList ( SgStringList originalCommandLineArgumentList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_originalCommandLineArgumentList = originalCommandLineArgumentList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgFile::get_verbose () const
   {
     assert (this != NULL);
     return p_verbose;
   }

void
SgFile::set_verbose ( int verbose )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_verbose = verbose;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_C_only () const
   {
     assert (this != NULL);
     return p_C_only;
   }

void
SgFile::set_C_only ( bool C_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_C_only = C_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_C99_only () const
   {
     assert (this != NULL);
     return p_C99_only;
   }

void
SgFile::set_C99_only ( bool C99_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_C99_only = C99_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_Fortran_only () const
   {
     assert (this != NULL);
     return p_Fortran_only;
   }

void
SgFile::set_Fortran_only ( bool Fortran_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_Fortran_only = Fortran_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_F77_only () const
   {
     assert (this != NULL);
     return p_F77_only;
   }

void
SgFile::set_F77_only ( bool F77_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_F77_only = F77_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_F90_only () const
   {
     assert (this != NULL);
     return p_F90_only;
   }

void
SgFile::set_F90_only ( bool F90_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_F90_only = F90_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_F95_only () const
   {
     assert (this != NULL);
     return p_F95_only;
   }

void
SgFile::set_F95_only ( bool F95_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_F95_only = F95_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_F2003_only () const
   {
     assert (this != NULL);
     return p_F2003_only;
   }

void
SgFile::set_F2003_only ( bool F2003_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_F2003_only = F2003_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_fixedFormat () const
   {
     assert (this != NULL);
     return p_fixedFormat;
   }

void
SgFile::set_fixedFormat ( bool fixedFormat )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fixedFormat = fixedFormat;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_freeFormat () const
   {
     assert (this != NULL);
     return p_freeFormat;
   }

void
SgFile::set_freeFormat ( bool freeFormat )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_freeFormat = freeFormat;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFile::outputFormatOption_enum 
SgFile::get_outputFormat () const
   {
     assert (this != NULL);
     return p_outputFormat;
   }

void
SgFile::set_outputFormat ( SgFile::outputFormatOption_enum outputFormat )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputFormat = outputFormat;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_fortran_implicit_none () const
   {
     assert (this != NULL);
     return p_fortran_implicit_none;
   }

void
SgFile::set_fortran_implicit_none ( bool fortran_implicit_none )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fortran_implicit_none = fortran_implicit_none;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_fortran_openmp () const
   {
     assert (this != NULL);
     return p_fortran_openmp;
   }

void
SgFile::set_fortran_openmp ( bool fortran_openmp )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fortran_openmp = fortran_openmp;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_skip_transformation () const
   {
     assert (this != NULL);
     return p_skip_transformation;
   }

void
SgFile::set_skip_transformation ( bool skip_transformation )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_skip_transformation = skip_transformation;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_skip_unparse () const
   {
     assert (this != NULL);
     return p_skip_unparse;
   }

void
SgFile::set_skip_unparse ( bool skip_unparse )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_skip_unparse = skip_unparse;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_unparse_includes () const
   {
     assert (this != NULL);
     return p_unparse_includes;
   }

void
SgFile::set_unparse_includes ( bool unparse_includes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_unparse_includes = unparse_includes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_skipfinalCompileStep () const
   {
     assert (this != NULL);
     return p_skipfinalCompileStep;
   }

void
SgFile::set_skipfinalCompileStep ( bool skipfinalCompileStep )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_skipfinalCompileStep = skipfinalCompileStep;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFile::outputLanguageOption_enum 
SgFile::get_outputLanguage () const
   {
     assert (this != NULL);
     return p_outputLanguage;
   }

void
SgFile::set_outputLanguage ( SgFile::outputLanguageOption_enum outputLanguage )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputLanguage = outputLanguage;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgFile::get_sourceFileNameWithPath () const
   {
     assert (this != NULL);
     return p_sourceFileNameWithPath;
   }

void
SgFile::set_sourceFileNameWithPath ( std::string sourceFileNameWithPath )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileNameWithPath = sourceFileNameWithPath;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgFile::get_sourceFileNameWithoutPath () const
   {
     assert (this != NULL);
     return p_sourceFileNameWithoutPath;
   }

void
SgFile::set_sourceFileNameWithoutPath ( std::string sourceFileNameWithoutPath )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileNameWithoutPath = sourceFileNameWithoutPath;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgFile::get_unparse_output_filename () const
   {
     assert (this != NULL);
     return p_unparse_output_filename;
   }

void
SgFile::set_unparse_output_filename ( std::string unparse_output_filename )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_unparse_output_filename = unparse_output_filename;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_useBackendOnly () const
   {
     assert (this != NULL);
     return p_useBackendOnly;
   }

void
SgFile::set_useBackendOnly ( bool useBackendOnly )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_useBackendOnly = useBackendOnly;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_compileOnly () const
   {
     assert (this != NULL);
     return p_compileOnly;
   }

void
SgFile::set_compileOnly ( bool compileOnly )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_compileOnly = compileOnly;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgFile::get_savedFrontendCommandLine () const
   {
     assert (this != NULL);
     return p_savedFrontendCommandLine;
   }

void
SgFile::set_savedFrontendCommandLine ( std::string savedFrontendCommandLine )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_savedFrontendCommandLine = savedFrontendCommandLine;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_no_implicit_templates () const
   {
     assert (this != NULL);
     return p_no_implicit_templates;
   }

void
SgFile::set_no_implicit_templates ( bool no_implicit_templates )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_no_implicit_templates = no_implicit_templates;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_no_implicit_inline_templates () const
   {
     assert (this != NULL);
     return p_no_implicit_inline_templates;
   }

void
SgFile::set_no_implicit_inline_templates ( bool no_implicit_inline_templates )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_no_implicit_inline_templates = no_implicit_inline_templates;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_skip_commentsAndDirectives () const
   {
     assert (this != NULL);
     return p_skip_commentsAndDirectives;
   }

void
SgFile::set_skip_commentsAndDirectives ( bool skip_commentsAndDirectives )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_skip_commentsAndDirectives = skip_commentsAndDirectives;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_collectAllCommentsAndDirectives () const
   {
     assert (this != NULL);
     return p_collectAllCommentsAndDirectives;
   }

void
SgFile::set_collectAllCommentsAndDirectives ( bool collectAllCommentsAndDirectives )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_collectAllCommentsAndDirectives = collectAllCommentsAndDirectives;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

ROSEAttributesListContainerPtr 
SgFile::get_preprocessorDirectivesAndCommentsList () const
   {
     assert (this != NULL);
     return p_preprocessorDirectivesAndCommentsList;
   }

void
SgFile::set_preprocessorDirectivesAndCommentsList ( ROSEAttributesListContainerPtr preprocessorDirectivesAndCommentsList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_preprocessorDirectivesAndCommentsList = preprocessorDirectivesAndCommentsList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgFile::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgFile::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgFile::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgFile::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgFile::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgFile::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgFile::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgFile::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgFile::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgFile::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_KCC_frontend () const
   {
     assert (this != NULL);
     return p_KCC_frontend;
   }

void
SgFile::set_KCC_frontend ( bool KCC_frontend )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_KCC_frontend = KCC_frontend;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_new_frontend () const
   {
     assert (this != NULL);
     return p_new_frontend;
   }

void
SgFile::set_new_frontend ( bool new_frontend )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_new_frontend = new_frontend;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_travTraceToDOT () const
   {
     assert (this != NULL);
     return p_travTraceToDOT;
   }

void
SgFile::set_travTraceToDOT ( bool travTraceToDOT )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_travTraceToDOT = travTraceToDOT;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_disable_edg_backend () const
   {
     assert (this != NULL);
     return p_disable_edg_backend;
   }

void
SgFile::set_disable_edg_backend ( bool disable_edg_backend )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_disable_edg_backend = disable_edg_backend;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_disable_sage_backend () const
   {
     assert (this != NULL);
     return p_disable_sage_backend;
   }

void
SgFile::set_disable_sage_backend ( bool disable_sage_backend )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_disable_sage_backend = disable_sage_backend;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgFile::get_testingLevel () const
   {
     assert (this != NULL);
     return p_testingLevel;
   }

void
SgFile::set_testingLevel ( int testingLevel )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_testingLevel = testingLevel;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_preinit_il () const
   {
     assert (this != NULL);
     return p_preinit_il;
   }

void
SgFile::set_preinit_il ( bool preinit_il )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_preinit_il = preinit_il;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_enable_cp_backend () const
   {
     assert (this != NULL);
     return p_enable_cp_backend;
   }

void
SgFile::set_enable_cp_backend ( bool enable_cp_backend )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_enable_cp_backend = enable_cp_backend;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_outputGrammarTreeFiles () const
   {
     assert (this != NULL);
     return p_outputGrammarTreeFiles;
   }

void
SgFile::set_outputGrammarTreeFiles ( bool outputGrammarTreeFiles )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputGrammarTreeFiles = outputGrammarTreeFiles;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_outputGrammarTreeFilesForHeaderFiles () const
   {
     assert (this != NULL);
     return p_outputGrammarTreeFilesForHeaderFiles;
   }

void
SgFile::set_outputGrammarTreeFilesForHeaderFiles ( bool outputGrammarTreeFilesForHeaderFiles )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputGrammarTreeFilesForHeaderFiles = outputGrammarTreeFilesForHeaderFiles;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_outputGrammarTreeFilesForEDG () const
   {
     assert (this != NULL);
     return p_outputGrammarTreeFilesForEDG;
   }

void
SgFile::set_outputGrammarTreeFilesForEDG ( bool outputGrammarTreeFilesForEDG )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputGrammarTreeFilesForEDG = outputGrammarTreeFilesForEDG;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_markGeneratedFiles () const
   {
     assert (this != NULL);
     return p_markGeneratedFiles;
   }

void
SgFile::set_markGeneratedFiles ( bool markGeneratedFiles )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_markGeneratedFiles = markGeneratedFiles;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_negative_test () const
   {
     assert (this != NULL);
     return p_negative_test;
   }

void
SgFile::set_negative_test ( bool negative_test )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_negative_test = negative_test;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_strict_language_handling () const
   {
     assert (this != NULL);
     return p_strict_language_handling;
   }

void
SgFile::set_strict_language_handling ( bool strict_language_handling )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_strict_language_handling = strict_language_handling;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgFile::get_embedColorCodesInGeneratedCode () const
   {
     assert (this != NULL);
     return p_embedColorCodesInGeneratedCode;
   }

void
SgFile::set_embedColorCodesInGeneratedCode ( int embedColorCodesInGeneratedCode )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_embedColorCodesInGeneratedCode = embedColorCodesInGeneratedCode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgFile::get_generateSourcePositionCodes () const
   {
     assert (this != NULL);
     return p_generateSourcePositionCodes;
   }

void
SgFile::set_generateSourcePositionCodes ( int generateSourcePositionCodes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_generateSourcePositionCodes = generateSourcePositionCodes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesCppFileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesCppFileExtension;
   }

void
SgFile::set_sourceFileUsesCppFileExtension ( bool sourceFileUsesCppFileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesCppFileExtension = sourceFileUsesCppFileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesFortranFileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesFortranFileExtension;
   }

void
SgFile::set_sourceFileUsesFortranFileExtension ( bool sourceFileUsesFortranFileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesFortranFileExtension = sourceFileUsesFortranFileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesFortran77FileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesFortran77FileExtension;
   }

void
SgFile::set_sourceFileUsesFortran77FileExtension ( bool sourceFileUsesFortran77FileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesFortran77FileExtension = sourceFileUsesFortran77FileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesFortran90FileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesFortran90FileExtension;
   }

void
SgFile::set_sourceFileUsesFortran90FileExtension ( bool sourceFileUsesFortran90FileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesFortran90FileExtension = sourceFileUsesFortran90FileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesFortran95FileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesFortran95FileExtension;
   }

void
SgFile::set_sourceFileUsesFortran95FileExtension ( bool sourceFileUsesFortran95FileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesFortran95FileExtension = sourceFileUsesFortran95FileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFile::get_sourceFileUsesFortran2003FileExtension () const
   {
     assert (this != NULL);
     return p_sourceFileUsesFortran2003FileExtension;
   }

void
SgFile::set_sourceFileUsesFortran2003FileExtension ( bool sourceFileUsesFortran2003FileExtension )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileUsesFortran2003FileExtension = sourceFileUsesFortran2003FileExtension;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFile* 
SgFile::get_binaryFile () const
   {
     assert (this != NULL);
     return p_binaryFile;
   }

void
SgFile::set_binaryFile ( SgFile* binaryFile )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_binaryFile != NULL && binaryFile != NULL && p_binaryFile != binaryFile)
        {
          printf ("Warning: binaryFile = %p overwriting valid pointer p_binaryFile = %p \n",binaryFile,p_binaryFile);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_binaryFile != NULL && binaryFile != NULL && p_binaryFile != binaryFile) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_binaryFile = binaryFile;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 8972 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

// void unparsestdout();
// void unparse(std::ostream&);

//! Declaration of space for static variables
//static int SgFile::p_defaultNumberOfCommandLineArguments = 0;
//static char** SgFile::p_defaultCommandLineArgumentList   = NULL;

//! Function prototype of EDG function to set call back function
void set_sage_transform_function(void (*f)(SgFile *));
void set_sage_edg_AST_display_function(void (*f)(SgFile *));
int edg_main(int, char *[], SgFile & sageFile );


#if 0
int openFortranParser_main(int, char *[], SgFile & sageFile );

// DQ (8/12/2007): Declare this locally for now and later put it into the Fortran support directly
int
openFortranParser_main(int numberOfArgs, char* commandline[], SgFile & sourceFile )
   {
     printf ("Inside of openFortranParser_main(): numberOfArgs = %d \n",numberOfArgs);

     SgGlobal* globalScope = sourceFile.get_globalScope();
     ROSE_ASSERT(globalScope != NULL);

  // printf ("Global scope = %p number of declarations = %zu \n",globalScope,globalScope->get_declarations().size());
  // sourceFile.display("In openFortranParser");

     printf ("\nCall to Java-based LANL's OpenFortranParser project not implemented \n\n");

     return 0;
   }
#else
// This is the "C" function implemented in:
//    ROSE/src/frontend/OpenFortranParser_SAGE_Connection/openFortranParser_main.c
// This function calls the Java JVM to load the Java implemented parser (written 
// using ANTLR, a parser generator).
extern "C" int openFortranParser_main(int argc, char **argv );

// This is how we pass the pointer to the SgFile created in ROSE before the Open 
// Fortran Parser is called to the Open Fortran Parser.  In the case of C/C++ using
// EDG the SgFile is passed through the edg_main() function, but not so with the 
// Open Fortran Parser's openFortranParser_main() function API.  So we use this
// global variable to pass the SgFile (so that the parser c_action functions can
// build the Fotran AST using the existing SgFile.
extern SgFile* OpenFortranParser_globalFilePointer;

#endif


#if 0
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgFile::get_file_info(void) const
   {
  // DQ (1/18/2006): Added function to be match virtual function on SgNode
  // (so that the SgFile's Sg_File_Info object could be accessed).
     return p_fileInfo;
   }
#endif

Sg_File_Info*
SgFile::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgFile::set_file_info( Sg_File_Info* fileinfo )
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode 
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     set_startOfConstruct(fileinfo);
   }

std::string
SgFile::getFileName ()
   {
  // Get the filename from the Sage III file object

  // ROSE_ASSERT(get_fileInfo() != NULL);

     SgScopeStatement *globalScope = (SgScopeStatement *)(&(root()));
     ROSE_ASSERT (globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
     ROSE_ASSERT (fileInfo != NULL);
     std::string fileName = fileInfo->get_filenameString();
     return fileName;
   }

// function prototype
ROSEAttributesListPtr getPreprocessorDirectives( char *fileName);

// DQ (2/3/2004): Debugging segfault in use of il_header within ROSE
// #include "sageCommonSourceHeader.h"
// extern an_il_header il_header;

void
SgFile::setupSourceFilename ( const vector<string>& argv )
   {
  // DQ (4/21/2006): New version of source file name handling (set the source file name early)
     Rose_STL_Container<string> fileList = CommandlineProcessing::generateSourceFilenames(argv);
     if (!fileList.empty())
        {
          ROSE_ASSERT(fileList.size() == 1);

       // DQ (8/31/2006): Convert the source file to have a path if it does not already
       // p_sourceFileNameWithPath    = *(fileList.begin());
          string sourceFilename = *(fileList.begin());

       // sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename);
          sourceFilename = StringUtility::getAbsolutePathFromRelativePath(sourceFilename, true);

          p_sourceFileNameWithPath = sourceFilename;

       // printf ("In SgFile::setupSourceFilename(int,char**): p_sourceFileNameWithPath = %s \n",p_sourceFileNameWithPath.c_str());

       // This should be an absolute path
          string targetSubstring = "/";
       // if (sourceFilename.substr(0,targetSubstring.size()) != targetSubstring)
       //      printf ("@@@@@@@@@@@@@@@@@@@@ In SgFile::setupSourceFilename(int,char**): sourceFilename = %s @@@@@@@@@@@@@@@@@@@@\n",sourceFilename.c_str());
       // ROSE_ASSERT(sourceFilename.substr(0,targetSubstring.size()) == targetSubstring);

       // Rama: 12/06/06: Fixup for problem with file names.  
	    // Made changes to this file and string utilities function getAbsolutePathFromRelativePath by cloning it with name getAbsolutePathFromRelativePathWithErrors
	    // Also refer to script that tests -- reasonably exhaustively -- to various combinarions of input files.

          if (sourceFilename.substr(0,targetSubstring.size()) != targetSubstring)
               printf ("sourceFilename encountered an error in filename\n");

       // DQ (11/29/2006): Even if this is C mode, we have to define the __cplusplus macro 
       // is we detect we are processing a source file using the a C++ filename extension.
          string filenameExtension = StringUtility::fileNameSuffix(sourceFilename);
       // if (StringUtility::isCppFileNameSuffix(filenameExtension) == true)
          if (CommandlineProcessing::isCppFileNameSuffix(filenameExtension) == true)
             {
            // This is a C++ file (so define __cplusplus, just like GNU gcc would)
            // set_requires_cplusplus_macro(true);
               set_sourceFileUsesCppFileExtension(true);
             }
            else
             {
            // This a not a C++ file (assume it is a C file and don't define the __cplusplus macro, just like GNU gcc would)
               set_sourceFileUsesCppFileExtension(false);
             }

          p_sourceFileNameWithoutPath = ROSE::stripPathFromFileName(p_sourceFileNameWithPath.c_str());
        }
       else
        {
       // ROSE_ASSERT (p_numberOfSourceFileNames == 0);
          ROSE_ASSERT (p_sourceFileNameWithPath.empty() == true);
       // If no source code file name was found then likely this is a link command
       // using the C++ compiler.  In this case skip the EDG processing.
          set_disable_edg_backend(true);
       // printf ("No source file found on command line, assuming to be linker command line \n");
        }

  // Keep the filename stored in the Sg_File_Info consistant.  Later we will want to remove this redundency
  // The reason we have the Sg_File_Info object is so that we can easily support filename matching based on
  // the integer values instead of string comparisions.
     get_file_info()->set_filenameString(p_sourceFileNameWithPath);
   }

void SgFile::doSetupForConstructor(const vector<string>& argv, int& errorCode, int fileNameIndex, SgProject* project) {

  // DQ (4/21/2006): I think we can now assert this! This is an unused function parameter!
     ROSE_ASSERT(fileNameIndex == 0);

  // DQ (5/9/2007): Moved this call down to after where the file name is available so that we could include the filename in the label.
  // DQ (7/6/2005): Introduce tracking of performance of ROSE.
  // TimingPerformance timer ("AST SgFile Constructor:");

  // Set the project early in the construction phase so that we can access data in 
  // the parent if needed (useful for template handling but also makes sure the parent is
  // set (and avoids fixup (currently done, but too late in the construction process for 
  // the template support).
     if (project != NULL)
          set_parent(project);

  // DQ (5/9/2007): The initialization() should do this, so this should not be required.
     p_root = NULL;
     p_binaryFile = NULL;

  // initalize all local variables to default values
     initialization();

  // DQ (4/21/2006): Setup the source filename as early as possible
     setupSourceFilename(argv);

  // DQ (5/9/2007): Moved this call from above to where the file name is available so that we could include 
  // the filename in the label.  This helps to identify the performance data with individual files where
  // multiple source files are specificed on the command line.
  // printf ("p_sourceFileNameWithPath = %s \n",p_sourceFileNameWithPath);
     string timerLabel = "AST SgFile Constructor for " + p_sourceFileNameWithPath + ":";
     TimingPerformance timer (timerLabel);

  // Build a DEEP COPY of the input parameters!
     vector<string> local_commandLineArgumentList = argv;

  // Save the commandline as a list of strings (we made a deep copy becasue the "callFrontEnd()" function might change it!
     set_originalCommandLineArgumentList( local_commandLineArgumentList );

  // DQ (5/22/2005): Store the file name index in the SgFile object so that it can figure out 
  // which file name applies to it.  This helps support functions such as "get_filename()" 
  // used elsewhere in Sage III.  Not clear if we really need this!
  // p_fileNameIndex = fileNameIndex;

#if 0
     printf ("In SgFile::SgFile() after initialization: get_skipfinalCompileStep() = %s \n",
          get_skipfinalCompileStep() ? "true" : "false");
#endif

  // printf ("In SgFile constructor: fileNameIndex = %d \n",fileNameIndex);

  // Store the command line for later use with compiling the unparsed code
  // set_NumberOfCommandLineArguments ( argc );
  // set_CommandLineArgumentList ( argv );

     ROSE_ASSERT (p_root != NULL);

  // error checking
     ROSE_ASSERT (argv.size() > 1);

  // printf ("DONE with copy of command line in SgFile constructor! \n");

#if 0
     printf ("In SgFile::SgFile() before callFrontEnd(): get_skipfinalCompileStep() = %s \n",
          get_skipfinalCompileStep() ? "true" : "false");
#endif

#if 1
  // DQ (10/16/2005): Modified to make clear that argc and argv are not modified
  // Call the EDG fron-end to generate the abstract syntax tree
  // int EDG_FrontEndErrorCode = callFrontEnd ( argc, argv, *this, fileNameIndex );
  // int EDG_FrontEndErrorCode = callFrontEnd (  local_commandLineArgumentList, *this, fileNameIndex );
  // int EDG_FrontEndErrorCode = callFrontEnd (  local_commandLineArgumentList );
     int EDG_FrontEndErrorCode = callFrontEnd();

  // Warning from EDG processing are OK but not errors
     ROSE_ASSERT (EDG_FrontEndErrorCode <= 3);

     errorCode = EDG_FrontEndErrorCode;

  // cout << "EDG/SAGE/ROSE Processing DONE! " << endl;
#endif

#if 0
     printf ("In SgFile::SgFile() after callFrontEnd(): get_skipfinalCompileStep() = %s \n",
          get_skipfinalCompileStep() ? "true" : "false");
#endif

  // DQ (5/24/2005): Fixup the file info information at the SgFile and the global scope (SgGlobal)
  // Opps, SgFile object does not have a Sg_File_Info pointer data member.
  // Sg_File_Info* localfileInfo = new Sg_File_Info(p_sourceFileNamesWithPath[fileNameIndex],0,0);
  // ROSE_ASSERT (localfileInfo != NULL);
  // set_file_info(localfileInfo);

  // DQ (10/15/2005): This has not been converted to a C++ string!
  // DQ (5/24/2005): Now fixup the file info's file name in the global scope!
  // printf ("In SgFile::SgFile p_sourceFileNamesWithPath[%d] = %s \n",fileNameIndex,p_sourceFileNamesWithPath[fileNameIndex]);
  // p_root->get_file_info()->set_filename(p_sourceFileNamesWithPath[fileNameIndex]);
     p_root->get_file_info()->set_filenameString(p_sourceFileNameWithPath);

  // DQ (1/18/2006): Set the filename in the SgFile::p_file_info
     ROSE_ASSERT(get_file_info() != NULL);
     get_file_info()->set_filenameString(p_sourceFileNameWithPath);

#if 0
     printf ("In SgFile::SgFile(): get_skipfinalCompileStep() = %s \n",
          get_skipfinalCompileStep() ? "true" : "false");
#endif

  // DQ (5/3/2007): Added assertion.
     ROSE_ASSERT (get_startOfConstruct() != NULL);
}

SgFile::SgFile ( int & argc, char** & argv , int & errorCode, int fileNameIndex, SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     ROSE_ASSERT (argv && argc >= 0);
     doSetupForConstructor(vector<string>(argv, argv + argc), errorCode, fileNameIndex, project);
   }

SgFile::SgFile ( vector<string> & argv , int & errorCode, int fileNameIndex, SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     doSetupForConstructor(argv, errorCode, fileNameIndex, project);
   }

SgFile::SgFile ()
   {
  // Default constructor
  // This builds a valid SgFile which has no global scope
  // we might make it have a global scope just to support 
  // the p_root pointer always being a valid pointer (and 
  // the list of declarations being empty).

  // DQ (1/18/2006): uncommented to test loop processing
  // DQ (9/26/2005): We can try to get this constructor working now
  // printf ("This is the default constructor, use SgFile (argc,argv) instead \n");
  // ROSE_ABORT();

     p_root                         = NULL;
     p_binaryFile                   = NULL;

  // DQ (10/16/2005): Removed as part of cleanup to SgFile
  // p_numberOfCommandLineArguments = 0;
  // p_commandLineArgumentList      = NULL;

     initialization ();

  // DQ (5/15/2006): Note that initialization() builds a SgGlobal but for this 
  // default constructor (used in the copy function) we don't want to build one of these.
  // So delete the SgGlobal just built.
     ROSE_ASSERT(p_root != NULL);
     delete p_root;
     p_root = NULL;

  // DQ (10/16/2005): Removed as part of cleanup to SgFile
  // DQ (7/13/2004): Reset the values based on constructor arguments
  // p_numberOfCommandLineArguments = p_defaultNumberOfCommandLineArguments;
  // p_commandLineArgumentList      = p_defaultCommandLineArgumentList;
   }

// DQ (1/17/2006): Added this (copy constructor) to be explicit 
// and avoid difficult bugs where it is compiler generated.
SgFile::SgFile ( const SgFile & X )
   {
     printf ("Error: calling private copy constructor! \n");
     ROSE_ASSERT(false);
   }


void
SgFile::initialization ()
   {
  /* START: List of variables that need to be initialized!
X         SgGlobal* p_root;
X         int p_numberOfCommandLineArguments;
X         char** p_commandLineArgumentList;
X         int p_defaultNumberOfCommandLineArguments;
X         char** p_defaultCommandLineArgumentList;
X         bool p_verbose;
X         bool p_C_only;
X         bool p_outputGrammarTreeFiles;
X         bool p_outputGrammarTreeFilesForEDG;
X         bool p_skip_transformation;
X         bool p_skip_unparse;
X         bool p_outputGrammarTreeFilesForHeaderFiles;
X         bool p_unparse_includes;
X         bool p_KCC_frontend;
X         bool p_new_frontend;
X         bool p_skipfinalCompileStep;
X         bool p_disable_edg_backend;
X         bool p_disable_sage_backend;
X         int p_testingLevel;
X         bool p_preinit_il;
X         bool p_enable_cp_backend;
X         int p_numberOfSourceFileNames;
X         char** p_sourceFileNamesWithPath;
X         char** p_sourceFileNamesWithoutPath;
X         bool p_skip_buildHigherLevelGrammars;
X         char* p_unparse_output_filename;
X         bool p_travTraceToDOT;
X         bool p_useBackendOnly;
X         bool p_compileOnly;
          string p_savedFrontendCommandLine;
X         ROSEAttributesListContainerPtr p_preprocessorDirectivesAndCommentsList;
     END: List of variables that need to be initialized!
*/


     ROSE_ASSERT(this != NULL);

  // This should use a Sg_File_Info with the correct name (maybe this 
  // should be initialized by "callFrontEnd()")
  // Sg_File_Info* fileInfo = new Sg_File_Info("SgFile file unknown",0,0);

  // DQ (1/17/2006): Initialize the local file info pointer (this was not previously set!)
  // the name will be reset to the file name later in the construction of the SgFile.
  // set_file_info(new Sg_File_Info (*fileInfo));

  // DQ (12/23/3006): Let the fileInfo be initialized with line 1, column 1 (instead of 
  // line 0, column 0). This avoids it failing the test for a valid Sg_File_Info object 
  // later (e.g. in fixupSourcePositionInformation.C).
  // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
  // enforce that the filename is always an absolute path (starting with "/").
  // Sg_File_Info* fileInfo = new Sg_File_Info("SgFile::SgFile",0,0);
  // Sg_File_Info* fileInfo = new Sg_File_Info("",0,0);
     Sg_File_Info* fileInfo = new Sg_File_Info("",1,1);
     ROSE_ASSERT(fileInfo != NULL);

  // set_file_info(fileInfo);
     set_startOfConstruct(fileInfo);
     fileInfo->set_parent(this);
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_file_info() != NULL);

     ROSE_ASSERT (p_root == NULL);
     ROSE_ASSERT (p_binaryFile == NULL);

  // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
  // enforce that the filename is always an absolute path (starting with "/").
  // Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("SgGlobal::SgGlobal",0,0);
     Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("",0,0);
     ROSE_ASSERT (globalScopeFileInfo != NULL);

     p_root = new SgGlobal( globalScopeFileInfo );
     ROSE_ASSERT (p_root != NULL);

#if 0
  // DQ (1/17/2006): Trying to debug NULL SgFile::get_fileInfo() result
     printf ("Printing out Sg_File_Info object %p in SgFile(%p)::initialization() \n",fileInfo,this);
     fileInfo->display("In SgFile::initialization()");
     get_fileInfo()->display("In SgFile::initialization() calling get_fileInfo()");
#endif

  // DQ (2/15/2006): Set the parent of the SgGlobal IR node
     p_root->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/13/2006): Initialize new AstAttributeMechanism pointer (moved from SgNode)
     p_attributeMechanism = NULL;

  // DQ (10/16/2005): Removed as part of cleanup to SgFile
  // DQ (12/6/2003): initialize these here.
  // p_defaultNumberOfCommandLineArguments = 0;
  // p_defaultCommandLineArgumentList      = NULL;

  // DQ (7/13/2004): Not previously initialized (except through constructor preinitialization list)
  // I have removed them from the constructor preinitialization list so that ALL local member data
  // could be set in this inialization function!
  // p_numberOfCommandLineArguments = 0;
  // p_commandLineArgumentList      = NULL;

  // DQ (4/7/2001) Added support for multiple files (save the preprocessor 
  //               directives and comments into the SgFile)
  //               the ROSEAttributesListContainer represents all preprocessor 
  //               declarations and comments from each source file (and its 
  //               corresponding include files) (thus a list of lists of lists 
  //               of cpp directives and comments!!!)

  // At construction this is a NULL pointer, it is updated later after construction of the AST.
     p_preprocessorDirectivesAndCommentsList = NULL; // new ROSEAttributesListContainer();
  // ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList != NULL);
     ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList == NULL);

  // DQ (10/15/2005): Don't have a default for this (use an empty string)!
  // p_unparse_output_filename = "rose_unparse.C";

     p_verbose                 = 0;
  // version                   = false;
  // help                      = false;

  // DQ (7/13/2004): Not previously initialized!
     p_C_only                  = false;
     p_C99_only                = false;

  // DQ (8/11/2007): Added support for Fortran
     p_Fortran_only            = false;
     p_F77_only                = false;
     p_F90_only                = false;
     p_F95_only                = false;
     p_F2003_only              = false;

     p_fixedFormat             = false;
     p_outputFormat            = SgFile::e_unknown_output_format;
     p_fortran_implicit_none   = false;
     p_fortran_openmp          = false;

     p_compileOnly             = false;

  // After higher level ASTs are build optionally apply transformations
     p_skip_transformation     = false;
     p_skip_unparse            = false;
     p_outputGrammarTreeFiles  = false;  // default should be false (set to true while debugging)
     p_outputGrammarTreeFilesForHeaderFiles = false; // default is to skip headers

  // DQ (8/27/2007): Support for alternative langauge code generation (unparsing), useful for testing specific language unparsers.
     p_outputLanguage          = SgFile::e_default_output_language;

  // p_new_unparser            = true;   // by default use the new unparser
     p_unparse_includes        = false;  // by default do NOT unparse include files into the source code
     p_KCC_frontend            = false;

  // Alternatively we can call the new edg frontend to test the edg process
     p_new_frontend            = false;

#if 1
  // The default should be to act like a C++ compiler
     p_skipfinalCompileStep    = false;
#else
     p_skipfinalCompileStep    = true;
#endif

  // controls call to the edg_main (disables all processing
  // and acts like a shell which calls the compiler)
     p_disable_edg_backend     = false;

  // Disable parsing of the EDG program tree into the SAGE program tree
     p_disable_sage_backend    = false;

  // Shorthand form for different levels of testing  (default is -1)
     p_testingLevel            = -1;

  // enable processing specific to templates
     p_preinit_il              = false;
     p_enable_cp_backend       = false;

  // Used to store filenames of input source files
  // p_numberOfSourceFileNames    = 0;

  // DQ (10/15/2005): This is now a C++ string (so we can't set these to NULL)
  // p_sourceFileNamesWithPath    = NULL;
  // p_sourceFileNamesWithoutPath = NULL;
  // currentDirectory             = NULL;

  // Used to trigger building of higher level ASTs
  // p_skip_buildHigherLevelGrammars  = false;

  // Support for faster processing of pdf output (where we likely don't need the pdf output of the the EDG AST)
     p_outputGrammarTreeFilesForEDG = false;

  // initialize p_useBackendOnly data member
     p_useBackendOnly = false;

  // DQ (12/6/2003): initialize this here
     p_travTraceToDOT = false;

  // DQ (6/21/2005): initialize g++ specific template instantiation control flags
     p_no_implicit_templates        = false;
     p_no_implicit_inline_templates = false;

  // DQ (4/19/2006): Added to control comment and directive handling (takes more time to process header files).
     p_collectAllCommentsAndDirectives = false;

  // Added to permit all comments and CPP directives to be skipped (e.g. when unparsing all hearders)
     p_skip_commentsAndDirectives      = false;

  // DQ (9/5/2006): Added mechanism to optionally watermark files generated by ROSE
     p_markGeneratedFiles = false;

  // DQ (9/19/2006): Allow testing of ROSE using input that is expected to fail (return passed if test failed)
     p_negative_test = false;

  // DQ (9/24/2006): Permit optional enforcement of ANSI standards
     p_strict_language_handling = false;

  // DQ (10/31/2006): Output information that can be used to colorize properties of generated code (useful for debugging).
     p_embedColorCodesInGeneratedCode = 0;

  // DQ (10/31/2006): Output separate file containing source position information for highlighting (useful for debugging).
     p_generateSourcePositionCodes = 0;

  // DQ (12/2/2006): This we be used (as in GNU) to set the languge mode (C++ files will turn on C++ language mode 
  // and only ".c" (C files) will turn on C language mode).
     p_sourceFileUsesCppFileExtension = false;

  // DQ (10/19/2007): Added initialization new data member added to support handing of binary AST and source code AST.
     p_binaryFile = NULL;
   }

#if 0
SgFile::~SgFile()
   {
  // This is the highest level of control for the cleanup of memory 
  // allocated as part of the creation of the program tree
#if 1
     delete p_root;
     p_root = NULL;
#endif

  // Not ready to delete this yet
  // delete p_preprocessorDirectivesAndCommentsList;
   }
#endif

SgGlobal &
SgFile::root() ROSE_DEPRECATED_FUNCTION
   {
     assert(p_root != NULL);
     return *p_root;
   }

// DQ (7/19/2005): Added to support better naming of global scope (root is not very clear)
// get_root() set_root() and root() will be depricated.
SgGlobal*
SgFile::get_globalScope() const
   {
  // This variable name will be changed in the future (to globalScope)
     ROSE_ASSERT(p_root != NULL);
     return p_root;
   }

#if 1
// function prototype (not required?)
// int compileOutput ( int & argc, char** & argv );

int
SgFile::compileOutput ( int fileNameIndex, const std::string& compilerName )
   {
  // Compile the output file from the unparing
     vector<string> argv = get_originalCommandLineArgumentList();
     ROSE_ASSERT(!argv.empty());
   
  // DQ (4/21/2006): I think we can now assert this! This is an unused function parameter!
     ROSE_ASSERT(fileNameIndex == 0);

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // error checking
     ROSE_ASSERT (argv.size() > 1);

  // BP : 10/31/2001, strip out any rose options before passing the command line.
     stripRoseCommandLineOptions( argv );

  // DQ (2/12/2004): strip out edg specific options that 
  // would cause an error in the backend compiler.
     stripEdgCommandLineOptions( argv );

  // Call the compile
     int errorCode = compileOutput ( argv, fileNameIndex, compilerName );

  // return the error code from the compilation
     return errorCode;
   }
#endif

// function prototype
// void pdfPrintAbstractSyntaxTreeSage ( SgFile & sageFile, bool writeOutHeaderFiles );

#if 0
void
SgFile::outputPDF ()
   {
  // Output the program tree
     printf ("In SgFile::outputPDF(): Dumping the program tree (AST) to a file \n");

  // Use Markus's new pdf generator
     AstPDFGeneration pdftest;
     pdftest.generateWithinFile(this);
   }
#endif

#if 0
int
SgFile::get_NumberOfCommandLineArguments()
   {
     ROSE_ASSERT (p_numberOfCommandLineArguments > 0);
     return p_numberOfCommandLineArguments;
   }

char**
SgFile::get_CommandLineArgumentList()
   {
     ROSE_ASSERT (p_commandLineArgumentList != NULL);
     return p_commandLineArgumentList;
   }
#endif

#if 0
// These variables are both references and so must be initialized by the constructors
void
SgFile::set_NumberOfCommandLineArguments ( int & n )
   {
     ROSE_ASSERT (n > 0);
     p_numberOfCommandLineArguments = n;
   }

void
SgFile::set_CommandLineArgumentList ( char** & argv )
   {
     ROSE_ASSERT (argv != NULL);
     p_commandLineArgumentList = argv;
   }
#endif

#if 0
// These can be automatically generated (I think)
ROSEAttributesListContainer &
SgFile::get_preprocessorDirectivesAndCommentsList ()
   {
  // assert(i==0);
  // return *p_file;

     ROSE_ASSERT (p_fileList != NULL);
     ROSEAttributesListContainer* targetList =  (*p_preprocessorDirectivesAndCommentsList);
     ROSE_ASSERT (targetList != NULL);

     return *targetList;
   }

void
SgFile::set_preprocessorDirectivesAndCommentsList ( ROSEAttributesListContainer & directivesList )
   {
     ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList != NULL);
     p_preprocessorDirectivesAndCommentsList->push_back(&directivesList);
   }
#endif

#if 0
void
roseDisplayMechanism( SgFile *file )
   {
  // This is the function called by EDG if set using the set_sage_transform_function() 
  // function. We use it to permit the EDG AST to be dumped out to a file.  This
  // step must be done before EDG's AST is deleted and so can't be done when other 
  // Sage/ROSE transformations are done (which is now after the EDG AST is released 
  // under the new (simplified) interface).

  // This function is called at the point where the EDG program tree has already 
  // been parsed into the C++ (modified Sage) grammar but the EDG AST still exists.

#if ROSE_INTERNAL_DEBUG
     if ( file->get_verbose() > 1 )
        {
       // Find out what file we are doing transformations upon
          printf ("In roseDisplayMechanism: globalSourceFileName = %s \n",file->getFileName());
        }
#endif

     if (file->get_outputGrammarTreeFiles() == true)
        {
       // Output the program tree
          printf ("## Dumping the program tree (AST) to a file ## \n");

       // Permit the AST for the  header files to be output
       // as well (this makes the output files very large)
          bool writeOutHeaderFiles = file->get_outputGrammarTreeFilesForHeaderFiles();

       // Added to speed up processing of large files when we just want the SAGE 3 AST
          bool writeOutEDG_AST = file->get_outputGrammarTreeFilesForEDG();

       // Output the source code file (as represented by the EDG AST) as a PDF file (with bookmarks)
       // Allow this to be off by default since the files generated are so large and most often we just want the SAGE 3 AST
          if (writeOutEDG_AST == true)
               pdfPrintAbstractSyntaxTreeEDG ( file, writeOutHeaderFiles );
            else
               printf ("Skipping output of EDG AST in PDF format (EDG output must be turned on explicitly using commandline option) \n");

       // Output the source code file (as represented by the SAGE AST) as a PDF file (with bookmarks)
       // pdfPrintAbstractSyntaxTreeSage ( file, writeOutHeaderFiles );

       // printf ("Exiting after testing pdf file output of source code! \n");
       // ROSE_ABORT();
        }
       else
        {
       // printf ("## Skip dumping the EDG program tree to a file ## \n");
        }
   }
#endif

int
// SgFile::callFrontEnd ( int & argc, char** & argv, SgFile & sageFile, int fileNameIndex )
// SgFile::callFrontEnd ( int & argc, char** & argv )
SgFile::callFrontEnd ()
   {
  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

     int fileNameIndex = 0;

  // DQ (4/21/2006): I think we can now assert this!
     ROSE_ASSERT(fileNameIndex == 0);

  // DQ (7/6/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST Front End Processing (SgFile):");

  // This function processes the command line and calls the EDG frontend.
     int frontendErrorLevel = 0;

  // Build an argc,argv based C style commandline (we might not really need this)
     vector<string> argv = get_originalCommandLineArgumentList();

#if ROSE_INTERNAL_DEBUG
     if (ROSE_DEBUG > 9)
        {
       // Print out the input arguments, so we can set them up internally instead of
       // on the command line (which is driving me nuts)
          for (unsigned int i=0; i < argv.size(); i++)
               printf ("argv[%d] = %s \n",i,argv[i]);
        }
#endif

  // printf ("Inside of SgFile::callFrontEnd(): fileNameIndex = %d \n",fileNameIndex);

  // Save this so that it can be used in the template instantiation phase later.
  // This file is later written into the *.ti file so that the compilation can 
  // be repeated as required to instantiate all function templates.
     std::string translatorCommandLineString = CommandlineProcessing::generateStringFromArgList(argv,false,true);
  // printf ("translatorCommandLineString = %s \n",translatorCommandLineString.c_str());
     set_savedFrontendCommandLine(translatorCommandLineString);

  // display("At TOP of SgFile::callFrontEnd()");

  // local copies of argc and argv variables
  // The purpose of building local copies is to avoid
  // the modification of the command line by SLA
     vector<string> localCopy_argv = argv;
  // printf ("DONE with copy of command line! \n");

  // Process command line options specific to ROSE
  // This leaves all filenames and non-rose specific option in the argv list
     processRoseCommandLineOptions (localCopy_argv);

  // DQ (6/21/2005): Process template specific options so that we can generated 
  // code for the backend compiler (this processing is backend specific).
     processBackendSpecificCommandLineOptions (localCopy_argv);

  // display("AFTER processRoseCommandLineOptions in SgFile::callFrontEnd()");

  // Use ROSE buildCommandLine() function
  // int numberOfCommandLineArguments = 24;
  // char** inputCommandLine = new char* [numberOfCommandLineArguments];
  // ROSE_ASSERT (inputCommandLine != NULL);
     vector<string> inputCommandLine;

  // Build the commandline for EDG
     build_EDG_CommandLine (inputCommandLine,localCopy_argv,fileNameIndex );

  // DQ (10/15/2005): This is now a single C++ string (and not a list)
  // Make sure the list of file names is allocated, even if there are no file names in the list.
  // DQ (1/23/2004): I wish that C++ string objects had been used uniformally through out this code!!!
  // ROSE_ASSERT (get_sourceFileNamesWithoutPath() != NULL);
  // ROSE_ASSERT (get_sourceFileNameWithoutPath().empty() == false);

  // display("AFTER build_EDG_CommandLine in SgFile::callFrontEnd()");

  // Exit if we are to ONLY call the vendor's backend compiler
     if (p_useBackendOnly == true)
          return 0;

     ROSE_ASSERT (p_useBackendOnly == false);

  // DQ (4/21/2006): If we have called the frontend for this SgFile then mark this file to be unparsed.
  // This will cause code to be generated and the compileOutput() function will then set the name of
  // the file that the backend (vendor) compiler will compile to be the the intermediate file. Else it
  // will be set to be the origianl source file.  In the new design, the frontendShell() can be called
  // to generate just the SgProject and SgFile nodes and we can loop over the SgFile objects and call 
  // the frontend separately for each SgFile.  so we have to set the output file name to be compiled
  // late in the processing (at backend compile time since we don't know when or if the frontend will
  // be called for each SgFile).
     set_skip_unparse(false);

#if 0
  // DQ (2/13/2004): This is no longer used!!!

  // This sets up a "call back" function. 
  // This function sets a function pointer internal to SAGE (EDG sage_gen_be.C) which 
  // is called by the sage processing after the EDG AST is translated into the SAGE AST.
  // The alternative would be to have the generation of the EDG PDF file be generated as 
  // an option to EDG, but this would requirre the addition of the PDF headers to EDG which 
  // I would like to avoid (I want to avoid modifying EDG if possible).
  // set_sage_transform_function(roseDisplayMechanism);
  // set_sage_edg_AST_display_function(roseDisplayMechanism);

  // DQ (4/23/2006): Declaration of friend function required here by g++ 4.1.0!
     void alternativeSageEdgInterfaceConstruction( SgFile *file );

     set_sage_transform_function(alternativeSageEdgInterfaceConstruction);
#endif

  // DQ (1/22/2004): As I recall this has a name that really 
  // should be "disable_edg" instead of "disable_edg_backend".
     if ( get_disable_edg_backend() == false )
        {
       // ROSE::new_frontend = true;

       // We can either use the newest EDG frontend separately (useful for debugging) 
       // or the EDG frontend that is included in SAGE III (currently EDG 3.3). 
       // New EDG frontend:
       //      This permits testing with the most up-to-date version of the EDG frontend and 
       //      can be useful in identifing errors or bugs in the SAGE processing (or ROSE itself).
       // EDG frontend used by SAGE III:
       //      The use of this frontend permits the continued processing via ROSE and the 
       //      unparsing of the AST to rebuilt the C++ source code (with transformations if any 
       //      were done).

       // DQ (10/15/2005): This is now a C++ string (and not char* C style string)
       // Make sure that we have generated a proper file name (or move filename
       // processing to processRoseCommandLineOptions()).
       // printf ("Print out the file name to make sure it is processed \n");
       // printf ("     filename = %s \n",get_unparse_output_filename());
       // ROSE_ASSERT (get_unparse_output_filename() != NULL);
       // ROSE_ASSERT (get_unparse_output_filename().empty() == false);

          std::string edgFrontEndCommandLineString;
          if ( get_new_frontend() == true )
             {
            // Use the current version of the EDG frontend from EDG (or any other version)
               printf ("ROSE::new_frontend == true (call edgFrontEnd using unix system() function!) \n");

               if ( get_KCC_frontend() == true )
                  {
                    edgFrontEndCommandLineString = "KCC ";  // -cpfe_only is no longer supported (I think)
                  }
                 else
                  {
                    edgFrontEndCommandLineString = "edgFrontEnd ";
                  }
               edgFrontEndCommandLineString += CommandlineProcessing::generateStringFromArgList(inputCommandLine,true,false);

               if ( get_verbose() > 1 )
                    printf ("edgFrontEndCommandLineString = %s \n",edgFrontEndCommandLineString.c_str());

               system(edgFrontEndCommandLineString.c_str());

            // exit(0);
             }
            else
             {
            // Call the "INTERNAL" EDG Front End used by ROSE (with modified command
            // line input so that ROSE's command line is simplified)!
               if ( get_verbose() > 1 )
                    printf ("Calling edg_main \n");
#if 0
               edgFrontEndCommandLineString = std::string(argv[0]) + std::string(" ") + CommandlineProcessing::generateStringFromArgList(inputCommandLine,false,false);

               if ( get_verbose() > 1 )
                    printf ("edgFrontEndCommandLineString = %s \n",edgFrontEndCommandLineString.c_str());
#endif
            // We need to detect errors in this stage so that we can prevent further processing
            // int edg_errorLevel = edg_main (numberOfCommandLineArguments, inputCommandLine,sageFile);
            // int edg_errorLevel = edg_main (numberOfCommandLineArguments, inputCommandLine,*this);
            // int frontendErrorLevel = 0;

#if 0
               printf ("get_C_only()       = %s \n",(get_C_only() == true) ? "true" : "false");
               printf ("get_C99_only()     = %s \n",(get_C99_only() == true) ? "true" : "false");
               printf ("get_Fortran_only() = %s \n",(get_Fortran_only() == true) ? "true" : "false");
               printf ("get_F77_only()     = %s \n",(get_F77_only() == true) ? "true" : "false");
               printf ("get_F90_only()     = %s \n",(get_F90_only() == true) ? "true" : "false");
               printf ("get_F95_only()     = %s \n",(get_F95_only() == true) ? "true" : "false");
               printf ("get_F2003_only()   = %s \n",(get_F2003_only() == true) ? "true" : "false");
#endif

               if (get_Fortran_only() == true)
                  {
                 // frontendErrorLevel = openFortranParser_main (numberOfCommandLineArguments, inputCommandLine,*this);
                 // printf ("Calling the openFortranParser_main() function (which loads the JVM) \n");

                 // DQ (9/30/2007): Introduce syntax checking on input code (initially we can just call the backend compiler 
                 // and let it report on the syntax errors).  Later we can make this a command line switch to disable (default 
                 // should be true).
                    bool syntaxCheckInputCode = true;
                    if (syntaxCheckInputCode == true)
                       {
                      // DQ (9/30/2007): Introduce tracking of performance of ROSE.
                         TimingPerformance timer ("Fortran syntax checking of input:");

                      // DQ (9/30/2007): For Fortran, we want to run gfortran up front so that we can verify that
                      // the input file is syntax error free.  First lets see what data is avilable to use to check
                      // that we have a fortran file.
                      // display("Before calling OpenFortranParser, what are the values in the SgFile");

                      // DQ (9/30/2007): Call the backend Fortran compiler (typically gfortran) to check the syntax 
                      // of the input program.  When using GNU gfortran, use the "-S" option which means:
                      // "Compile only; do not assemble or link".
                         string syntaxCheckingCommandline = "gfortran -S " + get_sourceFileNameWithPath();

                         printf ("Checking syntax of input program using gfortran: syntaxCheckingCommandline = %s \n",syntaxCheckingCommandline.c_str());

                      // Call the OS with the commandline defined by: syntaxCheckingCommandline
                         int returnValueForSyntaxCheckUsingBackendCompiler = system (syntaxCheckingCommandline.c_str());

                      // Check that there are no errors, I think that warnings are ignored!
                         if (returnValueForSyntaxCheckUsingBackendCompiler != 0)
                            {
                              printf ("Syntax errors detected in input problem ... \n");
                              exit(1);
                            }
                         ROSE_ASSERT(returnValueForSyntaxCheckUsingBackendCompiler == 0);
                       }

                 // edgFrontEndCommandLineString = std::string(argv[0]) + std::string(" --class parser.java.FortranParserActionJNI ") + CommandlineProcessing::generateStringFromArgcArgv(numberOfCommandLineArguments,(const char**)inputCommandLine,false,false);
                 // edgFrontEndCommandLineString = "xxx --class parser.java.FortranParserActionJNI /home/dquinlan/ROSE/NEW_ROSE/developersScratchSpace/Dan/Fortran_tests/test2007_01.f90";
                 // edgFrontEndCommandLineString = "--dump /home/dquinlan/ROSE/NEW_ROSE/developersScratchSpace/Dan/Fortran_tests/test2007_01.f90";
                 // edgFrontEndCommandLineString = std::string(argv[0]) + " --class parser.java.FortranParserActionJNI /home/dquinlan/ROSE/NEW_ROSE/developersScratchSpace/Dan/Fortran_tests/test2007_01.f90";
                    edgFrontEndCommandLineString = std::string(argv[0]) + " --class parser.java.FortranParserActionJNI " + get_sourceFileNameWithPath();

                    if ( get_verbose() > -1 )
                         printf ("numberOfCommandLineArguments = %zu edgFrontEndCommandLineString = %s \n",inputCommandLine.size(),edgFrontEndCommandLineString.c_str());

                    int openFortranParser_argc    = 0;
                    char** openFortranParser_argv = NULL;
                    CommandlineProcessing::generateArgcArgvFromList(CommandlineProcessing::generateArgListFromString(edgFrontEndCommandLineString),openFortranParser_argc,openFortranParser_argv);

                    // printf ("openFortranParser_argc = %d openFortranParser_argv = %s \n",openFortranParser_argc,CommandlineProcessing::generateStringFromArgList(openFortranParser_argv,false,false).c_str());

                 // DQ (8/19/2007): Setup the global pointer used to pass the SgFile to which the Open Fortran Parser 
                 // should attach the AST.  This is a bit ugly, but the parser interface only takes a commandline so it 
                 // would be more ackward to pass a pointer to a C++ object through the commandline or the Java interface.
                    OpenFortranParser_globalFilePointer = const_cast<SgFile*>(this);
                    ROSE_ASSERT(OpenFortranParser_globalFilePointer != NULL);

                    printf ("Calling openFortranParser_main(): OpenFortranParser_globalFilePointer = %p \n",OpenFortranParser_globalFilePointer);

                 // frontendErrorLevel = openFortranParser_main (numberOfCommandLineArguments, inputCommandLine);
                    frontendErrorLevel = openFortranParser_main (openFortranParser_argc, openFortranParser_argv);
                    printf ("DONE: Calling the openFortranParser_main() function (which loads the JVM) \n");

                 // Reset this global pointer after we are done (just to be safe and avoid it being used later and causing strange bugs).
                    OpenFortranParser_globalFilePointer = NULL;
                  }
                 else
                  {
                    edgFrontEndCommandLineString = std::string(argv[0]) + std::string(" ") + CommandlineProcessing::generateStringFromArgList(inputCommandLine,false,false);

                    if ( get_verbose() > 1 )
                         printf ("edgFrontEndCommandLineString = %s \n",edgFrontEndCommandLineString.c_str());

		    int edg_argc = 0;
		    char **edg_argv = NULL;
		    CommandlineProcessing::generateArgcArgvFromList(inputCommandLine, edg_argc, edg_argv);

                    frontendErrorLevel = edg_main (edg_argc, edg_argv, *this);
                  }

               if ( get_verbose() > 1 )
                    printf ("DONE: frontend called (frontendErrorLevel = %d) \n",frontendErrorLevel);

            // If we had any errors reporte by the EDG frontend then quite now
               if (frontendErrorLevel > 3)
                  {
                 // cout << "Errors in EDG Processing: (edg_errorLevel > 3)" << endl;
                    if ( get_verbose() > 1 )
                         printf ("frontendErrorLevel = %d \n",frontendErrorLevel);

                 // DQ (9/22/2006): We need to invert the test result (return code) for 
                 // negative tests (where failure is expected and success is an error).
                    if (get_negative_test() == true)
                       {
                         if ( get_verbose() > 1 )
                            {
                              printf ("(evaluation of frontend results) This is a negative tests, so an error in compilation is a PASS but a successful \n");
                              printf ("compilation is not a FAIL since the faulure might happen in the compilation of the generated code by the vendor compiler. \n");
                            }
                         exit(0);
                       }
                      else
                       {
                      // Exit because there are errors in the input program
                         cout << "Errors in EDG Processing: (frontendErrorLevel > 3)" << endl;
                         ROSE_ABORT();
                       }
                  }

            // if there are warnings report that there are in the verbose mode and continue 
               if (frontendErrorLevel > 0)
                  {
                    if ( get_verbose() >= 1 )
                         cout << "Warnings in Rose parser/IR translation processing! (continuing ...) " << endl;
                  }
             }
        }


  // DQ (4/20/2006): This code was moved from the SgFile constructor so that is would
  // permit the separate construction of the SgProject and call to the front-end cleaner.

  // DQ (5/22/2005): This is a older function with a newer more up-to-date comment on why we have it.
  // This function is a repository for minor AST fixups done as a post-processing step in the 
  // construction of the Sage III AST from the EDG frontend.  In some cases it fixes specific 
  // problems in either EDG or the translation of EDG to Sage III (more the later than the former).
  // In other cases if does post-processing (e.g. setting parent pointers in the AST) can could
  // only done from a more complete global view of the staticly defined AST.  In many cases these
  // AST fixups are not so temporary so the name of the function might change at some point.
  // Notice that all AST fixup is done before attachment of the comments to the AST.
  // temporaryAstFixes(this);
     AstPostProcessing(this);

  // This is set in the unparser now so that we can handle the source file plus all header files
     ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList == NULL);

  // Build the empty list container so that we can just add lists for new files as they are encountered
     p_preprocessorDirectivesAndCommentsList = new ROSEAttributesListContainer();
     ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList != NULL);

  // DQ (4/19/2006): since they can take a while and includes substantial 
  // file I/O we make this optional (selected from the command line).
  // bool collectAllCommentsAndDirectives = get_collectAllCommentsAndDirectives();

  // DQ (4/19/2006): attachAllPreprocessingInfo() is now merged into the attachPreprocessingInfo() 
  // function.
  // DQ (4/6/2006): This is also the correct function to call to use Wave.
  // Markus Kowarschik: attach preprocessor directives to AST nodes
  // This uses the AST traversal and so needs to be done after the 
  // call to temporaryAstFixes(), above.
     if (get_skip_commentsAndDirectives() == false)
        {
          if (get_verbose() > 1)
             {
               printf ("In SgFile::callFrontEnd(): calling attachAllPreprocessingInfo() \n");
             }

          attachPreprocessingInfo(this);

          if (get_verbose() > 1)
             {
               printf ("In SgFile::callFrontEnd(): Done with attachAllPreprocessingInfo() \n");
             }
        }

  // DQ (4/11/2006): This is Lingxiao's work (new patch, since the first and second attempts didn't work) 
  // to support attaching comments from all header files to the AST.  It seems that both 
  // attachPreprocessingInfo() and attachAllPreprocessingInfo() can be run as a mechanism to test 
  // Lingxiao's work on at least the source file.  Note that performance associated with collecting
  // all comments and CPP directives from header files might be a problem.
  // DQ (4/1/2006): This will have to be fixed a little later (next release)
  // DQ (3/29/2006): This is Lingxiao's work to support attaching comments from all header files to the 
  // AST (the previous mechanism only extracted comments from the source file and atted them to the AST, 
  // the part of the AST representing the input source file).
  // attachAllPreprocessingInfo(this,collectAllCommentsAndDirectives);

  // display("At bottom of SgFile::callFrontEnd()");

  // return the error code associated with the call to the C++ Front-end
     return frontendErrorLevel;
   }

void
SgFile::stripRoseCommandLineOptions ( vector<string>& argv )
   {
  // Strip out the rose specific commandline options
  // the assume all other arguments are to be passed onto the C or C++ compiler

     int optionCount = 0;
  // int i = 0;

#if ROSE_INTERNAL_DEBUG
  // printf ("ROSE_DEBUG = %d \n",ROSE_DEBUG);
  // printf ("get_verbose() = %s value = %d \n",(get_verbose() > 1) ? "true" : "false",get_verbose());

     if ( (ROSE_DEBUG >= 1) || (get_verbose() > 2 )
        {
          printf ("In stripRoseCommandLineOptions: List ALL arguments: argc = %zu \n",argv.size());
          for (size_t i=0; i < argv.size(); i++)
               printf ("     argv[%d] = %s \n",i,argv[i]);
        }
#endif

  // Split out the ROSE options first

  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
     optionCount = sla(argv, "-"     , "($)", "(h|help)",1);
     optionCount = sla(argv, "-rose:", "($)", "(h|help)",1);
     optionCount = sla(argv, "-rose:", "($)", "(V|version)", 1);
  // optionCount = sla(argv, "-rose:", "($)", "(v|verbose)",1);
     int integerOption = 0;
     optionCount = sla(argv, "-rose:", "($)^", "(v|verbose)", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)", "(C|C_only)",1);
     optionCount = sla(argv, "-rose:", "($)", "(C99|C99_only)",1);

  // DQ (8/11/2007): Support for Fortran and its different flavors
     optionCount = sla(argv, "-rose:", "($)", "(f|F|Fortran)",1);
     optionCount = sla(argv, "-rose:", "($)", "(f77|F77|Fortran77)",1);
     optionCount = sla(argv, "-rose:", "($)", "(f90|F90|Fortran90)",1);
     optionCount = sla(argv, "-rose:", "($)", "(f95|F95|Fortran95)",1);
     optionCount = sla(argv, "-rose:", "($)", "(f2003|F2003|Fortran2003)",1);

  // DQ (8/27/2007):Support for Fortran language output format
     optionCount = sla(argv, "-rose:", "($)", "(fixedOutput|fixedFormatOutput)",1);
     optionCount = sla(argv, "-rose:", "($)", "(freeOutput|freeFormatOutput)",1);
     optionCount = sla(argv, "-rose:", "($)", "(C_output_language|Cxx_output_language|Fortran_output_language|Promela_output_language)",1);

  // DQ (5/19/2005): The output file name is constructed from the input source name (as I recall)
  // optionCount = sla(argv, "-rose:", "($)^", "(o|output)", &p_unparse_output_filename ,1);

     optionCount = sla(argv, "-rose:", "($)", "(skip_rose)",1);
     optionCount = sla(argv, "-rose:", "($)", "(skip_transformation)",1);
     optionCount = sla(argv, "-rose:", "($)", "(skip_unparse)",1);
     optionCount = sla(argv, "-rose:", "($)", "(unparse_includes)",1);
     optionCount = sla(argv, "-rose:", "($)", "(collectAllCommentsAndDirectives)",1);
     optionCount = sla(argv, "-rose:", "($)", "(skip_commentsAndDirectives)",1);
     optionCount = sla(argv, "-rose:", "($)", "(skipfinalCompileStep)",1);
     optionCount = sla(argv, "-rose:", "($)", "(prelink)",1);
     optionCount = sla(argv, "-"     , "($)", "(ansi)",1);
     optionCount = sla(argv, "-rose:", "($)", "(markGeneratedFiles)",1);
     optionCount = sla(argv, "-rose:", "($)", "(negative_test)",1);
     integerOption = 0;
     optionCount = sla(argv, "-rose:", "($)^", "(embedColorCodesInGeneratedCode)", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)^", "(generateSourcePositionCodes)", &integerOption, 1);

     optionCount = sla(argv, "-rose:", "($)", "(outputGrammarTreeFiles)",1);
     optionCount = sla(argv, "-rose:", "($)", "(outputGrammarTreeFilesForHeaderFiles)",1);
     optionCount = sla(argv, "-rose:", "($)", "(outputGrammarTreeFilesForEDG)",1);
     optionCount = sla(argv, "-rose:", "($)", "(new_unparser)",1);
     optionCount = sla(argv, "-rose:", "($)", "(negative_test)",1);
     optionCount = sla(argv, "-rose:", "($)", "(strict)",1);
     integerOption = 0;
     optionCount = sla(argv, "-rose:", "($)^", "test", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)", "(skipfinalCompileStep)",1);
     optionCount = sla(argv, "-rose:", "($)", "(prelink)",1);

     char* templateInstationationOption = NULL;
     optionCount = sla(argv, "-rose:", "($)^", "(instantiation)",templateInstationationOption,1);

  // DQ (6/17/2005): Added support for AST merging (sharing common parts of the AST most often represented in common header files of a project)
     optionCount = sla(argv, "-rose:", "($)", "(astMerge)",1);
     char* filename = NULL;
     optionCount = sla(argv, "-rose:", "($)^", "(astMergeCommandFile)",filename,1);
     optionCount = sla(argv, "-rose:", "($)^", "(compilationPerformanceFile)",filename,1);


	 //AS(093007) Remove paramaters relating to excluding and include comments and directives
     optionCount = sla(argv, "-rose:", "($)^", "(excludeCommentsAndDirectives)", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)^", "(excludeCommentsAndDirectivesFrom)", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)^", "(includeCommentsAndDirectives)", &integerOption, 1);
     optionCount = sla(argv, "-rose:", "($)^", "(includeCommentsAndDirectivesFrom)", &integerOption, 1);

   }

void
SgFile::stripEdgCommandLineOptions ( vector<string> & argv )
   {
  // Strip out the EDG specific commandline options the assume all
  // other arguments are to be passed onto the C or C++ compiler

#if 0
     if ( (ROSE_DEBUG >= 0) || (get_verbose() > 1) )
        {
          Rose_STL_Container<string> l = CommandlineProcessing::generateArgListFromArgcArgv (argc,argv);
          printf ("In SgFile::stripEdgCommandLineOptions: argv = \n%s \n",StringUtility::listToString(l).c_str());
        }
#endif

  // Split out the EDG options (ignore the returned Rose_STL_Container<string> object)
     CommandlineProcessing::removeArgs (argv,"-edg:");
     CommandlineProcessing::removeArgs (argv,"--edg:");
     CommandlineProcessing::removeArgsWithParameters (argv,"-edg_parameter:");
     CommandlineProcessing::removeArgsWithParameters (argv,"--edg_parameter:");

#if 0
     Rose_STL_Container<string> l = CommandlineProcessing::generateArgListFromArgcArgv (argc,argv);
     printf ("In SgFile::stripEdgCommandLineOptions: argv = \n%s \n",StringUtility::listToString(l).c_str());

     printf ("Exiting in stripEdgCommandLineOptions() \n");
     ROSE_ASSERT (1 == 2);
#endif
   }


void
SgFile::processRoseCommandLineOptions ( vector<string> & argv )
   {
  // Strip out the rose specific command line options
  // then search for all filenames (options without the "-" prefix)
  // the assume all other arguments are to be passed onto the C or C++ compiler

  // int optionCount = 0;
  // int i = 0;

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // Split out the ROSE options first

  // printf ("Before processing ROSE options argc = %d \n",argc);

  //
  // help option (allows alternative -h or -help instead of just -rose:help)
  // This is the only rose options that does not require the "-rose:" prefix
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(h|help)",true) == true ||
          CommandlineProcessing::isOption(argv,"--", "(h|help)",true)    == true ||
          CommandlineProcessing::isOption(argv,"-","(h|help)",true)      == true )
        {
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
       // ROSE::usage(0);
          usage(0);
       // exit(0);
        }
  //
  // version option
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(V|version)",true) == true )
        {
       // function in SAGE III to access version number of EDG
          extern std::string edgVersionString();
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
          printf ("     Using C++ and C frontend from EDG (version %s) internally \n",edgVersionString().c_str());
        }

  //
  // markGeneratedFiles option
  //
     set_markGeneratedFiles(false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(markGeneratedFiles)",true) == true )
        {
       // Optionally mark the generated files with "#define ROSE_GENERATED_CODE"
          set_markGeneratedFiles(true);
        }

  //
  // embedColorCodesInGeneratedCode option
  //
     int integerOptionForEmbedColorCodesInGeneratedCode = 0;
     if ( CommandlineProcessing::isOptionWithParameter(argv,"-rose:","(embedColorCodesInGeneratedCode)",integerOptionForEmbedColorCodesInGeneratedCode,true) == true )
        {
          printf ("Calling set_embedColorCodesInGeneratedCode(%d) \n",integerOptionForEmbedColorCodesInGeneratedCode);
          set_embedColorCodesInGeneratedCode(integerOptionForEmbedColorCodesInGeneratedCode);
        }

  //
  // generateSourcePositionCodes option
  //
     int integerOptionForGenerateSourcePositionCodes = 0;
     if ( CommandlineProcessing::isOptionWithParameter(argv,"-rose:","(generateSourcePositionCodes)",integerOptionForGenerateSourcePositionCodes,true) == true )
        {
          printf ("Calling set_generateSourcePositionCodes(%d) \n",integerOptionForGenerateSourcePositionCodes);
          set_generateSourcePositionCodes(integerOptionForGenerateSourcePositionCodes);
        }

  //
  // verbose option
  //
  // DQ (4/20/2006): This can already be set (to none zero value) if the SgProject was previously build already (see tutorial/selectedFileTranslation.C)
  // ROSE_ASSERT (get_verbose() == 0);
  // if ( CommandlineProcessing::isOption(argv,"-rose:","(v|verbose)",true) )
     int integerOptionForVerbose = 0;
     if ( CommandlineProcessing::isOptionWithParameter(argv,"-rose:","(v|verbose)",integerOptionForVerbose,true) == true )
        {
       // set_verbose(true);
          set_verbose(integerOptionForVerbose);

       // DQ (8/12/2004): The semantics is to set the global concept of a value
       // for verbose to the maximum of that from the individual files.
          if (SgProject::get_verbose() < integerOptionForVerbose)
               SgProject::set_verbose(integerOptionForVerbose);

          if ( SgProject::get_verbose() >= 1 )
               printf ("verbose mode ON \n");
        }
  //
  // C only option (turns on EDG "--c" option and g++ "-xc" option)
  //

  // DQ (12/2/2006): Note that the filename extension could have set this to C++ mode and we only don't want an explicit specification of "-rose:C" to change this.
     set_C_only(false);
     ROSE_ASSERT (get_C_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(C|C_only)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("C only mode ON \n");
          set_C_only(true);
          if (get_sourceFileUsesCppFileExtension() == true)
             {
               printf ("Warning, C++ source file name specificed with explicit -rose:C C language option! (ignoring explicit option to mimic gcc behavior) \n");
               set_C_only(false);
             }
        }
  //
  // C99 only option (turns on EDG "--c" option and g++ "-xc" option)
  //
     set_C99_only(false);
     ROSE_ASSERT (get_C99_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(C99|C99_only)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("C99 mode ON \n");
          set_C99_only(true);
        }

     set_Fortran_only(false);
     ROSE_ASSERT (get_Fortran_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(f|F|Fortran)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran only mode ON \n");
          set_Fortran_only(true);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with explicit -rose:Fortran Fortran language option! \n");
               set_Fortran_only(false);
             }
        }

     set_F77_only(false);
     ROSE_ASSERT (get_F77_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(f77|F77|Fortran77)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran77 only mode ON \n");
          set_F77_only(true);
          set_Fortran_only(true);
          if (get_sourceFileUsesFortran77FileExtension() == false)
             {
               printf ("Warning, Non Fortran77 source file name specificed with explicit -rose:Fortran77 Fortran 77 language option! \n");
               set_F77_only(false);
             }
        }

     set_F90_only(false);
     ROSE_ASSERT (get_F90_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(f90|F90|Fortran90)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran90 only mode ON \n");
          set_F90_only(true);
          set_Fortran_only(true);
          if (get_sourceFileUsesFortran90FileExtension() == false)
             {
               printf ("Warning, Non Fortran90 source file name specificed with explicit -rose:Fortran90 Fortran 90 language option! \n");
               set_F90_only(false);
             }
        }

     set_F95_only(false);
     ROSE_ASSERT (get_F95_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(f95|F95|Fortran95)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran95 only mode ON \n");
          set_F95_only(true);
          set_Fortran_only(true);
          if (get_sourceFileUsesFortran95FileExtension() == false)
             {
               printf ("Warning, Non Fortran95 source file name specificed with explicit -rose:Fortran95 Fortran 95 language option! \n");
               set_F95_only(false);
             }
        }

     set_F2003_only(false);
     ROSE_ASSERT (get_F2003_only() == false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(f2003|F2003|Fortran2003)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran2003 only mode ON \n");
          set_F2003_only(true);
          set_Fortran_only(true);
          if (get_sourceFileUsesFortran2003FileExtension() == false)
             {
               printf ("Warning, Non Fortran2003 source file name specificed with explicit -rose:Fortran2003 Fortran 2003 language option! \n");
               set_F2003_only(false);
             }
        }

  // Fixed format v.s. free format option handling (ROSE defaults to fix or free format, depending on the file extension).
  // F77 default is fixed format, F90 and later default is free format.
  // Fortran source file format options for different compilers(for IBM/XL,Intel,Portland,GNU):
  //     IBM/XL           Intel            Portland     GNU
  //    -qfixed          -fixed           -Mfixed      -ffixed-form
  //    -qfree           -free            -Mfree       -free-form
  // GNU gfortran also supports -fno-fixed-form (we could use this to turn off all fixed form
  // formatting independent of the input source).
     set_fixedFormat(false);
     ROSE_ASSERT (get_fixedFormat() == false);
     if ( CommandlineProcessing::isOption(argv,"-","(ffixed-form|fixed|Mfixed|qfixed)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran fixed format mode explicitly set: ON \n");
          set_fixedFormat(true);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with explicit fixed format code generation (unparser) option! \n");
               set_fixedFormat(false);
             }
        }

     set_freeFormat(false);
     ROSE_ASSERT (get_freeFormat() == false);
     if ( CommandlineProcessing::isOption(argv,"-","(ffree-form|free|Mfree|qfree)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran free format mode explicitly set: ON \n");
          set_freeFormat(true);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with explicit free format code generation (unparser) option! \n");
               set_freeFormat(false);
             }
        }

  // DQ (8/19/2007): This option only controls the output format (unparsing) of Fortran code (free or fixed format).
  // It has no effect on C/C++ code generation (unparsing).
     set_outputFormat(SgFile::e_unknown_output_format);
     ROSE_ASSERT (get_outputFormat() == SgFile::e_unknown_output_format);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(fixedOutput|fixedFormatOutput)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran fixed format output specified \n");
          set_outputFormat(SgFile::e_fixed_form_output_format);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with code generation option: free format! \n");
               ROSE_ASSERT(false);
             }
        }
     if ( CommandlineProcessing::isOption(argv,"-rose:","(freeOutput|freeFormatOutput)",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran free format mode explicitly set: ON \n");
          set_outputFormat(SgFile::e_free_form_output_format);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with code generation option: fixed format! \n");
               ROSE_ASSERT(false);
             }
        }

     set_fortran_implicit_none(false);
     ROSE_ASSERT (get_fortran_implicit_none() == false);
     if ( CommandlineProcessing::isOption(argv,"-","fimplicit_none",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran free format mode explicitly set: ON \n");
          set_fortran_implicit_none(true);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with explicit free format code generation (unparser) option! \n");
               set_fortran_implicit_none(false);
             }
        }

  // DQ (8/19/2007): I have added the option here so that we can start to support OpenMP for Fortran.
  // Allows handling of OpenMP "!$omp" directives in free form and "c$omp", *$omp and "!$omp" directives in fixed form, enables "!$" conditional 
  // compilation sentinels in free form and "c$", "*$" and "!$" sentinels in fixed form and when linking arranges for the OpenMP runtime library 
  // to be linked in. (Not implemented yet).
     set_fortran_openmp(false);
     ROSE_ASSERT (get_fortran_openmp() == false);
     if ( CommandlineProcessing::isOption(argv,"-","fopenmp",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Fortran OpenMP option specified \n");
          set_fortran_openmp(true);
          if (get_sourceFileUsesFortranFileExtension() == false)
             {
               printf ("Warning, Non Fortran source file name specificed with explicit OpenMP option! \n");
               set_fortran_openmp(false);
             }
        }

  //
  // strict ANSI/ISO mode option
  //
  // set_strict_language_handling(false);
     if ( CommandlineProcessing::isOption(argv,"-rose:","(strict)",true) == true )
        {
       // Optionally specify strict language handling
          set_strict_language_handling(true);
        }

  //
  // specify output file option
  //
  // DQ (10/15/2005): There is a valid default value here, but we want to overwrite it!
     std::string stringParameter;
     if ( CommandlineProcessing::isOptionWithParameter(argv,"-rose:","(o|output)",stringParameter,true) == true )
        {
       // printf ("-rose:output %s \n",stringParameter.c_str());
          if (get_unparse_output_filename().empty() == false)
             {
               printf ("Overwriting value in get_unparse_output_filename() = %s \n",get_unparse_output_filename().c_str());
             }

       // DQ (10/15/2005): This is so much simpler!
          p_unparse_output_filename = stringParameter;
        }

  // printf ("After processing -rose:output option argc = %d \n",argc);
  // ROSE_ABORT();

  // DQ (4/20/2006): Added to support fall through option to be supported by user translators.
  //
  // skip_rose option (just call the backend compiler directly): This causes Rose to act identally
  // to the backend compiler (with no creation of the ROSE AST, translation, code generation, etc.).
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(skip_rose)",true) == true )
        {
          printf ("option -rose:skip_rose found \n");
       // set_skip_rose(true);

       // Need these to be set correctly as well
          p_useBackendOnly = true;
       // p_skip_buildHigherLevelGrammars  = true;
          p_disable_edg_backend  = true; // This variable should be called frontend NOT backend???
          p_skip_transformation  = true;
          p_skip_unparse         = true;
          p_skipfinalCompileStep = false;

       // Skip all processing of comments
          set_skip_commentsAndDirectives(true);
          set_collectAllCommentsAndDirectives(false);
        }

  //
  // skip_transformation option: if transformations of the AST check this variable then the 
  // resulting translators can skip the transformatios via this command-line specified option.
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(skip_transformation)",true) == true )
        {
          printf ("option -rose:skip_transformation found \n");
          set_skip_transformation(true);
        }

  //
  // skip_unparse option: if analysis only (without transformatio is required, then this can significantly 
  // improve the performance since it will also skip the backend compilation, as I recall)
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(skip_unparse)",true) == true )
        {
          printf ("option -rose:skip_unparse found \n");
          set_skip_unparse(true);
        }


  // unparser language option
  // DQ (8/27/2007): This option controls the output language (which language unparser is to be used).
  // This allows the code generation of one language to be tested using input of another langauge.  It is 
  // mostly a mechanism to test the unparser in the early stages of their development. Unshared language 
  // constructs are not supported and would have the be translated.  This step does none of this sort of 
  // translation, which might be difficult debendingon the input and output languages selected.
  // Supported options are:
  //      e_default_output_language
  //      e_C_output_language
  //      e_Cxx_output_language
  //      e_Fortran_output_language
  //      e_Promela_output_language
     set_outputLanguage(SgFile::e_default_output_language);
     ROSE_ASSERT (get_outputLanguage() == SgFile::e_default_output_language);
     if ( CommandlineProcessing::isOption(argv,"-rose:","C_output_language",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Use the C language code generator (unparser) \n");
          set_outputLanguage(SgFile::e_C_output_language);
        }
     if ( CommandlineProcessing::isOption(argv,"-rose:","Cxx_output_language",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Use the C++ language code generator (unparser) \n");
          set_outputLanguage(SgFile::e_Cxx_output_language);
        }
     if ( CommandlineProcessing::isOption(argv,"-rose:","Fortran_output_language",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Use the Fortran language code generator (unparser) \n");
          set_outputLanguage(SgFile::e_Fortran_output_language);
        }
     if ( CommandlineProcessing::isOption(argv,"-rose:","Promela_output_language",true) == true )
        {
          if ( SgProject::get_verbose() >= 1 )
               printf ("Use the Promela language code generator (unparser) \n");
          set_outputLanguage(SgFile::e_Promela_output_language);
        }


  //
  // unparse_includes option
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(unparse_includes)",true) == true )
        {
          printf ("option -rose:unparse_includes found \n");
          set_unparse_includes(true);
        }

  //
  // collectAllCommentsAndDirectives option: operates across all files (include files) and significantly slows the compilation.
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(collectAllCommentsAndDirectives)",true) == true )
        {
       // printf ("option -rose:collectAllCommentsAndDirectives found \n");
          set_collectAllCommentsAndDirectives(true);
        }

  //
  // skip_commentsAndDirectives option: if analysis that does not use comments or CPP directives is required 
  // then this option can improve the performance of the compilation.
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(skip_commentsAndDirectives)",true) == true )
        {
          printf ("option -rose:skip_commentsAndDirectives found \n");
          set_skip_commentsAndDirectives(true);

       // If we are skipping comments then we should not be collecting all comments (does not make sense)
          ROSE_ASSERT(get_collectAllCommentsAndDirectives() == false);
       // set_collectAllCommentsAndDirectives(false);
        }

  //
  // internal testing option (for internal use only, these may disappear at some point)
  //
     int integerOption = 0;
     if ( CommandlineProcessing::isOptionWithParameter(argv,"-rose:","test",integerOption,true) == true )
        {
       // printf ("option -rose:test %d found \n",integerOption);
          p_testingLevel = integerOption;
          switch (integerOption)
             {
               case 0 :
                 // transparent mode (does nothing)
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_disable_edg_backend  = true; // This variable should be called frontend NOT backend???
                    p_skip_transformation  = true;
                    p_skip_unparse         = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 1 :
                 // run the KCC front end only (can't unparse or compile output)
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_new_frontend         = true;
                    p_KCC_frontend         = true;
                    p_skip_transformation  = true;
                    p_skip_unparse         = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 2 :
                 // run the newer version of EDG (compiled separately from SAGE) "edgFrontEnd"
                 // (can't unparse or compile output)
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_new_frontend         = true;
                    p_skip_transformation  = true;
                    p_skip_unparse         = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 3 :
                 // run internal (older) version of edg front end (compiled with SAGE)
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_skip_transformation  = true;
                    p_skip_unparse         = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 4 :
                 // all of 3 (above) plus parse into SAGE program tree
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_skip_transformation  = true;
                    p_skip_unparse         = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 5 :
                 // all of 4 (above) plus unparse to generate (untransformed source code)
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_skip_transformation  = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 6 :
                 // all of 4 (above) plus compile generated source code
                 // p_skip_buildHigherLevelGrammars  = true;
                    p_skip_transformation  = true;
                    break;
               case 7 :
                 // all of 5 (above) plus parse into higher level grammars before unparsing
                    p_skip_transformation  = true;
                    p_skipfinalCompileStep = true;
                    break;
               case 8 :
	       // all of 7 (above) plus compile resulting unparsed code (without transformations)
                    p_skip_transformation  = true;
                    break;
               case 9 :
	       // all of 8 (above) plus run transformations before unparsing (do everything)
                    break;
               default:
                 // default mode is an error
                    printf ("Default reached in processing -rose:test # option (use 0-6, input option = %d) \n",integerOption);
                    ROSE_ABORT();
                    break;
             }
        }

#if 0
     printf ("Exiting after test of test option! \n");
     exit (0);
#endif

  // printf ("After processing -rose:test # option argc = %d \n",argc);

  //
  // new_unparser option
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(skipfinalCompileStep)",true) == true )
        {
          printf ("option -rose:skipfinalCompileStep found \n");
          set_skipfinalCompileStep(true);
        }

  //
  // Standard compiler options (allows alternative -E option to just run CPP)
  //
     if ( CommandlineProcessing::isOption(argv,"-","(E)",true) == true )
        {
       // printf ("/* option -E found (just run backend compiler with -E to call CPP) */ \n");
          p_useBackendOnly = true;
       // p_skip_buildHigherLevelGrammars  = true;
          p_disable_edg_backend  = true; // This variable should be called frontend NOT backend???
          p_skip_transformation  = true;
          p_skip_unparse         = true;
          p_skipfinalCompileStep = false;
        }

  //
  // Standard compiler options (allows alternative -H option to just output header file info)
  //
     if ( CommandlineProcessing::isOption(argv,"-","(H)",true) == true )
        {
       // printf ("option -H found (just run backend compiler with -E to call CPP) \n");
          p_useBackendOnly = true;
       // p_skip_buildHigherLevelGrammars  = true;
          p_disable_edg_backend  = true; // This variable should be called frontend NOT backend???
          p_skip_transformation  = true;
          p_skip_unparse         = true;
          p_skipfinalCompileStep = false;
        }

  //
  // negative_test option: allows passing all tests to be treated as an error!
  //
     if ( CommandlineProcessing::isOption(argv,"-rose:","(negative_test)",true) == true )
        {
          printf ("option -rose:negative_test found \n");
          set_negative_test(true);
        }

#if 1
  //
  // We have processed all rose supported command line options.  
  // Anything left in argv now should be a typo or option for either EDG or the C or C++ compiler.
  //
     if ( get_verbose() > 1 )
        {
          cout << "The remaining non-rose options will be passed onto either EDG or the C or C++ the compiler: " << endl;
          for (unsigned int i = 1; i < argv.size(); i++)
                  {
                    cout << "  argv[" << i << "]= " << argv[i] << endl;
                  }
        }

  // debugging aid
  // display("SgFile::processRoseCommandLineOptions()");
#endif
   }




void
SgFile::processBackendSpecificCommandLineOptions ( const vector<string>& argvOrig )
   {
  // DQ (6/21/2005): This function processes commandline options that are specific to the backend 
  // but which the front-end or ROSE should know about.  Examples include template options that
  // would influence how ROSE instatiates or outputs templates in the code generation phase.

  // This function leaves all commandline options in place (for use by the backend)

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  vector<string> argv = argvOrig;

  //
  // -ansi option (fairly general option name across a number of compilers, I think)
  //
     if ( CommandlineProcessing::isOption(argv,"-","ansi",true) == true )
        {
          set_strict_language_handling(true);
        }

  //
  // -fno-implicit-templates option
  //
     p_no_implicit_templates = false;
     if ( CommandlineProcessing::isOption(argv,"-f","no-implicit-templates",true) == true )
        {
       // don't instantiate any inline templates
          printf ("ROSE sees use of -fno-implicit-templates option for use by g++ \n");

       // printf ("ERROR: This g++ specific option is not yet supported \n");
       // ROSE_ASSERT(false);

          p_no_implicit_templates = true;
        }

  //
  // -fno-implicit-inline-templates option
  //
     p_no_implicit_inline_templates = false;
     if ( CommandlineProcessing::isOption(argv,"-f","no-implicit-inline-templates",true) == true )
        {
       // don't instantiate any inline templates
          printf ("ROSE sees use of -fno-implicit-inline-templates option for use by g++ \n");
          p_no_implicit_inline_templates = true;
        }
   }


bool
SgFile::isPrelinkPhase() const
   {
  // This function checks if the "-prelink" option was passed to the ROSE preprocessor
  // It could alternatively just check the commandline and set a flag in the SgFile object.
  // But then there would be a redundent flag in each SgFile object (perhaps the design needs to 
  // be better, using a common base class for commandline options (in both the SgProject and 
  // the SgFile (would not be a new IR node)).

     bool returnValue = false;

  // DQ (5/9/2004): If the parent is not set then this was compiled as a SgFile directly
  // (likely by the rewrite mechanism). IF so it can't be a prelink phase, which is 
  // called only on SgProjects). Not happy with this mechanism!
     if (get_parent() != NULL)
        {
          ROSE_ASSERT ( get_parent() != NULL );
          SgProject* project = isSgProject(get_parent());

          ROSE_ASSERT ( project != NULL );
          returnValue = project->get_prelink();
        }

     return returnValue;

  // Note that project can be false if this is called on an intermediate file 
  // generated by the rewrite system.
  // return (project == NULL) ? false : project->get_prelink();
   }


SgProject*
SgFile::get_project()
   {
  // If the project is a parent of the current SgFile then we find it, else return NULL.

     SgNode* parent = get_parent();

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // ROSE_ASSERT(parent != NULL);

     SgProject* project = NULL;

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // Just return NULL in this case!
     if (parent != NULL)
        {
          project = isSgProject(parent);
          while ( project == NULL && parent->get_parent() != NULL )
             {
               parent = parent->get_parent();
               ROSE_ASSERT(parent != NULL);
               project = isSgProject(parent);
             }
          ROSE_ASSERT ( project != NULL );
        }

     return project;
   }

void
SgFile::build_EDG_CommandLine (
   vector<string> & inputCommandLine, vector<string> & argv, int fileNameIndex )
   {
  // This function builds the command line input for the edg_main (the EDG C++ Front-End)
  // There are numerous options that must be set for different architectures. We can find
  // a more general setup of these options within something like Duct-Tape. In this function
  // argv and argc are the parameters from the user's commandline, and inputCommandLine and
  // numberOfCommandLineArguments are parameters for the new command line that will be build
  // for EDG.

  // Old information recorded here (but not useful any more):
  // Complete Command line required to run ROSE Preprocessor (old version for SUN CC 4.2
  // compiler worked out by Kei Davis at LANL):
  //    ../src/rose -D__CPLUSPLUS -D__STDC__=0 -Dsun -Dsparc -Dunix -D__KCC -D__sun__ 
  //         -D__sparc__ -D__unix__ -D_parc -D__unix -D__SVR4 -D_NO_LONGLONG 
  //         -I/opt/SUNWspro/SC4.2/include/CC/ -I$APlusPlus/include test1.C

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // printf ("##### Inside of SgFile::build_EDG_CommandLine file = %s \n",get_file_info()->get_filenameString().c_str());
  // printf ("##### Inside of SgFile::build_EDG_CommandLine file = %s = %s \n",get_file_info()->get_filenameString().c_str(),get_sourceFileNameWithPath().c_str());
     ROSE_ASSERT(get_file_info()->get_filenameString() == get_sourceFileNameWithPath());

  // ROSE_ASSERT (p_useBackendOnly == false);

  // DQ (4/21/2006): I think we can now assert this!
     ROSE_ASSERT(fileNameIndex == 0);

  // printf ("Inside of SgFile::build_EDG_CommandLine(): fileNameIndex = %d \n",fileNameIndex);

  // BP: (11/26/2001) trying out a new method of figuring out internal compiler definitions
#if defined(CXX_SPEC_DEF)

#if 1
     string configDefsString              = CXX_SPEC_DEF;
     const string Cxx_ConfigIncludeString = CXX_INCLUDE_STRING;
     const string C_ConfigIncludeString   = C_INCLUDE_STRING;

  // Removed reference to __restrict__ so it could be placed into the preinclude vendor specific header file for ROSE.
  // DQ (9/10/2004): Attept to add support for restrict (but I think this just sets it to true, using "-Dxxx=" works)
  // const string roseSpecificDefs    = "-DUSE_RESTRICT_POINTERS_IN_ROSE_TRANSFORMATIONS -DUSE_ROSE -D__restrict__=";
     const string roseSpecificDefs    = "-DUSE_RESTRICT_POINTERS_IN_ROSE_TRANSFORMATIONS -DUSE_ROSE";

     ROSE_ASSERT(configDefsString.empty() == false);
     ROSE_ASSERT(Cxx_ConfigIncludeString.empty() == false);
     ROSE_ASSERT(C_ConfigIncludeString.empty() == false);

  // printf ("configDefsString = %s \n",configDefsString);
#if 0
     printf ("Cxx_ConfigIncludeString = %s \n",Cxx_ConfigIncludeString.c_str());
     printf ("C_ConfigIncludeString   = %s \n",C_ConfigIncludeString.c_str());
#endif

  // AS (03/08/2006) Added support for g++ preincludes
  // Rose_STL_Container<std::string> listOfPreincludes;

  // DQ (12/1/2006): Code added by Andreas (07/03/06) and moved to a new position 
  // so that we could modify the string input from CXX_SPEC_DEF (configDefsString).
     string preinclude_string_target = "-include";
     string preinclude_string;
     for (unsigned int i=1; i < argv.size(); i++)
        {
       // AS (070306) Handle g++ --include directives
          std::string stack_arg(argv[i]);
       // std::cout << "stack arg is: " << stack_arg << std::endl;
          if( stack_arg.find(preinclude_string_target) <= 2)
             {
               i++;
               ROSE_ASSERT(i<argv.size());
               string currentArgument(argv[i]);
             
               string headerSuffix = ".h";
               int jlength = headerSuffix.size();
               int length = currentArgument.size();
               ROSE_ASSERT( length > jlength);
               ROSE_ASSERT( ( currentArgument.compare(length - jlength, jlength, headerSuffix) == 0 ) || CommandlineProcessing::isSourceFilename(currentArgument));

               string sourceFilePath = StringUtility::getPathFromFileName(currentArgument);
               currentArgument = StringUtility::stripPathFromFileName(currentArgument);
               if (sourceFilePath == "" )
                    sourceFilePath = "./";
               sourceFilePath = StringUtility::getAbsolutePathFromRelativePath(sourceFilePath);
               currentArgument = sourceFilePath+"/"+currentArgument;

            // std::cout << "Found preinclude : " << currentArgument << std::endl;

               preinclude_string += " --preinclude " + currentArgument + " ";
             }
        }

     configDefsString += preinclude_string;

     string initString;

  // This is OK since these use the existing memory and not the C language 
  // malloc/free (which would interfere with C++'s new/delete)
     initString = configDefsString;
     initString += " ";
  // initString += Cxx_ConfigIncludeString;

  // DQ (12/2/2006): Both GNU and EDG determin the language mode from the source file name extension. 
  // In ROSE we also require that C files be explicitly specified to use the C language mode. Thus 
  // C++ source files will be treated as C++ even if the C language rules are specified, however they 
  // are restricted to the C subset of C++.
  // bool treatAsCSourceFile = ((get_C_only() == true || get_C99_only() == true) && (get_sourceFileUsesCppFileExtension() == false));
  // if (treatAsCSourceFile == true)

  // Find the C++ sys include path for the rose_edg_required_macros_and_functions.h
     string roseHeaderDirCPP = " --sys_include ";

     Rose_STL_Container<string> internalIncludePathListForHeader = CommandlineProcessing::generateArgListFromString(Cxx_ConfigIncludeString);

     for (Rose_STL_Container<string>::iterator i = internalIncludePathListForHeader.begin(); i != internalIncludePathListForHeader.end(); i++)
        {
          if (i->substr(0,13) == "--sys_include")
             {
               i++;
               if ( ( i != internalIncludePathListForHeader.end() ) && ( (i->substr(0,8) != "--sys_include") || (i->substr(0,2) == "-I") ))
                  {
                    string file = (*i) + "/rose_edg_required_macros_and_functions.h";
                    FILE* testIfFileExist = fopen(file.c_str(),"r");
                    if (testIfFileExist)
                       {
                         roseHeaderDirCPP+=(*i);
                         fclose(testIfFileExist);
                         break;
                       }
                  }
             }
        }

  // Find the C sys include path for the rose_edg_required_macros_and_functions.h
     string roseHeaderDirC = " --sys_include ";
     internalIncludePathListForHeader = CommandlineProcessing::generateArgListFromString(C_ConfigIncludeString);

     for (Rose_STL_Container<string>::iterator i = internalIncludePathListForHeader.begin(); i != internalIncludePathListForHeader.end(); i++)
        {
          if (i->substr(0,13) == "--sys_include")
             {
               i++;
               if ( (i != internalIncludePathListForHeader.end() ) && ( (i->substr(0,13) != "--sys_include") || (i->substr(0,2) == "-I") ))
                  {
                    string file = (*i) + "/rose_edg_required_macros_and_functions.h";
                    FILE* testIfFileExist = fopen(file.c_str(),"r");
                 // std::cout << file << std::endl;
                    if (testIfFileExist)
                       {
                         roseHeaderDirC+=(*i);
                         fclose(testIfFileExist);
                         break;
                       }
                  }
             }
        }


     if (get_C_only() == true || get_C99_only() == true)
        {
       // AS(02/21/07) Add support for the gcc 'nostdinc' and 'nostdinc++' options
          string roseHeaderDir = " --sys_include ";

       // DQ (11/29/2006): if required turn on the use of the __cplusplus macro
       // if (get_requires_cplusplus_macro() == true)
          if (get_sourceFileUsesCppFileExtension() == true)
             {
            // The value here should be 1 to match that of GNU gcc (the C++ standard requires this to be "199711L")
            // initString += " -D__cplusplus=0 ";
               initString += " -D__cplusplus=1 ";
               if ( CommandlineProcessing::isOption(argv,"-","nostdinc",false) == true )
                  {
                    initString+=roseHeaderDirC; 
                 // no standard includes when -nostdinc is specified
                  }
                 else
                  {
                    if ( CommandlineProcessing::isOption(argv,"-","nostdinc++",false) == true )
                       {
                         initString += roseHeaderDirCPP;
                         initString += C_ConfigIncludeString;
                       }
                      else
                       {
                         initString += Cxx_ConfigIncludeString;
                       }
                  }

            // DQ (11/29/2006): Specify C++ mode for handling in rose_edg_required_macros_and_functions.h
               initString += " -DROSE_CPP_MODE=1 ";
             }
            else
             {
               if ( CommandlineProcessing::isOption(argv,"-","nostdinc",false) == true )
                  {
                    initString += roseHeaderDirC; 
                 // no standard includes when -nostdinc is specified
                  }
                 else
                  {
                    initString += C_ConfigIncludeString;
                  }
       
            // DQ (11/29/2006): Specify C mode for handling in rose_edg_required_macros_and_functions.h
               initString += " -DROSE_CPP_MODE=0 ";
             }
        }
       else
        {
          if ( CommandlineProcessing::isOption(argv,"-","nostdinc",false) == true )
             {
               initString+=roseHeaderDirCPP;
            // no standard includes when -nostdinc is specified
             }
            else
             {
               if ( CommandlineProcessing::isOption(argv,"-","nostdinc++",false) == true )
                  {
                    initString += roseHeaderDirCPP;
                    initString += C_ConfigIncludeString;
                  }
                 else
                  {
                    initString += Cxx_ConfigIncludeString;
                  }
             }

       // DQ (11/29/2006): Specify C++ mode for handling in rose_edg_required_macros_and_functions.h
          initString += " -DROSE_CPP_MODE=1 ";
        }

  // AS(02/24/06) Add support for the gcc "-isystem" option (this added a specificed directory 
  // to the start of the system include path).  This maps to the "--sys_include" in EDG.
     string isystem_string_target = "-isystem";
     string isystem_string;
     for (unsigned int i=1; i < argv.size(); i++)
        {
       // AS (070306) Handle g++ --include directives
          std::string stack_arg(argv[i]);
       // std::cout << "stack arg is: " << stack_arg << std::endl;
          if( stack_arg.find(isystem_string_target) <= 2){
              i++;
              ROSE_ASSERT(i<argv.size());
              std::string currentArgument(argv[i]);
              // std::cout << "Current argument " << currentArgument << std::endl; 
            
              currentArgument = StringUtility::getAbsolutePathFromRelativePath(currentArgument);
              isystem_string += " --sys_include " + currentArgument + " ";
          }
     }

     initString += isystem_string;


     initString += " ";
     initString += roseSpecificDefs;

  // DQ (9/17/2006): We should be able to build a version of this code which hands a std::string to StringUtility::splitStringIntoStrings()
  // Separate the string into substrings consistant with the structure of argv command line input
     inputCommandLine.clear();
     StringUtility::splitStringIntoStrings(initString, ' ', inputCommandLine);
#endif

#else
  // Output an error and exit
     cout << "ERROR: The preprocessor definition CXX_SPEC_DEF should have been defined by the configure process!!" << endl;
     ROSE_ABORT();
#endif

  // We only provide options to change the default values!

  // Handle option for use of ROSE as a C compiler instead of C++
  // some C code can not be compiled with a C++ compiler.
     if (get_C_only() == true)
        {
       // Add option to indicate use of C code (not C++) to EDG frontend
          inputCommandLine.push_back("--c");
        }

     if (get_C99_only() == true)
        {
       // Add option to indicate use of C code (not C++) to EDG frontend
          inputCommandLine.push_back("--c99");
        }

     if (get_strict_language_handling() == true)
        {
          inputCommandLine.push_back("--strict");
        }

  //
  // edg_new_frontend option
  //
     if ( CommandlineProcessing::isOption(argv,"-edg:","(new_frontend)",true) == true || (get_new_frontend() == true) )
        {
       // printf ("option -edg:new_frontend found \n");
          set_new_frontend(true);

       // if we use the new EDG frontend (not connected to SAGE) then we can't 
       // generate C++ code so we don't want to call the C++ compiler
          set_skipfinalCompileStep(true);
        }

  //
  // edg_KCC_frontend option
  //
     if ( CommandlineProcessing::isOption(argv,"-edg:","(KCC_frontend)",true) == true || (get_KCC_frontend() == true) )
        {
       // printf ("option -edg:KCC_frontend found \n");
          set_KCC_frontend(true);

       // if we use the new EDG frontend (not connected to SAGE) then we can't 
       // generate C++ code so we don't want to call the C++ compiler
          set_skipfinalCompileStep(true);
        }

  //
  // edg_backend option
  //
     if ( CommandlineProcessing::isOption(argv,"-edg:","(disable_edg_backend)",true) == true || (get_disable_edg_backend() == true) )
        {
       // printf ("option -edg:disable_edg_backend found \n");
          set_disable_edg_backend(true);
        }

#if 0
  //
  // sage_backend option
  //
     if ( CommandlineProcessing::isOption(argv,"-edg:","(disable_edg_backend)",true) == true || (get_disable_edg_backend() == true) )
        {
       // printf ("option -edg:disable_edg_backend found \n");
          set_disable_edg_backend(true);
        }
#endif
#if 0
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of argc
     optionCount = sla(&argc, argv, "-sage:", "($)", "(disable_sage_backend)",1);
     if( optionCount > 0 || (get_disable_sage_backend() == true) == true )
        {
          printf ("option -sage:disable_sage_backend found \n");
          set_disable_sage_backend(true);
          inputCommandLine.push_back("--disable_sage_backend");

       // We we aren't going to process the code through the backend then there is nothing to compile
          set_skipfinalCompileStep(true);
        }

  // printf ("After processing -sage:disable_sage_backend option argc = %d \n",argc);
#endif

#if 0
  //
  // cp_backend option
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
     optionCount = sla(&argc, argv, "-sage:", "($)", "(enable_cp_backend)",1);
     if ( optionCount > 0 || (get_enable_cp_backend() == true) )
        {
       // printf ("option -sage:enable_cp_backend found \n");
          set_enable_cp_backend(true);
          inputCommandLine.push_back("--enable_cp_backend");
        }

  // printf ("After processing -sage:enable_cp_backend option argc = %d \n",argc);

  //
  // preinit_il option
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
     optionCount = sla(&argc, argv, "-sage:", "($)", "(preinit_il)",1);
     if( optionCount > 0 || (get_preinit_il() == true))
        {
          printf ("option -sage:preinit_il found \n");
          set_preinit_il(true);
          inputCommandLine.push_back("--preinit_il");
        }

  // printf ("After processing -sage:preinit_il option argc = %zu \n",argv.size());
#endif

  // ***********************************************************************
  // Now process the -D options, -I options and the filenames so that these 
  // can also be used for the command line passed to the EDG frontend.
  // ***********************************************************************

  // *******************************
  // Add all input macro definitions 
  // *******************************

     vector<string> macroDefineOptions;

  // DQ (9/25/2006): Fixed handling of "-D DEFINE_ERROR_WITH_SPACE -DDEFINE_OK_WITHOUT_SPACE"

  // skip the 0th entry since this is just the name of the program (e.g. rose)
     unsigned int argIndex = 1;
     while (argIndex < argv.size())
        {
       // most options appear as -<option>
       // have to process +w2 (warnings option) on some compilers so include +<option>
          if ( (argv[argIndex][0] == '-') && (argv[argIndex][1] == 'D') )
             {
               unsigned int length = argv[argIndex].size();
            // printf ("Look for include path:  argv[%d] = %s length = %d \n",argIndex,argv[argIndex],length);

               macroDefineOptions.push_back(argv[argIndex]);

            // DQ (9/19/2006): There must be an option string associated with each "-D" option
            // ROSE_ASSERT(length > 2);
               if (length == 2)
                  {
                    printf ("Handling the case of \"-D\" with orphened option (unclear if this is legal) \n");
		    macroDefineOptions.push_back("-D" + argv[argIndex + 1]);
		    ++argIndex;
                  }
             }
          argIndex++;
        }

#if 0
     for (int i=0; i < macroDefineOptionCounter; i++)
        {
          printf ("     macroDefineOptions[%d] = %s \n",i,macroDefineOptions[i]);
        }
#endif

  // Add filenames (of source files) to so that the EDG front end will know what files to process
  inputCommandLine.insert(inputCommandLine.end(), macroDefineOptions.begin(), macroDefineOptions.end());

  // DQ (9/24/2006): Add -D option so that we can know when to turn on vendor compiler specific macros for ANSI/ISO compatability.
     if (get_strict_language_handling() == true)
        {
          inputCommandLine.push_back("-DROSE_STRICT_LANGUAGE_HANDLING");
        }

  // ********************************************************************************************
  // Now add the include paths to the end so that EDG knows where to find header files to process
  // ********************************************************************************************

  // Now add the include paths to the end so that EDG knows where to find head files to process
  // Add all input include paths so that the EDG front end will know where to find headers

     //AS(063006) Changed implementation so that real paths can be found later
     vector<string> includePaths;

  // skip the 0th entry since this is just the name of the program (e.g. rose)
     for (unsigned int i=1; i < argv.size(); i++)
        {
       // most options appear as -<option>
       // have to process +w2 (warnings option) on some compilers so include +<option>
          if ( argv[i].size() >= 2 && (argv[i][0] == '-') && (argv[i][1] == 'I') )
             {
            // int length = strlen(argv[i]);
            // printf ("Look for include path:  argv[%d] = %s length = %d \n",i,argv[i],length);
 
            // AS: Did changes to get absolute path
               std::string includeDirectorySpecifier =  argv[i].substr(2);
               includeDirectorySpecifier = "-I"+StringUtility::getAbsolutePathFromRelativePath(includeDirectorySpecifier );
               includePaths.push_back(includeDirectorySpecifier);
             }
        }

#if 0
     for (int i=0; i < includePathCounter; i++)
        {
          printf ("     includePaths[%d] = %s \n",i,includePaths[i]);
        }
#endif

  // Add the -I definitions to the command line
     inputCommandLine.insert(inputCommandLine.end(), includePaths.begin(), includePaths.end());

  // *******************************************************************
  // Handle general edg options (-xxx)
  // *******************************************************************

  // Strip out all the -edg:xxx options and put them into the edg command line as -xxx

  // Resets modifiedArgc and allocates memory to modifiedArgv
     Rose_STL_Container<string> edgOptionList = CommandlineProcessing::generateOptionList (argv,"-edg:");
     CommandlineProcessing::addListToCommandLine(inputCommandLine,"-",edgOptionList);

  // *******************************************************************
  // Handle general edg options (--xxx)
  // *******************************************************************

  // Strip out all the -edg:xxx options and put them into the edg command line as --xxx

  // Resets modifiedArgc and allocates memory to modifiedArgv
     edgOptionList = CommandlineProcessing::generateOptionList (argv,"--edg:");

  // DQ (8/6/2006): there are a number of options that when specified in their EDG forms 
  // should turn on ROSE mechanisms.  "--edg:c" should turn on C mode in ROSE.
  // printf ("--edg option processing: edgOptionList.size() = %zu \n",edgOptionList.size());
     Rose_STL_Container<string>::iterator i = edgOptionList.begin();
     while (i != edgOptionList.end())
        {
       // fprintf (stderr, "edgOptionList: i = %s \n",i->c_str());
          if (*i == "c" || *i == "old_c")
             {
            // This is the EDG option "--c" obtained from the ROSE "--edg:c" option
               set_C_only(true);
             }
          if (*i == "c99")
             {
            // This is the EDG option "--c99" obtained from the ROSE "--edg:c99" option
               set_C99_only(true);
             }
          i++;
        }

     CommandlineProcessing::addListToCommandLine(inputCommandLine,"--",edgOptionList);

  // *******************************************************************
  // Handle general edg options (-xxx abc)
  // *******************************************************************

  // Handle edg options taking a parameter (string or integer)
     edgOptionList = CommandlineProcessing::generateOptionWithNameParameterList (argv,"-edg_parameter:");
     CommandlineProcessing::addListToCommandLine(inputCommandLine,"-",edgOptionList);

  // *******************************************************************
  // Handle general edg options (--xxx abc)
  // *******************************************************************

  // Handle edg options taking a parameter (string or integer)
     edgOptionList = CommandlineProcessing::generateOptionWithNameParameterList (argv,"--edg_parameter:");
     CommandlineProcessing::addListToCommandLine(inputCommandLine,"--",edgOptionList);

  // *******************************************************************
  // Some EDG options have to turn on mechanims in ROSE
  // *******************************************************************

#if 0
     printf ("Some EDG options have to turn on mechanims in ROSE edgOptionList.size() = %ld \n",edgOptionList.size());
     Rose_STL_Container<string>::iterator j = edgOptionList.begin();
     while (j != edgOptionList.end())
        {
          printf ("edgOptionList: j = %s \n",j->c_str());
          j++;
        }
#endif

  // *******************************************************************
  // Handle specific edg options (-c)
  // *******************************************************************

  //
  // specify compilation only option (new style command line processing)
  //
#if 0
     if ( CommandlineProcessing::isOption(argc,argv,"-","c",false) == true )
        {
          printf ("In build_EDG_CommandLine(): Option -c found (compile only)! \n");
          set_compileOnly(true);
        }
       else
        {
          printf ("In build_EDG_CommandLine(): Option -c not found (compile AND link) adding --auto_instantiation ... \n");
          Rose_STL_Container<string> additionalOptions_a;
          Rose_STL_Container<string> additionalOptions_b;
       // Even though this is not an error to EDG, it does not appear to force instantiation of all templates
          additionalOptions_a.push_back("auto_instantiation");
          CommandlineProcessing::addListToCommandLine(numberOfCommandLineArguments,inputCommandLine,"--",additionalOptions_a);

       // DQ (5/12/05): Set the instantiation mode to "used" for specify what sort of templates to instantiate automatically
       // (generate "-tused" instead of "--instantiate used" since EDG does not seems to accept options containing white space).
          additionalOptions_b.push_back("tused");
          CommandlineProcessing::addListToCommandLine(numberOfCommandLineArguments,inputCommandLine, "-",additionalOptions_b);
        }
#else
     bool autoInstantiation = false;
     if ( CommandlineProcessing::isOption(argv,"-","c",false) == true )
        {
       // printf ("In build_EDG_CommandLine(): Option -c found (compile only)! \n");
          set_compileOnly(true);
        }
       else
        {
       // printf ("In build_EDG_CommandLine(): Option -c not found (compile AND link) set autoInstantiation = true ... \n");
          autoInstantiation = true;
        }

     if (isPrelinkPhase() == true)
        {
          printf ("In build_EDG_CommandLine(): isPrelinkPhase() == true set autoInstantiation = true ... \n");
          autoInstantiation = true;
        }

  // DQ (10/15/2005): Trap out case of C programs where it is an EDG error to specify template instantiation details 
     if (get_C_only() == true ||get_C99_only() == true )
        {
       // printf ("In build_EDG_CommandLine(): compiling input as C program so turn off all template instantiation details \n");
          autoInstantiation = false;
        }

     Rose_STL_Container<string> additionalOptions_a;
     Rose_STL_Container<string> additionalOptions_b;
#if 1
     if (autoInstantiation == true)
        {
       // printf ("In build_EDG_CommandLine(): autoInstantiation = true adding --auto_instantiation -tused ... \n");
       // Even though this is not an error to EDG, it does not appear to force instantiation of all templates (because we need "-tused")
          additionalOptions_a.push_back("auto_instantiation");
          CommandlineProcessing::addListToCommandLine(inputCommandLine,"--",additionalOptions_a);

       // DQ (5/12/05): Set the instantiation mode to "used" for specify what sort of templates to instantiate automatically
       // (generate "-tused" instead of "--instantiate used" since EDG does not seems to accept options containing white space).
          additionalOptions_b.push_back("tused");
          CommandlineProcessing::addListToCommandLine(inputCommandLine, "-",additionalOptions_b);
        }
       else 
        {
       // There are additional cases where we want to force instantiation of all used templates.

       // DQ (5/20/2005): Force instantiation of all used templated unless it is specified to instantiate no templates (explicitly to ROSE)
          bool instantiateAll = false;
          if (get_project() != NULL)
             {
               instantiateAll = (get_project()->get_template_instantiation_mode() == SgProject::e_default) ||
                                (get_project()->get_template_instantiation_mode() == SgProject::e_used)    ||
                                (get_project()->get_template_instantiation_mode() == SgProject::e_all)     ||
                                (get_project()->get_template_instantiation_mode() == SgProject::e_local);
             }

       // printf ("get_project()->get_template_instantiation_mode() = %d \n",get_project()->get_template_instantiation_mode());
       // printf ("In build_EDG_CommandLine(): instantiateAll = %s if true then adding --auto_instantiation -tlocal ... \n",
       //      instantiateAll ? "true" : "false");

       // DQ (6/1/2005):  This is the case of explicitly specifying the complation of C code and
       // not C++ code (EDG reports an error if auto_instantiation is specified for this case).
          if (get_C_only() == true || get_C99_only() == true)
             {
            // printf ("In build_EDG_CommandLine(): compiling input as C program so turn off all template instantiation details \n");
               instantiateAll = false;
             }

          if (instantiateAll == true)
             {
            // printf ("In build_EDG_CommandLine(): autoInstantiation = true adding --auto_instantiation -tlocal ... \n");
               additionalOptions_a.push_back("auto_instantiation");
               CommandlineProcessing::addListToCommandLine(inputCommandLine,"--",additionalOptions_a);

            // additionalOptions_b.push_back("tused");
               additionalOptions_b.push_back("tlocal");
               CommandlineProcessing::addListToCommandLine(inputCommandLine, "-",additionalOptions_b);
             }
        }
#else
  // DQ (5/20/05): Set the instantiation mode to "used" for specify what sort of templates to instantiate automatically
  // (generate "-tused" instead of "--instantiate used" since EDG does not seems to accept options containing white space).
     printf ("In build_EDG_CommandLine(): autoInstantiation = true adding --auto_instantiation -tused ... \n");
     
  // Even though this is not an error to EDG, it does not appear to force instantiation of all templates (because we need "-tused")
     additionalOptions_a.push_back("auto_instantiation");
     CommandlineProcessing::addListToCommandLine(inputCommandLine,"--",additionalOptions_a);

     additionalOptions_b.push_back("tused");
     CommandlineProcessing::addListToCommandLine(inputCommandLine, "-",additionalOptions_b);
#endif

#endif

  // printf ("###### Located source filename = %s \n",get_sourceFileNameWithPath().c_str());
  // ROSE_ASSERT ( get_numberOfSourceFileNames() > 0 );
     ROSE_ASSERT ( get_sourceFileNameWithPath().empty() == false);
     //AS Added support for absolute paths
     Rose_STL_Container<string> fileList;
     std::string sourceFile = get_sourceFileNameWithPath();
     std::string sourceFilePath = StringUtility::getPathFromFileName(sourceFile);
     sourceFile = StringUtility::stripPathFromFileName(sourceFile);
     if(sourceFilePath == "" )
        sourceFilePath = "./";
     sourceFilePath = StringUtility::getAbsolutePathFromRelativePath(sourceFilePath);
     fileList.push_back(sourceFilePath+"/"+sourceFile);
     
     CommandlineProcessing::addListToCommandLine(inputCommandLine,"",fileList);

  // AS Add Support for g++ style preincludes
  // CommandlineProcessing::addListToCommandLine(inputCommandLine,"--preinclude ",listOfPreincludes);

  // ROSE_ASSERT (saveSkipfinalCompileStep == p_skipfinalCompileStep);

  // Debugging (verbose) output
     if ( (get_verbose() > 1) )
        {
          std::string argString = CommandlineProcessing::generateStringFromArgList(inputCommandLine,false,false);
          printf ("In build_EDG_CommandLine(): Input Command Line Arguments: \n%s \n",argString.c_str());

       // Alternative way of displaying the commandline parameters
          for (unsigned int i=0; i < inputCommandLine.size(); i++)
               printf ("inputCommandLine[%u] = %s \n",i,inputCommandLine[i].c_str());
        }

#if 0
     printf ("Exiting at base of build_EDG_CommandLine() \n");
     ROSE_ABORT();
#endif

  // display("at base of build_EDG_CommandLine()");
   }

#if 1

// DQ (2/11/2004): This is still defined in the ROSE/src/command_line_options
void
SgFile::usage ( int status )
   {
     if (status != 0)
          fprintf (stderr,"Try option `--help' for more information.\n");
       else
        {
       // it would be nice to insert the version of ROSE being used (using the VERSION macro)
          fputs(
"\n"
"This ROSE translator provides a means for operating on C, C++, and Fortran\n"
"source code, as well as on x86 and ARM object code.\n"
"\n"
"Usage: rose [OPTION]... FILENAME...\n"
"\n"
"If a long option shows a mandatory argument, it is mandatory for the equivalent\n"
"short option as well, and similarly for optional arguments.\n"
"\n"
"Main operation mode:\n"
"     -rose:(o|output) FILENAME\n"
"                             file containing final unparsed C++ code\n"
"\n"
"Operation modifiers:\n"
"     -rose:C_only, -rose:C   follow C89 standard, disable C++\n"
"     -rose:C99_only, -rose:C99\n"
"                             follow C99 standard, disable C++\n"
"     -rose:Fortran, -rose:F, -rose:f\n"
"                             compile Fortran code, determining version of\n"
"                             Fortran from file suffix)\n"
"     -rose:Fortran77, -rose:F77, -rose:f77\n"
"                             compile Fortran 77 code\n"
"     -rose:Fortran90, -rose:F90, -rose:f90\n"
"                             compile Fortran 90 code\n"
"     -rose:Fortran95, -rose:F95, -rose:f95\n"
"                             compile Fortran 95 code\n"
"     -rose:Fortran2003, -rose:F2003, -rose:f2003\n"
"                             compile Fortran 2003 code\n"
"     -rose:strict            strict enforcement of ANSI/ISO standards\n"
"     -rose:astMerge          merge ASTs from different files\n"
"     -rose:astMergeCommandFile FILE\n"
"                             filename where compiler command lines are stored\n"
"                               for later processing (using AST merge mechanism)\n"
"     -rose:compilationPerformanceFile FILE\n"
"                             filename where compiler performance for internal\n"
"                               phases (in CSV form) is placed for later\n"
"                               processing (using script/graphPerformance)\n"
"     -rose:skip_rose         process command line and call backend directly,\n"
"                               skipping all ROSE-specific processing\n"
"     -rose:skip_transformation\n"
"                             read input file and skip all transformations\n"
"     -rose:skip_unparse      read and process input file but skip generation of\n"
"                               final C++ output file\n"
"     -rose:unparse_includes  unparse all include files into the source file.\n"
"                               This is a backup option for fail-safe processing\n"
"                               of CPP directives (which can be tricky)\n"
"     -rose:collectAllCommentsAndDirectives\n"
"                             store all comments and CPP directives in header\n"
"                               files into the AST\n"
"     -rose:excludeCommentsAndDirectives PATH\n"
"                             provide path to exclude when using the\n"
"                               collectAllCommentsAndDirectives option\n"
"     -rose:excludeCommentsAndDirectivesFrom FILENAME\n"
"                             provide filename to file with paths to exclude\n"
"                               when using the collectAllCommentsAndDirectives\n"
"                               option\n"
"     -rose:includeCommentsAndDirectives PATH\n"
"                             provide path to include when using the\n"
"                               collectAllCommentsAndDirectives option\n"
"     -rose:includeCommentsAndDirectivesFrom FILENAME\n"
"                             provide filename to file with paths to include\n"
"                             when using the collectAllCommentsAndDirectives\n"
"                             option\n"
"     -rose:skip_commentsAndDirectives\n"
"                             ignore all comments and CPP directives (can\n"
"                               generate (unparse) invalid code if not used with\n"
"                               -rose:unparse_includes)\n"
"     -rose:skipfinalCompileStep\n"
"                             read input file and skip all transformations\n"
"     -rose:prelink           activate prelink mechanism to force instantiation\n"
"                               of templates and assignment to files\n"
"     -rose:instantiation XXX control template instantiation\n"
"                             XXX is one of (none, used, all, local)\n"
"\n"
"GNU g++ options recognized:\n"
"     -ansi                   equivalent to -rose:strict\n"
"     -fno-implicit-templates disable output of template instantiations in\n"
"                               generated source\n"
"     -fno-implicit-inline-templates\n"
"                             disable output of inlined template instantiations\n"
"                               in generated source\n"
"\n"
"Informative output:\n"
"     -rose:help, --help, -help, --h\n"
"                             print this help, then exit\n"
"     -rose:version, --version, --V\n"
"                             print ROSE program version number, then exit\n"
"     -rose:markGeneratedFiles\n"
"                             add \"#define ROSE_GENERATED_CODE\" to top of all\n"
"                               generated code\n"
"     -rose:verbose [LEVEL]   verbosely list internal processing (default=0)\n"
"                               Higher values generate more output (can be\n"
"                               applied to individual files and to the project\n"
"                               separately).\n"
"     -rose:embedColorCodesInGeneratedCode LEVEL\n"
"                             embed color codes into generated output for\n"
"                               visualization of highlighted text using tview\n"
"                               tool for constructs specified by LEVEL\n"
"                             LEVEL is one of:\n"
"                               1: missing position information\n"
"                               2: compiler-generated code\n"
"                               3: other code\n"
"     -rose:generateSourcePositionCodes LEVEL\n"
"                             generate separate file of source position\n"
"                               information for highlighting original source\n"
"                               file using tview tool for constructs specified\n"
"                               by LEVEL\n"
"                             LEVEL is one of:\n"
"                               1: statements, preprocessor directives and\n"
"                                  comments\n"
"                               2: expressions\n"
"\n"
"Control EDG frontend processing:\n"
"     -edg:new_frontend       force use of external EDG front end (disables use\n"
"                               of rest of ROSE/SAGE)\n"
"     -edg:KCC_frontend       for use of KCC (with -c option) as new frontend\n"
"                               (must be specified with -edg:new_frontend)\n"
"     -edg:XXX                pass -XXX to EDG front-end\n"
"    --edg:XXX                pass --XXX to EDG front-end\n"
"     -edg_parameter: XXX YYY pass -XXX YYY to EDG front-end\n"
"    --edg_parameter: XXX YYY pass --XXX YYY to EDG front-end\n"
"\n"
"Control code generation:\n"
"     -rose:C_output_language\n"
"                             force use of C as output language (currently\n"
"                               generates C/C++)\n"
"     -rose:Cxx_output_language\n"
"                             force use of C++ as output language\n"
"     -rose:Fortran_output_language\n"
"                             force use of Fortran as output language\n"
"     -rose:Promela_output_language\n"
"                             force use of Promela as output language (not\n"
"                               supported)\n"
"\n"
"Testing Options:\n"
"     -rose:negative_test     test ROSE using input that is expected to fail\n"
"                               (returns 0 if input test failed, else error if\n"
"                               passed)\n"
"     -rose:test LEVEL        limit parts of ROSE which are run\n"
"                             LEVEL is one of:\n"
"                               0: transparent (ROSE translator does nothing)\n"
"                               1: run the KCC front end only (assumes it is in\n"
"                                    path)\n"
"                               2: run the newer version of EDG (compiled\n"
"                                    separately from SAGE) 'edgFrontEnd'\n"
"                                    (see\n"
"                                    src/frontend/EDG/EDG_3.3/src/Makefile.am\n"
"                                    for instructions on how to build EDG\n"
"                                    without SAGE III)\n"
"                               3: run internal (older) version of edg front end\n"
"                                    (deprecated option)\n"
"                               4: same as 3 plus parse into Sage III program\n"
"                                    tree\n"
"                               5: same as 4 plus unparse untransformed source\n"
"                                    code\n"
"                               6: same as 5 plus compile generated source code\n"
"                               7: same as 5 plus build higher level grammars\n"
"                                    before unparsing\n"
"                               8: same as 6 plus run midend (transformations)\n"
"                                    before unparsing\n"
"\n"
"Report bugs to <dquinlan@llnl.gov>.\n"
  , stdout);

  // Obsolete options
  // -sage:sage_backend            have EDG call the sage backend
  // -sage:disable_cp_backend      prevent EDG from calling the cp backend
  // -rose:outputGrammarTreeFiles  write out program tree representation in C++ grammar (useful for internal debugging)
  // -rose:outputGrammarTreeFilesForHeaderFiles (include header files in above option (must be specified after above option)

  // DQ (5/20/2005): More obsolete options
  // -edg:disable_edg_backend      prevent EDG from calling the sage backend 
  // -sage:disable_sage_backend    prevent EDG from calling the sage backend 
  // -sage:enable_cp_backend       have EDG call the cp backend 
  // -sage:preinit_il              do a preinit stage between the front-end and
    }

#if 1
  // Comment this out for now while we test!
     exit (status);
#endif
   }
#endif

 //! get the current directory
string
SgFile::getWorkingDirectory ()
   {
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

     char* returnString = getcwd(currentDirectory,maxPathNameLength - 1);
     ROSE_ASSERT (returnString != NULL);
     currentDirectory[maxPathNameLength - 1] = 0; // Just in case

  // The semantics of the getcwd is that these shuld be the same (see if they are)
  // printf ("In ROSE::getWorkingDirectory: Current directory = %s \n",currentDirectory);
  // printf ("In ROSE::getWorkingDirectory: Current directory = %s \n",returnString);

  // live with the possible memory leak for now
  // delete currentDirectory;
     currentDirectory = NULL;

     return returnString;
   }

 //! get the source directory
string
SgFile::getSourceDirectory ()
   {
#if 0
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

#endif
     printf ("SgFile::getSourceDirectory not implemented! \n");
     ROSE_ABORT();

     return "";
   }


string
SgFile::generateOutputFileName() const
   {
  // DQ (10/16/2005): This function abstracts the generation of an 
  // output file name from the source file name.

     std::string sourceFileName = get_sourceFileNameWithPath();

  // std::string baseFileName    = ROSE::stripPathFromFileName(sourceFileName.c_str());
     std::string baseFileName    = StringUtility::stripPathFromFileName(sourceFileName);

     std::string baseFileNameWithoutSuffix = StringUtility::stripFileSuffixFromFileName(baseFileName);

  // printf ("sourceFileName = %s oldFileName = %s\n",sourceFileName.c_str(),baseFileName.c_str());

     std::string objectFileName;

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

#if 0
     printf ("sourceFileName = %s \n",sourceFileName.c_str());
     printf ("baseFileName = %s \n",baseFileName.c_str());
     printf ("baseFileNameWithoutSuffix = %s \n",baseFileNameWithoutSuffix.c_str());
#endif

#ifndef USE_ORIGINAL_SOURCE_FILE_NAME_IN_PRELINKING

  // DQ (8/12/2007): I think this was part of the prelinker which is not no longer used!
  // printf ("isPrelinkPhase() = %s \n",isPrelinkPhase() ? "true" : "false");
     ROSE_ASSERT(isPrelinkPhase() == false);

     if (isPrelinkPhase() == true)
        {
       // test for leading "rose_" prefix in name (it should be present)
          ROSE_ASSERT(baseFileName.find("rose_") == 0);
       // and remove it since we want the unmodified file name to be used as a name of the object file!
          baseFileName.erase(0,5);

       // test for leading "rose_" prefix in name (it should NOT be present now)
          ROSE_ASSERT(baseFileName.find("rose_") == std::string::npos);
        }
#endif

#if 0
  // DQ (12/5/2006): Make sure that the baseFileName is long enough (fixed small filename test).
  // DQ (12/8/2004): Build the *.o file based on the old name not the new name (what was I thinking!)
  // AS(07/07/04) modified to create .o files for .cpp files also
  // if ( baseFileName.substr(baseFileName.length()-4, baseFileName.length()) == std::string(".cpp") )
     if ( (baseFileName.length() >= 4) && (baseFileName.substr(baseFileName.length()-4, baseFileName.length()) == std::string(".cpp") ) )
        {
          objectFileName = baseFileName.substr(0,baseFileName.length()-4) + std::string(".o");
        }
       else
        {
       // DQ (12/5/2006): Make sure that the baseFileName is long enough (fixed small filename test).
       // DQ (9/10/2004): Added support for ".cc" suffix to handle KOLAH and Kull files
       // if ( baseFileName.substr(baseFileName.length()-3, baseFileName.length()) == std::string(".cc") )
          if ( (baseFileName.length() >= 3) && (baseFileName.substr(baseFileName.length()-3, baseFileName.length()) == std::string(".cc") ) )
             {
               objectFileName = baseFileName.substr(0,baseFileName.length()-3) + std::string(".o");
             }
            else
             {
            // DQ (12/5/2006): Added a lower bound for baseFileName size.
               if (baseFileName.length() >= 2)
                  {
                    objectFileName = baseFileName.substr(0,baseFileName.length()-2) + std::string(".o");
                  }
                 else
                  {
                    printf ("Error: base filename = %s is too short \n",baseFileName.c_str());

                 // Maybe we should allow this to a least be defined if we decide later that files names can be allowed to be this short.
                    objectFileName = baseFileName;
                  }
               ROSE_ASSERT(baseFileName.length() >= 2);
             }
        }
#else
  // DQ (8/12/2007): Newer simpler code, made possible because of better internal support.  
  // This version is also now language independent and so supports the Fortran work.
     objectFileName = baseFileNameWithoutSuffix + ".o";
#endif

  // printf ("At base of SgFile::generateOutputFileName(): objectFileName = %s \n",objectFileName.c_str());
  // display("In SgFile::generateOutputFileName()");

     return objectFileName;
   }


string
SgFile::buildCompilerCommandLineOptions ( vector<string> & argv, int fileNameIndex, const string& compilerName )
   {
  // This function assembles the commandline that will be passed to the backend (vendor) C++/C compiler 
  // (using the new generated source code from the ROSE unparser).

  // DQ (4/21/2006): I think we can now assert this!
     ROSE_ASSERT(fileNameIndex == 0);

  // display("Data in SgFile in buildCompilerCommandLineOptions()");

  // To use rose in place of a C or C++ compiler specify the compiler name using
  //      rose -compiler <originalCompilerName> ...
  // the default value of "originalCompilerName" is "CC"
     std::string compilerNameString = compilerName;

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

#if 0
     printf ("C   compiler       = %s \n",BACKEND_C_COMPILER_NAME_WITH_PATH);
     printf ("C++ compiler       = %s \n",BACKEND_CXX_COMPILER_NAME_WITH_PATH);
     printf ("get_C_only()       = %s \n",(get_C_only() == true) ? "true" : "false");
     printf ("get_C99_only()     = %s \n",(get_C99_only() == true) ? "true" : "false");
     printf ("get_Fortran_only() = %s \n",(get_Fortran_only() == true) ? "true" : "false");
     printf ("get_F77_only()     = %s \n",(get_F77_only() == true) ? "true" : "false");
     printf ("get_F90_only()     = %s \n",(get_F90_only() == true) ? "true" : "false");
     printf ("get_F95_only()     = %s \n",(get_F95_only() == true) ? "true" : "false");
     printf ("get_F2003_only()   = %s \n",(get_F2003_only() == true) ? "true" : "false");
#endif

  // DQ (9/10/2006): We now explicitly store the C and C++ compiler names with 
  // paths so that we can assemble the final commandline to compile the generated 
  // code within ROSE.
  // We need a better way of identifying the C compiler which might not be known
  // ideally it should be specified at configure time so that it can be known in 
  // case the -rose:C_only option is used.
     if (get_C_only() == true || get_C99_only() == true)
        {
       // compilerNameString = "gcc ";
          compilerNameString = BACKEND_C_COMPILER_NAME_WITH_PATH;
        }
       else
        {
          compilerNameString = BACKEND_CXX_COMPILER_NAME_WITH_PATH;
          if (get_Fortran_only() == true)
             {
            // compilerNameString = "f77 ";
               compilerNameString = "gfortran ";
             }
        }

  // printf ("compilerName       = %s \n",compilerName);
  // printf ("compilerNameString = %s \n",compilerNameString.c_str());
     if (compilerNameString.find("icc") != string::npos)
        {
       // This is the Intel C compiler: icc, we need to add the -restrict option
          compilerNameString += " -restrict";
        }

     if (compilerNameString.find("icpc") != string::npos)
        {
       // This is the Intel C++ compiler: icc, we need to add the -restrict option
          compilerNameString += " -restrict";
        }

  // DQ (9/24/2006): Not clear if we want this, if we just skip stripping it out then it will be passed to the backend directly!
  // But we have to add it in the case of "-rose:strict", so we have to add it uniformally and strip it from the input.
     if (get_strict_language_handling() == true)
        {
       // Check if it is appears as "-ansi" on the original commandline
          if ( CommandlineProcessing::isOption(argv,"-","ansi",false) == true )
             {
               printf ("Option -ansi detected on the original commandline \n");
             }
            else
             {
            // This is might be specific to GNU
               compilerNameString += " -ansi ";
             }
        }

  // printf ("Selected compiler = %s \n",compilerNameString.c_str());

  // Since we need to do this often, support is provided in the utility_functions.C
  // and we can simplify this code.
     std::string currentDirectory = getWorkingDirectory();

  // printf ("In buildCompilerCommandLineOptions(): currentDirectory = %s \n",currentDirectory);

  // specify compilation only option (new style command line processing)
     if ( CommandlineProcessing::isOption(argv,"-","c",false) == true )
        {
       // printf ("Option -c found (compile only)! \n");
          set_compileOnly(true);
        }
       else
        {
       // printf ("Option -c not found (compile AND link) ... \n");
       // compilerNameString += " -c ";
        }

  // DQ (3/31/2004): New cleaned up source file handling
     Rose_STL_Container<string> argcArgvList = argv;

  // DQ (9/25/2007): Moved to std::vector from std::list uniformally within ROSE.
  // Remove the first argument (argv[0])
  // argcArgvList.pop_front();
     argcArgvList.erase(argcArgvList.begin());

     SgProject* project = isSgProject(this->get_parent());
     ROSE_ASSERT (project != NULL);
     Rose_STL_Container<string> sourceFilenames = project->get_sourceFileNameList();

  // printf ("sourceFilenames.size() = %zu sourceFilenames = %s \n",sourceFilenames.size(),StringUtility::listToString(sourceFilenames).c_str());

  // DQ (4/20/2006): Modified to only do this when generating code and compiling it
  // Remove the source names from the argcArgvList (translated versions of these will be inserted later)
  // if (get_skip_unparse() == true && get_skipfinalCompileStep() == false)
     if (get_skip_unparse() == false)
        {
          for (Rose_STL_Container<string>::iterator i = sourceFilenames.begin(); i != sourceFilenames.end(); i++)
             {
            // printf ("Removing sourceFilenames list element i = %s \n",(*i).c_str());
#if USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST
#error "USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST is not supported yet"

            // DQ (9/1/2006): Check for use of absolute path and convert filename to absolute path if required
               bool usesAbsolutePath = ((*i)[0] == '/');
               if (usesAbsolutePath == false)
                  {
                    string targetSourceFileToRemove = StringUtility::getAbsolutePathFromRelativePath(*i);
                 // printf ("Converting source file to absolute path to search for it and remove it! targetSourceFileToRemove = %s \n",targetSourceFileToRemove.c_str());
                    argcArgvList.remove(targetSourceFileToRemove);
                  }
                 else
                 {
                 // printf ("This source file used the absolute path so no conversion to absolute path is required! \n");
                    argcArgvList.remove(*i);
                  }
#else
            // DQ (9/25/2007): Moved to std::vector from std::list uniformally within ROSE.
            // printf ("Skipping test for absolute path removing the source filename as it appears in the source file name list file = % \n",i->c_str());
            // argcArgvList.remove(*i);
               argcArgvList.erase(find(argcArgvList.begin(),argcArgvList.end(),*i));
#endif
             }
        }

  // printf ("After removing source file name: argcArgvList.size() = %zu argcArgvList = %s \n",argcArgvList.size(),StringUtility::listToString(argcArgvList).c_str());
  // ROSE_ASSERT(false);

  // AS(080704) Fix so that if user specifies name of -o file rose do not specify another in addition 
     bool  objectNameSpecified = false;
     for (Rose_STL_Container<string>::iterator i = argcArgvList.begin(); i != argcArgvList.end(); i++)
        {
       // printf ("In SgFile::buildCompilerCommandLineOptions(): Loop over commandline arguments i = %s \n",i->c_str());
       // DQ (8/17/2006): This fails for directories such as "ROSE/projects/OpenMP_Translator/tests/npb2.3-omp-c"
       // which can be repeated in the specification of include directives on the commandline.
       // We need to check for the leading characters and nothing else.
       // if (i->find("-o") != std::string::npos)
       // if (i->find("-o ") != std::string::npos)
       // printf ("i->substr(0,2) = %s \n",i->substr(0,2).c_str());
          if (i->substr(0,2) == "-o")
             {
            // DQ (6/12/2005): Added error checking!
               if (objectNameSpecified == true)
                  {
                 // Error: "-o" has been specified twice
                    printf ("Error: \"-o \" has been specified twice \n");
                  }
               ROSE_ASSERT(objectNameSpecified == false);
               objectNameSpecified = true;
             }
        }

  // DQ (4/14/2005): Fixup quoted strings in args fix "-DTEST_STRING_MACRO="Thu Apr 14 08:18:33 PDT 2005" 
  // to be -DTEST_STRING_MACRO=\""Thu Apr 14 08:18:33 PDT 2005"\"  This is a problem in the compilation of
  // a Kull file (version.cc), when the backend is specified as /usr/apps/kull/tools/mpig++-3.4.1.  The
  // problem is that /usr/apps/kull/tools/mpig++-3.4.1 is a wrapper for a shell script /usr/local/bin/mpiCC
  // which does not tend to observe quotes well.  The solution is to add additional escaped quotes.
     for (Rose_STL_Container<string>::iterator i = argcArgvList.begin(); i != argcArgvList.end(); i++)
        {
#if 0
          printf ("sizeof(std::string::size_type) = %d \n",sizeof(std::string::size_type));
          printf ("sizeof(std::string::iterator)  = %d \n",sizeof(std::string::iterator));
          printf ("sizeof(unsigned int)           = %d \n",sizeof(unsigned int));
          printf ("sizeof(unsigned long)          = %d \n",sizeof(unsigned long));
#endif

       // DQ (1/26/2006): Fix for 64 bit support.
       // unsigned int startingQuote = i->find("\"");
          std::string::size_type startingQuote = i->find("\"");
          if (startingQuote != std::string::npos)
             {
            // This string at least has a quote
            // unsigned int endingQuote   = i->rfind("\"");
               std::string::size_type endingQuote   = i->rfind("\"");

            // There should be a double quote on both ends of the string
               ROSE_ASSERT (endingQuote != std::string::npos);

               std::string quotedSubstring = i->substr(startingQuote,endingQuote);
            // printf ("quotedSubstring = %s \n",quotedSubstring.c_str());

               std::string fixedQuotedSubstring = std::string("\\\"") + quotedSubstring + std::string("\\\"");
            // printf ("fixedQuotedSubstring = %s \n",fixedQuotedSubstring.c_str());

            // Now replace the quotedSubstring with the fixedQuotedSubstring
               i->replace(startingQuote,endingQuote,fixedQuotedSubstring);

            // printf ("Modified argument = %s \n",(*i).c_str());
             }
        }

  // Add any options specified by the user (and add space at the end)
     compilerNameString += std::string(" ") + StringUtility::listToString(argcArgvList) + std::string(" ");

  // printf ("buildCompilerCommandLineOptions() #1: compilerNameString = \n%s \n",compilerNameString.c_str());

     std::string sourceFileName = get_sourceFileNameWithPath();

     std::string oldFileNamePathOnly = ROSE::getPathFromFileName(sourceFileName.c_str());
     std::string oldFileName         = ROSE::stripPathFromFileName(sourceFileName.c_str());

#if 0
     printf ("oldFileNamePathOnly = %s \n",oldFileNamePathOnly.c_str());
     printf ("oldFileName         = %s \n",oldFileName.c_str());
#endif

  // DQ (12/8/2004): Add -Ipath option so that source file's directory will be searched for any 
  // possible headers.  This is especially important when we are compiling the generated file
  // located in a different directory!  (When the original source file included header files 
  // in the source directory!)  This is only important when get_useBackendOnly() == false
  // since otherwise the source file is the original source file and the compiler will search 
  // its directory for header files.  Be sure the put the oldFile's source directory last in the 
  // list of -I options so that it will be searched last (preserving the semantics of #include "...").
  // Only add the path if it is a valid name (not an empty name, in which case skip it since the oldFile 
  // is in the current directory (likely a generated file itself; e.g. swig or ROSE applied recursively, etc.)).
  // printf ("oldFileNamePathOnly.length() = %d \n",oldFileNamePathOnly.length());
     if (oldFileNamePathOnly.empty() == false)
          compilerNameString += std::string("-I") + oldFileNamePathOnly + " ";

  // DQ (4/20/2006): This allows the ROSE translator to be just a wrapper for the backend (vendor) compiler.
  // compilerNameString += get_unparse_output_filename();
     if (get_skip_unparse() == false)
        {
       // Generate the name of the ROSE generated source file (instead of the original source file)
       // this file will be compiled by the backend (vendor) compiler.
          ROSE_ASSERT(get_unparse_output_filename().empty() == false);
          compilerNameString += get_unparse_output_filename();
        }
       else
        {
       // In this case the compilerNameString already has the original file name since it was not removed
       // compilerNameString += get_unparse_output_filename();
       // printf ("Case of skip_unparse() == true: original source file name should be present compilerNameString = %s \n",compilerNameString.c_str());
        }
     
     if ( get_compileOnly() == true )
        {
          std::string objectFileName = generateOutputFileName();
       // printf ("In buildCompilerCommandLineOptions: objectNameSpecified = %s objectFileName = %s \n",objectNameSpecified ? "true" : "false",objectFileName.c_str());

       // DQ (7/14/2004): Suggested fix from Andreas
          if (objectNameSpecified == false)
             {
               compilerNameString += " -o " + currentDirectory + "/" + objectFileName;
             }
        }

  // printf ("At base of buildCompilerCommandLineOptions: compilerNameString = \n%s\n",compilerNameString.c_str());

#if 0
     printf ("Exiting at base of buildCompilerCommandLineOptions() ... \n");
     ROSE_ASSERT (false);
#endif

     return compilerNameString;
   }

// Forward declarations of classes used to control and tailor the code generation.
// class UnparseDelegate;
// class UnparseFormatHelp;

// DQ (3/18/2006): Modified interface to allow specification of pointer to user 
// defined UnparseFormatHelp object (to control code generation).
// DQ (8/20/2005): Removed default parameter from extern function declaration
// extern void unparseFile( SgFile&, UnparseDelegate* repl = NULL );
extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp = NULL, UnparseDelegate* unparseDelegate = NULL );

void
// SgFile::unparse ()
SgFile::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
  // DQ (7/12/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST Code Generation (unparsing):");

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // printf ("Inside of SgFile::unparse () ROSE_DEBUG = %d  \n",ROSE_DEBUG);
#if 0
  // DQ (4/21/2006): this has been moved to the backen unparseFile function (as late as possible)

     ROSE_ASSERT (get_unparse_output_filename().empty() == true);

     string outputFilename;
     if (get_skip_unparse() == true)
        {
       // We we are skipping the unparsing then we didn't generate an intermediate 
       // file and so we want to compile the original source file.
          outputFilename = get_sourceFileNameWithPath();
        }
       else
        {
       // If we did unparse an intermediate file then we want to compile that 
       // file instead of the original source file.
          outputFilename = "rose_" + get_sourceFileNameWithoutPath();
        }

     set_unparse_output_filename(outputFilename);

     ROSE_ASSERT (get_unparse_output_filename().empty() == false);

     printf ("Inside of SgFile::unparse(UnparseFormatHelp*,UnparseDelegate*) outputFilename = %s \n",outputFilename.c_str());
#endif

  // Check that these are set and not reset to null!
  // ROSE_ASSERT (p_commandLineArgumentList != NULL);

  // Call the unparser mechanism
  // unparseFile ( *this );
     unparseFile ( this, unparseFormatHelp, unparseDelegate );

  // Check that these are set and not reset to null!
  // ROSE_ASSERT (p_commandLineArgumentList != NULL);
   }

int
SgFile::compileOutput ( vector<string>& argv, int fileNameIndex, const string& compilerNameOrig )
   {
  // DQ (7/12/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST Object Code Generation (compile output):");

  // DQ (4/21/2006): I think we can now assert this!
     ROSE_ASSERT(fileNameIndex == 0);

  // This function does the final compilation of the unparsed file
  // Remaining arguments from the original compile time are used as well
  // as additional arguments added by the buildCompilerCommandLineOptions() function

  // DQ NOTE: This function has to be modified to compile more than 
  //       just one file (as part of the multi-file support)
  // ROSE_ASSERT (sageProject.numberOfFiles() == 1);

  // ******************************************************************************
  // At this point in the control flow (for ROSE) we have returned from the processing 
  // via the EDG frontend (or skipped it if that option was specified).
  // The following has been done or explicitly skipped if such options were specified 
  // on the commandline:
  //    1) The application program has been parsed
  //    2) All AST's have been build (one for each grammar)
  //    3) The transformations have been edited into the C++ AST
  //    4) The C++ AST has been unparsed to form the final output file (all code has 
  //       been generated into a different filename)
  // ******************************************************************************

  // What remains is to run the specified compiler (typically the C++ compiler) using 
  // the generated output file (unparsed and transformed application code).
     int returnValueForRose = 0;

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // BP : 11/13/2001, checking to see that the compiler name is set
     string compilerName = compilerNameOrig + " ";

  // DQ (4/21/2006): Setup the output file name.
  // Rose_STL_Container<string> fileList = CommandlineProcessing::generateSourceFilenames(argc,argv);
  // ROSE_ASSERT (fileList.size() == 1);
  // p_sourceFileNameWithPath    = *(fileList.begin());
  // p_sourceFileNameWithoutPath = ROSE::stripPathFromFileName(p_sourceFileNameWithPath.c_str());

#if 1
  // ROSE_ASSERT (get_unparse_output_filename().empty() == true);

  // DQ (4/21/2006): If we have not set the unparse_output_filename then we could not have called 
  // unparse and we want to compile the original source file as a backup mechanism to generate an 
  // object file.
     if (get_unparse_output_filename().empty() == true)
        {
          ROSE_ASSERT(get_skip_unparse() == true);
          string outputFilename = get_sourceFileNameWithPath();
#if 0
          if (get_skip_unparse() == true)
             {
            // We we are skipping the unparsing then we didn't generate an intermediate 
            // file and so we want to compile the original source file.
               outputFilename = get_sourceFileNameWithPath();
             }
            else
             {
            // If we did unparse an intermediate file then we want to compile that 
            // file instead of the original source file.
               outputFilename = "rose_" + get_sourceFileNameWithoutPath();
             }
#endif
          set_unparse_output_filename(outputFilename);

       // DQ (6/25/2006): I think it is OK to not have an output file name specified.
       // display ("In SgFile::compileOutput(): get_unparse_output_filename().empty() == true");
        }
#endif

     ROSE_ASSERT (get_unparse_output_filename().empty() == false);

  // Now call the compiler that rose is replacing
  // if (get_useBackendOnly() == false)
     if ( SgProject::get_verbose() >= 1 )
          printf ("Now call the backend (vendor's) compiler for file = %s \n",get_unparse_output_filename().c_str());

  // Build the commandline to hand off to the C++/C compiler
     std::string compilerNameString = buildCompilerCommandLineOptions (argv,fileNameIndex, compilerName );
  // ROSE_ASSERT (compilerNameString != NULL);

     int returnValueForCompiler = 0;

  // error checking
  // display("Called from SgFile::compileOutput()");

  // allow conditional skipping of the final compile step for testing ROSE
     if (get_skipfinalCompileStep() == false)
        {
          if ( get_verbose() > 1 )
               printf ("calling system(%s) \n",compilerNameString.c_str());

          returnValueForCompiler = system (compilerNameString.c_str());
        }
       else
        {
          if ( get_verbose() > 1 )
               printf ("COMPILER NOT CALLED: compilerNameString = %s \n",compilerNameString.c_str());

          printf ("Skipped call to backend vendor compiler! \n");
        }

  // DQ (7/20/2006): Catch errors returned from unix "system" function (commonly "out of memory" errors, suggested by Peter and Jeremiah).
     if (returnValueForCompiler < 0)
        {
          perror("Serious Error returned from internal system command");
        }

  // Assemble an exit status that combines the values for ROSE and the C++/C compiler
  // return an exit status which is the boolean OR of the bits from the EDG/SAGE/ROSE and the compile step
     int finalCompiledExitStatus = returnValueForRose | returnValueForCompiler;

  // It is a strange property of the UNIX $status that it does not map uniformally from 
  // the return value of the "exit" command (or "return" statement).  So if the exit 
  // status from the compilation stage is nonzero then we just make the exit status 1
  // (this does seem to be a portable solution).
  // FYI: only the first 8 bits of the exit value are significant (Solaris uses 'exit_value mod 256').
     if (finalCompiledExitStatus != 0)
        {
       // If this it is non-zero then make it 1 to be more clear to external tools (e.g. make)
          finalCompiledExitStatus = 1;
        }

  // DQ (9/19/2006): We need to invert the test result (return code) for 
  // negative tests (where failure is expected and success is an error).
     if (get_negative_test() == true)
        {
          if ( get_verbose() > 1 )
               printf ("This is a negative tests, so an error in compilation is a PASS and successful compilation is a FAIL (vendor compiler return value = %d) \n",returnValueForCompiler);
       // printf ("     (before) finalCompiledExitStatus = %d \n",finalCompiledExitStatus);
          finalCompiledExitStatus = (finalCompiledExitStatus == 0) ? /* error */ 1 : /* success */ 0;
       // printf ("     (after) finalCompiledExitStatus = %d \n",finalCompiledExitStatus);
        }

  // printf ("Program Terminated Normally (exit status = %d)! \n\n\n\n",finalCompiledExitStatus);

     return finalCompiledExitStatus;
   }


void
SgFile::display ( const std::string & label ) const
   {
  // This function prints out the member data values within the object
     printf ("\nIn SgFile::display(%s) \n",label.c_str());

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

     printf ("     p_root is %s pointer \n",(p_root != NULL) ? "VALID" : "NULL");
     ROSE_ASSERT (p_root != NULL);

  // printf ("Output the SgFile::p_file_info object = %p \n",get_file_info());
  // get_file_info()->display("Called from SgFile::display");
     printf ("Output the SgFile::p_startOfConstruct object = %p \n",get_startOfConstruct());
     ROSE_ASSERT (get_startOfConstruct() != NULL);
     get_startOfConstruct()->display("Called from SgFile::display");

     printf ("     p_preprocessorDirectivesAndCommentsList is %s pointer \n",(p_preprocessorDirectivesAndCommentsList != NULL) ? "VALID" : "NULL");
  // ROSE_ASSERT (p_preprocessorDirectivesAndCommentsList != NULL);

  // printf ("     p_unparse_output_filename = %s \n",(p_unparse_output_filename != NULL) ? p_unparse_output_filename : "NULL POINTER");
     printf ("     p_unparse_output_filename = %s \n",p_unparse_output_filename.c_str());

     printf ("     p_verbose                              = %s (value=%d) \n",                      (p_verbose > 1) ? "true" : "false",p_verbose);
     printf ("     p_useBackendOnly                       = %s \n",(p_useBackendOnly                       == true) ? "true" : "false");
     printf ("     p_skip_transformation                  = %s \n",(p_skip_transformation                  == true) ? "true" : "false");
     printf ("     p_skip_unparse                         = %s \n",(p_skip_unparse                         == true) ? "true" : "false");
     printf ("     p_outputGrammarTreeFiles               = %s \n",(p_outputGrammarTreeFiles               == true) ? "true" : "false");
     printf ("     p_outputGrammarTreeFilesForHeaderFiles = %s \n",(p_outputGrammarTreeFilesForHeaderFiles == true) ? "true" : "false");
     printf ("     p_unparse_includes                     = %s \n",(p_unparse_includes                     == true) ? "true" : "false");
     printf ("     p_KCC_frontend                         = %s \n",(p_KCC_frontend                         == true) ? "true" : "false");
     printf ("     p_new_frontend                         = %s \n",(p_new_frontend                         == true) ? "true" : "false");
     printf ("     p_skipfinalCompileStep                 = %s \n",(p_skipfinalCompileStep                 == true) ? "true" : "false");
     printf ("     p_disable_edg_backend                  = %s \n",(p_disable_edg_backend                  == true) ? "true" : "false");
     printf ("     p_disable_sage_backend                 = %s \n",(p_disable_sage_backend                 == true) ? "true" : "false");
     printf ("     p_testingLevel                         = %d \n",p_testingLevel);
     printf ("     p_preinit_il                           = %s \n",(p_preinit_il                           == true) ? "true" : "false");
     printf ("     p_enable_cp_backend                    = %s \n",(p_enable_cp_backend                    == true) ? "true" : "false");
  // printf ("     p_numberOfSourceFileNames              = %d \n",p_numberOfSourceFileNames);

     printf ("     p_C_only()                             = %s \n",(p_C_only == true) ? "true" : "false");
     printf ("     p_C99_only()                           = %s \n",(p_C99_only == true) ? "true" : "false");
     printf ("     p_Fortran_only()                       = %s \n",(p_Fortran_only == true) ? "true" : "false");
     printf ("     p_F77_only()                           = %s \n",(p_F77_only == true) ? "true" : "false");
     printf ("     p_F90_only()                           = %s \n",(p_F90_only == true) ? "true" : "false");
     printf ("     p_F95_only()                           = %s \n",(p_F95_only == true) ? "true" : "false");
     printf ("     p_F2003_only()                         = %s \n",(p_F2003_only == true) ? "true" : "false");

#if 0
     for (int i = 0; i < p_numberOfSourceFileNames; i++)
        {
          printf ("          p_sourceFileNamesWithPath    [%d] = %s \n",
               i,(p_sourceFileNamesWithPath[i] != NULL) ? p_sourceFileNamesWithPath[i] : "NULL STRING");
          printf ("          p_sourceFileNamesWithoutPath [%d] = %s \n",
               i,(p_sourceFileNamesWithoutPath[i] != NULL) ? p_sourceFileNamesWithoutPath[i] : "NULL STRING");
        }
#else
     printf ("     p_sourceFileNameWithPath    = %s \n",p_sourceFileNameWithPath.c_str());
     printf ("     p_sourceFileNameWithoutPath = %s \n",p_sourceFileNameWithoutPath.c_str());
#endif

  // printf ("     p_skip_buildHigherLevelGrammars = %s \n",(p_skip_buildHigherLevelGrammars == true) ? "true" : "false");
     printf ("     p_outputGrammarTreeFilesForEDG  = %s \n",(p_outputGrammarTreeFilesForEDG  == true) ? "true" : "false");

  // DQ (1/17/2006): test this
  // ROSE_ASSERT(get_fileInfo() != NULL);

  // printf ("p_ = %s \n",(p_ == true) ? "true" : "false");
  // printf (" is %s pointer \n",( != NULL) ? "VALID" : "NULL");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFile::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFile::variantT() const {
  return V_SgFile;
}

#if 0
int
SgFile::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FileTag;
   }
#endif

const char*
SgFile::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFile";  
   }

std::string
SgFile::class_name() const
   {
     assert(this != NULL);
     return "SgFile";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFile::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFile::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FileTag)
        {
          printf ("Error in SgFile::error(): SgFile object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFile::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FileTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFile::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFile::variant() const \n");
#endif
     assert(this != NULL);
     return FileTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFile* isSgFile ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFile*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFile* isSgFile ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFile*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFile::~SgFile ()
   {
#if 0
  // debugging information!
     printf ("In SgFile::~SgFile (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_startOfConstruct;
     delete p_preprocessorDirectivesAndCommentsList;

  // case: not a listType for startOfConstruct
     p_startOfConstruct = NULL; // non list case 
  // case: not a listType for root
     p_root = NULL; // non list case 
  // case: not a listType for verbose
     p_verbose = 0; // non list case 
  // case: not a listType for C_only
     p_C_only = false; // non list case 
  // case: not a listType for C99_only
     p_C99_only = false; // non list case 
  // case: not a listType for Fortran_only
     p_Fortran_only = false; // non list case 
  // case: not a listType for F77_only
     p_F77_only = false; // non list case 
  // case: not a listType for F90_only
     p_F90_only = false; // non list case 
  // case: not a listType for F95_only
     p_F95_only = false; // non list case 
  // case: not a listType for F2003_only
     p_F2003_only = false; // non list case 
  // case: not a listType for fixedFormat
     p_fixedFormat = false; // non list case 
  // case: not a listType for freeFormat
     p_freeFormat = false; // non list case 
  // case: not a listType for outputFormat
     p_outputFormat = SgFile::e_unknown_output_format; // non list case 
  // case: not a listType for fortran_implicit_none
     p_fortran_implicit_none = false; // non list case 
  // case: not a listType for fortran_openmp
     p_fortran_openmp = false; // non list case 
  // case: not a listType for skip_transformation
     p_skip_transformation = false; // non list case 
  // case: not a listType for skip_unparse
     p_skip_unparse = false; // non list case 
  // case: not a listType for unparse_includes
     p_unparse_includes = false; // non list case 
  // case: not a listType for skipfinalCompileStep
     p_skipfinalCompileStep = false; // non list case 
  // case: not a listType for outputLanguage
     p_outputLanguage = SgFile::e_default_output_language; // non list case 
  // case: not a listType for sourceFileNameWithPath
     p_sourceFileNameWithPath = ""; // non list case 
  // case: not a listType for sourceFileNameWithoutPath
     p_sourceFileNameWithoutPath = ""; // non list case 
  // case: not a listType for unparse_output_filename
     p_unparse_output_filename = ""; // non list case 
  // case: not a listType for useBackendOnly
     p_useBackendOnly = false; // non list case 
  // case: not a listType for compileOnly
     p_compileOnly = false; // non list case 
  // case: not a listType for savedFrontendCommandLine
     p_savedFrontendCommandLine = ""; // non list case 
  // case: not a listType for no_implicit_templates
     p_no_implicit_templates = false; // non list case 
  // case: not a listType for no_implicit_inline_templates
     p_no_implicit_inline_templates = false; // non list case 
  // case: not a listType for skip_commentsAndDirectives
     p_skip_commentsAndDirectives = false; // non list case 
  // case: not a listType for collectAllCommentsAndDirectives
     p_collectAllCommentsAndDirectives = false; // non list case 
  // case: not a listType for preprocessorDirectivesAndCommentsList
     p_preprocessorDirectivesAndCommentsList = NULL; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 
  // case: not a listType for KCC_frontend
     p_KCC_frontend = false; // non list case 
  // case: not a listType for new_frontend
     p_new_frontend = false; // non list case 
  // case: not a listType for travTraceToDOT
     p_travTraceToDOT = false; // non list case 
  // case: not a listType for disable_edg_backend
     p_disable_edg_backend = false; // non list case 
  // case: not a listType for disable_sage_backend
     p_disable_sage_backend = false; // non list case 
  // case: not a listType for testingLevel
     p_testingLevel = -1; // non list case 
  // case: not a listType for preinit_il
     p_preinit_il = false; // non list case 
  // case: not a listType for enable_cp_backend
     p_enable_cp_backend = false; // non list case 
  // case: not a listType for outputGrammarTreeFiles
     p_outputGrammarTreeFiles = false; // non list case 
  // case: not a listType for outputGrammarTreeFilesForHeaderFiles
     p_outputGrammarTreeFilesForHeaderFiles = false; // non list case 
  // case: not a listType for outputGrammarTreeFilesForEDG
     p_outputGrammarTreeFilesForEDG = false; // non list case 
  // case: not a listType for markGeneratedFiles
     p_markGeneratedFiles = false; // non list case 
  // case: not a listType for negative_test
     p_negative_test = false; // non list case 
  // case: not a listType for strict_language_handling
     p_strict_language_handling = false; // non list case 
  // case: not a listType for embedColorCodesInGeneratedCode
     p_embedColorCodesInGeneratedCode = 0; // non list case 
  // case: not a listType for generateSourcePositionCodes
     p_generateSourcePositionCodes = 0; // non list case 
  // case: not a listType for sourceFileUsesCppFileExtension
     p_sourceFileUsesCppFileExtension = false; // non list case 
  // case: not a listType for sourceFileUsesFortranFileExtension
     p_sourceFileUsesFortranFileExtension = false; // non list case 
  // case: not a listType for sourceFileUsesFortran77FileExtension
     p_sourceFileUsesFortran77FileExtension = false; // non list case 
  // case: not a listType for sourceFileUsesFortran90FileExtension
     p_sourceFileUsesFortran90FileExtension = false; // non list case 
  // case: not a listType for sourceFileUsesFortran95FileExtension
     p_sourceFileUsesFortran95FileExtension = false; // non list case 
  // case: not a listType for sourceFileUsesFortran2003FileExtension
     p_sourceFileUsesFortran2003FileExtension = false; // non list case 
  // case: not a listType for binaryFile
     p_binaryFile = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFilePtrListPtr 
SgProject::get_fileList () const
   {
     assert (this != NULL);
     return p_fileList;
   }

void
SgProject::set_fileList ( SgFilePtrListPtr fileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fileList = fileList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_originalCommandLineArgumentList () const
   {
     assert (this != NULL);
     return p_originalCommandLineArgumentList;
   }

void
SgProject::set_originalCommandLineArgumentList ( SgStringList originalCommandLineArgumentList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_originalCommandLineArgumentList = originalCommandLineArgumentList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgProject::get_frontendErrorCode () const
   {
     assert (this != NULL);
     return p_frontendErrorCode;
   }

void
SgProject::set_frontendErrorCode ( int frontendErrorCode )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_frontendErrorCode = frontendErrorCode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgProject::get_backendErrorCode () const
   {
     assert (this != NULL);
     return p_backendErrorCode;
   }

void
SgProject::set_backendErrorCode ( int backendErrorCode )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_backendErrorCode = backendErrorCode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgProject::get_outputFileName () const
   {
     assert (this != NULL);
     return p_outputFileName;
   }

void
SgProject::set_outputFileName ( std::string outputFileName )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputFileName = outputFileName;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_sourceFileNameList () const
   {
     assert (this != NULL);
     return p_sourceFileNameList;
   }

void
SgProject::set_sourceFileNameList ( SgStringList sourceFileNameList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_sourceFileNameList = sourceFileNameList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_objectFileNameList () const
   {
     assert (this != NULL);
     return p_objectFileNameList;
   }

void
SgProject::set_objectFileNameList ( SgStringList objectFileNameList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_objectFileNameList = objectFileNameList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_libraryFileList () const
   {
     assert (this != NULL);
     return p_libraryFileList;
   }

void
SgProject::set_libraryFileList ( SgStringList libraryFileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_libraryFileList = libraryFileList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_librarySpecifierList () const
   {
     assert (this != NULL);
     return p_librarySpecifierList;
   }

void
SgProject::set_librarySpecifierList ( SgStringList librarySpecifierList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_librarySpecifierList = librarySpecifierList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_libraryDirectorySpecifierList () const
   {
     assert (this != NULL);
     return p_libraryDirectorySpecifierList;
   }

void
SgProject::set_libraryDirectorySpecifierList ( SgStringList libraryDirectorySpecifierList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_libraryDirectorySpecifierList = libraryDirectorySpecifierList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStringList 
SgProject::get_includeDirectorySpecifierList () const
   {
     assert (this != NULL);
     return p_includeDirectorySpecifierList;
   }

void
SgProject::set_includeDirectorySpecifierList ( SgStringList includeDirectorySpecifierList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_includeDirectorySpecifierList = includeDirectorySpecifierList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgProject::get_compileOnly () const
   {
     assert (this != NULL);
     return p_compileOnly;
   }

void
SgProject::set_compileOnly ( bool compileOnly )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_compileOnly = compileOnly;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgProject::get_prelink () const
   {
     assert (this != NULL);
     return p_prelink;
   }

void
SgProject::set_prelink ( bool prelink )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_prelink = prelink;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgProject::template_instantiation_enum 
SgProject::get_template_instantiation_mode () const
   {
     assert (this != NULL);
     return p_template_instantiation_mode;
   }

void
SgProject::set_template_instantiation_mode ( SgProject::template_instantiation_enum template_instantiation_mode )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_template_instantiation_mode = template_instantiation_mode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgProject::get_astMerge () const
   {
     assert (this != NULL);
     return p_astMerge;
   }

void
SgProject::set_astMerge ( bool astMerge )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_astMerge = astMerge;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgProject::get_astMergeCommandFile () const
   {
     assert (this != NULL);
     return p_astMergeCommandFile;
   }

void
SgProject::set_astMergeCommandFile ( std::string astMergeCommandFile )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_astMergeCommandFile = astMergeCommandFile;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgProject::get_C_PreprocessorOnly () const
   {
     assert (this != NULL);
     return p_C_PreprocessorOnly;
   }

void
SgProject::set_C_PreprocessorOnly ( bool C_PreprocessorOnly )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_C_PreprocessorOnly = C_PreprocessorOnly;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgProject::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgProject::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgProject::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgProject::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgProject::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgProject::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgProject::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgProject::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgProject::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgProject::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgProject::get_compilationPerformanceFile () const
   {
     assert (this != NULL);
     return p_compilationPerformanceFile;
   }

void
SgProject::set_compilationPerformanceFile ( std::string compilationPerformanceFile )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_compilationPerformanceFile = compilationPerformanceFile;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12529 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


//! Declaration of space for static variables
//static int SgProject::p_defaultNumberOfCommandLineArguments = 0;
//static char** SgProject::p_defaultCommandLineArgumentList   = NULL;


//! (static data) global concept of verbose level which controls useful output from the compiler
int SgProject::p_verbose = 0;

//! this can constructor can be used but parse(int argc, char** argv) needs to be called
SgProject::SgProject()
   {
     initialization();
   }

SgProject::SgProject( const SgProject & project )
   {
  // This copy constructor is not supported, it is implemented with to return an error message!

     initialization();

  // What is the point of this code!
  // p_numberOfCommandLineArguments(project.p_numberOfCommandLineArguments),
  // p_commandLineArgumentList(project.p_commandLineArgumentList),
  // p_defaultNumberOfCommandLineArguments(project.p_defaultNumberOfCommandLineArguments),
  // p_defaultCommandLineArgumentList(project.p_defaultCommandLineArgumentList),

  // Build the empty STL lists
     p_fileList = new SgFilePtrList();
     ROSE_ASSERT (p_fileList != NULL);

  // print error message and quit
     printf ("ERROR: this SgProject copy constructor is not supposed to be used \n");
     printf ("    use SgProject ( int & argc, char** & argv , int & errorCode ) OR copy member function instead \n");
     ROSE_ABORT();
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( int argc, char** argv)
   {
     initialization();

     std::vector<std::string> argvList(argv, argv + argc);
     int errorCode = parse(argvList);
     set_frontendErrorCode(errorCode);
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( const std::vector<std::string>& argv )
   {
     initialization();

     int errorCode = parse(argv);
     set_frontendErrorCode(errorCode);
   }

#if 0
// DQ (10/16/2005): Depreicated a long time ago, removed it now!
//! Deprecated, do not use.
SgProject::SgProject ( int& argc, char** argv, int& refErrorCode)
   {
     printf ("This SgProject constructor is deprecated, do not use. \n");

     initialization();

     int errorCode;
     errorCode = parse(argc,argv);
     set_frontendErrorCode(errorCode);
     refErrorCode = errorCode;
   }
#endif

void
SgProject::initialization()
   {
  // DQ (10/16/2005): This function initializes default values (until we use an automatically generated version)
     p_fileList                            = NULL;
  // p_numberOfCommandLineArguments        = 0;
  // p_commandLineArgumentList             = NULL;
  // p_defaultNumberOfCommandLineArguments = 0;
  // p_defaultCommandLineArgumentList      = NULL;
     p_frontendErrorCode                   = 0;
     p_backendErrorCode                    = 0;
     p_outputFileName                      = "";
     p_compileOnly                         = false;
     p_prelink                             = false;
     p_template_instantiation_mode         = e_unknown;
     p_astMerge                            = false;
     p_astMergeCommandFile                 = "";
     p_compilationPerformanceFile          = "";
     p_C_PreprocessorOnly                  = false;

  // DQ (5/2/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism = NULL;
   }

// DQ (2/1/2007): Added new operator so that w could depricate the inconsistant usage of 
// SgFile& in get_file() member function.  The get_file() member function is now depricated.
SgFile*
SgProject::operator[]( unsigned int i )
   {
     ROSE_ASSERT(i < get_fileList()->size());

  // Since we use an STL vector internally we can use the vector::operator[] directly.
     return p_fileList->operator[](i);
   }


//! internal function to invoke the EDG frontend and generate the AST
int
SgProject::parse(const vector<string>& argv)
   {
  // Not sure that if we are just linking that we should call a function called "parse()"!!!

  // DQ (7/6/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST (SgProject::parse(argc,argv)):");

  // builds file list (or none if this is a link line)
	  processCommandLine(argv);

#if 0
     std::string outputFileName = get_outputFileName();
     int outputFilenameLength = outputFileName.length();
     if (outputFilenameLength <= 2)
        {
          printf ("Warning in SgProject::parse(): abnormally short output filename = %s \n",outputFileName.c_str());
        }
     ROSE_ASSERT (outputFilenameLength > 2);

  // DQ (9/30/2006): This is a better way to get the suffix, but I don't think we really need this code here!
  // std::string suffix = outputFileName.substr(outputFilenameLength-2,2);
     std::string suffix;
     size_t suffix_separator_location = filename.rfind('.');
     if (suffix_separator_location == string::npos)
        {
          printf ("In SgProject::parse(): No suffix identified \n");
        }
       else
        {
          suffix = filename.substr(suffix_separator_location);
          printf ("In SgProject::parse(): Suffix = %s \n",suffix.c_str());
        }
#endif

     int errorCode = 0;

  // DQ (7/7/2005): Added support for AST Merge Mechanism
     if (p_astMerge == true)
        {
       // If astMerge is specified, then the command file is accessed to execute all 
       // the commands from each of the associated working directories.  Each new AST 
       // in merged with the previous AST.

          if (p_astMergeCommandFile != "")
             {
            // If using astMerge mechanism we have to save the command line and 
            // working directories to a separate file.  This permits a makefile to
            // call a ROSE translator repeatedly and the command line for each 
            // file be saved.
               errorCode = AstMergeSupport(this);
             }
            else
             {
            // DQ (5/26/2007): This case could make sense, if there were more than
            // one file on the command line (or if we wanted to force a single file
            // to share as much as possible in a merge with itself, there is a 
            // typical 20% reduction in memory useage for this case since the 
            // types are then better shared than is possible during initial construction 
            // of the AST).
#if 0
            // error case
               printf ("astMerge requires specification of a command file \n");
               ROSE_ASSERT(false);
               errorCode = -1;
#endif
               errorCode = AstMergeSupport(this);
             }
        }
       else
        {
       // DQ (7/7/2005): Specification of the AST merge command filename triggers accumulation 
       // of working directories and commandlines into the specified file (no other processing 
       // is done, the AST (beyond the SgProject) is not built). 
          if (p_astMergeCommandFile != "")
             {
            // If using astMerge mechanism we have to save the command line and 
            // working directories to a separate file.

            // DQ (5/26/2007): This might be a problem where object files are required to be built
            // and so we might have to call the backend compiler as a way of forcing the correct
            // object files to be built so that, for example, libraries can be constructed when
            // operating across multiple directories.

               errorCode = buildAstMergeCommandFile(this);
             }
            else
             {
            // Normal case without AST Merge: Compiling ...
               if (get_sourceFileNameList().size() > 0)
                  {
                 // This is a compile line
                 // printf ("Compiling project: outputFileName = %s \n",outputFileName.c_str());
                    errorCode = parse();
                  }

            // DQ (5/26/2007): This is meaningless, so remove it!
            // errorCode = errorCode;
             }
        }

     return errorCode;
   }


void 
SgProject::processCommandLine(const vector<string>& input_argv)
   {
  // This functions only copies the command line and extracts information from the 
  // command line which is useful at the SgProject level (other information useful 
  // at the SgFile level is not extracted).
  // Specifically:
  //      1) --help is processed (along with -help, to be friendly)
  //      2) -o <filename> is processed (since both the compilation and the linking 
  //         phases must know the output file name and it makes sense to process that once).
  //      3) Lists of files and libraries are processed (sense they too are required in 
  //         both comilation and linking).  (e.g. -l<libname>, -L <directory>, <libname>.a,
  //         <filename>.C, <filename>.c, -I<directory name>, <filename>.h
  // NOTE: there is no side-effect to argc and argv.  Thus the original ROSE translator can 
  // see all options.  Any ROSE or EDG specific options can be striped by calling the
  // appropriate functions to strip them out.

  // This function now makes an internal copy of the command line parameters to
  // allow the originals to remain unmodified (SLA modifies the command line).

  // printf ("Inside of SgProject::processCommandLine() \n");

  // local copies of argc and argv variables
  // The purpose of building local copies is to avoid
  // the modification of the command line by SLA (to save the original command line)
     vector<string> local_commandLineArgumentList = input_argv;

  // Save a deep copy fo the original command line input the the translator
  // pass in out copies of the argc and argv to make clear that we don't modify argc and argv
     set_originalCommandLineArgumentList( local_commandLineArgumentList );

  // printf ("DONE with copy of command line in SgProject constructor! \n");

  // Build the empty STL lists
     p_fileList = new SgFilePtrList();
     ROSE_ASSERT (p_fileList != NULL);

  // return value for calls to SLA
     int optionCount = 0;

  //
  // help option (allows alternative -h or -help instead of just -rose:help)
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
  // optionCount = sla(&argc, argv, "-", "($)", "(h|help)",1);
     optionCount = sla_none(local_commandLineArgumentList, "-", "($)", "(h|help)",1);
     if( optionCount > 0 )
        {
       // printf ("option -help found \n");
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
       // ROSE::usage(0);
          SgFile::usage(0);
          exit(0);
        }

  // printf ("After SgProject processing -help option argc = %d \n",argc);

  //
  // help option (allows alternative --h or --help)
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
  // optionCount = sla(&argc, argv, "--", "($)", "(h|help)",1);
     optionCount = sla_none(local_commandLineArgumentList, "--", "($)", "(h|help)",1);
     if( optionCount > 0 )
        {
       // printf ("option --help found \n");
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
       // ROSE::usage(0);
          SgFile::usage(0);
          exit(0);
        }

  //
  // version option (allows alternative --version or --V)
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
  // optionCount = sla(&argc, argv, "--", "($)", "(V|version)",1);
     optionCount = sla_none(local_commandLineArgumentList, "--", "($)", "(V|version)",1);
     if ( optionCount > 0 )
        {
       // printf ("SgProject::processCommandLine(): option --version found \n");
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
          exit(0);
        }

  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of agrc
  // optionCount = sla(&argc, argv, "--", "($)", "(V|version)",1);
     optionCount = sla_none(local_commandLineArgumentList, "-rose:", "($)", "(V|version)",1);
     if ( optionCount > 0 )
        {
       // printf ("SgProject::processCommandLine(): option --version found \n");
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
          exit(0);
        }

#if 0
  // DQ (8/6/2006): Not sure that I want this here!
  //
  // version option (using -rose:version)
  //
     if ( CommandlineProcessing::isOption(argc,argv,"-rose:","(V|version)",true) == true )
        {
       // function in SAGE III to access version number of EDG
          extern std::string edgVersionString();
          printf ("\nROSE (pre-release alpha version: %s) \n",VERSION);
          printf ("     Using C++ and C frontend from EDG (version %s) internally \n",edgVersionString().c_str());
        }
#endif
  // DQ (10/15/2005): Added because verbose was not set when the number of files (source files) was zero (case for linking only)
  //
  // specify verbose setting for projects (should be set even for linking where there are no source files
  //
     ROSE_ASSERT (get_verbose() == 0);
     int integerOptionForVerbose = 0;
  // if ( CommandlineProcessing::isOptionWithParameter(argc,argv,"-rose:","(v|verbose)",integerOptionForVerbose,true) == true )
     if ( CommandlineProcessing::isOptionWithParameter(local_commandLineArgumentList,"-rose:","(v|verbose)",integerOptionForVerbose,true) == true )
        {
       // set_verbose(true);
          set_verbose(integerOptionForVerbose);

          if ( SgProject::get_verbose() >= 1 )
               printf ("verbose mode ON \n");
        }

  //
  // Standard compiler options (allows alternative -E option to just run CPP)
  //
  // if ( CommandlineProcessing::isOption(argc,argv,"-","(E)",false) == true )
     if ( CommandlineProcessing::isOption(local_commandLineArgumentList,"-","(E)",false) == true )
        {
       // printf ("/* option -E found (just run backend compiler with -E to call CPP) */ \n");
          p_C_PreprocessorOnly = true;
        }

  //
  // specify compilation only option (new style command line processing)
  //
  // if ( CommandlineProcessing::isOption(argc,argv,"-","c",false) == true )
     if ( CommandlineProcessing::isOption(local_commandLineArgumentList,"-","c",false) == true )
        {
       // printf ("Option -c found (compile only)! \n");
          set_compileOnly(true);
        }

  //
  // prelink option
  //
  // if ( CommandlineProcessing::isOption(argc,argv,"-rose:","(prelink)",true) == true )
     if ( CommandlineProcessing::isOption(local_commandLineArgumentList,"-rose:","(prelink)",true) == true )
        {
       // printf ("prelink mode ON \n");
          set_prelink(true);
        }
       else
        {
       // printf ("-rose:prelink not found: prelink mode OFF \n");
          set_prelink(false);
        }

  //
  // specify output file option
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of argc
     string tempOutputFilename;
  // optionCount = sla(&argc, argv, "-", "($)^", "(o|output)", &tempOutputFilename ,1);
     optionCount = sla(local_commandLineArgumentList, "-", "($)^", "(o|output)", &tempOutputFilename ,1);
     if( optionCount > 0 )
        {
       // Make our own copy of the filename string
          p_outputFileName = tempOutputFilename;
       // printf ("option -o|output found outputFileName = %s \n",p_outputFileName.c_str());
        }
       else
        {
       // Usual default for output executables (comes from the default name for 
       // assembler output a long long time ago, way way back in the 1970's).
       // For history of why "a.out" is the default see: 
       // http://cm.bell-labs.com/cm/cs/who/dmr/chist.html
          p_outputFileName = "a.out";
        }

  //
  // DQ (5/20/2005): specify template handling options (e.g. -rose:instantiation none)
  //
  // Use 1 at end of argument list to SLA to force removal of option from argv and decrement of argc
     string tempTemplateHandling;
  // optionCount = sla(&argc, argv, "-rose:", "($)^", "(instantiation)", &tempTemplateHandling ,1);
     optionCount = sla(local_commandLineArgumentList, "-rose:", "($)^", "(instantiation)", &tempTemplateHandling ,1);
     if ( optionCount > 0 )
        {
          std::string templateHandlingString = tempTemplateHandling;
          if (templateHandlingString == "none")
               p_template_instantiation_mode = e_none;
          if (templateHandlingString == "used")
               p_template_instantiation_mode = e_used;
          if (templateHandlingString == "all")
               p_template_instantiation_mode = e_all;
          if (templateHandlingString == "local")
               p_template_instantiation_mode = e_local;

       // printf ("option -rose:instantiation found tempTemplateHandling = %s \n",tempTemplateHandling);
        }
       else
        {
       // usual default for template handling
       // printf ("option -rose:instantiation NOT found setting p_template_instantiation_mode = e_default \n");
          p_template_instantiation_mode = e_default;
        }

  // DQ (10/16/2005):
  // Build versions of argc and argv that are separate from the input_argc and input_argv 
  // (so that we can be clear that there are no side-effects to the original argc and argv 
  // that come from the user's ROSE translator.  Mostly we want to use the short names 
  // (e.g. "argc" and "argv").
     vector<string> argv = get_originalCommandLineArgumentList();
     ROSE_ASSERT(argv.size() > 0);

  // Build a list of source, object, and library files on the command line
  // int sourceFileNameCounter = 0;
     for (unsigned int i = 1; i < argv.size(); i++)
        {
       // find the source code filenames and modify them to be the output filenames
          unsigned int length = argv[i].size();

       // printf ("assemble compiler command line option: argv[%d] = %s length = %d \n",i,argv[i],length);
       // printf ("ROSE::sourceFileNamesWithoutPath[%d] = \n",sourceFileNameCounter,
       //     ROSE::sourceFileNamesWithoutPath[sourceFileNameCounter]);
       // ROSE_ASSERT (ROSE::sourceFileNamesWithoutPath[sourceFileNameCounter] != NULL);

       // PC (4/27/2006): Support for custom source file suffixes
          if ( CommandlineProcessing::isSourceFilename(argv[i]) )
             {
            // AS added support for absolute paths
               std::string sourceFile = argv[i];
               std::string sourceFilePath = StringUtility::getPathFromFileName(sourceFile);
#if USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST
#error "USE_ABSOLUTE_PATHS_IN_SOURCE_FILE_LIST is not supported yet"

            // DQ (9/1/2006): We rely upon using the source file names as specified 
            // so that we can search for them and match them in the original command 
            // line so we can't really be normalizing these.
               sourceFile = StringUtility::stripPathFromFileName(sourceFile);
               if (sourceFilePath == "")
                    sourceFilePath = "./";
               sourceFilePath = StringUtility::getAbsolutePathFromRelativePath(sourceFilePath);
            // printf ("sourceFile = %s \n",sourceFile.c_str());
               p_sourceFileNameList.push_back(sourceFilePath+"/"+sourceFile);
#else
            // DQ (9/1/2006): save the un modified source file name in the source file list held in the SgProject
               p_sourceFileNameList.push_back(sourceFile);
#endif
             }

       // look only for .o  (object code files)
          if ( (length > 2) && 
               ( (argv[i][0] != '-') || (argv[i][0] != '+') ) && 
               ( (argv[i][length-2] == '.') && (argv[i][length-1] == 'o') ) )
             {
               std::string objectFile = argv[i];
               p_objectFileNameList.push_back(objectFile);
             }

       // look only for .a files (library files)
          if ( (length > 2) &&
               ( (argv[i][0] != '-') || (argv[i][0] != '+') ) &&
               ( (argv[i][length-2] == '.') && (argv[i][length-1] == 'a') ) )
             {
               std::string libraryFile = argv[i];
               p_libraryFileList.push_back(libraryFile);
             }

       // look only for -l library files (library files)
          if ( (length > 2) && (argv[i][0] == '-') && (argv[i][1] == 'l') )
             {
               std::string librarySpecifier = argv[i].substr(2);
            // librarySpecifier = std::string("lib") + librarySpecifier;
               p_librarySpecifierList.push_back(librarySpecifier);
             }

       // look only for -L directories (directories where -lxxx libraries will be found)
          if ( (length > 2) && (argv[i][0] == '-') && (argv[i][1] == 'L') )
             {
	      //AS Changed source code to support absolute paths
               std::string libraryDirectorySpecifier = argv[i].substr(2);
               libraryDirectorySpecifier = StringUtility::getAbsolutePathFromRelativePath(libraryDirectorySpecifier);			     
               p_libraryDirectorySpecifierList.push_back(libraryDirectorySpecifier);

             }

       // look only for -I include directories (directories where #include<filename> will be found)
          if ( (length > 2) && (argv[i][0] == '-') && (argv[i][1] == 'I') )
             {
	      //AS Changed source code to support absolute paths
	      std::string includeDirectorySpecifier =  argv[i].substr(2);
	      includeDirectorySpecifier = StringUtility::getAbsolutePathFromRelativePath(includeDirectorySpecifier );
              p_includeDirectorySpecifierList.push_back("-I"+includeDirectorySpecifier);
             }
        }

#if 0
     if ( get_verbose() > 1 )
        {
       // Find out what file we are doing transformations upon
          printf ("In SgProject::processCommandLine() (verbose mode ON): \n");
          display ("In SgProject::processCommandLine()");
        }
#endif

  // DQ (6/17/2005): Added support for AST merging (sharing common parts of the AST most often represented in common header files of a project)
  //
  // specify AST merge option
  //
  // if ( CommandlineProcessing::isOption(argc,argv,"-rose:","(astMerge)",true) == true )
     if ( CommandlineProcessing::isOption(local_commandLineArgumentList,"-rose:","(astMerge)",true) == true )
        {
          printf ("-rose:astMerge option found \n");
       // set something not yet defined!
          p_astMerge = true;
        }

  // DQ (6/17/2005): Added support for AST merging (sharing common parts of the AST most often represented in common header files of a project)
  //
  // specify AST merge command file option
  //
     std::string astMergeFilenameParameter;
     if ( CommandlineProcessing::isOptionWithParameter(local_commandLineArgumentList,
          "-rose:","(astMergeCommandFile)",astMergeFilenameParameter,true) == true )
        {
          printf ("-rose:astMergeCommandFile %s \n",astMergeFilenameParameter.c_str());
       // Make our own copy of the filename string
       // set_astMergeCommandLineFilename(xxx);
          p_astMergeCommandFile = astMergeFilenameParameter;
        }

  // DQ (8/29/2006): Added support for accumulation of performance data into CSV data file (for later processing to build performance graphs)
     std::string compilationPerformanceFilenameParameter;
     if ( CommandlineProcessing::isOptionWithParameter(local_commandLineArgumentList,
          "-rose:","(compilationPerformanceFile)",compilationPerformanceFilenameParameter,true) == true )
        {
       // printf ("-rose:compilationPerformanceFile = %s \n",compilationPerformanceFilenameParameter.c_str());
          p_compilationPerformanceFile = compilationPerformanceFilenameParameter;
        }

#if 0
     printf ("Exiting after SgProject::processCommandLine() \n");
     display("At base of SgProject::processCommandLine()");
  // ROSE_ASSERT (false);
#endif
   }

std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<string> & l )
   {
  // printf ("Output Rose_STL_Container<string> in operator<< (std::ostream,Rose_STL_Container<string>) \n");
     return os;
   }

// DQ (5/22/2007): Moved to astPostProcessing
// DQ (5/8/2007): Function prototype declared in HiddenList.h
// void buildHiddenTypeAndDeclarationLists( SgProject* project );

int 
SgProject::parse()
   {
     int errorCode = 0;

  // DQ (7/6/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST (SgProject::parse()):");

     ROSE_ASSERT (p_fileList != NULL);

  // Simplify multi-file handling so that a single file is just the trivial 
  // case and not a special separate case.
  // printf ("Loop through the source files on the command line! \n");
  // for (unsigned int i = 0; i < p_sourceFileNameList.size(); i++)
     Rose_STL_Container<string>::iterator nameIterator = p_sourceFileNameList.begin();
     unsigned int i = 0;
     while (nameIterator != p_sourceFileNameList.end())
        {
       // printf ("Build a SgFile object for file #%d \n",i);
          int nextErrorCode = 0;

       // DQ (4/20/2006): Exclude other files from list in argc and argv
          vector<string> argv = get_originalCommandLineArgumentList();
          string currentFileName = *nameIterator;
          CommandlineProcessing::removeAllFileNamesExcept(argv,p_sourceFileNameList,currentFileName);

       // printf ("Command line being passed to SgFile constructor: \n%s\n",CommandlineProcessing::generateStringFromArgcArgv(argc,(const char**)argv,false,false).c_str());

       // DQ (2/24/2004): Added support for SgProject to be passed so that the parent 
       // pointer could be set earily in the construction process.
       // SgFile* newFile = new SgFile ( argc, argv, nextErrorCode, i, this );
          SgFile* newFile = new SgFile ( argv, nextErrorCode, 0, this );
          ROSE_ASSERT (newFile != NULL);

          ROSE_ASSERT (newFile->get_startOfConstruct() != NULL);

       // Set the parent explicitly (so that we can easily find the SgProject from the SgFile).
          newFile->set_parent(this);

       // This just adds the new file to the list of files stored internally
          set_file ( *newFile );

#if 0
          printf ("In Project::parse(): get_file(%d).get_skipfinalCompileStep() = %s \n",
               i,(get_file(i).get_skipfinalCompileStep()) ? "true" : "false");
#endif

       // errorCode = (errorCode >= nextErrorCode) ? errorCode : nextErrorCode; // use STL max
          errorCode = max(errorCode,nextErrorCode); // use STL max

          nameIterator++;
          i++;
        }

  // report the error code if it is non-zero
     if (errorCode > 0)
        {
          printf ("Frontend Warnings only: errorCode = %d \n",errorCode);
          if (errorCode > 3)
             {
               printf ("Frontend Errors found: errorCode = %d \n",errorCode);
             }
        }

  // warnings from EDG processing are OK but not errors
     ROSE_ASSERT (errorCode <= 3);

  // if (get_useBackendOnly() == false)
     if ( SgProject::get_verbose() >= 1 )
          cout << "C++ source(s) parsed. AST generated." << endl;

     if ( get_verbose() > 3 )
        {
          printf ("In SgProject::parse() (verbose mode ON): \n");
          display ("In SgProject::parse()");
        }

  // DQ (5/22/2007): Moved to astPostProcessing
  // DQ (5/8/2007): Now build the hidden lists for types and declarations (Robert Preissl's work)
  // buildHiddenTypeAndDeclarationLists(this);

     return errorCode;
   }

#if 0
SgProject::~SgProject()
   {
  // delete the list of files (comment out for now)
  // delete p_fileList;
   }
#endif

int
SgProject::numberOfFiles() const
   {
  // This function does not return a meaningful result until all the files have been processed
     ROSE_ASSERT (p_fileList != NULL);
     int returnValue = p_fileList->size();
  // ROSE_ASSERT ( returnValue > 0 );

  // Seems like a good upper bound for now!
  // ROSE_ASSERT ( returnValue < 100 );

     return returnValue;
   }

SgFile &
SgProject::get_file ( int i ) const
   {
  // assert(i==0);
  // return *p_file;

  // error checking
     ROSE_ASSERT (i >= 0);
  // ROSE_ASSERT (i < 10);
     ROSE_ASSERT (i < numberOfFiles());

     ROSE_ASSERT (p_fileList != NULL);
     SgFile* targetFile =  (*p_fileList)[i];
     ROSE_ASSERT (targetFile != NULL);

     return *targetFile;
   }

void
SgProject::set_file ( SgFile & file )
   {
     ROSE_ASSERT (p_fileList != NULL);
     p_fileList->push_back(&file);
     ROSE_ASSERT (numberOfFiles() > 0);
   }

void
// SgProject::unparse()
SgProject::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
       // printf ("In SgProject::unparse(): Unparsing file #%d \n",i);
          SgFile & file = get_file(i);

       // DQ (3/18/2006): Added support for user defined control of code generation
          file.unparse(unparseFormatHelp,unparseDelegate);
        }
   }

int
SgProject::compileOutput( const std::string& compilerName )
   {
  // DQ (7/6/2005): Introduce tracking of performance of ROSE.
     TimingPerformance timer ("AST Backend Compilation (SgProject):");

     int errorCode = 0;
     int i = 0;

     if (numberOfFiles() == 0)
        {
          printf ("Note in SgProject::compileOutput(%s): numberOfFiles() == 0 \n",compilerName.c_str());
        }

     if (get_C_PreprocessorOnly() == true)
        {
       // DQ (10/16/2005): Handle special case (issue a single compile command for all files)
          vector<string> argv = get_originalCommandLineArgumentList();

       // strip out any rose options before passing the command line.
          SgFile::stripRoseCommandLineOptions( argv );

       // strip out edg specific options that would cause an error in the backend linker (compiler).
          SgFile::stripEdgCommandLineOptions( argv );

       // Skip the name of the ROSE translator (so that we can insert the backend compiler name, below)
          bool skipInitialEntry = true;

       // Include all the specified source files
          bool skipSourceFiles  = false;

          std::string originalCommandLine = CommandlineProcessing::generateStringFromArgList(argv,skipInitialEntry,skipSourceFiles);

       // DQ (8/13/2006): Use the path to the compiler specified as that backend compiler (should not be specifi to GNU!)
       // DQ (8/6/2006): Test for g++ and use gcc with "-E" option 
       // (makes a different for header file processing in ARES configuration)
       // string compilerNameString = compilerName;
          string compilerNameString;          
          if (get_C_only() == true)
             {
               compilerNameString = BACKEND_C_COMPILER_NAME_WITH_PATH;
             }
            else
             {
               compilerNameString = BACKEND_CXX_COMPILER_NAME_WITH_PATH;
               if (get_Fortran_only() == true)
                  {
                    compilerNameString = "f77 ";
                  }
             }

       // DQ (8/13/2006): Add a space to avoid building "g++-E" as output.
          compilerNameString += " ";

       // Prepend the compiler name to the original command line
       // originalCommandLine = std::string(compilerName) + std::string(" ") + originalCommandLine;
          originalCommandLine = compilerNameString + originalCommandLine;

       // Prepend the compiler name to the original command line
       // originalCommandLine = std::string(compilerName) + std::string(" ") + originalCommandLine;

       // printf ("originalCommandLine = %s \n",originalCommandLine.c_str());

#if 0
          printf ("Support for \"-E\" not implemented yet. \n");
          ROSE_ASSERT(false);
#endif

          errorCode = system(originalCommandLine.c_str());

       // printf ("Exiting after call to compiler using -E option! \n");
       // ROSE_ASSERT(false);
        }
       else
        {
       // Typical case
          for (i=0; i < numberOfFiles(); i++)
             {
               SgFile & file = get_file(i);
#if 0
               printf ("In Project::compileOutput(%s): get_file(%d).get_skipfinalCompileStep() = %s \n",
                    compilerName,i,(get_file(i).get_skipfinalCompileStep()) ? "true" : "false");
#endif

            // DQ (8/13/2006): Only use the first file (I don't think this
            // makes sense with multiple files specified on the commandline)!
            // int localErrorCode = file.compileOutput(i, compilerName);
               int localErrorCode = file.compileOutput(0, compilerName);
               if (localErrorCode > errorCode)
                    errorCode = localErrorCode;
             }
        }

     return errorCode;
   }

// DQ (10/16/2005): I would like to get rid of this function since it is redundant with other 
// automatically generated functions containing list of source files (with and without paths).
Rose_STL_Container<string>
SgProject::getFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }

int
SgProject::get_verbose (void)
   {
#if 0
  // DQ (8/12/2004): Not certain what semantics would be best here?????
  // look at how the files are set (set to max value)
     int returnVerbose = 0;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          int localFileVerbosity = get_file(i).get_verbose();
          if (localFileVerbosity > returnVerbose)
               returnVerbose = localFileVerbosity;
        }
     p_verbose = returnVerbose;
#endif
     return p_verbose;
   }

void
SgProject::set_verbose ( int x )
   {
     p_verbose = x;
   }

bool
SgProject::get_skip_transformation (void) const
   {
  // look at how the files are set
     bool returnSkipTransformation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTransformation = returnSkipTransformation && (bool) file.get_skip_transformation();
        }
     return returnSkipTransformation;
   }

bool
SgProject::get_useBackendOnly (void) const
   {
  // look at how the files are set
     bool returnUseBackendOnly = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnUseBackendOnly = returnUseBackendOnly && (bool) file.get_useBackendOnly();
        }
     return returnUseBackendOnly;
   }

bool
SgProject::get_C_only (void) const
   {
  // look at how the files are set (C here implies C89)
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C_only();
        }
     return result;
   }

bool
SgProject::get_C99_only (void) const
   {
  // look at how the files are set (C99 only)
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_only();
        }
     return result;
   }

bool
SgProject::get_Fortran_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Fortran_only();
        }
     return result;
   }

bool
SgProject::get_F77_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F77_only();
        }
     return result;
   }

bool
SgProject::get_F90_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F90_only();
        }
     return result;
   }

bool
SgProject::get_F95_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F95_only();
        }
     return result;
   }

bool
SgProject::get_F2003_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2003_only();
        }
     return result;
   }

void
SgProject::display ( const std::string & label ) const
   {
     printf ("In SgProject::display(%s) \n",label.c_str());

     printf ("   p_outputFileName                       = %s \n",p_outputFileName.c_str());

     printf ("   p_sourceFileNameList.size()            = %zu \n", p_sourceFileNameList.size());
     printf ("   p_sourceFileNameList                   = \n      %s \n",StringUtility::listToString(p_sourceFileNameList).c_str());

     printf ("   p_objectFileNameList.size()            = %zu \n", p_objectFileNameList.size());
     printf ("   p_objectFileNameList                   = \n      %s \n",StringUtility::listToString(p_objectFileNameList).c_str());

     printf ("   p_libraryFileList.size()               = %zu \n", p_libraryFileList.size());
     printf ("   p_libraryFileList                      = \n      %s \n",StringUtility::listToString(p_libraryFileList).c_str());

     printf ("   p_librarySpecifierList.size()          = %zu \n", p_librarySpecifierList.size());
     printf ("   p_librarySpecifierList                 = \n      %s \n",StringUtility::listToString(p_librarySpecifierList).c_str());

     printf ("   p_libraryDirectorySpecifierList.size() = %zu \n", p_libraryDirectorySpecifierList.size());
     printf ("   p_libraryDirectorySpecifierList        = \n      %s \n",StringUtility::listToString(p_libraryDirectorySpecifierList).c_str());

     printf ("   p_includeDirectorySpecifierList.size() = %zu \n", p_includeDirectorySpecifierList.size());
     printf ("   p_includeDirectorySpecifierList        = \n      %s \n",StringUtility::listToString(p_includeDirectorySpecifierList).c_str());

     printf ("   p_compileOnly                          = %s \n",(p_compileOnly == true) ? "true" : "false");
     printf ("   p_prelink                              = %s \n",(p_prelink     == true) ? "true" : "false");

     printf ("   p_template_instantiation_mode          = %d \n",p_template_instantiation_mode);

     printf ("   p_astMerge                             = %s \n",(p_astMerge == true) ? "true" : "false");
     printf ("   p_astMergeCommandFile                  = %s \n",p_astMergeCommandFile.c_str());
     printf ("   p_compilationPerformanceFile           = %s \n",p_compilationPerformanceFile.c_str());

     printf ("In this project: numberOfFiles() = %d \n",numberOfFiles());
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.display("called from SgProject::display()");
        }
   }

int
SgProject::link ( std::string linkerName )
   {
  // Compile the output file from the unparing
#if 0
     int argc    = get_NumberOfCommandLineArguments();
     char** argv = get_CommandLineArgumentList();
#else
     vector<string> argv = get_originalCommandLineArgumentList();
#endif

  // error checking
     ROSE_ASSERT (argv.size() > 1);
     ROSE_ASSERT(linkerName != "");

  // strip out any rose options before passing the command line.
     SgFile::stripRoseCommandLineOptions( argv );

  // strip out edg specific options that would cause an error in the backend linker (compiler).
     SgFile::stripEdgCommandLineOptions( argv );

  // Call the compile
     int errorCode = link ( argv, linkerName );

  // return the error code from the compilation
     return errorCode;
   }

int
SgProject::link ( const std::vector<std::string>& argv, std::string linkerName )
   {
  // This link function will be moved into the SgProject IR node when complete
     const std::string whiteSpace = " ";

  // printf ("This link function is not longer called (I think!) \n");
  // ROSE_ASSERT(false);

  // DQ (10/15/2005): Trap out case of C programs where we want to make sure that we don't use the C++ compiler to do our linking!
     if (get_C_only() == true || get_C99_only() == true)
        {
          linkerName = BACKEND_C_COMPILER_NAME_WITH_PATH;
        }
       else
        {
          linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH;
          if (get_Fortran_only() == true)
             {
               linkerName = "f77 ";
             }
        }
     
#if 0
     std::string objectFiles = StringUtility::listToString(get_objectFileNameList());
     printf ("objectFiles = %s \n",objectFiles.c_str());

     std::string outputFile;
     if (get_outputFileName() != "")
        {
          outputFile = whiteSpace + std::string("-o") + whiteSpace + get_outputFileName();
        }
     printf ("outputFile = %s \n",outputFile.c_str());

     std::string libraryDirectorySpecifierList =  StringUtility::listToString(get_libraryDirectorySpecifierList());
     printf ("libraryDirectorySpecifierList = %s \n",libraryDirectorySpecifierList.c_str());
     std::string librarySpecifierList          =  StringUtility::listToString(get_librarySpecifierList());
     printf ("librarySpecifierList          = %s \n",librarySpecifierList.c_str());
     std::string libraryFileList               =  StringUtility::listToString(get_libraryFileList());
     printf ("libraryFileList               = %s \n",libraryFileList.c_str());
     std::string includeDirectorySpecifierList =  StringUtility::listToString(get_includeDirectorySpecifierList());
     printf ("includeDirectorySpecifierList = %s \n",includeDirectorySpecifierList.c_str());

     std::string linkerCommandLine = linkerName + whiteSpace + 
                                includeDirectorySpecifierList + whiteSpace + 
                                objectFiles + outputFile + whiteSpace + libraryFileList;
     printf ("linkerCommandLine = %s \n",linkerCommandLine.c_str());

  // skip the 0th entry since this is just the name of the program (e.g. rose)
     for (int i=1; i < 	get_NumberOfCommandLineArguments(); i++)
        {
          printf ("get_commandLineArgumentList()[%d] = %s \n",i,get_CommandLineArgumentList()[i]);
        }
#else
  // This is a better implementation since it will include any additional command line options that target the linker
     Rose_STL_Container<string> l = argv;

  // remove the name of the translator (argv[0]) from the command line input
     ROSE_ASSERT(l.size() > 0);

  // DQ (9/25/2007): Moved to std::vector from std::list uniformally within ROSE.
  // l.pop_front();
     l.erase(l.begin());

     std::string linkerCommandLine = linkerName + whiteSpace + StringUtility::listToString(l);
     if ( get_verbose() > 1 )
          printf ("linkerCommandLine = %s \n",linkerCommandLine.c_str());
#endif

     int status = system(linkerCommandLine.c_str());

     if ( get_verbose() > 1 )
          printf ("linker error status = %d \n",status);

     return status;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgProject::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgProject::variantT() const {
  return V_SgProject;
}

#if 0
int
SgProject::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ProjectTag;
   }
#endif

const char*
SgProject::sage_class_name() const
   {
     assert(this != NULL);
     return "SgProject";  
   }

std::string
SgProject::class_name() const
   {
     assert(this != NULL);
     return "SgProject";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgProject::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgProject::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ProjectTag)
        {
          printf ("Error in SgProject::error(): SgProject object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgProject::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ProjectTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgProject::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgProject::variant() const \n");
#endif
     assert(this != NULL);
     return ProjectTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgProject* isSgProject ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgProject*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgProject* isSgProject ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgProject*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgProject::~SgProject ()
   {
#if 0
  // debugging information!
     printf ("In SgProject::~SgProject (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: listType for fileList
  // case: listType (typeIsPointerToList == true) for fileList
     p_fileList = NULL;
  // case: not a listType for frontendErrorCode
     p_frontendErrorCode = 0; // non list case 
  // case: not a listType for backendErrorCode
     p_backendErrorCode = 0; // non list case 
  // case: not a listType for outputFileName
     p_outputFileName = ""; // non list case 
  // case: not a listType for compileOnly
     p_compileOnly = false; // non list case 
  // case: not a listType for prelink
     p_prelink = false; // non list case 
  // case: not a listType for template_instantiation_mode
     p_template_instantiation_mode = SgProject::e_default; // non list case 
  // case: not a listType for astMerge
     p_astMerge = false; // non list case 
  // case: not a listType for astMergeCommandFile
     p_astMergeCommandFile = ""; // non list case 
  // case: not a listType for C_PreprocessorOnly
     p_C_PreprocessorOnly = false; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 
  // case: not a listType for compilationPerformanceFile
     p_compilationPerformanceFile = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 13652 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgOptions::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgOptions::variantT() const {
  return V_SgOptions;
}

#if 0
int
SgOptions::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return OptionsTag;
   }
#endif

const char*
SgOptions::sage_class_name() const
   {
     assert(this != NULL);
     return "SgOptions";  
   }

std::string
SgOptions::class_name() const
   {
     assert(this != NULL);
     return "SgOptions";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgOptions::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgOptions::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != OptionsTag)
        {
          printf ("Error in SgOptions::error(): SgOptions object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgOptions::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == OptionsTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgOptions::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgOptions::variant() const \n");
#endif
     assert(this != NULL);
     return OptionsTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgOptions* isSgOptions ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgOptions*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgOptions* isSgOptions ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgOptions*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgOptions::~SgOptions ()
   {
#if 0
  // debugging information!
     printf ("In SgOptions::~SgOptions (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_default_output;
     delete p_debug_output;
     delete p_error_output;
     delete p_logging_output;

  // case: not a listType for default_output
     p_default_output = NULL; // non list case 
  // case: not a listType for debug_output
     p_debug_output = NULL; // non list case 
  // case: not a listType for error_output
     p_error_output = NULL; // non list case 
  // case: not a listType for logging_output
     p_logging_output = NULL; // non list case 
  // case: not a listType for debug_level
     p_debug_level = 0; // non list case 
  // case: not a listType for logging_level
     p_logging_level = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgOptions::SgOptions (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgOptions::SgOptions () sage_class_name() = %s \n",sage_class_name());
#endif

     p_default_output = NULL;
     p_debug_output = NULL;
     p_error_output = NULL;
     p_logging_output = NULL;
     p_debug_level = 0;
     p_logging_level = 0;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(OptionsTag == variant());
     post_construction_initialization();

  // Test the isSgOptions() function since it has been problematic
     assert(isSgOptions(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgUnparse_Info::get_access_attribute () const
   {
     assert (this != NULL);
     return p_access_attribute;
   }

void
SgUnparse_Info::set_access_attribute ( int access_attribute )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_access_attribute = access_attribute;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgUnparse_Info::get_declstatement_ptr () const
   {
     assert (this != NULL);
     return p_declstatement_ptr;
   }

void
SgUnparse_Info::set_declstatement_ptr ( SgDeclarationStatement* declstatement_ptr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declstatement_ptr != NULL && declstatement_ptr != NULL && p_declstatement_ptr != declstatement_ptr)
        {
          printf ("Warning: declstatement_ptr = %p overwriting valid pointer p_declstatement_ptr = %p \n",declstatement_ptr,p_declstatement_ptr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declstatement_ptr != NULL && declstatement_ptr != NULL && p_declstatement_ptr != declstatement_ptr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declstatement_ptr = declstatement_ptr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamedType* 
SgUnparse_Info::get_current_context () const
   {
     assert (this != NULL);
     return p_current_context;
   }

void
SgUnparse_Info::set_current_context ( SgNamedType* current_context )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_current_context != NULL && current_context != NULL && p_current_context != current_context)
        {
          printf ("Warning: current_context = %p overwriting valid pointer p_current_context = %p \n",current_context,p_current_context);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_current_context != NULL && current_context != NULL && p_current_context != current_context) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_current_context = current_context;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgUnparse_Info::get_array_index_list () const
   {
     assert (this != NULL);
     return p_array_index_list;
   }

void
SgUnparse_Info::set_array_index_list ( SgName array_index_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_array_index_list = array_index_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDeclarationStatement* 
SgUnparse_Info::get_current_namespace () const
   {
     assert (this != NULL);
     return p_current_namespace;
   }

void
SgUnparse_Info::set_current_namespace ( SgNamespaceDeclarationStatement* current_namespace )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_current_namespace != NULL && current_namespace != NULL && p_current_namespace != current_namespace)
        {
          printf ("Warning: current_namespace = %p overwriting valid pointer p_current_namespace = %p \n",current_namespace,p_current_namespace);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_current_namespace != NULL && current_namespace != NULL && p_current_namespace != current_namespace) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_current_namespace = current_namespace;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgUnparse_Info::get_outputCodeGenerationFormatDelimiters () const
   {
     assert (this != NULL);
     return p_outputCodeGenerationFormatDelimiters;
   }

void
SgUnparse_Info::set_outputCodeGenerationFormatDelimiters ( bool outputCodeGenerationFormatDelimiters )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_outputCodeGenerationFormatDelimiters = outputCodeGenerationFormatDelimiters;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgQualifiedNamePtrListPtr 
SgUnparse_Info::get_qualifiedNameList () const
   {
     assert (this != NULL);
     return p_qualifiedNameList;
   }

void
SgUnparse_Info::set_qualifiedNameList ( SgQualifiedNamePtrListPtr qualifiedNameList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_qualifiedNameList = qualifiedNameList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionCallExp* 
SgUnparse_Info::get_current_function_call () const
   {
     assert (this != NULL);
     return p_current_function_call;
   }

void
SgUnparse_Info::set_current_function_call ( SgFunctionCallExp* current_function_call )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_current_function_call != NULL && current_function_call != NULL && p_current_function_call != current_function_call)
        {
          printf ("Warning: current_function_call = %p overwriting valid pointer p_current_function_call = %p \n",current_function_call,p_current_function_call);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_current_function_call != NULL && current_function_call != NULL && p_current_function_call != current_function_call) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_current_function_call = current_function_call;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgUnparse_Info::get_current_scope () const
   {
     assert (this != NULL);
     return p_current_scope;
   }

void
SgUnparse_Info::set_current_scope ( SgScopeStatement* current_scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_current_scope != NULL && current_scope != NULL && p_current_scope != current_scope)
        {
          printf ("Warning: current_scope = %p overwriting valid pointer p_current_scope = %p \n",current_scope,p_current_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_current_scope != NULL && current_scope != NULL && p_current_scope != current_scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_current_scope = current_scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13656 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// SgUnparse_Info SgNO_UNPARSE_INFO;
extern void printSgVariant(std::ostream&,int);

// DQ (1/11/2004): Remove this static member and make it a member pointer
// Declaration of static member to support unparsing complex structures
SgTypePtrList SgUnparse_Info::p_structureTagProcessingList;

/*! \brief Debugging support 

     Debugging support to test correctness of the implementation the SgUnparse_Info 
     object as an inherited attribute in the unparser.
 */
bool SgUnparse_Info::p_forceDefaultConstructorToTriggerError = false;

bool
SgUnparse_Info::get_forceDefaultConstructorToTriggerError()
   {
     return p_forceDefaultConstructorToTriggerError;
   }
 
void
SgUnparse_Info::set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError)
   {
     p_forceDefaultConstructorToTriggerError = forceDefaultConstructorToTriggerError;
   }
 


// Default constructor defined here because the automatically generated constructor
// would not be generated with the error checking that I require to debug the use of
// the SgUnparse_Info object as an inherited attribute in the unparser.
SgUnparse_Info::SgUnparse_Info (  )
   : SgSupport()
   {
     static int counter = 0;
     counter++;

#ifdef DEBUG
     printf ("In SgUnparse_Info::SgUnparse_Info () sage_class_name() = %s counter = %d \n",sage_class_name(),counter);
#endif

  // Supporting error checking for test of SgUnparse_Info as an inherited attribute in the unparser
     if (p_forceDefaultConstructorToTriggerError == true)
        {
          printf ("SgUnparse_Info constructor called in inappropriate location (part of debugging code) counter = %d \n",counter);
          ROSE_ABORT();
        }

  // Test the variant virtual function
     assert(Unparse_InfoTag == variant());
     post_construction_initialization();

  // printf ("p_unparse_attribute.size() = %zu \n",p_unparse_attribute.size());
  // printf ("SgNO_UNPARSE_INFO.p_unparse_attribute.size() = %zu \n",SgNO_UNPARSE_INFO.p_unparse_attribute.size());
     ROSE_ASSERT (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // ROSE_ASSERT (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Test the isSgUnparse_Info() function since it has been problematic
     assert(isSgUnparse_Info(this) != NULL);
   }

std::string
getSgVariant ( int variant )
   {
  // Return a string associated with the input variant!
  // check to make sure we have the correct variant and a valid string
     ROSE_ASSERT(variant == Cxx_GrammarTerminalNames[variant].variant);

     return Cxx_GrammarTerminalNames[variant].name;
   }

SgUnparse_Info::SgUnparse_Info ( const SgUnparse_Info & X )
   : SgSupport()
   {
     ROSE_ASSERT (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     *this = X;

     ROSE_ASSERT (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // ROSE_ASSERT (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
   }

SgUnparse_Info & SgUnparse_Info::operator= ( const SgUnparse_Info & X )
   {
     p_unparse_attribute = X.p_unparse_attribute;
     p_access_attribute  = X.p_access_attribute;
     p_nested_expression = X.p_nested_expression;
     p_operator_name     = X.p_operator_name;
     p_var_name          = X.p_var_name;
     p_declstatement_ptr = X.p_declstatement_ptr;
     p_current_context   = X.p_current_context;
     p_array_index_list  = X.p_array_index_list;

  // DQ (11/6/2004): aded initialization of namespace context
     p_current_namespace = X.p_current_namespace;

  // DQ (1/11/2003): Part of bug fix for problems with implementation as a static member
  // Copy the STL list (not required now that it is a static data member
  // p_structureTagProcessingList = X.p_structureTagProcessingList;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = X.p_outputCodeGenerationFormatDelimiters;

     ROSE_ASSERT (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
     ROSE_ASSERT (p_unparse_attribute.size()   == UNPARSE_TYPE_LAST);
  // ROSE_ASSERT (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList = X.p_qualifiedNameList;

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = X.p_current_function_call;

  // DQ (5/22/2007): Added to support name qualification and access to the new hidden 
  // type, declaration and class elaboration lists stored in the scopes.
     p_current_scope = X.p_current_scope;

     return *this;
   }

// DQ (11/4/2003): changed input parameter of "unsigned int" to "unparse_type_num"
// so that we could support 64 bit long bitwise operations.
// DQ (12/6/2003): Modified again to use vector<bool> instead of "long long int".

int
SgUnparse_Info::checkBit(unparse_type_num bit) const
   {
  // if(p_unparse_attribute & bit) return 1; else return 0;
  // bool returnValue = false;
  // if (p_unparse_attribute[bit]) 
  //      returnValue = true;
  // return returnValue;

     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (bit > 0);
     ROSE_ASSERT (bit < UNPARSE_TYPE_LAST);
     ROSE_ASSERT (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     return p_unparse_attribute[bit];
   }

void
SgUnparse_Info::setBit(unparse_type_num bit)
   { 
  // p_unparse_attribute |= bit; 

     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (bit > 0);
     ROSE_ASSERT (bit < UNPARSE_TYPE_LAST);
     ROSE_ASSERT (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = true;
   }

void
SgUnparse_Info::unsetBit(unparse_type_num bit)
   { 
  // p_unparse_attribute &= ~bit;

     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (bit > 0);
     ROSE_ASSERT (bit < UNPARSE_TYPE_LAST);
     ROSE_ASSERT (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = false;
   }

void
SgUnparse_Info::post_construction_initialization()
   {
  // DQ (11/4/2003): Modified initialization from "0" to "NULL"
  // and "" for non-integer values

     ROSE_ASSERT (this != NULL);

  // Clear all bit flags
  // p_unparse_attribute = b_enum_defaultValue;
     for (int i = 0; i < UNPARSE_TYPE_LAST; i++)
        {
          p_unparse_attribute.push_back(false);
        }
     ROSE_ASSERT (p_unparse_attribute.size() > 0);

     p_access_attribute  = a_unset_access;
     p_nested_expression = false;
     p_operator_name     = "";
     p_var_name          = "";
     p_declstatement_ptr = NULL;
     p_current_context   = NULL;
     p_array_index_list  = "";

  // DQ (11/6/2004): Added initialization of namespace context (error reported valgrind)
     p_current_namespace = NULL;

  // DQ (1/12/2003): If calling constructor then empty the list
  // constructors (except copy constructor) are only call in the 
  // initiation of a unparser traversal (precisely where there 
  // is no context yet build up).
  
  // printf ("p_structureTagProcessingList.size() = %zu \n",p_structureTagProcessingList.size());
     if (p_structureTagProcessingList.empty() != true)
        {
       // empty the list (using STL list's assignment operator)
          SgTypePtrList emptyList;
          p_structureTagProcessingList = emptyList;
        }

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = false;

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList = NULL;

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = NULL;

  // DQ (6/2/2007): Added initialization of new data member.
     p_current_scope = NULL;
   }

int
SgUnparse_Info::isUnsetAccess() const
   { return p_access_attribute == a_unset_access; }

void
SgUnparse_Info::set_isUnsetAccess()
   { p_access_attribute = a_unset_access; }

int
SgUnparse_Info::isPrivateAccess() const
   { return p_access_attribute == a_private_access; }

void
SgUnparse_Info::set_isPrivateAccess()
   { p_access_attribute = a_private_access; }

int
SgUnparse_Info::isProtectedAccess() const
   { return p_access_attribute == a_protected_access; }

void
SgUnparse_Info::set_isProtectedAccess()
   { p_access_attribute = a_protected_access; } 
int
SgUnparse_Info::isPublicAccess() const
   { return p_access_attribute == a_public_access; }
void
SgUnparse_Info::set_isPublicAccess()
   { p_access_attribute = a_public_access; }  

int
SgUnparse_Info::isPointerToSomething() const
   { return checkBit(b_isPointerToSomething); }
void
SgUnparse_Info::set_isPointerToSomething()
   { setBit(b_isPointerToSomething); }
void
SgUnparse_Info::unset_isPointerToSomething()
   { unsetBit(b_isPointerToSomething); }

int
SgUnparse_Info::isReferenceToSomething() const
   { return checkBit(b_isReferenceToSomething); }

void
SgUnparse_Info::set_isReferenceToSomething()
   { setBit(b_isReferenceToSomething); }

void
SgUnparse_Info::unset_isReferenceToSomething()
   { unsetBit(b_isReferenceToSomething); }

int
SgUnparse_Info::inVarDecl() const
   { return checkBit(b_inVarDecl); }

void
SgUnparse_Info::set_inVarDecl()
   { setBit(b_inVarDecl); }

void
SgUnparse_Info::unset_inVarDecl()
   { unsetBit(b_inVarDecl); }

int
SgUnparse_Info::inArgList() const
   { return checkBit(b_inArgList); }

void
SgUnparse_Info::set_inArgList()
   { setBit(b_inArgList); }

void
SgUnparse_Info::unset_inArgList()
   { unsetBit(b_inArgList); }

int
SgUnparse_Info::SkipSemiColon() const
   { return checkBit(b_SkipSemiColon); }

void
SgUnparse_Info::set_SkipSemiColon()
   { setBit(b_SkipSemiColon); }

void
SgUnparse_Info::unset_SkipSemiColon()
   { unsetBit(b_SkipSemiColon); }

int
SgUnparse_Info::inEnumDecl() const
   { return checkBit(b_inEnumDecl); }

void
SgUnparse_Info::set_inEnumDecl()
   { setBit(b_inEnumDecl); }

void
SgUnparse_Info::unset_inEnumDecl()
   { unsetBit(b_inEnumDecl); }

int
SgUnparse_Info::inTemplateList() const
   { return checkBit(b_inTemplateList); }

void
SgUnparse_Info::set_inTemplateList()
   { setBit(b_inTemplateList); }

void
SgUnparse_Info::unset_inTemplateList()
   { unsetBit(b_inTemplateList); }

int
SgUnparse_Info::SkipBaseType() const
   { return checkBit(b_SkipBaseType); }

void
SgUnparse_Info::set_SkipBaseType()
   { setBit(b_SkipBaseType); }

void
SgUnparse_Info::unset_SkipBaseType()
   { unsetBit(b_SkipBaseType); }

int
SgUnparse_Info::inAggregateInitializer() const
   { return checkBit(b_inAggregateInitializer); }

void
SgUnparse_Info::set_inAggregateInitializer()
   { setBit(b_inAggregateInitializer); }

void
SgUnparse_Info::unset_inAggregateInitializer()
   { unsetBit(b_inAggregateInitializer); }

int
SgUnparse_Info::isWithType() const
   { return checkBit(b_isWithType); }

void
SgUnparse_Info::set_isWithType()
   { setBit(b_isWithType); }

void
SgUnparse_Info::unset_isWithType()
   { unsetBit(b_isWithType); }

int
SgUnparse_Info::inConditional() const
   { return checkBit(b_inConditional); }

void
SgUnparse_Info::set_inConditional()
   { setBit(b_inConditional); }

void
SgUnparse_Info::unset_inConditional()
   { unsetBit(b_inConditional); }

// DQ (1/23/03) Modified use of SkipDefinition to separate the functionality across
// different types of definitions (Enum, Function, and Class definitions).
int
SgUnparse_Info::SkipDefinition() const
   { // return checkBit(b_SkipDefinition);
     return checkBit(b_SkipEnumDefinition) && 
            checkBit(b_SkipFunctionDefinition) && 
            checkBit(b_SkipClassDefinition);
   }

void
SgUnparse_Info::set_SkipDefinition()
   { 
  // setBit(b_SkipDefinition); 
     setBit(b_SkipEnumDefinition); 
     setBit(b_SkipFunctionDefinition); 
     setBit(b_SkipClassDefinition); 
   }

void
SgUnparse_Info::unset_SkipDefinition()
   {
  // unsetBit(b_SkipDefinition);
     unsetBit(b_SkipEnumDefinition);
     unsetBit(b_SkipFunctionDefinition);
     unsetBit(b_SkipClassDefinition);
   }

int
SgUnparse_Info::SkipClassSpecifier() const
   { return checkBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::set_SkipClassSpecifier()
   { setBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::unset_SkipClassSpecifier()
   { unsetBit(b_SkipClassSpecifier); }

int
SgUnparse_Info::inEmbeddedDecl() const
   { return checkBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::set_inEmbeddedDecl()
   { setBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::unset_inEmbeddedDecl()
   { unsetBit(b_inEmbeddedDecl); }

int
SgUnparse_Info::SkipGlobal() const
   { return checkBit(b_SkipGlobal); }

void
SgUnparse_Info::set_SkipGlobal()
   { setBit(b_SkipGlobal); }

void
SgUnparse_Info::unset_SkipGlobal()
   { unsetBit(b_SkipGlobal); }

int
SgUnparse_Info::SkipAtomic() const
   { return checkBit(b_SkipAtomic); }

void
SgUnparse_Info::set_SkipAtomic()
   { setBit(b_SkipAtomic); }

void
SgUnparse_Info::unset_SkipAtomic()
   { unsetBit(b_SkipAtomic); }

int
SgUnparse_Info::PrintName() const
   { return checkBit(b_PrintName); }

void
SgUnparse_Info::set_PrintName()
   { if(!p_var_name.is_null()) setBit(b_PrintName); }

void
SgUnparse_Info::unset_PrintName()
   { unsetBit(b_PrintName); }

int
SgUnparse_Info::CheckAccess() const
   { return checkBit(b_CheckAccess); }

void
SgUnparse_Info::set_CheckAccess()
   { setBit(b_CheckAccess); }

void
SgUnparse_Info::unset_CheckAccess()
   { unsetBit(b_CheckAccess); }

int
SgUnparse_Info::SkipFunctionQualifier() const
   { return checkBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::set_SkipFunctionQualifier()
   { setBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::unset_SkipFunctionQualifier()
   { unsetBit(b_SkipFunctionQualifier); }

int
SgUnparse_Info::isArrayType() const
   { return checkBit(b_isArrayType); }

void
SgUnparse_Info::set_isArrayType()
   { setBit(b_isArrayType); }

void
SgUnparse_Info::unset_isArrayType()
   { unsetBit(b_isArrayType); }

int
SgUnparse_Info::inRhsExpr() const
   { return checkBit(b_inRhsExpr); }

void
SgUnparse_Info::set_inRhsExpr()
   { setBit(b_inRhsExpr); }

void
SgUnparse_Info::unset_inRhsExpr()
   { unsetBit(b_inRhsExpr); }

int
SgUnparse_Info::SkipParen() const
   { return checkBit(b_SkipParen); }

void
SgUnparse_Info::set_SkipParen()
   { setBit(b_SkipParen); }

void
SgUnparse_Info::unset_SkipParen()
   { unsetBit(b_SkipParen); }

int
SgUnparse_Info::isTypeSecondPart() const
   { return checkBit(b_isTypeSecondPart); }

void
SgUnparse_Info::set_isTypeSecondPart()  
   { setBit(b_isTypeSecondPart); unsetBit(b_isTypeFirstPart); }

void
SgUnparse_Info::unset_isTypeSecondPart()
   { unsetBit(b_isTypeSecondPart); }

int
SgUnparse_Info::isTypeFirstPart() const
   { return checkBit(b_isTypeFirstPart); }

void
SgUnparse_Info::set_isTypeFirstPart()  
   { setBit(b_isTypeFirstPart); unsetBit(b_isTypeSecondPart); }

void
SgUnparse_Info::unset_isTypeFirstPart()
   { unsetBit( b_isTypeFirstPart); }

std::string
SgUnparse_Info::get_operator_name()
   { return p_operator_name; }

void
SgUnparse_Info::set_operator_name(const std::string& on)
   {
     p_operator_name = on;
   }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
int
SgUnparse_Info::SkipInitializer() const
   { return checkBit(b_SkipInitializer); }

void
SgUnparse_Info::set_SkipInitializer()
   { setBit(b_SkipInitializer); }

void
SgUnparse_Info::unset_SkipInitializer()
   { unsetBit(b_SkipInitializer); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
int
SgUnparse_Info::SkipComments() const
   { return checkBit(b_SkipComments); }

void
SgUnparse_Info::set_SkipComments()
   { setBit(b_SkipComments); }

void
SgUnparse_Info::unset_SkipComments()
   { unsetBit(b_SkipComments); }

//! (09/03/03) MS: Added to make whitespace optional
int
SgUnparse_Info::SkipWhitespaces() const
   { return checkBit(b_SkipWhitespaces); }

void
SgUnparse_Info::set_SkipWhitespaces()
   { setBit(b_SkipWhitespaces); }

void
SgUnparse_Info::unset_SkipWhitespaces()
   { unsetBit(b_SkipWhitespaces); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
int
SgUnparse_Info::SkipCPPDirectives() const
   { return checkBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::set_SkipCPPDirectives()
   { setBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::unset_SkipCPPDirectives()
   { unsetBit(b_SkipCPPDirectives); }

int
SgUnparse_Info::SkipEnumDefinition() const
   { return checkBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::set_SkipEnumDefinition()
   { setBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::unset_SkipEnumDefinition()
   { unsetBit(b_SkipEnumDefinition); }

int
SgUnparse_Info::SkipFunctionDefinition() const
   { return checkBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::set_SkipFunctionDefinition()
   { setBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::unset_SkipFunctionDefinition()
   { unsetBit(b_SkipFunctionDefinition); }

int
SgUnparse_Info::SkipClassDefinition() const
   { return checkBit(b_SkipClassDefinition); }

void
SgUnparse_Info::set_SkipClassDefinition()
   { setBit(b_SkipClassDefinition); }

void
SgUnparse_Info::unset_SkipClassDefinition()
   { unsetBit(b_SkipClassDefinition); }

int
SgUnparse_Info::AddSemiColonAfterDeclaration() const
   { return checkBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::set_AddSemiColonAfterDeclaration()
   { setBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::unset_AddSemiColonAfterDeclaration()
   { unsetBit(b_AddSemiColonAfterDeclaration); }

int
SgUnparse_Info::SkipBasicBlock() const
   { return checkBit(b_SkipBasicBlock); }

void
SgUnparse_Info::set_SkipBasicBlock()
   { setBit(b_SkipBasicBlock); }

void
SgUnparse_Info::unset_SkipBasicBlock()
   { unsetBit(b_SkipBasicBlock); }

// DQ (3/18/2004): Added to support unparsing of class templates in variables but 
// not in in instatiated template declarations (unless the template is transformed 
// in which case another test is used).
int
SgUnparse_Info::outputClassTemplateName() const
   { return checkBit(b_outputClassTemplateName); }

void
SgUnparse_Info::set_outputClassTemplateName()
   { setBit(b_outputClassTemplateName); }

void
SgUnparse_Info::unset_outputClassTemplateName()
   { unsetBit(b_outputClassTemplateName); }

// DQ (5/27/2005): support (see documentation above, in header file enum value)
int
SgUnparse_Info::outputCompilerGeneratedStatements() const
   { return checkBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::set_outputCompilerGeneratedStatements()
   { setBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::unset_outputCompilerGeneratedStatements()
   { unsetBit(b_outputCompilerGeneratedStatements); }


// DQ (4/5/2006): Added support for constant folded values to be optionally output
int
SgUnparse_Info::SkipConstantFoldedExpressions() const
   { return checkBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::set_SkipConstantFoldedExpressions()
   { setBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::unset_SkipConstantFoldedExpressions()
   { unsetBit(b_SkipConstantFoldedExpressions); }


// DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
int
SgUnparse_Info::forceQualifiedNames() const
   { return checkBit(b_forceQualifiedNames); }

void
SgUnparse_Info::set_forceQualifiedNames()
   { setBit(b_forceQualifiedNames); }

void
SgUnparse_Info::unset_forceQualifiedNames()
   { unsetBit(b_forceQualifiedNames); }

int
SgUnparse_Info::skipCheckAccess() const
   { return checkBit(b_skipCheckAccess); }

void
SgUnparse_Info::set_skipCheckAccess()
   { setBit(b_skipCheckAccess); }

void
SgUnparse_Info::unset_skipCheckAccess()
   { unsetBit(b_skipCheckAccess); }

// DQ (10/11/2006): Added to support new implementation of name qualification
int
SgUnparse_Info::SkipQualifiedNames() const
   { return checkBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::set_SkipQualifiedNames()
   { setBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::unset_SkipQualifiedNames()
   { unsetBit(b_SkipQualifiedNames); }

int
SgUnparse_Info::requiresGlobalNameQualification() const
   { return checkBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::set_requiresGlobalNameQualification()
   { setBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::unset_requiresGlobalNameQualification()
   { unsetBit(b_requiresGlobalNameQualification); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
int
SgUnparse_Info::useTypeAttributes() const
   { return checkBit(b_useTypeAttributes); }

void
SgUnparse_Info::set_useTypeAttributes()
   { setBit(b_useTypeAttributes); }

void
SgUnparse_Info::unset_useTypeAttributes()
   { unsetBit(b_useTypeAttributes); }


SgName&
SgUnparse_Info::get_name()
   { return p_var_name; }

void
SgUnparse_Info::set_name(const SgName& name)
   { p_var_name = name; set_PrintName(); }

void
SgUnparse_Info::unset_name()
   {
     unset_PrintName(); 
     p_var_name=0;
   }

SgDeclarationStatement*
SgUnparse_Info::get_decl_stmt()
   { return p_declstatement_ptr; }

void
SgUnparse_Info::set_decl_stmt(SgDeclarationStatement* stmt )
   { p_declstatement_ptr = stmt; }

void
SgUnparse_Info::unset_decl_stmt()
   { p_declstatement_ptr=0; }

int
SgUnparse_Info::get_nested_expression()
   { return p_nested_expression; }

void
SgUnparse_Info::set_nested_expression()
   { p_nested_expression++; }

void
SgUnparse_Info::unset_nested_expression()
   { p_nested_expression--; }

void
SgUnparse_Info::unset_current_context()
   { p_current_context = NULL; }

SgName
SgUnparse_Info::get_array_index_list()
{ return p_array_index_list; }

void
SgUnparse_Info::set_array_index_list(SgExpression *e, SgUnparse_Info finfo )
   {
#if 1
     printf ("ERROR: not implemented in SAGE3! \n");
     ROSE_ABORT();
#else
     p_array_index_list << "[";
     ostringstream buffer;
     if(e) e->unparse(finfo,buffer);
     p_array_index_list << buffer.str() << "]";
#endif
   }

void
SgUnparse_Info::unset_array_index_list()
   { p_array_index_list=0; }

void
SgUnparse_Info::display ( const std::string & label ) const
   {
     printf ("Inside of SgUnparse_Info::display(%s) \n",label.c_str());

#if 0
#define PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) printf (#XX" = %s \n",(XX() == true) ? "true" : "false");

     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)
#else
  // DQ: Note that this provides better formatting of the output!
     printf ("isPointerToSomething                   = %s \n",( isPointerToSomething() == true ) ? "true" : "false");
     printf ("isReferenceToSomething                 = %s \n",( isReferenceToSomething() == true ) ? "true" : "false");
     printf ("inVarDecl                              = %s \n",( inVarDecl() == true ) ? "true" : "false");
     printf ("inArgList                              = %s \n",( inArgList() == true ) ? "true" : "false");
     printf ("SkipSemiColon                          = %s \n",( SkipSemiColon() == true ) ? "true" : "false");
     printf ("inEnumDecl                             = %s \n",( inEnumDecl() == true ) ? "true" : "false");
     printf ("inTemplateList                         = %s \n",( inTemplateList() == true ) ? "true" : "false");
     printf ("SkipBaseType                           = %s \n",( SkipBaseType() == true ) ? "true" : "false");
     printf ("inAggregateInitializer                 = %s \n",( inAggregateInitializer() == true ) ? "true" : "false");
     printf ("isWithType                             = %s \n",( isWithType() == true ) ? "true" : "false");
     printf ("inConditional                          = %s \n",( inConditional() == true ) ? "true" : "false");
     printf ("SkipDefinition                         = %s \n",( SkipDefinition() == true ) ? "true" : "false");
     printf ("SkipClassSpecifier                     = %s \n",( SkipClassSpecifier() == true ) ? "true" : "false");
     printf ("inEmbeddedDecl                         = %s \n",( inEmbeddedDecl() == true ) ? "true" : "false");
     printf ("SkipGlobal                             = %s \n",( SkipGlobal() == true ) ? "true" : "false");
     printf ("SkipAtomic                             = %s \n",( SkipAtomic() == true ) ? "true" : "false");
     printf ("PrintName                              = %s \n",( PrintName() == true ) ? "true" : "false");
     printf ("CheckAccess                            = %s \n",( CheckAccess() == true ) ? "true" : "false");
     printf ("SkipFunctionQualifier                  = %s \n",( SkipFunctionQualifier() == true ) ? "true" : "false");
     printf ("isArrayType                            = %s \n",( isArrayType() == true ) ? "true" : "false");
     printf ("inRhsExpr                              = %s \n",( inRhsExpr() == true ) ? "true" : "false");
     printf ("SkipParen                              = %s \n",( SkipParen() == true ) ? "true" : "false");
     printf ("isTypeSecondPart                       = %s \n",( isTypeSecondPart() == true ) ? "true" : "false");
     printf ("isTypeFirstPart                        = %s \n",( isTypeFirstPart() == true ) ? "true" : "false");
     printf ("SkipInitializer                        = %s \n",( SkipInitializer() == true ) ? "true" : "false");
     printf ("SkipComments                           = %s \n",( SkipComments() == true ) ? "true" : "false");
     printf ("SkipCPPDirectives                      = %s \n",( SkipCPPDirectives() == true ) ? "true" : "false");
     printf ("SkipEnumDefinition                     = %s \n",( SkipEnumDefinition() == true ) ? "true" : "false");
     printf ("SkipFunctionDefinition                 = %s \n",( SkipFunctionDefinition() == true ) ? "true" : "false");
     printf ("SkipClassDefinition                    = %s \n",( SkipClassDefinition() == true ) ? "true" : "false");
     printf ("AddSemiColonAfterDeclaration           = %s \n",( AddSemiColonAfterDeclaration() == true ) ? "true" : "false");
     printf ("SkipWhitespaces                        = %s \n",( SkipWhitespaces() == true ) ? "true" : "false");
     printf ("SkipBasicBlock                         = %s \n",( SkipBasicBlock() == true ) ? "true" : "false");
     printf ("outputClassTemplateName                = %s \n",( outputClassTemplateName() == true ) ? "true" : "false");
     printf ("outputCompilerGeneratedStatements      = %s \n",( outputCompilerGeneratedStatements() == true ) ? "true" : "false");
     printf ("SkipConstantFoldedExpressions          = %s \n",( SkipConstantFoldedExpressions() == true ) ? "true" : "false");
     printf ("forceQualifiedNames                    = %s \n",( forceQualifiedNames() == true ) ? "true" : "false");
     printf ("SkipQualifiedNames                     = %s \n",( SkipQualifiedNames() == true ) ? "true" : "false");
     printf ("skipCheckAccess                        = %s \n",( skipCheckAccess() == true ) ? "true" : "false");
     printf ("requiresGlobalNameQualification        = %s \n",( requiresGlobalNameQualification() == true ) ? "true" : "false");
#endif

     switch (p_access_attribute)
        {
          case a_unset_access:
               printf ("p_access                               = unset access \n");
               break;
          case a_private_access:
               printf ("p_access                               = private access \n");
               break;
          case a_protected_access:
               printf ("p_access                               = protected access \n");
               break;
          case a_public_access:
               printf ("p_access                               = public access \n");
               break;
          default:
               printf ("Error: default reached in switch \n");
               ROSE_ASSERT(false);
        }

  // DQ (1/26/2006): Modified to handle 64 bit machines
     printf ("p_structureTagProcessingList.size()    = %zu \n", p_structureTagProcessingList.size());
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          printf ("--- structure tag pointer = %p class name = %s \n",*i,(*i)->sage_class_name());

          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               printf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     printf ("p_nested_expression                    = %d \n",p_nested_expression);
     printf ("p_operator_name                        = %s \n", p_operator_name.c_str());
     printf ("p_var_name                             = %s \n",(p_var_name.is_null() == false) ? p_var_name.str() : "EmPtY sTrInG");
     printf ("p_declstatement_ptr                    = %p \n",p_declstatement_ptr);
     printf ("p_current_context                      = %p \n",p_current_context);
     printf ("p_array_index_list                     = %s \n",(p_array_index_list.is_null() == false) ? p_array_index_list.str() : "EmPtY sTrInG");
     printf ("p_current_namespace                    = %p \n",p_current_namespace);
     printf ("p_outputCodeGenerationFormatDelimiters = %s \n",p_outputCodeGenerationFormatDelimiters ? "true" : "false");
     printf ("p_current_function_call                = %p \n",p_current_function_call);
   }

string
SgUnparse_Info::displayString ( const std::string & label ) const
   {
  // using namespace std;
     std::string returnString = std::string("Inside of SgUnparse_Info::display( ") + label + std::string(" )\n");

#define STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) \
     returnString += std::string("     ") + std::string(#XX) + std::string(" = ") + std::string((XX() == true) ? "true" : "false") + std::string(" \n");

     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)

     switch (p_access_attribute)
        {
          case a_unset_access:
               returnString += std::string("p_access = unset access \n");
               break;
          case a_private_access:
               returnString += std::string("p_access = private access \n");
               break;
          case a_protected_access:
               returnString += std::string("p_access = protected access \n");
               break;
          case a_public_access:
               returnString += std::string("p_access = public access \n");
               break;
          default:
               printf("Error: default reached in switch \n");
               ROSE_ASSERT(false);
        }

     returnString += std::string("p_structureTagProcessingList.size() = ") + 
                     StringUtility::numberToString(p_structureTagProcessingList.size()) + std::string("\n");
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          returnString += std::string("--- structure tag pointer = ") + 
                          StringUtility::numberToString((void*)(*i)) + 
                          std::string("= class name = ") + std::string((*i)->sage_class_name()) + std::string("\n");
          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               returnString += std::string("     Class name = ") + std::string(classType->get_name().str()) + std::string("\n");
            // printf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     return returnString;
   }

void
SgUnparse_Info::addStructureTag ( SgNamedType* structureTag )
   {
  // push the pointer to the back of the list
     p_structureTagProcessingList.push_back(structureTag);
   }

SgTypePtrList &
SgUnparse_Info::getStructureTagList ()
   {
  // Access function for internal STL list
     return p_structureTagProcessingList;
   }

#if 0
// DQ (9/6/2004): Support for list of scopes required to qualify names (e.g. types, data members, member functions, etc.)
SgSymbolPtrList &
SgUnparse_Info::get_listOfScopeSymbols()
   {
     return p_listOfScopeSymbols;
   }

void
SgUnparse_Info::set_listOfScopeSymbols ( const SgSymbolPtrList & l )
   {
     p_listOfScopeSymbols = l;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnparse_Info::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnparse_Info::variantT() const {
  return V_SgUnparse_Info;
}

#if 0
int
SgUnparse_Info::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return Unparse_InfoTag;
   }
#endif

const char*
SgUnparse_Info::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnparse_Info";  
   }

std::string
SgUnparse_Info::class_name() const
   {
     assert(this != NULL);
     return "SgUnparse_Info";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnparse_Info::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnparse_Info::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != Unparse_InfoTag)
        {
          printf ("Error in SgUnparse_Info::error(): SgUnparse_Info object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnparse_Info::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == Unparse_InfoTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnparse_Info::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnparse_Info::variant() const \n");
#endif
     assert(this != NULL);
     return Unparse_InfoTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnparse_Info* isSgUnparse_Info ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnparse_Info*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnparse_Info* isSgUnparse_Info ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnparse_Info*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnparse_Info::~SgUnparse_Info ()
   {
#if 0
  // debugging information!
     printf ("In SgUnparse_Info::~SgUnparse_Info (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for access_attribute
     p_access_attribute = 0; // non list case 
  // case: not a listType for nested_expression
     p_nested_expression = 0; // non list case 
  // case: not a listType for operator_name
     p_operator_name = ""; // non list case 
  // case: not a listType for var_name
     p_var_name = ""; // non list case 
  // case: not a listType for declstatement_ptr
     p_declstatement_ptr = NULL; // non list case 
  // case: not a listType for current_context
     p_current_context = NULL; // non list case 
  // case: not a listType for array_index_list
     p_array_index_list = ""; // non list case 
  // case: not a listType for current_namespace
     p_current_namespace = NULL; // non list case 
  // case: not a listType for outputCodeGenerationFormatDelimiters
     p_outputCodeGenerationFormatDelimiters = false; // non list case 
  // case: listType for qualifiedNameList
  // case: listType (typeIsPointerToList == true) for qualifiedNameList
     p_qualifiedNameList = NULL;
  // case: not a listType for current_function_call
     p_current_function_call = NULL; // non list case 
  // case: not a listType for current_scope
     p_current_scope = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDeclaration* 
SgBaseClass::get_base_class () const
   {
     assert (this != NULL);
     return p_base_class;
   }

void
SgBaseClass::set_base_class ( SgClassDeclaration* base_class )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_class != NULL && base_class != NULL && p_base_class != base_class)
        {
          printf ("Warning: base_class = %p overwriting valid pointer p_base_class = %p \n",base_class,p_base_class);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_class != NULL && base_class != NULL && p_base_class != base_class) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_class = base_class;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgBaseClass::get_isDirectBaseClass () const
   {
     assert (this != NULL);
     return p_isDirectBaseClass;
   }

void
SgBaseClass::set_isDirectBaseClass ( bool isDirectBaseClass )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_isDirectBaseClass = isDirectBaseClass;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 6297 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


void
SgBaseClass::post_construction_initialization()
   {
  // DQ (4/25/2004): Note that because of limitiations in the ordering of output 
  // class declarations in ROSETTA, I was unable make this SgBaseClassModifier a 
  // data member and was forced to handle it as a pointer).
     p_baseClassModifier = new SgBaseClassModifier();
     ROSE_ASSERT ( p_baseClassModifier != NULL);
   }

#if 0
// This function should be autogenerated
SgBaseClass::SgBaseClass(int specifier ,SgClassDeclaration* ptr, int dir)
   : p_specifier(specifier), p_ptr(ptr), p_isDirectBaseClass(dir)
   {
   }
#endif

SgBaseClass::SgBaseClass(const SgBaseClass& X)
   {
  // these are the old names
  // p_specifier = ptr.p_specifier;
  // p_ptr       = ptr.p_ptr;
  // p_base_specifier = X.p_base_specifier;
     p_base_class     = X.p_base_class;

  // DQ (6/21/2005): Commented out since it is not used, we might want it later!
  // DQ: initialize all values
     p_isDirectBaseClass = 0;

     ROSE_ASSERT ( X.p_baseClassModifier != NULL);
     p_baseClassModifier = new SgBaseClassModifier( *(X.p_baseClassModifier) );
     ROSE_ASSERT ( p_baseClassModifier != NULL);
   }

#if 0
// generated automatically
SgBaseClass::~SgBaseClass()
   {
  /* delete p_ptr; */
   }
#endif

SgBaseClass &
SgBaseClass::operator= (const SgBaseClass & X)
   {
  // Old names
  // p_specifier = ptr.p_specifier;
  // p_direct    = ptr.p_direct; 
  // p_ptr       = ptr.p_ptr;

  // p_base_specifier     = X.p_base_specifier;
     p_base_class         = X.p_base_class;

  // DQ (6/21/2005): Renamed to make this more clear
     p_isDirectBaseClass  = X.p_isDirectBaseClass;

     ROSE_ASSERT (p_baseClassModifier   != NULL);
     ROSE_ASSERT (X.p_baseClassModifier != NULL);
     *p_baseClassModifier = *X.p_baseClassModifier;

     return *this;
   }

#if 0
// These are automatically generated now!
int
SgBaseClass::get_base_specifier() const
   { return p_specifier; }

SgClassDeclaration*
SgBaseClass::get_base_class() const
   { return p_ptr; }
#endif

#if 0
// DQ: I don't think this is used anywhere
SgClassDeclaration*
replace_base_class(SgClassDeclaration *);
#endif

// I assume these relational member functions are added to permit use with STL
bool
SgBaseClass::operator== (const SgBaseClass& ) const
   { return false; }

bool
SgBaseClass::operator< (const SgBaseClass&) const
   { return false; }

// DQ (4/25/2004): Part of new modifier interface
SgBaseClassModifier & 
SgBaseClass::get_baseClassModifier()
   {
     ROSE_ASSERT ( p_baseClassModifier != NULL);
     return *p_baseClassModifier;
   }
 


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBaseClass::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBaseClass::variantT() const {
  return V_SgBaseClass;
}

#if 0
int
SgBaseClass::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BaseClassTag;
   }
#endif

const char*
SgBaseClass::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBaseClass";  
   }

std::string
SgBaseClass::class_name() const
   {
     assert(this != NULL);
     return "SgBaseClass";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBaseClass::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBaseClass::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BaseClassTag)
        {
          printf ("Error in SgBaseClass::error(): SgBaseClass object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBaseClass::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BaseClassTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBaseClass::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBaseClass::variant() const \n");
#endif
     assert(this != NULL);
     return BaseClassTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBaseClass* isSgBaseClass ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBaseClass*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBaseClass* isSgBaseClass ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBaseClass*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBaseClass::~SgBaseClass ()
   {
#if 0
  // debugging information!
     printf ("In SgBaseClass::~SgBaseClass (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_baseClassModifier;

  // case: not a listType for base_class
     p_base_class = NULL; // non list case 
  // case: not a listType for isDirectBaseClass
     p_isDirectBaseClass = false; // non list case 
  // case: not a listType for baseClassModifier
     p_baseClassModifier = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBaseClass::SgBaseClass ( SgClassDeclaration* base_class, bool isDirectBaseClass )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgBaseClass::SgBaseClass (SgClassDeclaration* base_class, bool isDirectBaseClass) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_class = base_class;
     p_isDirectBaseClass = isDirectBaseClass;
     p_baseClassModifier = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(BaseClassTag == variant());
     post_construction_initialization();

  // Test the isSgBaseClass() function since it has been problematic
     assert(isSgBaseClass(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 14762 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

const SgTypePtrList & 
SgTypedefSeq::get_typedefs() const 
   { return p_typedefs; }

SgTypePtrList & 
SgTypedefSeq::get_typedefs() 
   { return p_typedefs; }

void
SgTypedefSeq::append_typedef( SgType* what) 
   {
     insert_typedef(p_typedefs.end(),what);
   }

void
SgTypedefSeq::insert_typedef(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_typedefs.insert(where,what);
   }


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypedefSeq::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypedefSeq::variantT() const {
  return V_SgTypedefSeq;
}

#if 0
int
SgTypedefSeq::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_TYPEDEF_SEQ;
   }
#endif

const char*
SgTypedefSeq::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypedefSeq";  
   }

std::string
SgTypedefSeq::class_name() const
   {
     assert(this != NULL);
     return "SgTypedefSeq";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypedefSeq::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypedefSeq::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_TYPEDEF_SEQ)
        {
          printf ("Error in SgTypedefSeq::error(): SgTypedefSeq object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypedefSeq::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_TYPEDEF_SEQ);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypedefSeq::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypedefSeq::variant() const \n");
#endif
     assert(this != NULL);
     return T_TYPEDEF_SEQ;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypedefSeq* isSgTypedefSeq ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypedefSeq*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypedefSeq* isSgTypedefSeq ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypedefSeq*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypedefSeq::~SgTypedefSeq ()
   {
#if 0
  // debugging information!
     printf ("In SgTypedefSeq::~SgTypedefSeq (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypedefSeq::SgTypedefSeq (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgTypedefSeq::SgTypedefSeq () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_TYPEDEF_SEQ == variant());
     post_construction_initialization();

  // Test the isSgTypedefSeq() function since it has been problematic
     assert(isSgTypedefSeq(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateParameter::template_parameter_enum 
SgTemplateParameter::get_parameterType () const
   {
     assert (this != NULL);
     return p_parameterType;
   }

void
SgTemplateParameter::set_parameterType ( SgTemplateParameter::template_parameter_enum parameterType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_parameterType = parameterType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgTemplateParameter::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgTemplateParameter::set_type ( SgType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgTemplateParameter::get_defaultTypeParameter () const
   {
     assert (this != NULL);
     return p_defaultTypeParameter;
   }

void
SgTemplateParameter::set_defaultTypeParameter ( SgType* defaultTypeParameter )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_defaultTypeParameter != NULL && defaultTypeParameter != NULL && p_defaultTypeParameter != defaultTypeParameter)
        {
          printf ("Warning: defaultTypeParameter = %p overwriting valid pointer p_defaultTypeParameter = %p \n",defaultTypeParameter,p_defaultTypeParameter);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_defaultTypeParameter != NULL && defaultTypeParameter != NULL && p_defaultTypeParameter != defaultTypeParameter) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_defaultTypeParameter = defaultTypeParameter;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgTemplateParameter::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgTemplateParameter::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgTemplateParameter::get_defaultExpressionParameter () const
   {
     assert (this != NULL);
     return p_defaultExpressionParameter;
   }

void
SgTemplateParameter::set_defaultExpressionParameter ( SgExpression* defaultExpressionParameter )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_defaultExpressionParameter != NULL && defaultExpressionParameter != NULL && p_defaultExpressionParameter != defaultExpressionParameter)
        {
          printf ("Warning: defaultExpressionParameter = %p overwriting valid pointer p_defaultExpressionParameter = %p \n",defaultExpressionParameter,p_defaultExpressionParameter);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_defaultExpressionParameter != NULL && defaultExpressionParameter != NULL && p_defaultExpressionParameter != defaultExpressionParameter) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_defaultExpressionParameter = defaultExpressionParameter;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateParameter::get_templateDeclaration () const
   {
     assert (this != NULL);
     return p_templateDeclaration;
   }

void
SgTemplateParameter::set_templateDeclaration ( SgTemplateDeclaration* templateDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration)
        {
          printf ("Warning: templateDeclaration = %p overwriting valid pointer p_templateDeclaration = %p \n",templateDeclaration,p_templateDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_templateDeclaration = templateDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateParameter::get_defaultTemplateDeclarationParameter () const
   {
     assert (this != NULL);
     return p_defaultTemplateDeclarationParameter;
   }

void
SgTemplateParameter::set_defaultTemplateDeclarationParameter ( SgTemplateDeclaration* defaultTemplateDeclarationParameter )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_defaultTemplateDeclarationParameter != NULL && defaultTemplateDeclarationParameter != NULL && p_defaultTemplateDeclarationParameter != defaultTemplateDeclarationParameter)
        {
          printf ("Warning: defaultTemplateDeclarationParameter = %p overwriting valid pointer p_defaultTemplateDeclarationParameter = %p \n",defaultTemplateDeclarationParameter,p_defaultTemplateDeclarationParameter);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_defaultTemplateDeclarationParameter != NULL && defaultTemplateDeclarationParameter != NULL && p_defaultTemplateDeclarationParameter != defaultTemplateDeclarationParameter) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_defaultTemplateDeclarationParameter = defaultTemplateDeclarationParameter;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 14840 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


void SgTemplateParameter::post_construction_initialization()
   {
     p_parameterType                       = parameter_undefined;
     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;
   }

// Different constructors for use in building the different types of parameters possible
SgTemplateParameter::SgTemplateParameter ( SgType* parameter, SgType* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType        = type_parameter;
     p_type                 = parameter;
     p_defaultTypeParameter = defaultParameter;
   }

SgTemplateParameter::SgTemplateParameter ( SgExpression* parameter, SgExpression* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType              = nontype_parameter;
     p_expression                 = NULL;
     p_defaultExpressionParameter = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType                       = template_parameter;
     p_templateDeclaration                 = parameter;
     p_defaultTemplateDeclarationParameter = defaultParameter;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateParameter::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateParameter::variantT() const {
  return V_SgTemplateParameter;
}

#if 0
int
SgTemplateParameter::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TemplateParameterTag;
   }
#endif

const char*
SgTemplateParameter::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateParameter";  
   }

std::string
SgTemplateParameter::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateParameter";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateParameter::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateParameter::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TemplateParameterTag)
        {
          printf ("Error in SgTemplateParameter::error(): SgTemplateParameter object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateParameter::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TemplateParameterTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateParameter::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateParameter::variant() const \n");
#endif
     assert(this != NULL);
     return TemplateParameterTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateParameter* isSgTemplateParameter ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateParameter*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateParameter* isSgTemplateParameter ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateParameter*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateParameter::~SgTemplateParameter ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateParameter::~SgTemplateParameter (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for parameterType
     p_parameterType = parameter_undefined; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for defaultTypeParameter
     p_defaultTypeParameter = NULL; // non list case 
  // case: not a listType for expression
     p_expression = NULL; // non list case 
  // case: not a listType for defaultExpressionParameter
     p_defaultExpressionParameter = NULL; // non list case 
  // case: not a listType for templateDeclaration
     p_templateDeclaration = NULL; // non list case 
  // case: not a listType for defaultTemplateDeclarationParameter
     p_defaultTemplateDeclarationParameter = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateParameter::SgTemplateParameter ( SgTemplateParameter::template_parameter_enum parameterType, SgType* type, SgType* defaultTypeParameter, SgExpression* expression, SgExpression* defaultExpressionParameter, SgTemplateDeclaration* templateDeclaration, SgTemplateDeclaration* defaultTemplateDeclarationParameter )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgTemplateParameter::SgTemplateParameter (SgTemplateParameter::template_parameter_enum parameterType, SgType* type, SgType* defaultTypeParameter, SgExpression* expression, SgExpression* defaultExpressionParameter, SgTemplateDeclaration* templateDeclaration, SgTemplateDeclaration* defaultTemplateDeclarationParameter) sage_class_name() = %s \n",sage_class_name());
#endif

     p_parameterType = parameterType;
     p_type = type;
     p_defaultTypeParameter = defaultTypeParameter;
     p_expression = expression;
     p_defaultExpressionParameter = defaultExpressionParameter;
     p_templateDeclaration = templateDeclaration;
     p_defaultTemplateDeclarationParameter = defaultTemplateDeclarationParameter;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TemplateParameterTag == variant());
     post_construction_initialization();

  // Test the isSgTemplateParameter() function since it has been problematic
     assert(isSgTemplateParameter(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateArgument::template_argument_enum 
SgTemplateArgument::get_argumentType () const
   {
     assert (this != NULL);
     return p_argumentType;
   }

void
SgTemplateArgument::set_argumentType ( SgTemplateArgument::template_argument_enum argumentType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_argumentType = argumentType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTemplateArgument::get_isArrayBoundUnknownType () const
   {
     assert (this != NULL);
     return p_isArrayBoundUnknownType;
   }

void
SgTemplateArgument::set_isArrayBoundUnknownType ( bool isArrayBoundUnknownType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_isArrayBoundUnknownType = isArrayBoundUnknownType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgTemplateArgument::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgTemplateArgument::set_type ( SgType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgTemplateArgument::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgTemplateArgument::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateArgument::get_templateDeclaration () const
   {
     assert (this != NULL);
     return p_templateDeclaration;
   }

void
SgTemplateArgument::set_templateDeclaration ( SgTemplateDeclaration* templateDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration)
        {
          printf ("Warning: templateDeclaration = %p overwriting valid pointer p_templateDeclaration = %p \n",templateDeclaration,p_templateDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_templateDeclaration = templateDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTemplateArgument::get_explicitlySpecified () const
   {
     assert (this != NULL);
     return p_explicitlySpecified;
   }

void
SgTemplateArgument::set_explicitlySpecified ( bool explicitlySpecified )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_explicitlySpecified = explicitlySpecified;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 14884 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


void SgTemplateArgument::post_construction_initialization()
   {
     p_argumentType          = argument_undefined;
     p_type                  = NULL;
     p_expression            = NULL;
  // p_templateInstantiation = NULL;
     p_templateDeclaration = NULL;
   }

// Different constructors for use in building the different types of arguments possible
SgTemplateArgument::SgTemplateArgument ( SgType* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = type_argument;
     p_type                = argument;
     p_explicitlySpecified = explicitlySpecified;

  // Don't set the parent of a type!
  // argument->set_parent(this);
   }

SgTemplateArgument::SgTemplateArgument ( SgExpression* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = nontype_argument;
     p_expression          = argument;
     p_explicitlySpecified = explicitlySpecified;

  // DQ (8/24/2006): Set the parent
     argument->set_parent(this);
   }

#if 0
// DQ (8/24/2006): This is the incorrect constructor to have, it should have been a SgTemplateDeclaration (see new version below)
SgTemplateArgument::SgTemplateArgument ( SgTemplateInstantiationDecl* parameter, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType          = template_argument;
     p_templateInstantiation = parameter;
     p_explicitlySpecified   = explicitlySpecified;
   }
#endif

// DQ (8/24/2006): This is the more correct version to have.
SgTemplateArgument::SgTemplateArgument ( SgTemplateDeclaration* argument, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType          = template_template_argument;
     p_templateDeclaration   = argument;
     p_explicitlySpecified   = explicitlySpecified;

  // DQ (8/24/2006): Set the parent ???  (make sure it is not already set!)
  // This is likely a shared IR node, so we don't want to set the parent here!
  // ROSE_ASSERT(argument->get_parent() == NULL);
  // argument->set_parent(this);
#if PRINT_DEVELOPER_WARNINGS
     printf ("Skipping setting of parent on SgTemplateDeclaration in SgTemplateArgument \n");
#endif
   }

// RV (2/2/2006): Added mangling of template arguments.
SgName
SgTemplateArgument::get_mangled_name (void) const
   {
     ostringstream mangled_name;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               ROSE_ASSERT (type != NULL);
               SgName mangled_type = type->get_mangled();
               mangled_name << mangled_type.str();
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();
               ROSE_ASSERT(expr != NULL);
               mangled_name << mangleExpression(expr);
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT (templateDeclaration != NULL);

            // DQ (8/24/2006): This is not yet implemented, we can't handle this as a expression!
            // mangled_name << mangleExpression (templateDeclaration);

            // Let the mangled name be the simple name of the template (at least for now).
            // SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();
               SgName mangled_templateDeclaration = templateDeclaration->get_name();
               mangled_name << mangled_templateDeclaration.str();

#if PRINT_DEVELOPER_WARNINGS
               printf ("Mangling of template template argument to template type not well tested yet mangled name = %s \n",mangled_templateDeclaration.str());
#endif
            // ROSE_ASSERT(false);
               break;
             }

          default:
        //! \todo Find out when "unknown template argument" case occurs.
               mangled_name << "UNKNOWN";
               ROSE_ASSERT (false);
               break;
        }

     string str_mangled_name (mangled_name.str());

     return SgName (str_mangled_name.c_str());
   }

// DQ (6/9/2007): Some template arguments have a concept of scope, this is required to get the name qualification correct.
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
  // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)

     const SgNode* parentNode = this;
     while ( (isSgScopeStatement(parentNode) == NULL) && (parentNode->get_parent() != NULL) )
        {
          parentNode = parentNode->get_parent();
        }

  // Check to see if we made it back to the root (current root is SgProject).
  // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).
     if ( isSgScopeStatement(parentNode) == NULL &&
          dynamic_cast<const SgType*>(parentNode) == NULL &&
          dynamic_cast<const SgSymbol*>(parentNode) == NULL )
        {
          printf ("Error in SgTemplateArgument::get_scope(): could not trace back to SgScopeStatement node this = %s parentNode = %s \n",class_name().c_str(),parentNode->class_name().c_str());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(parentNode);
          if (templateInstantiation != NULL)
             {
               templateInstantiation->get_startOfConstruct()->display("Error in SgTemplateArgument::get_scope()");
             }
          ROSE_ASSERT(parentNode->get_parent() != NULL);
       // ROSE_ABORT();
          return NULL;
        }
       else
        {
          if ( dynamic_cast<const SgType*>(parentNode) != NULL || dynamic_cast<const SgSymbol*>(parentNode) != NULL )
             {
               printf ("Error: can't locate an associated SgStatement from SgTemplateArgument = %p \n",this);
               return NULL;
             }
        }

  // Make sure we have a SgStatement node
     const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     ROSE_ASSERT (scopeStatement != NULL);

  // return statement;
     return const_cast<SgScopeStatement*>(scopeStatement);
   }

#if 0
// Not the correct idea!
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
     SgScopeStatement* scope = NULL;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               ROSE_ASSERT (type != NULL);
               const SgNamedType* namedType = isSgNamedType(type);
               if (namedType != NULL)
                  {
                    ROSE_ASSERT(namedType->get_declaration() != NULL);
                    scope = namedType->get_declaration()->get_scope();
                  }
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
            // Not clear if the scope should be defined here!
               const SgExpression* expr = get_expression();
               ROSE_ASSERT(expr != NULL);
               scope = NULL;
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT (templateDeclaration != NULL);

               scope = templateDeclaration->get_scope();
               break;
             }

          default:
             {
               printf ("Error in SgTemplateArgument::get_scope(): default reached! \n");
               ROSE_ASSERT (false);
               break;
             }
        }

     return scope;
   } 
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateArgument::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateArgument::variantT() const {
  return V_SgTemplateArgument;
}

#if 0
int
SgTemplateArgument::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TemplateArgumentTag;
   }
#endif

const char*
SgTemplateArgument::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateArgument";  
   }

std::string
SgTemplateArgument::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateArgument";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateArgument::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateArgument::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TemplateArgumentTag)
        {
          printf ("Error in SgTemplateArgument::error(): SgTemplateArgument object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateArgument::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TemplateArgumentTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateArgument::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateArgument::variant() const \n");
#endif
     assert(this != NULL);
     return TemplateArgumentTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateArgument* isSgTemplateArgument ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateArgument*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateArgument* isSgTemplateArgument ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateArgument*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateArgument::~SgTemplateArgument ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateArgument::~SgTemplateArgument (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for argumentType
     p_argumentType = argument_undefined; // non list case 
  // case: not a listType for isArrayBoundUnknownType
     p_isArrayBoundUnknownType = false; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for expression
     p_expression = NULL; // non list case 
  // case: not a listType for templateDeclaration
     p_templateDeclaration = NULL; // non list case 
  // case: not a listType for explicitlySpecified
     p_explicitlySpecified = true; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateArgument::SgTemplateArgument ( SgTemplateArgument::template_argument_enum argumentType, bool isArrayBoundUnknownType, SgType* type, SgExpression* expression, SgTemplateDeclaration* templateDeclaration, bool explicitlySpecified )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgTemplateArgument::SgTemplateArgument (SgTemplateArgument::template_argument_enum argumentType, bool isArrayBoundUnknownType, SgType* type, SgExpression* expression, SgTemplateDeclaration* templateDeclaration, bool explicitlySpecified) sage_class_name() = %s \n",sage_class_name());
#endif

     p_argumentType = argumentType;
     p_isArrayBoundUnknownType = isArrayBoundUnknownType;
     p_type = type;
     p_expression = expression;
     p_templateDeclaration = templateDeclaration;
     p_explicitlySpecified = explicitlySpecified;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TemplateArgumentTag == variant());
     post_construction_initialization();

  // Test the isSgTemplateArgument() function since it has been problematic
     assert(isSgTemplateArgument(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFileList* 
SgDirectory::get_fileList () const
   {
     assert (this != NULL);
     return p_fileList;
   }

void
SgDirectory::set_fileList ( SgFileList* fileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_fileList != NULL && fileList != NULL && p_fileList != fileList)
        {
          printf ("Warning: fileList = %p overwriting valid pointer p_fileList = %p \n",fileList,p_fileList);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_fileList != NULL && fileList != NULL && p_fileList != fileList) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_fileList = fileList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDirectoryList* 
SgDirectory::get_directoryList () const
   {
     assert (this != NULL);
     return p_directoryList;
   }

void
SgDirectory::set_directoryList ( SgDirectoryList* directoryList )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_directoryList != NULL && directoryList != NULL && p_directoryList != directoryList)
        {
          printf ("Warning: directoryList = %p overwriting valid pointer p_directoryList = %p \n",directoryList,p_directoryList);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_directoryList != NULL && directoryList != NULL && p_directoryList != directoryList) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_directoryList = directoryList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgDirectory::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgDirectory::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgDirectory::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgDirectory::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgDirectory::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgDirectory::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgDirectory::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgDirectory::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgDirectory::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgDirectory::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12523 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDirectory::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDirectory::variantT() const {
  return V_SgDirectory;
}

#if 0
int
SgDirectory::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DirectoryTag;
   }
#endif

const char*
SgDirectory::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDirectory";  
   }

std::string
SgDirectory::class_name() const
   {
     assert(this != NULL);
     return "SgDirectory";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDirectory::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDirectory::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DirectoryTag)
        {
          printf ("Error in SgDirectory::error(): SgDirectory object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDirectory::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DirectoryTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDirectory::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDirectory::variant() const \n");
#endif
     assert(this != NULL);
     return DirectoryTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDirectory* isSgDirectory ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDirectory*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDirectory* isSgDirectory ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDirectory*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDirectory::~SgDirectory ()
   {
#if 0
  // debugging information!
     printf ("In SgDirectory::~SgDirectory (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for fileList
     p_fileList = NULL; // non list case 
  // case: not a listType for directoryList
     p_directoryList = NULL; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDirectory::SgDirectory (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgDirectory::SgDirectory () sage_class_name() = %s \n",sage_class_name());
#endif

     p_fileList = NULL;
     p_directoryList = NULL;
     p_attributeMechanism = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DirectoryTag == variant());
     post_construction_initialization();

  // Test the isSgDirectory() function since it has been problematic
     assert(isSgDirectory(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFilePtrList 
SgFileList::get_listOfFiles () const
   {
     assert (this != NULL);
     return p_listOfFiles;
   }

void
SgFileList::set_listOfFiles ( SgFilePtrList listOfFiles )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_listOfFiles = listOfFiles;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12520 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFileList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFileList::variantT() const {
  return V_SgFileList;
}

#if 0
int
SgFileList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FileListTag;
   }
#endif

const char*
SgFileList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFileList";  
   }

std::string
SgFileList::class_name() const
   {
     assert(this != NULL);
     return "SgFileList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFileList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFileList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FileListTag)
        {
          printf ("Error in SgFileList::error(): SgFileList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFileList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FileListTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFileList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFileList::variant() const \n");
#endif
     assert(this != NULL);
     return FileListTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFileList* isSgFileList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFileList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFileList* isSgFileList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFileList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFileList::~SgFileList ()
   {
#if 0
  // debugging information!
     printf ("In SgFileList::~SgFileList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFileList::SgFileList (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgFileList::SgFileList () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(FileListTag == variant());
     post_construction_initialization();

  // Test the isSgFileList() function since it has been problematic
     assert(isSgFileList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDirectoryPtrList 
SgDirectoryList::get_listOfDirectories () const
   {
     assert (this != NULL);
     return p_listOfDirectories;
   }

void
SgDirectoryList::set_listOfDirectories ( SgDirectoryPtrList listOfDirectories )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_listOfDirectories = listOfDirectories;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12526 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDirectoryList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDirectoryList::variantT() const {
  return V_SgDirectoryList;
}

#if 0
int
SgDirectoryList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DirectoryListTag;
   }
#endif

const char*
SgDirectoryList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDirectoryList";  
   }

std::string
SgDirectoryList::class_name() const
   {
     assert(this != NULL);
     return "SgDirectoryList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDirectoryList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDirectoryList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DirectoryListTag)
        {
          printf ("Error in SgDirectoryList::error(): SgDirectoryList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDirectoryList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DirectoryListTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDirectoryList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDirectoryList::variant() const \n");
#endif
     assert(this != NULL);
     return DirectoryListTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDirectoryList* isSgDirectoryList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDirectoryList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDirectoryList* isSgDirectoryList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDirectoryList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDirectoryList::~SgDirectoryList ()
   {
#if 0
  // debugging information!
     printf ("In SgDirectoryList::~SgDirectoryList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDirectoryList::SgDirectoryList (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgDirectoryList::SgDirectoryList () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DirectoryListTag == variant());
     post_construction_initialization();

  // Test the isSgDirectoryList() function since it has been problematic
     assert(isSgDirectoryList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 14807 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

const SgTypePtrList & 
SgFunctionParameterTypeList::get_arguments() const 
   { return p_arguments; }

SgTypePtrList & 
SgFunctionParameterTypeList::get_arguments() 
   { return p_arguments; }

void
SgFunctionParameterTypeList::append_argument( SgType* what) 
   {
     insert_argument(p_arguments.end(),what);
   }

void
SgFunctionParameterTypeList::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
  // WAS: void SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)
  // printf ("ERROR (in modified SAGE3 function): not implemented in SAGE3! \n");
  // abort();
     p_arguments.insert(where,what);
   }

// DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFunctionParameterTypeList::SgFunctionParameterTypeList()
   {
  // Build the default constructor (nothing to build here since the only data member is an STL list)
   }
 


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionParameterTypeList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionParameterTypeList::variantT() const {
  return V_SgFunctionParameterTypeList;
}

#if 0
int
SgFunctionParameterTypeList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_FUNCTION_PARAMETER_TYPE_LIST;
   }
#endif

const char*
SgFunctionParameterTypeList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionParameterTypeList";  
   }

std::string
SgFunctionParameterTypeList::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionParameterTypeList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionParameterTypeList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionParameterTypeList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_FUNCTION_PARAMETER_TYPE_LIST)
        {
          printf ("Error in SgFunctionParameterTypeList::error(): SgFunctionParameterTypeList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionParameterTypeList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_FUNCTION_PARAMETER_TYPE_LIST);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionParameterTypeList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionParameterTypeList::variant() const \n");
#endif
     assert(this != NULL);
     return T_FUNCTION_PARAMETER_TYPE_LIST;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionParameterTypeList* isSgFunctionParameterTypeList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionParameterTypeList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionParameterTypeList* isSgFunctionParameterTypeList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionParameterTypeList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionParameterTypeList::~SgFunctionParameterTypeList ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionParameterTypeList::~SgFunctionParameterTypeList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgQualifiedName::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgQualifiedName::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7599 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgQualifiedName::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgQualifiedName::variantT() const {
  return V_SgQualifiedName;
}

#if 0
int
SgQualifiedName::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return QualifiedNameTag;
   }
#endif

const char*
SgQualifiedName::sage_class_name() const
   {
     assert(this != NULL);
     return "SgQualifiedName";  
   }

std::string
SgQualifiedName::class_name() const
   {
     assert(this != NULL);
     return "SgQualifiedName";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgQualifiedName::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgQualifiedName::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != QualifiedNameTag)
        {
          printf ("Error in SgQualifiedName::error(): SgQualifiedName object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgQualifiedName::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == QualifiedNameTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgQualifiedName::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgQualifiedName::variant() const \n");
#endif
     assert(this != NULL);
     return QualifiedNameTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgQualifiedName* isSgQualifiedName ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgQualifiedName*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgQualifiedName* isSgQualifiedName ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgQualifiedName*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgQualifiedName::~SgQualifiedName ()
   {
#if 0
  // debugging information!
     printf ("In SgQualifiedName::~SgQualifiedName (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for scope
     p_scope = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgQualifiedName::SgQualifiedName ( SgScopeStatement* scope )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgQualifiedName::SgQualifiedName (SgScopeStatement* scope) sage_class_name() = %s \n",sage_class_name());
#endif

     p_scope = scope;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(QualifiedNameTag == variant());
     post_construction_initialization();

  // Test the isSgQualifiedName() function since it has been problematic
     assert(isSgQualifiedName(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateArgumentPtrList 
SgTemplateArgumentList::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

void
SgTemplateArgumentList::set_args ( SgTemplateArgumentPtrList args )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_args = args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 15110 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateArgumentList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateArgumentList::variantT() const {
  return V_SgTemplateArgumentList;
}

#if 0
int
SgTemplateArgumentList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TemplateArgumentListTag;
   }
#endif

const char*
SgTemplateArgumentList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateArgumentList";  
   }

std::string
SgTemplateArgumentList::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateArgumentList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateArgumentList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateArgumentList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TemplateArgumentListTag)
        {
          printf ("Error in SgTemplateArgumentList::error(): SgTemplateArgumentList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateArgumentList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TemplateArgumentListTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateArgumentList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateArgumentList::variant() const \n");
#endif
     assert(this != NULL);
     return TemplateArgumentListTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateArgumentList* isSgTemplateArgumentList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateArgumentList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateArgumentList* isSgTemplateArgumentList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateArgumentList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateArgumentList::~SgTemplateArgumentList ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateArgumentList::~SgTemplateArgumentList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateArgumentList::SgTemplateArgumentList (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgTemplateArgumentList::SgTemplateArgumentList () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TemplateArgumentListTag == variant());
     post_construction_initialization();

  // Test the isSgTemplateArgumentList() function since it has been problematic
     assert(isSgTemplateArgumentList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateParameterPtrList 
SgTemplateParameterList::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

void
SgTemplateParameterList::set_args ( SgTemplateParameterPtrList args )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_args = args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 15107 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateParameterList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateParameterList::variantT() const {
  return V_SgTemplateParameterList;
}

#if 0
int
SgTemplateParameterList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TemplateParameterListTag;
   }
#endif

const char*
SgTemplateParameterList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateParameterList";  
   }

std::string
SgTemplateParameterList::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateParameterList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateParameterList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateParameterList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TemplateParameterListTag)
        {
          printf ("Error in SgTemplateParameterList::error(): SgTemplateParameterList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateParameterList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TemplateParameterListTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateParameterList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateParameterList::variant() const \n");
#endif
     assert(this != NULL);
     return TemplateParameterListTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateParameterList* isSgTemplateParameterList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateParameterList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateParameterList* isSgTemplateParameterList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateParameterList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateParameterList::~SgTemplateParameterList ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateParameterList::~SgTemplateParameterList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateParameterList::SgTemplateParameterList (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgTemplateParameterList::SgTemplateParameterList () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TemplateParameterListTag == variant());
     post_construction_initialization();

  // Test the isSgTemplateParameterList() function since it has been problematic
     assert(isSgTemplateParameterList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraphEdge::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgGraphEdge::set_name ( std::string name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraphEdge::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgGraphEdge::set_type ( std::string type )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
SgGraphEdge::get_properties () const
   {
     assert (this != NULL);
     return p_properties;
   }

void
SgGraphEdge::set_properties ( std::map<int, std::string> properties )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_properties = properties;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 15129 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

   // tps (08/08/07): Added the graph, graph nodes and graph edges 
int 
SgGraphEdge::get_graph_id() const {
    return p_graph_id;
  }	
void
SgGraphEdge::append_properties( int addr, std::string prop )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr]=prop;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGraphEdge::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGraphEdge::variantT() const {
  return V_SgGraphEdge;
}

#if 0
int
SgGraphEdge::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GraphEdgeTag;
   }
#endif

const char*
SgGraphEdge::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGraphEdge";  
   }

std::string
SgGraphEdge::class_name() const
   {
     assert(this != NULL);
     return "SgGraphEdge";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGraphEdge::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGraphEdge::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GraphEdgeTag)
        {
          printf ("Error in SgGraphEdge::error(): SgGraphEdge object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGraphEdge::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GraphEdgeTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGraphEdge::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGraphEdge::variant() const \n");
#endif
     assert(this != NULL);
     return GraphEdgeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGraphEdge* isSgGraphEdge ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGraphEdge*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGraphEdge* isSgGraphEdge ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGraphEdge*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGraphEdge::~SgGraphEdge ()
   {
#if 0
  // debugging information!
     printf ("In SgGraphEdge::~SgGraphEdge (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for type
     p_type = ""; // non list case 
  // case: not a listType for graph_id
     p_graph_id = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGraphEdge::SgGraphEdge ( std::string name, std::string type, int graph_id )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgGraphEdge::SgGraphEdge (std::string name, std::string type, int graph_id) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_type = type;
     p_graph_id = graph_id;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(GraphEdgeTag == variant());
     post_construction_initialization();

  // Test the isSgGraphEdge() function since it has been problematic
     assert(isSgGraphEdge(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNode* 
SgDirectedGraphEdge::get_from () const
   {
     assert (this != NULL);
     return p_from;
   }

void
SgDirectedGraphEdge::set_from ( SgNode* from )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_from != NULL && from != NULL && p_from != from)
        {
          printf ("Warning: from = %p overwriting valid pointer p_from = %p \n",from,p_from);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_from != NULL && from != NULL && p_from != from) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_from = from;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNode* 
SgDirectedGraphEdge::get_to () const
   {
     assert (this != NULL);
     return p_to;
   }

void
SgDirectedGraphEdge::set_to ( SgNode* to )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_to != NULL && to != NULL && p_to != to)
        {
          printf ("Warning: to = %p overwriting valid pointer p_to = %p \n",to,p_to);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_to != NULL && to != NULL && p_to != to) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_to = to;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDirectedGraphEdge::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDirectedGraphEdge::variantT() const {
  return V_SgDirectedGraphEdge;
}

#if 0
int
SgDirectedGraphEdge::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DirectedGraphEdgeTag;
   }
#endif

const char*
SgDirectedGraphEdge::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraphEdge";  
   }

std::string
SgDirectedGraphEdge::class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraphEdge";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDirectedGraphEdge::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDirectedGraphEdge::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DirectedGraphEdgeTag)
        {
          printf ("Error in SgDirectedGraphEdge::error(): SgDirectedGraphEdge object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDirectedGraphEdge::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DirectedGraphEdgeTag);
     return SgGraphEdge::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDirectedGraphEdge::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDirectedGraphEdge::variant() const \n");
#endif
     assert(this != NULL);
     return DirectedGraphEdgeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDirectedGraphEdge* isSgDirectedGraphEdge ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDirectedGraphEdge*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDirectedGraphEdge* isSgDirectedGraphEdge ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDirectedGraphEdge*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDirectedGraphEdge::~SgDirectedGraphEdge ()
   {
#if 0
  // debugging information!
     printf ("In SgDirectedGraphEdge::~SgDirectedGraphEdge (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for from
     p_from = NULL; // non list case 
  // case: not a listType for to
     p_to = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDirectedGraphEdge::SgDirectedGraphEdge ( std::string name, std::string type, int graph_id, SgNode* from, SgNode* to )
   : SgGraphEdge(name, type, graph_id)
   {
#ifdef DEBUG
  // printf ("In SgDirectedGraphEdge::SgDirectedGraphEdge (std::string name, std::string type, int graph_id, SgNode* from, SgNode* to) sage_class_name() = %s \n",sage_class_name());
#endif

     p_from = from;
     p_to = to;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DirectedGraphEdgeTag == variant());
     post_construction_initialization();

  // Test the isSgDirectedGraphEdge() function since it has been problematic
     assert(isSgDirectedGraphEdge(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraphNode::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgGraphNode::set_name ( std::string name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraphNode::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgGraphNode::set_type ( std::string type )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
SgGraphNode::get_properties () const
   {
     assert (this != NULL);
     return p_properties;
   }

void
SgGraphNode::set_properties ( std::map<int, std::string> properties )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_properties = properties;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNode* 
SgGraphNode::get_SgNode () const
   {
     assert (this != NULL);
     return p_SgNode;
   }

void
SgGraphNode::set_SgNode ( SgNode* SgNode )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_SgNode != NULL && SgNode != NULL && p_SgNode != SgNode)
        {
          printf ("Warning: SgNode = %p overwriting valid pointer p_SgNode = %p \n",SgNode,p_SgNode);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_SgNode != NULL && SgNode != NULL && p_SgNode != SgNode) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_SgNode = SgNode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 15114 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

   // tps (08/08/07): Added the graph, graph nodes and graph edges 
int 
SgGraphNode::get_graph_id() const {
    return p_graph_id;
  }	
void
SgGraphNode::append_properties( int addr, std::string prop )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr]=prop;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGraphNode::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGraphNode::variantT() const {
  return V_SgGraphNode;
}

#if 0
int
SgGraphNode::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GraphNodeTag;
   }
#endif

const char*
SgGraphNode::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGraphNode";  
   }

std::string
SgGraphNode::class_name() const
   {
     assert(this != NULL);
     return "SgGraphNode";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGraphNode::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGraphNode::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GraphNodeTag)
        {
          printf ("Error in SgGraphNode::error(): SgGraphNode object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGraphNode::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GraphNodeTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGraphNode::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGraphNode::variant() const \n");
#endif
     assert(this != NULL);
     return GraphNodeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGraphNode* isSgGraphNode ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGraphNode*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGraphNode* isSgGraphNode ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGraphNode*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGraphNode::~SgGraphNode ()
   {
#if 0
  // debugging information!
     printf ("In SgGraphNode::~SgGraphNode (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for type
     p_type = ""; // non list case 
  // case: not a listType for graph_id
     p_graph_id = 0; // non list case 
  // case: not a listType for SgNode
     p_SgNode = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGraphNode::SgGraphNode ( std::string name, std::string type, int graph_id )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgGraphNode::SgGraphNode (std::string name, std::string type, int graph_id) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_type = type;
     p_graph_id = graph_id;
     p_SgNode = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(GraphNodeTag == variant());
     post_construction_initialization();

  // Test the isSgGraphNode() function since it has been problematic
     assert(isSgGraphNode(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDirectedGraphNode::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDirectedGraphNode::variantT() const {
  return V_SgDirectedGraphNode;
}

#if 0
int
SgDirectedGraphNode::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DirectedGraphNodeTag;
   }
#endif

const char*
SgDirectedGraphNode::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraphNode";  
   }

std::string
SgDirectedGraphNode::class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraphNode";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDirectedGraphNode::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDirectedGraphNode::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DirectedGraphNodeTag)
        {
          printf ("Error in SgDirectedGraphNode::error(): SgDirectedGraphNode object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDirectedGraphNode::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DirectedGraphNodeTag);
     return SgGraphNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDirectedGraphNode::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDirectedGraphNode::variant() const \n");
#endif
     assert(this != NULL);
     return DirectedGraphNodeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDirectedGraphNode* isSgDirectedGraphNode ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDirectedGraphNode*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDirectedGraphNode* isSgDirectedGraphNode ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDirectedGraphNode*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDirectedGraphNode::~SgDirectedGraphNode ()
   {
#if 0
  // debugging information!
     printf ("In SgDirectedGraphNode::~SgDirectedGraphNode (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDirectedGraphNode::SgDirectedGraphNode ( std::string name, std::string type, int graph_id )
   : SgGraphNode(name, type, graph_id)
   {
#ifdef DEBUG
  // printf ("In SgDirectedGraphNode::SgDirectedGraphNode (std::string name, std::string type, int graph_id) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DirectedGraphNodeTag == variant());
     post_construction_initialization();

  // Test the isSgDirectedGraphNode() function since it has been problematic
     assert(isSgDirectedGraphNode(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraph::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgGraph::set_name ( std::string name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgGraph::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgGraph::set_type ( std::string type )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
SgGraph::get_nodes () const
   {
     assert (this != NULL);
     return p_nodes;
   }

void
SgGraph::set_nodes ( std::map<int, std::string> nodes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nodes = nodes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
SgGraph::get_edges () const
   {
     assert (this != NULL);
     return p_edges;
   }

void
SgGraph::set_edges ( std::map<int, std::string> edges )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_edges = edges;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::map<int, std::string> 
SgGraph::get_properties () const
   {
     assert (this != NULL);
     return p_properties;
   }

void
SgGraph::set_properties ( std::map<int, std::string> properties )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_properties = properties;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 15144 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

   // tps (08/08/07): Added the graph, graph nodes and graph edges 
void
SgGraph::append_properties( int addr, std::string prop )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr]=prop;
   }

int 
SgGraph::hashCode( char* p, int len) // hash a character array
  { 
    unsigned int h = 0;
    for (int i=0; i<len; i++)
    { h = (h<<5)|(h>>27);               // 5-bit cyclic shift
      h += (unsigned int)p[i];         // add in next character
    }
    return (int)h; 
  }

int 
SgGraph::get_graph_id()  {
    string name = p_name+p_type;
    int len = sizeof(name);
     char* pointer = reinterpret_cast< char *>(&name);
    return hashCode(pointer, len);
  }	


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGraph::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGraph::variantT() const {
  return V_SgGraph;
}

#if 0
int
SgGraph::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GraphTag;
   }
#endif

const char*
SgGraph::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGraph";  
   }

std::string
SgGraph::class_name() const
   {
     assert(this != NULL);
     return "SgGraph";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGraph::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGraph::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GraphTag)
        {
          printf ("Error in SgGraph::error(): SgGraph object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGraph::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GraphTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGraph::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGraph::variant() const \n");
#endif
     assert(this != NULL);
     return GraphTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGraph* isSgGraph ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGraph*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGraph* isSgGraph ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGraph*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGraph::~SgGraph ()
   {
#if 0
  // debugging information!
     printf ("In SgGraph::~SgGraph (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for type
     p_type = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGraph::SgGraph ( std::string name, std::string type )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgGraph::SgGraph (std::string name, std::string type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_type = type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(GraphTag == variant());
     post_construction_initialization();

  // Test the isSgGraph() function since it has been problematic
     assert(isSgGraph(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDirectedGraph::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDirectedGraph::variantT() const {
  return V_SgDirectedGraph;
}

#if 0
int
SgDirectedGraph::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DirectedGraphTag;
   }
#endif

const char*
SgDirectedGraph::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraph";  
   }

std::string
SgDirectedGraph::class_name() const
   {
     assert(this != NULL);
     return "SgDirectedGraph";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDirectedGraph::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDirectedGraph::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DirectedGraphTag)
        {
          printf ("Error in SgDirectedGraph::error(): SgDirectedGraph object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDirectedGraph::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DirectedGraphTag);
     return SgGraph::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDirectedGraph::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDirectedGraph::variant() const \n");
#endif
     assert(this != NULL);
     return DirectedGraphTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDirectedGraph* isSgDirectedGraph ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDirectedGraph*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDirectedGraph* isSgDirectedGraph ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDirectedGraph*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDirectedGraph::~SgDirectedGraph ()
   {
#if 0
  // debugging information!
     printf ("In SgDirectedGraph::~SgDirectedGraph (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDirectedGraph::SgDirectedGraph ( std::string name, std::string type )
   : SgGraph(name, type)
   {
#ifdef DEBUG
  // printf ("In SgDirectedGraph::SgDirectedGraph (std::string name, std::string type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DirectedGraphTag == variant());
     post_construction_initialization();

  // Test the isSgDirectedGraph() function since it has been problematic
     assert(isSgDirectedGraph(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgAttribute::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgAttribute::set_name ( std::string name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7603 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

#if 0 // MS:02/15/02 this constructor is generated (see support.code)
SgAttribute::SgAttribute()
   {
  // should just make it p_name=0 in the future
     char *str = "BAD";
     p_name = new char [::strlen(str) + 1];
     ROSE_ASSERT (p_name != NULL);
     strcpy(p_name, str);
   }

SgAttribute::~SgAttribute()
   { if(p_name) delete [] p_name; }
#endif

#if 0 // MS:02/15/02 this function is generated as access function (see support.code)
SgAttribute::SgAttribute(char *str)
   {
     p_name = new char [::strlen(str) + 1];
     ROSE_ASSERT (p_name != NULL);
     strcpy(p_name, str);
   }
#endif

int
SgAttribute::isSame(const std::string& str)
   {
     return p_name == str;
   }

#if 0
// This function is automatically generated!
char*
SgAttribute::get_name() const
   {
     return p_name;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAttribute::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAttribute::variantT() const {
  return V_SgAttribute;
}

#if 0
int
SgAttribute::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return AttributeTag;
   }
#endif

const char*
SgAttribute::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAttribute";  
   }

std::string
SgAttribute::class_name() const
   {
     assert(this != NULL);
     return "SgAttribute";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAttribute::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAttribute::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != AttributeTag)
        {
          printf ("Error in SgAttribute::error(): SgAttribute object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAttribute::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == AttributeTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAttribute::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAttribute::variant() const \n");
#endif
     assert(this != NULL);
     return AttributeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAttribute* isSgAttribute ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAttribute*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAttribute* isSgAttribute ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAttribute*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAttribute::~SgAttribute ()
   {
#if 0
  // debugging information!
     printf ("In SgAttribute::~SgAttribute (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAttribute::SgAttribute ( std::string name )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgAttribute::SgAttribute (std::string name) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(AttributeTag == variant());
     post_construction_initialization();

  // Test the isSgAttribute() function since it has been problematic
     assert(isSgAttribute(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgPragma::get_startOfConstruct () const
   {
     assert (this != NULL);
     return p_startOfConstruct;
   }

void
SgPragma::set_startOfConstruct ( Sg_File_Info* startOfConstruct )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct)
        {
          printf ("Warning: startOfConstruct = %p overwriting valid pointer p_startOfConstruct = %p \n",startOfConstruct,p_startOfConstruct);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_startOfConstruct = startOfConstruct;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgPragma::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgPragma::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgPragma::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgPragma::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgPragma::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgPragma::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgPragma::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgPragma::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgPragma::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgPragma::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 7737 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
SgPragma::SgPragma(char *name)
   : SgAttribute(name), p_printed(0)
   {
   }
#endif

std::string
SgPragma::get_pragma() const
   { return get_name(); }

bool
SgPragma::samePragma(const std::string& str)
   { return get_name() == str; }

bool
SgPragma::isPragma() const
   { return 1; }

bool
SgPragma::gotPrinted() const
   { return p_printed; }

void
SgPragma::setPrinted(bool s)
   { p_printed=s; }

void
SgPragma::post_construction_initialization()
   {
     p_printed = false;
   }

// DQ (11/6/2006): This is not generated due to the name change of "file_info" to "startOfConstruct" (uncommented)
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgPragma::get_file_info() const
   {
  // return p_fileInfo;
     return p_startOfConstruct;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPragma::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPragma::variantT() const {
  return V_SgPragma;
}

#if 0
int
SgPragma::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PragmaTag;
   }
#endif

const char*
SgPragma::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPragma";  
   }

std::string
SgPragma::class_name() const
   {
     assert(this != NULL);
     return "SgPragma";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPragma::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPragma::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PragmaTag)
        {
          printf ("Error in SgPragma::error(): SgPragma object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPragma::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PragmaTag);
     return SgAttribute::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPragma::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPragma::variant() const \n");
#endif
     assert(this != NULL);
     return PragmaTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPragma* isSgPragma ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPragma*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPragma* isSgPragma ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPragma*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPragma::~SgPragma ()
   {
#if 0
  // debugging information!
     printf ("In SgPragma::~SgPragma (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_startOfConstruct;

  // case: not a listType for startOfConstruct
     p_startOfConstruct = NULL; // non list case 
  // case: not a listType for printed
     p_printed = 0; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPragma::SgPragma ( std::string name, Sg_File_Info* startOfConstruct )
   : SgAttribute(name)
   {
#ifdef DEBUG
  // printf ("In SgPragma::SgPragma (std::string name, Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_startOfConstruct = startOfConstruct;
     p_printed = 0;
     p_attributeMechanism = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(PragmaTag == variant());
     post_construction_initialization();

  // Test the isSgPragma() function since it has been problematic
     assert(isSgPragma(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned long int 
SgBitAttribute::get_bitflag () const
   {
     assert (this != NULL);
     return p_bitflag;
   }

void
SgBitAttribute::set_bitflag ( unsigned long int bitflag )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_bitflag = bitflag;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7645 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
SgBitAttribute::SgBitAttribute(char *str)
   : SgAttribute(str), p_bitflag(0) 
   {
   }
#endif

#if 0
// DQ (8/19/2004): Removed use of old attribute mechanism
int
SgBitAttribute::isAttributeSet(unsigned long int bit) const
   { return (p_bitflag & bit); }

void
SgBitAttribute::setAttribute(unsigned long int bit)
   { p_bitflag |=bit; }

void
SgBitAttribute::unsetAttribute(unsigned long int bit)
   { p_bitflag &= ~bit; }

int
SgBitAttribute::isPragma() const
   { return 0; } 
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBitAttribute::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBitAttribute::variantT() const {
  return V_SgBitAttribute;
}

#if 0
int
SgBitAttribute::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BitAttributeTag;
   }
#endif

const char*
SgBitAttribute::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBitAttribute";  
   }

std::string
SgBitAttribute::class_name() const
   {
     assert(this != NULL);
     return "SgBitAttribute";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBitAttribute::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBitAttribute::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BitAttributeTag)
        {
          printf ("Error in SgBitAttribute::error(): SgBitAttribute object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBitAttribute::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BitAttributeTag);
     return SgAttribute::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBitAttribute::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBitAttribute::variant() const \n");
#endif
     assert(this != NULL);
     return BitAttributeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBitAttribute* isSgBitAttribute ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBitAttribute*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBitAttribute* isSgBitAttribute ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBitAttribute*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBitAttribute::~SgBitAttribute ()
   {
#if 0
  // debugging information!
     printf ("In SgBitAttribute::~SgBitAttribute (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for bitflag
     p_bitflag = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBitAttribute::SgBitAttribute ( std::string name, unsigned long int bitflag )
   : SgAttribute(name)
   {
#ifdef DEBUG
  // printf ("In SgBitAttribute::SgBitAttribute (std::string name, unsigned long int bitflag) sage_class_name() = %s \n",sage_class_name());
#endif

     p_bitflag = bitflag;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(BitAttributeTag == variant());
     post_construction_initialization();

  // Test the isSgBitAttribute() function since it has been problematic
     assert(isSgBitAttribute(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 2705 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFuncDecl_attr::SgFuncDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFuncDecl_attr::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFuncDecl_attr::variantT() const {
  return V_SgFuncDecl_attr;
}

#if 0
int
SgFuncDecl_attr::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FuncDecl_attrTag;
   }
#endif

const char*
SgFuncDecl_attr::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFuncDecl_attr";  
   }

std::string
SgFuncDecl_attr::class_name() const
   {
     assert(this != NULL);
     return "SgFuncDecl_attr";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFuncDecl_attr::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFuncDecl_attr::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FuncDecl_attrTag)
        {
          printf ("Error in SgFuncDecl_attr::error(): SgFuncDecl_attr object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFuncDecl_attr::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FuncDecl_attrTag);
     return SgBitAttribute::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFuncDecl_attr::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFuncDecl_attr::variant() const \n");
#endif
     assert(this != NULL);
     return FuncDecl_attrTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFuncDecl_attr* isSgFuncDecl_attr ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFuncDecl_attr*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFuncDecl_attr* isSgFuncDecl_attr ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFuncDecl_attr*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFuncDecl_attr::~SgFuncDecl_attr ()
   {
#if 0
  // debugging information!
     printf ("In SgFuncDecl_attr::~SgFuncDecl_attr (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 2732 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgClassDecl_attr::SgClassDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassDecl_attr::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassDecl_attr::variantT() const {
  return V_SgClassDecl_attr;
}

#if 0
int
SgClassDecl_attr::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ClassDecl_attrTag;
   }
#endif

const char*
SgClassDecl_attr::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassDecl_attr";  
   }

std::string
SgClassDecl_attr::class_name() const
   {
     assert(this != NULL);
     return "SgClassDecl_attr";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassDecl_attr::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassDecl_attr::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ClassDecl_attrTag)
        {
          printf ("Error in SgClassDecl_attr::error(): SgClassDecl_attr object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassDecl_attr::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ClassDecl_attrTag);
     return SgBitAttribute::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassDecl_attr::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassDecl_attr::variant() const \n");
#endif
     assert(this != NULL);
     return ClassDecl_attrTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassDecl_attr* isSgClassDecl_attr ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassDecl_attr*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassDecl_attr* isSgClassDecl_attr ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassDecl_attr*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassDecl_attr::~SgClassDecl_attr ()
   {
#if 0
  // debugging information!
     printf ("In SgClassDecl_attr::~SgClassDecl_attr (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 932 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


SgModifier::SgModifier ( const SgModifier & X )
   {
  // DQ (4/13/2004): Nothing to do here, but this function prevents the SgSupport copy 
  // constructor from being called and we would like to keep that copy constructor 
  // private so that we can enforce error checking via the type system.
   }

SgModifier & 
SgModifier::operator= ( const SgModifier & X )
   {
     return *this;
   }

bool
SgModifier::checkBit ( unsigned int bit, const SgBitVector & bitVector ) const 
   {
     ROSE_ASSERT (bit < bitVector.size());
     return bitVector[bit];
   }

void
SgModifier::setBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     ROSE_ASSERT (bit < bitVector.size());
     bitVector[bit] = true;
   }

void
SgModifier::unsetBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     ROSE_ASSERT (bit < bitVector.size());
     bitVector[bit] = false;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModifier::variantT() const {
  return V_SgModifier;
}

#if 0
int
SgModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ModifierTag;
   }
#endif

const char*
SgModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModifier";  
   }

std::string
SgModifier::class_name() const
   {
     assert(this != NULL);
     return "SgModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ModifierTag)
        {
          printf ("Error in SgModifier::error(): SgModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ModifierTag);
     return SgSupport::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModifier::variant() const \n");
#endif
     assert(this != NULL);
     return ModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModifier* isSgModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModifier* isSgModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModifier::~SgModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgModifier::~SgModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModifier::SgModifier (  )
   : SgSupport()
   {
#ifdef DEBUG
  // printf ("In SgModifier::SgModifier () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ModifierTag == variant());
     post_construction_initialization();

  // Test the isSgModifier() function since it has been problematic
     assert(isSgModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgModifierTypePtrVector 
SgModifierNodes::get_nodes () const
   {
     assert (this != NULL);
     return p_nodes;
   }

void
SgModifierNodes::set_nodes ( SgModifierTypePtrVector nodes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nodes = nodes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgModifierNodes* 
SgModifierNodes::get_next () const
   {
     assert (this != NULL);
     return p_next;
   }

void
SgModifierNodes::set_next ( SgModifierNodes* next )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_next != NULL && next != NULL && p_next != next)
        {
          printf ("Warning: next = %p overwriting valid pointer p_next = %p \n",next,p_next);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_next != NULL && next != NULL && p_next != next) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_next = next;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 971 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 1
// These are generated
SgModifierNodes::SgModifierNodes()
   {
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // p_next = (SgModifierNodes*)0L;
  // MK: Call the following function instead
     post_construction_initialization();
   }

#if 0
SgModifierNodes::~SgModifierNodes()
   {
     // delete nodes[];
     delete p_next;
   }
#endif
#endif

void
SgModifierNodes::post_construction_initialization()
   {
  // nodes = new (SgModifierType*)[4];
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // MK: p_nodes is an STL vector now, it needs to be initilized differently
     for (int i= 0; i<4; i++)
          p_nodes.push_back((SgModifierType*) NULL);
     p_next = (SgModifierNodes*) NULL;
   }

#if 0
// DQ (4/13/2004): Commented out as a test to see if we need this function
SgModifierType*
SgModifierNodes::match(SgType* base, unsigned int f)
   {
     for (int j = 0; j < 4; j++)
        {
          if (!p_nodes[j])
             {
               SgModifierType* newType = new SgModifierType(base, f);
               assert(newType != NULL);

               p_nodes[j] = newType;
               assert(p_nodes[j] != NULL);

               return p_nodes[j];
            // return nodes[j] = new SgModifierType(base, f);
             }
          assert(p_nodes[j] != NULL);
          if (p_nodes[j]->bitfield() == f)
             {
               return p_nodes[j];
             }
        }

     if (!p_next)
        {
          p_next = new SgModifierNodes();
          assert(p_next != NULL);
        }

     return p_next->match(base, f);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModifierNodes::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModifierNodes::variantT() const {
  return V_SgModifierNodes;
}

#if 0
int
SgModifierNodes::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ModifierNodesTag;
   }
#endif

const char*
SgModifierNodes::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModifierNodes";  
   }

std::string
SgModifierNodes::class_name() const
   {
     assert(this != NULL);
     return "SgModifierNodes";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModifierNodes::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModifierNodes::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ModifierNodesTag)
        {
          printf ("Error in SgModifierNodes::error(): SgModifierNodes object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModifierNodes::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ModifierNodesTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModifierNodes::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModifierNodes::variant() const \n");
#endif
     assert(this != NULL);
     return ModifierNodesTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModifierNodes* isSgModifierNodes ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModifierNodes*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModifierNodes* isSgModifierNodes ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModifierNodes*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModifierNodes::~SgModifierNodes ()
   {
#if 0
  // debugging information!
     printf ("In SgModifierNodes::~SgModifierNodes (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for next
     p_next = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgConstVolatileModifier::cv_modifier_enum 
SgConstVolatileModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgConstVolatileModifier::set_modifier ( SgConstVolatileModifier::cv_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1041 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


SgConstVolatileModifier::SgConstVolatileModifier ( const SgConstVolatileModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgConstVolatileModifier &
SgConstVolatileModifier::operator= ( const SgConstVolatileModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgConstVolatileModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgConstVolatileModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgConstVolatileModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgConstVolatileModifier::isDefault() const { return p_modifier == e_default; }
void SgConstVolatileModifier::setDefault()      { p_modifier = e_default; }

bool SgConstVolatileModifier::isConst() const { return p_modifier == e_const; }
void SgConstVolatileModifier::setConst()      { p_modifier = e_const; }
void SgConstVolatileModifier::unsetConst()    { setDefault(); }

bool SgConstVolatileModifier::isVolatile() const { return p_modifier == e_volatile; }
void SgConstVolatileModifier::setVolatile()      { p_modifier = e_volatile; }
void SgConstVolatileModifier::unsetVolatile()    { setDefault(); }

std::ostream & operator<< ( std::ostream & os, SgConstVolatileModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgConstVolatileModifier::displayString() const
   {
     std::string s = "SgConstVolatileModifier(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isConst() = ")    + std::string(isConst()    ? "true " : "false ");
     s += std::string("isVolatile() = ") + std::string(isVolatile() ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgConstVolatileModifier::display ( std::string label ) const
   {
     printf ("In SgConstVolatileModifier::display(%s) \n",label.c_str());
#if 0
     printf ("   isUnknown()         = %s \n",isUnknown()  ? "true" : "false");
     printf ("   isDefault()         = %s \n",isDefault()  ? "true" : "false");
     printf ("   isConst()           = %s \n",isConst()    ? "true" : "false");
     printf ("   isVolatile()        = %s \n",isVolatile() ? "true" : "false");
#else
     printf ("%s \n",displayString().c_str());
#endif
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgConstVolatileModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgConstVolatileModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgConstVolatileModifier::variantT() const {
  return V_SgConstVolatileModifier;
}

#if 0
int
SgConstVolatileModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ConstVolatileModifierTag;
   }
#endif

const char*
SgConstVolatileModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgConstVolatileModifier";  
   }

std::string
SgConstVolatileModifier::class_name() const
   {
     assert(this != NULL);
     return "SgConstVolatileModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgConstVolatileModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgConstVolatileModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ConstVolatileModifierTag)
        {
          printf ("Error in SgConstVolatileModifier::error(): SgConstVolatileModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgConstVolatileModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ConstVolatileModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgConstVolatileModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgConstVolatileModifier::variant() const \n");
#endif
     assert(this != NULL);
     return ConstVolatileModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgConstVolatileModifier* isSgConstVolatileModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgConstVolatileModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgConstVolatileModifier* isSgConstVolatileModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgConstVolatileModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgConstVolatileModifier::~SgConstVolatileModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgConstVolatileModifier::~SgConstVolatileModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgConstVolatileModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgConstVolatileModifier::SgConstVolatileModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgConstVolatileModifier::SgConstVolatileModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgConstVolatileModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ConstVolatileModifierTag == variant());
     post_construction_initialization();

  // Test the isSgConstVolatileModifier() function since it has been problematic
     assert(isSgConstVolatileModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStorageModifier::storage_modifier_enum 
SgStorageModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgStorageModifier::set_modifier ( SgStorageModifier::storage_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1116 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgStorageModifier::SgStorageModifier ( const SgStorageModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgStorageModifier &
SgStorageModifier::operator= ( const SgStorageModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgStorageModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgStorageModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgStorageModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgStorageModifier::isDefault() const { return p_modifier == e_default; }
void SgStorageModifier::setDefault()      { p_modifier = e_default; }

bool SgStorageModifier::isExtern() const { return p_modifier == e_extern; }
void SgStorageModifier::setExtern()      { p_modifier = e_extern; }

bool SgStorageModifier::isStatic() const { return p_modifier == e_static; }
void SgStorageModifier::setStatic()      { p_modifier = e_static; }

bool SgStorageModifier::isAuto() const { return p_modifier == e_auto; }
void SgStorageModifier::setAuto()      { p_modifier = e_auto; }

bool SgStorageModifier::isUnspecified() const { return p_modifier == e_unspecified; }
void SgStorageModifier::setUnspecified()      { p_modifier = e_unspecified; }

// This is not used (but is present in the EDG AST)
bool SgStorageModifier::isTypedef() const { return p_modifier == e_typedef; }
void SgStorageModifier::setTypedef()      { p_modifier = e_typedef; }

bool SgStorageModifier::isRegister() const { return p_modifier == e_register; }
void SgStorageModifier::setRegister()      { p_modifier = e_register; }

bool SgStorageModifier::isMutable() const { return p_modifier == e_mutable; }
void SgStorageModifier::setMutable()      { p_modifier = e_mutable; }

bool SgStorageModifier::isAsm() const { return p_modifier == e_asm; }
void SgStorageModifier::setAsm()      { p_modifier = e_asm; }

#ifdef FORTRAN_SUPPORTED
// These remaining access functions are specific to FORTRAN
bool SgStorageModifier::isLocal() const { return p_modifier == e_local; }
void SgStorageModifier::setLocal()      { p_modifier = e_local; }

bool SgStorageModifier::isCommon() const { return p_modifier == e_common; }
void SgStorageModifier::setCommon()      { p_modifier = e_common; }

bool SgStorageModifier::isAssociated() const { return p_modifier == e_associated; }
void SgStorageModifier::setAssociated()      { p_modifier = e_associated; }

bool SgStorageModifier::isIntrinsic() const { return p_modifier == e_intrinsic; }
void SgStorageModifier::setIntrinsic()      { p_modifier = e_intrinsic; }

bool SgStorageModifier::isPointerBased() const { return p_modifier == e_pointer_based; }
void SgStorageModifier::setPointerBased()      { p_modifier = e_pointer_based; }
#endif

std::ostream & operator<< ( std::ostream & os, SgStorageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgStorageModifier::displayString() const
   {
     std::string s = "SgStorageModifier(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isExtern() = ")       + std::string(isExtern()       ? "true " : "false ");
     s += std::string("isStatic() = ")       + std::string(isStatic()       ? "true " : "false ");
     s += std::string("isAuto() = ")         + std::string(isAuto()         ? "true " : "false ");
     s += std::string("isUnspecified() = ")  + std::string(isUnspecified()  ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isRegister() = ")     + std::string(isRegister()     ? "true " : "false ");
     s += std::string("isMutable() = ")      + std::string(isMutable()      ? "true " : "false ");
     s += std::string("isAsm() = ")          + std::string(isAsm()          ? "true"  : "false");
#ifdef FORTRAN_SUPPORTED
     s += std::string("isLocal() = ")        + std::string(isLocal()        ? "true " : "false ");
     s += std::string("isCommon() = ")       + std::string(isCommon()       ? "true " : "false ");
     s += std::string("isAssociated() = ")   + std::string(isAssociated()   ? "true " : "false ");
     s += std::string("isIntrinsic() = ")    + std::string(isIntrinsic()    ? "true " : "false ");
     s += std::string("isPointerBased() = ") + std::string(isPointerBased() ? "true" : "false");
#endif
     s += ")";
     return s;
   }

void
SgStorageModifier::display ( std::string label ) const
   {
     printf ("In SgStorageModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgStorageModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStorageModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStorageModifier::variantT() const {
  return V_SgStorageModifier;
}

#if 0
int
SgStorageModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return StorageModifierTag;
   }
#endif

const char*
SgStorageModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStorageModifier";  
   }

std::string
SgStorageModifier::class_name() const
   {
     assert(this != NULL);
     return "SgStorageModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStorageModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStorageModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != StorageModifierTag)
        {
          printf ("Error in SgStorageModifier::error(): SgStorageModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStorageModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == StorageModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStorageModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStorageModifier::variant() const \n");
#endif
     assert(this != NULL);
     return StorageModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStorageModifier* isSgStorageModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStorageModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStorageModifier* isSgStorageModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStorageModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStorageModifier::~SgStorageModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgStorageModifier::~SgStorageModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgStorageModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStorageModifier::SgStorageModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgStorageModifier::SgStorageModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgStorageModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(StorageModifierTag == variant());
     post_construction_initialization();

  // Test the isSgStorageModifier() function since it has been problematic
     assert(isSgStorageModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgAccessModifier::access_modifier_enum 
SgAccessModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgAccessModifier::set_modifier ( SgAccessModifier::access_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1232 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgAccessModifier::SgAccessModifier ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgAccessModifier &
SgAccessModifier::operator= ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgAccessModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgAccessModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgAccessModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgAccessModifier::isDefault() const { return p_modifier == e_default; }
void SgAccessModifier::setDefault()      { p_modifier = e_default; }

bool SgAccessModifier::isPrivate() const { return p_modifier == e_private; }
void SgAccessModifier::setPrivate()      { p_modifier = e_private; }

bool SgAccessModifier::isProtected() const { return p_modifier == e_protected; }
void SgAccessModifier::setProtected()      { p_modifier = e_protected; }

bool SgAccessModifier::isPublic() const { return p_modifier == e_public; }
void SgAccessModifier::setPublic()      { p_modifier = e_public; }

std::ostream & operator<< ( std::ostream & os, SgAccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgAccessModifier::displayString() const
   {
     std::string s = "SgAccessModifier(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isPrivate() = ")   + std::string(isPrivate()   ? "true " : "false ");
     s += std::string("isProtected() = ") + std::string(isProtected() ? "true " : "false ");
     s += std::string("isPublic() = ")    + std::string(isPublic()    ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgAccessModifier::display ( std::string label ) const
   {
     printf ("In SgAccessModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgAccessModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAccessModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAccessModifier::variantT() const {
  return V_SgAccessModifier;
}

#if 0
int
SgAccessModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return AccessModifierTag;
   }
#endif

const char*
SgAccessModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAccessModifier";  
   }

std::string
SgAccessModifier::class_name() const
   {
     assert(this != NULL);
     return "SgAccessModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAccessModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAccessModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != AccessModifierTag)
        {
          printf ("Error in SgAccessModifier::error(): SgAccessModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAccessModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == AccessModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAccessModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAccessModifier::variant() const \n");
#endif
     assert(this != NULL);
     return AccessModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAccessModifier* isSgAccessModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAccessModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAccessModifier* isSgAccessModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAccessModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAccessModifier::~SgAccessModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgAccessModifier::~SgAccessModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgAccessModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAccessModifier::SgAccessModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgAccessModifier::SgAccessModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgAccessModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(AccessModifierTag == variant());
     post_construction_initialization();

  // Test the isSgAccessModifier() function since it has been problematic
     assert(isSgAccessModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBitVector 
SgFunctionModifier::get_modifierVector () const
   {
     assert (this != NULL);
     return p_modifierVector;
   }

void
SgFunctionModifier::set_modifierVector ( SgBitVector modifierVector )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifierVector = modifierVector;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1303 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

// Copy constructor
SgFunctionModifier::SgFunctionModifier ( const SgFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

SgFunctionModifier &
SgFunctionModifier::operator= ( const SgFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
SgFunctionModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgFunctionModifier::isUnknown() const { return checkBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::setUnknown()      { setBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::unsetUnknown()    { unsetBit(e_unknown,p_modifierVector); }

bool SgFunctionModifier::isDefault() const { return checkBit(e_default,p_modifierVector); }
void SgFunctionModifier::setDefault()      { setBit(e_default,p_modifierVector); }
void SgFunctionModifier::unsetDefault()    { unsetBit(e_default,p_modifierVector); }

bool SgFunctionModifier::isInline() const { return checkBit(e_inline,p_modifierVector); }
void SgFunctionModifier::setInline()      { setBit(e_inline,p_modifierVector); }
void SgFunctionModifier::unsetInline()    { unsetBit(e_inline,p_modifierVector); }

bool SgFunctionModifier::isVirtual() const { return checkBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::setVirtual()      { setBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::unsetVirtual()    { unsetBit(e_virtual,p_modifierVector); }

bool SgFunctionModifier::isPureVirtual() const { return checkBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::setPureVirtual()      { setBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::unsetPureVirtual()    { unsetBit(e_pure_virtual,p_modifierVector); }

bool SgFunctionModifier::isExplicit() const { return checkBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::setExplicit()      { setBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::unsetExplicit()    { unsetBit(e_explicit,p_modifierVector); }

std::ostream & operator<< ( std::ostream & os, SgFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv ) 
   {
  // DQ (1/26/2006): Modified to handle 64 bit machines
  // for (unsigned int i=0; i < bv.size(); i++)
  // for (vector<bool>::size_type i=0; i < bv.size(); i++)
     for (unsigned int i=0; i < bv.size(); i++)
          os << ((bv[i] == true) ? "T" : "F");
     return os;
   }

string
SgFunctionModifier::displayString() const
   {
     std::string s = "SgFunctionModifier(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isInline() = ")      + std::string(isInline()      ? "true " : "false ");
     s += std::string("isVirtual() = ")     + std::string(isVirtual()     ? "true " : "false ");
     s += std::string("isPureVirtual() = ") + std::string(isPureVirtual() ? "true " : "false ");
     s += std::string("isExplicit() = ")    + std::string(isExplicit()    ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgFunctionModifier::display ( std::string label ) const
   {
     printf ("In SgFunctionModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgFunctionModifier::reset()
   {
  // Unset each bit separately
     unsetUnknown();
     unsetInline();
     unsetVirtual();
     unsetPureVirtual();
     unsetExplicit();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionModifier::variantT() const {
  return V_SgFunctionModifier;
}

#if 0
int
SgFunctionModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FunctionModifierTag;
   }
#endif

const char*
SgFunctionModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionModifier";  
   }

std::string
SgFunctionModifier::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FunctionModifierTag)
        {
          printf ("Error in SgFunctionModifier::error(): SgFunctionModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FunctionModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionModifier::variant() const \n");
#endif
     assert(this != NULL);
     return FunctionModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionModifier* isSgFunctionModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionModifier* isSgFunctionModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionModifier::~SgFunctionModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionModifier::~SgFunctionModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionModifier::SgFunctionModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgFunctionModifier::SgFunctionModifier () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(FunctionModifierTag == variant());
     post_construction_initialization();

  // Test the isSgFunctionModifier() function since it has been problematic
     assert(isSgFunctionModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgUPC_AccessModifier::upc_access_modifier_enum 
SgUPC_AccessModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgUPC_AccessModifier::set_modifier ( SgUPC_AccessModifier::upc_access_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1402 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"

// Copy constructor
SgUPC_AccessModifier::SgUPC_AccessModifier ( const SgUPC_AccessModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgUPC_AccessModifier &
SgUPC_AccessModifier::operator= ( const SgUPC_AccessModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgUPC_AccessModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgUPC_AccessModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgUPC_AccessModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgUPC_AccessModifier::isDefault() const { return p_modifier == e_default; }
void SgUPC_AccessModifier::setDefault()      { p_modifier = e_default; }

bool SgUPC_AccessModifier::isUPC_Shared() const { return p_modifier == e_upc_shared; }
void SgUPC_AccessModifier::setUPC_Shared()      { p_modifier = e_upc_shared; }

bool SgUPC_AccessModifier::isUPC_Strict() const { return p_modifier == e_upc_strict; }
void SgUPC_AccessModifier::setUPC_Strict()      { p_modifier = e_upc_strict; }

bool SgUPC_AccessModifier::isUPC_Relaxed() const { return p_modifier == e_upc_relaxed; }
void SgUPC_AccessModifier::setUPC_Relaxed()      { p_modifier = e_upc_relaxed; }

std::ostream & operator<< ( std::ostream & os, SgUPC_AccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgUPC_AccessModifier::displayString() const
   {
     std::string s = "SgUPC_AccessModifier(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isUPC_Shared() = ")  + std::string(isUPC_Shared()  ? "true " : "false ");
     s += std::string("isUPC_Strict() = ")  + std::string(isUPC_Strict()  ? "true " : "false ");
     s += std::string("isUPC_Relaxed() = ") + std::string(isUPC_Relaxed() ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgUPC_AccessModifier::display ( std::string label ) const
   {
     printf ("In SgUPC_AccessModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgUPC_AccessModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUPC_AccessModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUPC_AccessModifier::variantT() const {
  return V_SgUPC_AccessModifier;
}

#if 0
int
SgUPC_AccessModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UPC_AccessModifierTag;
   }
#endif

const char*
SgUPC_AccessModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUPC_AccessModifier";  
   }

std::string
SgUPC_AccessModifier::class_name() const
   {
     assert(this != NULL);
     return "SgUPC_AccessModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUPC_AccessModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUPC_AccessModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UPC_AccessModifierTag)
        {
          printf ("Error in SgUPC_AccessModifier::error(): SgUPC_AccessModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUPC_AccessModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UPC_AccessModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUPC_AccessModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUPC_AccessModifier::variant() const \n");
#endif
     assert(this != NULL);
     return UPC_AccessModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUPC_AccessModifier* isSgUPC_AccessModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUPC_AccessModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUPC_AccessModifier* isSgUPC_AccessModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUPC_AccessModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUPC_AccessModifier::~SgUPC_AccessModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgUPC_AccessModifier::~SgUPC_AccessModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgUPC_AccessModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUPC_AccessModifier::SgUPC_AccessModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgUPC_AccessModifier::SgUPC_AccessModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgUPC_AccessModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UPC_AccessModifierTag == variant());
     post_construction_initialization();

  // Test the isSgUPC_AccessModifier() function since it has been problematic
     assert(isSgUPC_AccessModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBitVector 
SgSpecialFunctionModifier::get_modifierVector () const
   {
     assert (this != NULL);
     return p_modifierVector;
   }

void
SgSpecialFunctionModifier::set_modifierVector ( SgBitVector modifierVector )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifierVector = modifierVector;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1472 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgSpecialFunctionModifier::SgSpecialFunctionModifier ( const SgSpecialFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

SgSpecialFunctionModifier &
SgSpecialFunctionModifier::operator= ( const SgSpecialFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
SgSpecialFunctionModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgSpecialFunctionModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgSpecialFunctionModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgSpecialFunctionModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgSpecialFunctionModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgSpecialFunctionModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgSpecialFunctionModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgSpecialFunctionModifier::isNotSpecial() const  { return checkBit(e_none,p_modifierVector); }
void SgSpecialFunctionModifier::setNotSpecial()       { setBit(e_none,p_modifierVector); }
void SgSpecialFunctionModifier::unsetNotSpecial()     { unsetBit(e_none,p_modifierVector); }

bool SgSpecialFunctionModifier::isConstructor() const { return checkBit(e_constructor,p_modifierVector); }
void SgSpecialFunctionModifier::setConstructor()      { setBit(e_constructor,p_modifierVector); }
void SgSpecialFunctionModifier::unsetConstructor()    { unsetBit(e_constructor,p_modifierVector); }

bool SgSpecialFunctionModifier::isDestructor() const  { return checkBit(e_destructor,p_modifierVector); }
void SgSpecialFunctionModifier::setDestructor()       { setBit(e_destructor,p_modifierVector); }
void SgSpecialFunctionModifier::unsetDestructor()     { unsetBit(e_destructor,p_modifierVector); }

bool SgSpecialFunctionModifier::isConversion() const  { return checkBit(e_conversion,p_modifierVector); }
void SgSpecialFunctionModifier::setConversion()       { setBit(e_conversion,p_modifierVector); }
void SgSpecialFunctionModifier::unsetConversion()     { unsetBit(e_conversion,p_modifierVector); }

bool SgSpecialFunctionModifier::isOperator() const    { return checkBit(e_operator,p_modifierVector); }
void SgSpecialFunctionModifier::setOperator()         { setBit(e_operator,p_modifierVector); }
void SgSpecialFunctionModifier::unsetOperator()       { unsetBit(e_operator,p_modifierVector); }

std::ostream & operator<< ( std::ostream & os, SgSpecialFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

string
SgSpecialFunctionModifier::displayString() const
   {
     std::string s = "SgSpecialFunctionModifier(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isNotSpecial() = ")  + std::string(isNotSpecial()  ? "true " : "false ");
     s += std::string("isConstructor() = ") + std::string(isConstructor() ? "true " : "false ");
     s += std::string("isDestructor() = ")  + std::string(isDestructor()  ? "true " : "false ");
     s += std::string("isConversion() = ")  + std::string(isConversion()  ? "true " : "false ");
     s += std::string("isOperator() = ")    + std::string(isOperator()    ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgSpecialFunctionModifier::display ( std::string label ) const
   {
     printf ("In SgSpecialFunctionModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgSpecialFunctionModifier::reset()
   {
     unsetUnknown();
     unsetNotSpecial();
     unsetConstructor();
     unsetDestructor();
     unsetConversion();
     unsetOperator();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSpecialFunctionModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSpecialFunctionModifier::variantT() const {
  return V_SgSpecialFunctionModifier;
}

#if 0
int
SgSpecialFunctionModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SpecialFunctionModifierTag;
   }
#endif

const char*
SgSpecialFunctionModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSpecialFunctionModifier";  
   }

std::string
SgSpecialFunctionModifier::class_name() const
   {
     assert(this != NULL);
     return "SgSpecialFunctionModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSpecialFunctionModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSpecialFunctionModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SpecialFunctionModifierTag)
        {
          printf ("Error in SgSpecialFunctionModifier::error(): SgSpecialFunctionModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSpecialFunctionModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SpecialFunctionModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSpecialFunctionModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSpecialFunctionModifier::variant() const \n");
#endif
     assert(this != NULL);
     return SpecialFunctionModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSpecialFunctionModifier* isSgSpecialFunctionModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSpecialFunctionModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSpecialFunctionModifier* isSgSpecialFunctionModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSpecialFunctionModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSpecialFunctionModifier::~SgSpecialFunctionModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgSpecialFunctionModifier::~SgSpecialFunctionModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSpecialFunctionModifier::SgSpecialFunctionModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgSpecialFunctionModifier::SgSpecialFunctionModifier () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(SpecialFunctionModifierTag == variant());
     post_construction_initialization();

  // Test the isSgSpecialFunctionModifier() function since it has been problematic
     assert(isSgSpecialFunctionModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgElaboratedTypeModifier::elaborated_type_modifier_enum 
SgElaboratedTypeModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgElaboratedTypeModifier::set_modifier ( SgElaboratedTypeModifier::elaborated_type_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1838 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgElaboratedTypeModifier::SgElaboratedTypeModifier ( const SgElaboratedTypeModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgElaboratedTypeModifier &
SgElaboratedTypeModifier::operator= ( const SgElaboratedTypeModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgElaboratedTypeModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgElaboratedTypeModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgElaboratedTypeModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgElaboratedTypeModifier::isDefault() const { return p_modifier == e_default; }
void SgElaboratedTypeModifier::setDefault()      { p_modifier = e_default; }

bool SgElaboratedTypeModifier::isClass() const { return p_modifier == e_class; }
void SgElaboratedTypeModifier::setClass()      { p_modifier = e_class; }

bool SgElaboratedTypeModifier::isStruct() const { return p_modifier == e_struct; }
void SgElaboratedTypeModifier::setStruct()      { p_modifier = e_struct; }

bool SgElaboratedTypeModifier::isUnion() const { return p_modifier == e_union; }
void SgElaboratedTypeModifier::setUnion()      { p_modifier = e_union; }

bool SgElaboratedTypeModifier::isEnum() const { return p_modifier == e_enum; }
void SgElaboratedTypeModifier::setEnum()      { p_modifier = e_enum; }

bool SgElaboratedTypeModifier::isTypename() const { return p_modifier == e_typename; }
void SgElaboratedTypeModifier::setTypename()      { p_modifier = e_typename; }

std::ostream & operator<< ( std::ostream & os, SgElaboratedTypeModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgElaboratedTypeModifier::displayString() const
   {
     std::string s = "SgElaboratedTypeModifier(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isClass() = ")    + std::string(isClass()    ? "true " : "false ");
     s += std::string("isStruct() = ")   + std::string(isStruct()   ? "true " : "false ");
     s += std::string("isUnion() = ")    + std::string(isUnion()    ? "true " : "false ");
     s += std::string("isEnum() = ")     + std::string(isEnum()     ? "true " : "false ");
     s += std::string("isTypename() = ") + std::string(isTypename() ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgElaboratedTypeModifier::display ( std::string label ) const
   {
     printf ("In SgElaboratedTypeModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgElaboratedTypeModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgElaboratedTypeModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgElaboratedTypeModifier::variantT() const {
  return V_SgElaboratedTypeModifier;
}

#if 0
int
SgElaboratedTypeModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ElaboratedTypeModifierTag;
   }
#endif

const char*
SgElaboratedTypeModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgElaboratedTypeModifier";  
   }

std::string
SgElaboratedTypeModifier::class_name() const
   {
     assert(this != NULL);
     return "SgElaboratedTypeModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgElaboratedTypeModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgElaboratedTypeModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ElaboratedTypeModifierTag)
        {
          printf ("Error in SgElaboratedTypeModifier::error(): SgElaboratedTypeModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgElaboratedTypeModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ElaboratedTypeModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgElaboratedTypeModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgElaboratedTypeModifier::variant() const \n");
#endif
     assert(this != NULL);
     return ElaboratedTypeModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgElaboratedTypeModifier* isSgElaboratedTypeModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgElaboratedTypeModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgElaboratedTypeModifier* isSgElaboratedTypeModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgElaboratedTypeModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgElaboratedTypeModifier::~SgElaboratedTypeModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgElaboratedTypeModifier::~SgElaboratedTypeModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgElaboratedTypeModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgElaboratedTypeModifier::SgElaboratedTypeModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgElaboratedTypeModifier::SgElaboratedTypeModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgElaboratedTypeModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ElaboratedTypeModifierTag == variant());
     post_construction_initialization();

  // Test the isSgElaboratedTypeModifier() function since it has been problematic
     assert(isSgElaboratedTypeModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLinkageModifier::linkage_modifier_enum 
SgLinkageModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgLinkageModifier::set_modifier ( SgLinkageModifier::linkage_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1916 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgLinkageModifier::SgLinkageModifier ( const SgLinkageModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgLinkageModifier &
SgLinkageModifier::operator= ( const SgLinkageModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgLinkageModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgLinkageModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgLinkageModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgLinkageModifier::isDefault() const { return p_modifier == e_default; }
void SgLinkageModifier::setDefault()      { p_modifier = e_default; }

bool SgLinkageModifier::isC_Linkage() const { return p_modifier == e_C_linkage; }
void SgLinkageModifier::setC_Linkage()      { p_modifier = e_C_linkage; }

bool SgLinkageModifier::isCppLinkage() const { return p_modifier == e_Cpp_linkage; }
void SgLinkageModifier::setCppLinkage()      { p_modifier = e_Cpp_linkage; }

bool SgLinkageModifier::isFortranLinkage() const { return p_modifier == e_fortran_linkage; }
void SgLinkageModifier::setFortranLinkage()      { p_modifier = e_fortran_linkage; }

std::ostream & operator<< ( std::ostream & os, SgLinkageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgLinkageModifier::displayString() const
   {
     std::string s = "SgLinkageModifier(";
     s += std::string("isUnknown() = ")        + std::string(isUnknown()        ? "true " : "false ");
     s += std::string("isDefault() = ")        + std::string(isDefault()        ? "true " : "false ");
     s += std::string("isC_Linkage() = ")      + std::string(isC_Linkage()      ? "true " : "false ");
     s += std::string("isCppLinkage() = ")     + std::string(isCppLinkage()     ? "true " : "false ");
     s += std::string("isFortranLinkage() = ") + std::string(isFortranLinkage() ? "true"  : "false");
     s += ")";
     return s;
   }

void
SgLinkageModifier::display ( std::string label ) const
   {
     printf ("In SgLinkageModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgLinkageModifier::reset()
   {
     setDefault();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLinkageModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLinkageModifier::variantT() const {
  return V_SgLinkageModifier;
}

#if 0
int
SgLinkageModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LinkageModifierTag;
   }
#endif

const char*
SgLinkageModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLinkageModifier";  
   }

std::string
SgLinkageModifier::class_name() const
   {
     assert(this != NULL);
     return "SgLinkageModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLinkageModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLinkageModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LinkageModifierTag)
        {
          printf ("Error in SgLinkageModifier::error(): SgLinkageModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLinkageModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LinkageModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLinkageModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLinkageModifier::variant() const \n");
#endif
     assert(this != NULL);
     return LinkageModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLinkageModifier* isSgLinkageModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLinkageModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLinkageModifier* isSgLinkageModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLinkageModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLinkageModifier::~SgLinkageModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgLinkageModifier::~SgLinkageModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgLinkageModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLinkageModifier::SgLinkageModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgLinkageModifier::SgLinkageModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgLinkageModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LinkageModifierTag == variant());
     post_construction_initialization();

  // Test the isSgLinkageModifier() function since it has been problematic
     assert(isSgLinkageModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBaseClassModifier::baseclass_modifier_enum 
SgBaseClassModifier::get_modifier () const
   {
     assert (this != NULL);
     return p_modifier;
   }

void
SgBaseClassModifier::set_modifier ( SgBaseClassModifier::baseclass_modifier_enum modifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifier = modifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1986 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgBaseClassModifier::SgBaseClassModifier ( const SgBaseClassModifier & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
   }

SgBaseClassModifier &
SgBaseClassModifier::operator= ( const SgBaseClassModifier & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
     return *this;
   }

void
SgBaseClassModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgBaseClassModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgBaseClassModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgBaseClassModifier::isDefault() const { return p_modifier == e_default; }
void SgBaseClassModifier::setDefault()      { p_modifier = e_default; }

bool SgBaseClassModifier::isVirtual() const { return p_modifier == e_virtual; }
void SgBaseClassModifier::setVirtual()      { p_modifier = e_virtual; }

std::ostream & operator<< ( std::ostream & os, SgBaseClassModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgBaseClassModifier::displayString() const
   {
     std::string s = "SgBaseClassModifier(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isVirtual() = ") + std::string(isVirtual() ? "true " : "false ");
     s += std::string("\n     ") + get_accessModifier().displayString();
     s += ")";
     return s;
   }

void
SgBaseClassModifier::display ( std::string label ) const
   {
     printf ("In SgBaseClassModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgAccessModifier &
SgBaseClassModifier::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgAccessModifier &
SgBaseClassModifier::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgBaseClassModifier::reset()
   {
     setDefault();
     get_accessModifier().reset();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBaseClassModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBaseClassModifier::variantT() const {
  return V_SgBaseClassModifier;
}

#if 0
int
SgBaseClassModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BaseClassModifierTag;
   }
#endif

const char*
SgBaseClassModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBaseClassModifier";  
   }

std::string
SgBaseClassModifier::class_name() const
   {
     assert(this != NULL);
     return "SgBaseClassModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBaseClassModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBaseClassModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BaseClassModifierTag)
        {
          printf ("Error in SgBaseClassModifier::error(): SgBaseClassModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBaseClassModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BaseClassModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBaseClassModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBaseClassModifier::variant() const \n");
#endif
     assert(this != NULL);
     return BaseClassModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBaseClassModifier* isSgBaseClassModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBaseClassModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBaseClassModifier* isSgBaseClassModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBaseClassModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBaseClassModifier::~SgBaseClassModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgBaseClassModifier::~SgBaseClassModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for modifier
     p_modifier = SgBaseClassModifier::e_unknown; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBaseClassModifier::SgBaseClassModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgBaseClassModifier::SgBaseClassModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_modifier = SgBaseClassModifier::e_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(BaseClassModifierTag == variant());
     post_construction_initialization();

  // Test the isSgBaseClassModifier() function since it has been problematic
     assert(isSgBaseClassModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBitVector 
SgTypeModifier::get_modifierVector () const
   {
     assert (this != NULL);
     return p_modifierVector;
   }

void
SgTypeModifier::set_modifierVector ( SgBitVector modifierVector )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifierVector = modifierVector;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1709 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgTypeModifier::SgTypeModifier ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
   }

SgTypeModifier &
SgTypeModifier::operator= ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
     return *this;
   }

void
SgTypeModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgTypeModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgTypeModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgTypeModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgTypeModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgTypeModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgTypeModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgTypeModifier::isRestrict() const { return checkBit(e_restrict,p_modifierVector); }
void SgTypeModifier::setRestrict()      { setBit(e_restrict,p_modifierVector); }
void SgTypeModifier::unsetRestrict()    { unsetBit(e_restrict,p_modifierVector); }

std::ostream& operator<< (std::ostream& os, SgTypeModifier& tm) 
   {
      os << tm.get_modifierVector(); 
     return os;
   }

string
SgTypeModifier::displayString() const
   {
     std::string s = "SgTypeModifier(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isRestrict() = ") + std::string(isRestrict() ? "true " : "false ");
     s += std::string("\n     ") + get_constVolatileModifier().displayString() + " ";
     s += std::string("\n     ") + get_upcModifier().displayString() + " ";
     s += std::string("\n     ") + get_elaboratedTypeModifier().displayString();
     s += ")";
     return s;
   }

void
SgTypeModifier::display ( std::string label ) const
   {
     printf ("In SgTypeModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgConstVolatileModifier &
SgTypeModifier::get_constVolatileModifier ()
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

SgUPC_AccessModifier &
SgTypeModifier::get_upcModifier ()
   {
     assert (this != NULL);
     return p_upcModifier;
   }

SgElaboratedTypeModifier &
SgTypeModifier::get_elaboratedTypeModifier ()
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgTypeModifier::reset()
   {
     unsetUnknown();
     unsetRestrict();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_constVolatileModifier().reset();
     get_upcModifier().reset();
     get_elaboratedTypeModifier().reset();
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgConstVolatileModifier &
SgTypeModifier::get_constVolatileModifier (void) const
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgUPC_AccessModifier &
SgTypeModifier::get_upcModifier (void) const
   {
     assert (this != NULL);
     return p_upcModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgElaboratedTypeModifier &
SgTypeModifier::get_elaboratedTypeModifier (void) const
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeModifier::variantT() const {
  return V_SgTypeModifier;
}

#if 0
int
SgTypeModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TypeModifierTag;
   }
#endif

const char*
SgTypeModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeModifier";  
   }

std::string
SgTypeModifier::class_name() const
   {
     assert(this != NULL);
     return "SgTypeModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TypeModifierTag)
        {
          printf ("Error in SgTypeModifier::error(): SgTypeModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TypeModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeModifier::variant() const \n");
#endif
     assert(this != NULL);
     return TypeModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeModifier* isSgTypeModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeModifier* isSgTypeModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeModifier::~SgTypeModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeModifier::~SgTypeModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for upcModifier
     p_upcModifier .reset(); // non list case 
  // case: not a listType for constVolatileModifier
     p_constVolatileModifier .reset(); // non list case 
  // case: not a listType for elaboratedTypeModifier
     p_elaboratedTypeModifier .reset(); // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeModifier::SgTypeModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgTypeModifier::SgTypeModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_upcModifier .reset();
     p_constVolatileModifier .reset();
     p_elaboratedTypeModifier .reset();

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TypeModifierTag == variant());
     post_construction_initialization();

  // Test the isSgTypeModifier() function since it has been problematic
     assert(isSgTypeModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBitVector 
SgDeclarationModifier::get_modifierVector () const
   {
     assert (this != NULL);
     return p_modifierVector;
   }

void
SgDeclarationModifier::set_modifierVector ( SgBitVector modifierVector )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifierVector = modifierVector;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1566 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


// Copy constructor
SgDeclarationModifier::SgDeclarationModifier ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
   }

SgDeclarationModifier &
SgDeclarationModifier::operator= ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
     return *this;
   }

void
SgDeclarationModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgDeclarationModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgDeclarationModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgDeclarationModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgDeclarationModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgDeclarationModifier::isFriend() const  { return checkBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::setFriend()       { setBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::unsetFriend()     { unsetBit(e_friend,p_modifierVector); }

bool SgDeclarationModifier::isTypedef() const  { return checkBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::setTypedef()       { setBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::unsetTypedef()     { unsetBit(e_typedef,p_modifierVector); }

bool SgDeclarationModifier::isExport() const  { return checkBit(e_export,p_modifierVector); }
void SgDeclarationModifier::setExport()       { setBit(e_export,p_modifierVector); }
void SgDeclarationModifier::unsetExport()     { unsetBit(e_export,p_modifierVector); }

bool SgDeclarationModifier::isThrow() const  { return checkBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::setThrow()       { setBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::unsetThrow()     { unsetBit(e_throw,p_modifierVector); }

std::ostream & operator<< ( std::ostream & os, SgDeclarationModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

string
SgDeclarationModifier::displayString() const
   {
     std::string s = "SgDeclarationModifier(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isFriend() = ")  + std::string(isFriend()  ? "true " : "false ");
     s += std::string("isTypedef() = ") + std::string(isTypedef() ? "true " : "false ");
     s += std::string("isExport() = ")  + std::string(isExport()  ? "true " : "false ");
     s += std::string("isThrow() = ")   + std::string(isThrow()   ? "true " : "false ");
     s += std::string("\n     ") + get_typeModifier().displayString() + " ";
     s += std::string("\n     ") + get_accessModifier().displayString() + " ";
     s += std::string("\n     ") + get_storageModifier().displayString();
     s += ")";
     return s;
   }

void
SgDeclarationModifier::display ( std::string label ) const
   {
     printf ("In SgDeclarationModifier::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgTypeModifier &
SgDeclarationModifier::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

SgAccessModifier &
SgDeclarationModifier::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

SgStorageModifier &
SgDeclarationModifier::get_storageModifier ()
   {
     assert (this != NULL);
     return p_storageModifier;
   }

const SgTypeModifier &
SgDeclarationModifier::get_typeModifier () const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

const SgAccessModifier &
SgDeclarationModifier::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgStorageModifier &
SgDeclarationModifier::get_storageModifier () const
   {
     assert (this != NULL);
     return p_storageModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgDeclarationModifier::reset()
   {
     unsetUnknown();
     unsetFriend();
     unsetTypedef();
     unsetExport();
     unsetThrow();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_typeModifier().reset();
     get_accessModifier().reset();
     get_storageModifier().reset();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDeclarationModifier::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDeclarationModifier::variantT() const {
  return V_SgDeclarationModifier;
}

#if 0
int
SgDeclarationModifier::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DeclarationModifierTag;
   }
#endif

const char*
SgDeclarationModifier::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDeclarationModifier";  
   }

std::string
SgDeclarationModifier::class_name() const
   {
     assert(this != NULL);
     return "SgDeclarationModifier";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDeclarationModifier::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDeclarationModifier::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DeclarationModifierTag)
        {
          printf ("Error in SgDeclarationModifier::error(): SgDeclarationModifier object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDeclarationModifier::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DeclarationModifierTag);
     return SgModifier::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDeclarationModifier::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDeclarationModifier::variant() const \n");
#endif
     assert(this != NULL);
     return DeclarationModifierTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDeclarationModifier* isSgDeclarationModifier ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDeclarationModifier*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDeclarationModifier* isSgDeclarationModifier ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDeclarationModifier*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDeclarationModifier::~SgDeclarationModifier ()
   {
#if 0
  // debugging information!
     printf ("In SgDeclarationModifier::~SgDeclarationModifier (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for typeModifier
     p_typeModifier .reset(); // non list case 
  // case: not a listType for accessModifier
     p_accessModifier .reset(); // non list case 
  // case: not a listType for storageModifier
     p_storageModifier .reset(); // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDeclarationModifier::SgDeclarationModifier (  )
   : SgModifier()
   {
#ifdef DEBUG
  // printf ("In SgDeclarationModifier::SgDeclarationModifier () sage_class_name() = %s \n",sage_class_name());
#endif

     p_typeModifier .reset();
     p_accessModifier .reset();
     p_storageModifier .reset();

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DeclarationModifierTag == variant());
     post_construction_initialization();

  // Test the isSgDeclarationModifier() function since it has been problematic
     assert(isSgDeclarationModifier(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgLocatedNode::get_startOfConstruct () const
   {
     assert (this != NULL);
     return p_startOfConstruct;
   }

void
SgLocatedNode::set_startOfConstruct ( Sg_File_Info* startOfConstruct )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct)
        {
          printf ("Warning: startOfConstruct = %p overwriting valid pointer p_startOfConstruct = %p \n",startOfConstruct,p_startOfConstruct);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_startOfConstruct != NULL && startOfConstruct != NULL && p_startOfConstruct != startOfConstruct) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_startOfConstruct = startOfConstruct;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgLocatedNode::get_endOfConstruct () const
   {
     assert (this != NULL);
     return p_endOfConstruct;
   }

void
SgLocatedNode::set_endOfConstruct ( Sg_File_Info* endOfConstruct )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_endOfConstruct != NULL && endOfConstruct != NULL && p_endOfConstruct != endOfConstruct)
        {
          printf ("Warning: endOfConstruct = %p overwriting valid pointer p_endOfConstruct = %p \n",endOfConstruct,p_endOfConstruct);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_endOfConstruct != NULL && endOfConstruct != NULL && p_endOfConstruct != endOfConstruct) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_endOfConstruct = endOfConstruct;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AttachedPreprocessingInfoType* 
SgLocatedNode::get_attachedPreprocessingInfoPtr () const
   {
     assert (this != NULL);
     return p_attachedPreprocessingInfoPtr;
   }

void
SgLocatedNode::set_attachedPreprocessingInfoPtr ( AttachedPreprocessingInfoType* attachedPreprocessingInfoPtr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attachedPreprocessingInfoPtr != NULL && attachedPreprocessingInfoPtr != NULL && p_attachedPreprocessingInfoPtr != attachedPreprocessingInfoPtr)
        {
          printf ("Warning: attachedPreprocessingInfoPtr = %p overwriting valid pointer p_attachedPreprocessingInfoPtr = %p \n",attachedPreprocessingInfoPtr,p_attachedPreprocessingInfoPtr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attachedPreprocessingInfoPtr != NULL && attachedPreprocessingInfoPtr != NULL && p_attachedPreprocessingInfoPtr != attachedPreprocessingInfoPtr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attachedPreprocessingInfoPtr = attachedPreprocessingInfoPtr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgLocatedNode::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgLocatedNode::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgLocatedNode::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgLocatedNode::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgLocatedNode::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgLocatedNode::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgLocatedNode::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgLocatedNode::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgLocatedNode::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgLocatedNode::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 459 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/LocatedNode.code"


#if 0
// DQ (4/10/2006): This is replaced by a better interface for attributes.
AstAttributeMechanism & 
SgLocatedNode::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

#if 0
const char*
SgLocatedNode::getFileName ()
   {
  // Function added by DQ (7/22/2001)

     const char* fileName = "NO NAME FILE";
  // Sometimes the locatedNode doesn't have a SgFile object 
  // (likely because it is part of a parent statement object)
     if (get_file_info() != NULL)
        {
          Sg_File_Info* fileInfo = get_file_info();
          ROSE_ASSERT (fileInfo != NULL);
          fileName = fileInfo->get_filename();
          ROSE_ASSERT (fileName != NULL);
        }

     return fileName;
   }
#endif

const std::string &
SgLocatedNode::getFilenameString() const
   {
  // Function added by DQ (2/2/2007) to replace depricated function const char* SgLocatedNode::getFileName()
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     return get_startOfConstruct()->get_filenameString();
   }

Sg_File_Info*
SgLocatedNode::get_file_info() const
   {
  // DQ (11/8/2006):
  // At this level in the hierarchy of AST IR nodes we want the get_file_info() 
  // member function to be mapped to the get_startOfConstruct() member function.
  // For SgExpression IR nodes we will map it to the get_operatorPosition() 
  // member function.
     return get_startOfConstruct();
   }

void
SgLocatedNode::set_file_info( Sg_File_Info* fileInfo )
   {
  // DQ (5.14.2006): Allow input to be NULL so that we can safely reset the Sg_File_Info pointer.
  // ROSE_ASSERT (fileInfo != NULL);
     set_startOfConstruct(fileInfo);
#ifndef REMOVE_SET_PARENT_FUNCTION
     fileInfo->set_parent(this);
#endif
   }

void
SgLocatedNode::post_construction_initialization()
   {
  // Make sure that the pointer to the data structure storing the
  // attached PreprocessingInfo objects is NULL
     p_attachedPreprocessingInfoPtr = NULL;

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_startOfConstruct != NULL)
        {
          p_startOfConstruct->set_parent(this);
        }

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_endOfConstruct != NULL)
        {
          p_endOfConstruct->set_parent(this);
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setCompilerGenerated ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setCompilerGenerated();
     get_endOfConstruct()->setCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setCompilerGenerated();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetCompilerGenerated()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetCompilerGenerated();
     get_endOfConstruct()->unsetCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetCompilerGenerated();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setFrontendSpecific ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setFrontendSpecific();
     get_endOfConstruct()->setFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetFrontendSpecific()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetFrontendSpecific();
     get_endOfConstruct()->unsetFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setSourcePositionUnavailableInFrontend ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->setSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetSourcePositionUnavailableInFrontend()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->unsetSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setOutputInCodeGeneration ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setOutputInCodeGeneration();
     get_endOfConstruct()->setOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setOutputInCodeGeneration();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetOutputInCodeGeneration()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetOutputInCodeGeneration();
     get_endOfConstruct()->unsetOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetOutputInCodeGeneration();
        }
   }


#if 0
SgLocatedNode::~SgLocatedNode()
   {
  // Some expressions are initialized with NULL_FILE (which is a null Sg_File_Info pointer)
  // so we can't assert that p_file_info != NULL.
  // ROSE_ASSERT(p_file_info != NULL);

#if 0
  // At the moment uncommenting this will cause SAGE 3 to crash 
  // (SAGE 2 never tried to cleanup memory leaks and is it not 
  // done well in SAGE 3 yet either, though it is started).
     ROSE_ASSERT(get_file_info()->getReferenceCount() > 0);
     get_file_info()->decrementReferenceCount();
     if (get_file_info()->getReferenceCount() == 0)
        {
       // We need to add reference counting to Sg_File_Info objects 
       // before we can properly cleanup the meory that they allocate
          delete p _ file _ info;
        }
#endif

  // p_file_info = NULL;
     set_startOfConstruct(NULL);
     set_endOfConstruct(NULL);
   } 
#endif

#if 0
void SgLocatedNode::directives(ostream& os)
   {
#if 0
     if (p_file_info) 
        {
          p_file_info->output(os);
        }
     output_pragma(os);	

#if MEIDEBUG 
     SgExpression *e=isSgExpression(this);
     if(e && e->get_is_lvalue())
        {
          os << "<a_LVAL>";
        }
#endif
#else
     printf ("ERROR: not yet implemented within SAGE3! \n");
     abort();
#endif
   }
#endif

#if 0
void 
SgLocatedNode::setlineNumber(unsigned long new_line)
   {
     if (p_file_info == 0) 
        {
          p_file_info = new Sg_File_Info(0, new_line, 0);
        }
       else 
        {
          p_file_info->set_line(new_line);
        }
   }
#endif

#if 0
void 
SgLocatedNode::delete_file_info() 
   {
     if (p_file_info != 0)
        {
          p_file_info->deregister_node(this);
          p_file_info = 0;
        }
   }
#endif

#if 0
bool
SgLocatedNode::_print(int depth) const
   {
     if (SgNode::_print(depth))
        {
          Sg_print_info().output_field(get_file_info(),depth+1);
          return true;
        }

     return false;
   }
#endif

// [MK] Member function to attach PreprocessingInfo object to the node
void
SgLocatedNode::addToAttachedPreprocessingInfo(
     PreprocessingInfo *prepInfoPtr,
  // PositionOfPreprocessingInfoInListType locationInList )
     PreprocessingInfo::RelativePositionType locationInList )
   {
     ROSE_ASSERT(prepInfoPtr != NULL);

#if 0
  // DQ (9/19/2003)
  // This function takes a PreprocessingInfo::RelativePositionType type parameter which
  // makes no since because it is used only to determine if the new comment/directive is
  // added to the front or back of the current list of comments/directives.  It does not 
  // change the value of the PreprocessingInfo::RelativePositionType field in the
  // PreprocessingInfo object that it takes for the other parameter (nor should it).
  // This function was poorly desinged in the first place and needs to be fixed!!!
  // printf ("In LocatedNode::addToAttachedPreprocessingInfo(PreprocessingInfo,PreprocessingInfo::RelativePositionType): FIX INTERFACE!!!! \n");
#endif

#if 0
     printf ("Current node is a %s: prepInfoPtr->stringPointer = %s \n",
          sage_class_name(),prepInfoPtr->stringPointer);
#endif

  // Nodes that should not have comments attached (since they are not unparsed)
     if (isSgForInitStatement(this) != NULL)
        {
          printf ("Error: should not have comments attached, location: \n");
          this->get_startOfConstruct()->display("Error: should not have comments attached: debug (start)");
          this->get_endOfConstruct()->display("Error: should not have comments attached: debug (end)");
          printf ("Internal string = \n*****\n%s\n*****\n",prepInfoPtr->getString().c_str());
          prepInfoPtr->get_file_info()->display("prepInfoPtr: debug");
          ROSE_ASSERT(this->get_parent() != NULL);
          SgForStatement* forStatement = isSgForStatement(this->get_parent());
          ROSE_ASSERT(forStatement != NULL);
          forStatement->get_startOfConstruct()->display("forStatement: debug (start)");
          forStatement->get_endOfConstruct()->display("forStatement: debug (end)");
        }

  // Nodes that should not have comments attached (since they are not unparsed)
     ROSE_ASSERT (dynamic_cast<SgForInitStatement*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgTypedefSeq*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCatchStatementSeq*>(this) == NULL);

  // These should not be used but are are least handled in the unparser (if not debugged)
  // ROSE_ASSERT (dynamic_cast<SgFunctionParameterList*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCtorInitializerList*>(this) == NULL);

     SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(this);
     if (functionParameterList != NULL)
        {
          printf ("SgFunctionParameterList are not typically associated with comments or CPP directives \n");
          ROSE_ASSERT(get_startOfConstruct() != NULL);
          ROSE_ASSERT(get_endOfConstruct() != NULL);
       // get_startOfConstruct()->display("startOfConstruct");
       // get_endOfConstruct()->display("endOfConstruct");
        }

  // Create data structure for storing the attached PreprocessingInfo objects, if necessary
     if(!p_attachedPreprocessingInfoPtr)
        {
          p_attachedPreprocessingInfoPtr = new AttachedPreprocessingInfoType;
          ROSE_ASSERT(p_attachedPreprocessingInfoPtr != NULL);
        }

  // Add the current PreprocessingInfo object
  // p_attachedPreprocessingInfoPtr->push_back(prepInfoPtr);
     switch (locationInList)
        {
//        case defaultValue:
          case PreprocessingInfo::defaultValue:
          case PreprocessingInfo::undef:
               printf ("Error: defaultValue found in switch statement \n");
               ROSE_ABORT();
               break;
//        case prependPreprocessingInfoToList:
          case PreprocessingInfo::before:

            // DQ (9/25/2007): Moved form std::list to std::vector.
            // (9/10/2003) DQ: Force new comments to be attached closest to the target statement
            // p_attachedPreprocessingInfoPtr->push_front(prepInfoPtr);
            // p_attachedPreprocessingInfoPtr->push_back(prepInfoPtr);
               p_attachedPreprocessingInfoPtr->insert(p_attachedPreprocessingInfoPtr->begin(),prepInfoPtr);
               break;

//        case appendPreprocessingInfoToList:
          case PreprocessingInfo::after:
            // (9/10/2003) DQ: Force new comments to be attached closest to the target statement
               p_attachedPreprocessingInfoPtr->push_back(prepInfoPtr);
            // p_attachedPreprocessingInfoPtr->push_front(prepInfoPtr);
               break;
          default:
               printf ("Error: default found in switch statement \n");
               ROSE_ABORT();
        }
   }

// [MK] Member function to return attached PreprocessingInfo objects
AttachedPreprocessingInfoType*&
SgLocatedNode::getAttachedPreprocessingInfo(void)
   {
     return p_attachedPreprocessingInfoPtr;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLocatedNode::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLocatedNode::variantT() const {
  return V_SgLocatedNode;
}

#if 0
int
SgLocatedNode::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LocatedNodeTag;
   }
#endif

const char*
SgLocatedNode::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLocatedNode";  
   }

std::string
SgLocatedNode::class_name() const
   {
     assert(this != NULL);
     return "SgLocatedNode";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLocatedNode::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLocatedNode::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LocatedNodeTag)
        {
          printf ("Error in SgLocatedNode::error(): SgLocatedNode object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLocatedNode::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LocatedNodeTag);
     return SgNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLocatedNode::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLocatedNode::variant() const \n");
#endif
     assert(this != NULL);
     return LocatedNodeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLocatedNode* isSgLocatedNode ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLocatedNode*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLocatedNode* isSgLocatedNode ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLocatedNode*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLocatedNode::~SgLocatedNode ()
   {
#if 0
  // debugging information!
     printf ("In SgLocatedNode::~SgLocatedNode (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_startOfConstruct;
     delete p_endOfConstruct;
     delete p_attachedPreprocessingInfoPtr;

  // case: not a listType for startOfConstruct
     p_startOfConstruct = NULL; // non list case 
  // case: not a listType for endOfConstruct
     p_endOfConstruct = NULL; // non list case 
  // case: not a listType for attachedPreprocessingInfoPtr
     p_attachedPreprocessingInfoPtr = NULL; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLocatedNode::SgLocatedNode ( Sg_File_Info* startOfConstruct )
   : SgNode()
   {
#ifdef DEBUG
  // printf ("In SgLocatedNode::SgLocatedNode (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_startOfConstruct = startOfConstruct;
     p_endOfConstruct = NULL;
     p_attachedPreprocessingInfoPtr = NULL;
     p_attributeMechanism = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LocatedNodeTag == variant());
     post_construction_initialization();

  // Test the isSgLocatedNode() function since it has been problematic
     assert(isSgLocatedNode(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgToken::get_lexeme_string () const
   {
     assert (this != NULL);
     return p_lexeme_string;
   }

void
SgToken::set_lexeme_string ( std::string lexeme_string )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_lexeme_string = lexeme_string;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned int 
SgToken::get_classification_code () const
   {
     assert (this != NULL);
     return p_classification_code;
   }

void
SgToken::set_classification_code ( unsigned int classification_code )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_classification_code = classification_code;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 891 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/LocatedNode.code"

/*
Some assumptions:
We know that keywords in FORTRAN can be separated by whitespace
Our lexer handles end if as two identifiers with lexemes "end", "if"
A later pass can coalese these two identifers into one token 
   of type ROSE_IDENTIFIER
   of lexeme "end if"
Look at the the coalese tokens phase
*/

// DQ (4/14/2007): Modified to use new enum values
// DQ (3/24/2007): I would like to make this a const array (double check with Rama).
const SgToken::token_element SgToken::ROSE_Fortran_keyword_map[127] = 
   {
      {"abstract",             SgToken::FORTRAN_ABSTRACT}, 
      {"access",               SgToken::FORTRAN_ACCESS}, 
      {"action",               SgToken::FORTRAN_ACTION}, 
      {"abstractinterface",    SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"allocate",             SgToken::FORTRAN_ALLOCATE},            /*   GFORTRAN/G95 equivalent is ST_ALLOCATE        */
      {"allocatable",          SgToken::FORTRAN_ALLOCATABLE},         /*   GFORTRAN/G95 equivalent is ST_ALLOCATABLE     */
      {"assign",               SgToken::FORTRAN_ASSIGN},              /*   GFORTRAN/G95 equivalent is ST_ASSIGN          */
      {"associate",            SgToken::FORTRAN_ASSOCIATE}, 
      {"asynchronous",         SgToken::FORTRAN_ASYNCHRONOUS},        /*   GFORTRAN/G95 equivalent is ST_ASYNCHRONOUS    */
      {"backspace",            SgToken::FORTRAN_BACKSPACE},           /*   GFORTRAN/G95 equivalent is ST_BACKSPACE       */
      {"bind",                 SgToken::FORTRAN_BIND},                /*   GFORTRAN/G95 equivalent is ST_BIND            */
      {"blank",                SgToken::FORTRAN_BLANK},         
      {"blockdata",            SgToken::FORTRAN_BLOCK_DATA},          /*   GFORTRAN/G95 equivalent is ST_BLOCK_DATA      */
      {"call",                 SgToken::FORTRAN_CALL},                /*   GFORTRAN/G95 equivalent is ST_CALL            */
      {"character",            SgToken::FORTRAN_CHARACTER}, 
      {"class",                SgToken::FORTRAN_CLASS},
      {"close",                SgToken::FORTRAN_CLOSE},               /*   GFORTRAN/G95 equivalent is ST_CLOSE           */
      {"continue",             SgToken::FORTRAN_CONTINUE},            /*   GFORTRAN/G95 equivalent is ST_CONTINUE        */
      {"cycle",                SgToken::FORTRAN_CYCLE},               /*   GFORTRAN/G95 equivalent is ST_CYCLE           */
      {"case",                 SgToken::FORTRAN_CASE},                /*   GFORTRAN/G95 equivalent is ST_CASE            */
      {"common",               SgToken::FORTRAN_COMMON},              /*   GFORTRAN/G95 equivalent is ST_COMMON          */
      {"complex",              SgToken::FORTRAN_COMPLEX},
      {"contains",             SgToken::FORTRAN_CONTAINS},            /*   GFORTRAN/G95 equivalent is ST_CONTAINS        */
      {"deallocate",           SgToken::FORTRAN_DEALLOCATE},          /*   GFORTRAN/G95 equivalent is ST_DEALLOCATE      */
      {"data",                 SgToken::FORTRAN_DATA},                /*   GFORTRAN/G95 equivalent is ST_DATA            */
      {"deferred",             SgToken::FORTRAN_DEFERRED},  
      {"delim",                SgToken::FORTRAN_DELIM},  
      {"dimension",            SgToken::FORTRAN_DIMENSION},           /*   GFORTRAN/G95 equivalent is ST_DIMENSION       */
      {"do",                   SgToken::FORTRAN_DO},
      {"dt",                   SgToken::FORTRAN_DT},
      {"doubleprecision",      SgToken::FORTRAN_DOUBLEPRECISION},
      {"encoding",             SgToken::FORTRAN_ENCODING},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endcase",              SgToken::FORTRAN_END_CASE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"enddo",                SgToken::FORTRAN_ENDDO},               /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endfile",              SgToken::FORTRAN_END_FILE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endenum",              SgToken::FORTRAN_END_ENUM}, 
      {"endinterface",         SgToken::FORTRAN_END_INTERFACE}, 
      {"endtype",              SgToken::FORTRAN_END_TYPE}, 
      {"err",                  SgToken::FORTRAN_ERR}, 
      {"errmsg",               SgToken::FORTRAN_ERRMSG}, 
      {"exit",                 SgToken::FORTRAN_EXIT},                /*   GFORTRAN/G95 equivalent is ST_EXIT            */
      {"else",                 SgToken::FORTRAN_ELSE},                /*   GFORTRAN/G95 equivalent is ST_ELSE            */
      {"elsewhere",            SgToken::FORTRAN_ELSEWHERE},           /*   GFORTRAN/G95 equivalent is ST_ELSEWHERE       */
      {"elseif",               SgToken::FORTRAN_ELSEIF},              /*   GFORTRAN/G95 equivalent is ST_ELSEIF          */
      {"endif",                SgToken::FORTRAN_ENDIF},
      {"entry% ",              SgToken::FORTRAN_ENTRY},               /*   GFORTRAN/G95 equivalent is ST_ENTRY           */
      {"end",                  SgToken::FORTRAN_END},             
      {"enum",                 SgToken::FORTRAN_ENUM},                /*   GFORTRAN/G95 equivalent is ST_ENUM            */
      {"enumerator",           SgToken::FORTRAN_ENUMERATOR},          /*   GFORTRAN/G95 equivalent is ST_ENUMERATOR      */
      {"equivalence",          SgToken::FORTRAN_EQUIVALENCE},         /*   GFORTRAN/G95 equivalent is ST_EQUIVALENCE     */
      {"external",             SgToken::FORTRAN_EXTERNAL},            /*   GFORTRAN/G95 equivalent is ST_EXTERNAL        */
      {"extends",              SgToken::FORTRAN_EXTENDS}, 
      {"file",                 SgToken::FORTRAN_FILE}, 
      {"final",                SgToken::FORTRAN_FINAL},               /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"fmt",                  SgToken::FORTRAN_FMT},                 /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"forall",               SgToken::FORTRAN_FORALL},              /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"form",                 SgToken::FORTRAN_FORM},  
      {"formatted",            SgToken::FORTRAN_FORMATTED},  
      {"format",               SgToken::FORTRAN_FORMAT},              /*   GFORTRAN/G95 equivalent is ST_FORMAT          */
      {"flush",                SgToken::FORTRAN_FLUSH},               /*   GFORTRAN/G95 equivalent is ST_FLUSH           */
      {"function",             SgToken::FORTRAN_FUNCTION},         
      {"generic",              SgToken::FORTRAN_GENERIC},             /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"goto",                 SgToken::FORTRAN_GOTO},                /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"id",                   SgToken::FORTRAN_ID},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"if",                   SgToken::FORTRAN_IF},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"inquire",              SgToken::FORTRAN_INQUIRE},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"integer",              SgToken::FORTRAN_INTEGER},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"iomsg",                SgToken::FORTRAN_IOMSG}, 
      {"iostat",               SgToken::FORTRAN_IOSTAT}, 
      {"implicit",             SgToken::FORTRAN_IMPLICIT},            /*   GFORTRAN/G95 equivalent is ST_IMPLICIT        */
      {"implicitnone",         SgToken::FORTRAN_IMPLICIT_NONE},       /*   GFORTRAN/G95 equivalent is ST_IMPLICIT_NONE   */
      {"import",               SgToken::FORTRAN_IMPORT},              /*   GFORTRAN/G95 equivalent is ST_IMPORT          */
      {"interface",            SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"intent",               SgToken::FORTRAN_INTENT},              /*   GFORTRAN/G95 equivalent is ST_INTENT          */
      {"intrinsic",            SgToken::FORTRAN_INTRINSIC},           /*   GFORTRAN/G95 equivalent is ST_INTRINSIC       */
      {"len",                  SgToken::FORTRAN_LEN},         
      {"logical",              SgToken::FORTRAN_LOGICAL},          
      {"kind",                 SgToken::FORTRAN_KIND}, 
      {"moduleprocedure",      SgToken::FORTRAN_MODULE_PROC},         /*   GFORTRAN/G95 equivalent is ST_E_MODULE_PROC   */
      {"module",               SgToken::FORTRAN_MODULE},              /*   GFORTRAN/G95 equivalent is ST_MODULE          */
      {"non_intrinsic",        SgToken::FORTRAN_NON_INTRINSIC},       /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"non_overridable",      SgToken::FORTRAN_NON_OVERRIDABLE},     /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"null",                 SgToken::FORTRAN_NULL},
      {"nullify",              SgToken::FORTRAN_NULLIFY},             /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"namelist",             SgToken::FORTRAN_NAMELIST},            /*   GFORTRAN/G95 equivalent is ST_NAMELIST        */
      {"nml",                  SgToken::FORTRAN_NML},
      {"none",                 SgToken::FORTRAN_NONE},                /*   GFORTRAN/G95 equivalent is ST_NONE            */
      {"nopass",               SgToken::FORTRAN_NOPASS},  
      {"only",                 SgToken::FORTRAN_ONLY},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"open",                 SgToken::FORTRAN_OPEN},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"optional",             SgToken::FORTRAN_OPTIONAL},            /*   GFORTRAN/G95 equivalent is ST_OPTIONAL        */
      {"parameter",            SgToken::FORTRAN_PARAMETER},           /*   GFORTRAN/G95 equivalent is ST_PARAMETER       */
      {"pass",                 SgToken::FORTRAN_PASS}, 
      {"pause",                SgToken::FORTRAN_PAUSE},               /*   GFORTRAN/G95 equivalent is ST_PAUSE           */
      {"pointer",              SgToken::FORTRAN_POINTER},             /*   GFORTRAN/G95 equivalent is ST_POINTER         */
      {"print",                SgToken::FORTRAN_PRINT},               /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"private",              SgToken::FORTRAN_PRIVATE},             /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"procedure",            SgToken::FORTRAN_PROCEDURE},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"program",              SgToken::FORTRAN_PROGRAM},             /*   GFORTRAN/G95 equivalent is ST_PROGRAM         */
      {"protected",            SgToken::FORTRAN_PROTECTED},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"read",                 SgToken::FORTRAN_READ},                /*   GFORTRAN/G95 equivalent is ST_READ            */
      {"real",                 SgToken::FORTRAN_REAL}, 
      {"return",               SgToken::FORTRAN_RETURN},              /*   GFORTRAN/G95 equivalent is ST_RETURN          */
      {"rewind",               SgToken::FORTRAN_REWIND},              /*   GFORTRAN/G95 equivalent is ST_REWIND          */
      {"round",                SgToken::FORTRAN_ROUND},  
      {"selectcase",           SgToken::FORTRAN_SELECTCASE}, 
      {"selecttype",           SgToken::FORTRAN_SELECTTYPE}, 
      {"sequence",             SgToken::FORTRAN_SEQUENCE},            /*   GFORTRAN/G95 equivalent is ST_SEQUENCE        */
      {"save",                 SgToken::FORTRAN_SAVE},                /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"sign",                 SgToken::FORTRAN_SIGN}, 
      {"size",                 SgToken::FORTRAN_SIZE}, 
      {"source",               SgToken::FORTRAN_SOURCE},              /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"stat",                 SgToken::FORTRAN_STAT}, 
      {"stop",                 SgToken::FORTRAN_STOP},                /*   GFORTRAN/G95 equivalent is ST_STOP            */
      {"subroutine",           SgToken::FORTRAN_SUBROUTINE},
      {"target",               SgToken::FORTRAN_TARGET},              /*   GFORTRAN/G95 equivalent is ST_TARGET          */
      {"then",                 SgToken::FORTRAN_THEN}, 
      {"type",                 SgToken::FORTRAN_DERIVED_DECL},        /*   GFORTRAN/G95 equivalent is ST_DERIVED_DECL    */
      {"typeis",               SgToken::FORTRAN_TYPEIS}, 
      {"unformatted",          SgToken::FORTRAN_UNFORMATTED}, 
      {"unit",                 SgToken::FORTRAN_UNIT}, 
      {"use",                  SgToken::FORTRAN_USE},                 /*   GFORTRAN/G95 equivalent is ST_USE             */
      {"value",                SgToken::FORTRAN_VALUE},               /*   GFORTRAN/G95 equivalent is ST_VALUE           */
      {"volatile",             SgToken::FORTRAN_VOLATILE},            /*   GFORTRAN/G95 equivalent is ST_VOLATILE        */
      {"wait",                 SgToken::FORTRAN_WAIT},                /*   GFORTRAN/G95 equivalent is ST_WAIT            */
      {"where",                SgToken::FORTRAN_WHERE},               /*   GFORTRAN/G95 equivalent is ST_WHERE,          */
      {"write",                SgToken::FORTRAN_WRITE}                /*   GFORTRAN/G95 equivalent is ST_WRITE           */
   };




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgToken::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgToken::variantT() const {
  return V_SgToken;
}

#if 0
int
SgToken::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TOKEN;
   }
#endif

const char*
SgToken::sage_class_name() const
   {
     assert(this != NULL);
     return "SgToken";  
   }

std::string
SgToken::class_name() const
   {
     assert(this != NULL);
     return "SgToken";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgToken::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgToken::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TOKEN)
        {
          printf ("Error in SgToken::error(): SgToken object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgToken::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TOKEN);
     return SgLocatedNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgToken::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgToken::variant() const \n");
#endif
     assert(this != NULL);
     return TOKEN;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgToken* isSgToken ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgToken*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgToken* isSgToken ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgToken*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgToken::~SgToken ()
   {
#if 0
  // debugging information!
     printf ("In SgToken::~SgToken (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lexeme_string
     p_lexeme_string = ""; // non list case 
  // case: not a listType for classification_code
     p_classification_code = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgToken::SgToken ( Sg_File_Info* startOfConstruct, std::string lexeme_string, unsigned int classification_code )
   : SgLocatedNode(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgToken::SgToken (Sg_File_Info* startOfConstruct, std::string lexeme_string, unsigned int classification_code) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lexeme_string = lexeme_string;
     p_classification_code = classification_code;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TOKEN == variant());
     post_construction_initialization();

  // Test the isSgToken() function since it has been problematic
     assert(isSgToken(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgStatement::get_numeric_label () const
   {
     assert (this != NULL);
     return p_numeric_label;
   }

void
SgStatement::set_numeric_label ( int numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_numeric_label = numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1934 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgVariableDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Define a traversal to update the references to symbols (per statement)
     class StatementTraversal : public AstSimpleProcessing
        {
          private:
              SgCopyHelp & helpSupport;

          public:
               StatementTraversal (SgCopyHelp & help) : helpSupport(help) {}

               void visit(SgNode* n)
                  {
                    switch(n->variantT())
                       {
                         case V_SgVarRefExp:
                            {
                              SgVarRefExp* varRefExp = isSgVarRefExp(n);
                              ROSE_ASSERT(varRefExp != NULL);
                              SgVariableSymbol* variableSymbol_original = varRefExp->get_symbol();
                              ROSE_ASSERT(variableSymbol_original != NULL);
                              SgInitializedName* initializedName_original = variableSymbol_original->get_declaration();
                              ROSE_ASSERT(initializedName_original != NULL);
                              SgCopyHelp::copiedNodeMapTypeIterator i = helpSupport.get_copiedNodeMap().find(initializedName_original);

                           // printf ("Inside of SgStatement::fixupCopy(): i != helpSupport.get_copiedNodeMap().end() = %s \n",(i != helpSupport.get_copiedNodeMap().end()) ? "true" : "false");

                           // If the declaration is in the map then it is because we have copied it previously
                           // and thus it symbol should be updated to reflect the copied declaration.
                           // ROSE_ASSERT(i != help.get_copiedNodeMap().end());
                              if (i != helpSupport.get_copiedNodeMap().end())
                                 {
                                   SgInitializedName* initializedName_copy = isSgInitializedName(i->second);
                                   ROSE_ASSERT(initializedName_copy != NULL);
                                   SgSymbol* symbol_copy = initializedName_copy->get_symbol_from_symbol_table();
                                // printf ("Inside of SgStatement::fixupCopy(): symbol_copy = %p \n",symbol_copy);
                                   if (symbol_copy != NULL)
                                      {
                                        SgVariableSymbol* variableSymbol_copy = isSgVariableSymbol(symbol_copy);
                                        ROSE_ASSERT(variableSymbol_copy != NULL);
                                        varRefExp->set_symbol(variableSymbol_copy);
                                      }
                                 }
                              break;
                            }

                         case V_SgFunctionRefExp:
                            {
                              SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(n);
                              ROSE_ASSERT(functionRefExp != NULL);
                              SgFunctionSymbol* functionSymbol_original = functionRefExp->get_symbol();
                              ROSE_ASSERT(functionSymbol_original != NULL);
                              SgFunctionDeclaration* functionDeclaration_original = functionSymbol_original->get_declaration();
                              ROSE_ASSERT(functionDeclaration_original != NULL);
                              SgCopyHelp::copiedNodeMapTypeIterator i = helpSupport.get_copiedNodeMap().find(functionDeclaration_original);

                           // printf ("Inside of SgStatement::fixupCopy(): (case SgFunctionRefExp) i != helpSupport.get_copiedNodeMap().end() = %s \n",(i != helpSupport.get_copiedNodeMap().end()) ? "true" : "false");

                           // If the declaration is in the map then it is because we have copied it previously
                           // and thus it symbol should be updated to reflect the copied declaration.
                           // ROSE_ASSERT(i != help.get_copiedNodeMap().end());
                              if (i != helpSupport.get_copiedNodeMap().end())
                                 {
                                   SgFunctionDeclaration* functionDeclaration_copy = isSgFunctionDeclaration(i->second);
                                   ROSE_ASSERT(functionDeclaration_copy != NULL);
                                   SgSymbol* symbol_copy = functionDeclaration_copy->get_symbol_from_symbol_table();
                                // printf ("Inside of SgStatement::fixupCopy(): symbol_copy = %p \n",symbol_copy);
                                   if (symbol_copy != NULL)
                                      {
                                        SgFunctionSymbol* functionSymbol_copy = isSgFunctionSymbol(symbol_copy);
                                        ROSE_ASSERT(functionSymbol_copy != NULL);
                                        functionRefExp->set_symbol(functionSymbol_copy);
                                      }
                                 }
                              break;
                            }

                         case V_SgMemberFunctionRefExp:
                            {
                              SgMemberFunctionRefExp* functionRefExp = isSgMemberFunctionRefExp(n);
                              ROSE_ASSERT(functionRefExp != NULL);
                              SgMemberFunctionSymbol* functionSymbol_original = functionRefExp->get_symbol();
                              ROSE_ASSERT(functionSymbol_original != NULL);
                              SgMemberFunctionDeclaration* functionDeclaration_original = functionSymbol_original->get_declaration();
                              ROSE_ASSERT(functionDeclaration_original != NULL);
                              SgCopyHelp::copiedNodeMapTypeIterator i = helpSupport.get_copiedNodeMap().find(functionDeclaration_original);

                           // printf ("Inside of SgStatement::fixupCopy(): (case SgMemberFunctionRefExp) i != helpSupport.get_copiedNodeMap().end() = %s \n",(i != helpSupport.get_copiedNodeMap().end()) ? "true" : "false");

                           // If the declaration is in the map then it is because we have copied it previously
                           // and thus it symbol should be updated to reflect the copied declaration.
                           // ROSE_ASSERT(i != help.get_copiedNodeMap().end());
                              if (i != helpSupport.get_copiedNodeMap().end())
                                 {
                                   SgMemberFunctionDeclaration* functionDeclaration_copy = isSgMemberFunctionDeclaration(i->second);
                                   ROSE_ASSERT(functionDeclaration_copy != NULL);
                                   SgSymbol* symbol_copy = functionDeclaration_copy->get_symbol_from_symbol_table();
                                // printf ("Inside of SgStatement::fixupCopy(): symbol_copy = %p \n",symbol_copy);
                                   if (symbol_copy != NULL)
                                      {
                                        SgMemberFunctionSymbol* functionSymbol_copy = isSgMemberFunctionSymbol(symbol_copy);
                                        ROSE_ASSERT(functionSymbol_copy != NULL);
                                        functionRefExp->set_symbol(functionSymbol_copy);
                                      }
                                 }
                              break;
                            }

                         case V_SgLabelStatement:
                            {
                           // printf ("Inside of SgStatement::fixupCopy(): we might have to handle SgLabelStatement \n");
                              break;
                            }

                          default:
                            {
                           // Nothing to do for this case
                            }
                       }
                  }
        };

  // Build an run the traversal defined above.
     StatementTraversal t(help);
     t.traverse(copy,preorder);

     SgStatement* copyStatement = isSgStatement(copy);
     ROSE_ASSERT(copyStatement != NULL);

  // DQ (7/15/2007): Added assertion...
  // ROSE_ASSERT(this->get_parent() != NULL);
  // ROSE_ASSERT(copyStatement->get_parent() != NULL);

  // DQ (10/15/2007): If the parent of the original AST is not set then we will not process theparent in the copy, 
  // thus the AST copy mechanism can handle incompletely setup AST (as required for use in the EDG/Sage translation) 
  // yet only return an AST of similare quality.
     if (this->get_parent() != NULL)
        {
       // Make sure that the copy sets the scopes to be the same type
          if (copyStatement->get_parent() == NULL || copyStatement->get_parent()->variantT() != this->get_parent()->variantT())
             {
            // printf ("this->get_parent()          = %p = %s \n",this->get_parent(),this->get_parent()->class_name().c_str());
            // printf ("copyStatement->get_parent() = %p = %s \n",copyStatement->get_parent(),copyStatement->get_parent() == NULL ? "NULL" : copyStatement->get_parent()->class_name().c_str());

            // Reset using the map of copied IR nodes.
            // DQ (10/15/2007): This is a simpler approach using the map stored in the SgCopyHelp object.
               SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(this->get_parent());
               if (i != help.get_copiedNodeMap().end())
                  {
                 // Use the associated value from the map as the scope.
                    SgNode* parentNode_copy = i->second;
                    ROSE_ASSERT(parentNode_copy != NULL);
                    copyStatement->set_parent(parentNode_copy);
                  }
                 else
                  {
                 // Else set the scope in the copyDeclarationStatement to be the same as this->get_scope()
                    SgNode* currentParent = this->get_parent();
                    ROSE_ASSERT(currentParent != NULL);
                 // printf ("In SgStatement::fixupCopy() this = %p = %s this->get_parent() = %p = %s \n",this,this->class_name().c_str(),currentParent,currentParent->class_name().c_str());
                    copyStatement->set_parent(currentParent);
                  }
             }

       // DQ (7/15/2007): Added assertion...
          ROSE_ASSERT(this->get_parent() != NULL);
          ROSE_ASSERT(copyStatement->get_parent() != NULL);

          ROSE_ASSERT(copyStatement->get_parent()->variantT() == this->get_parent()->variantT());
        }
       else
        {
       // printf ("In SgStatement::fixupCopy(): parent not set for original AST at %p = %s, thus copy left similarly incomplete \n",this,this->class_name().c_str());
        }
   }
#endif

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgStatement::get_symbol_from_symbol_table() called on base class SgStatement = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
   }




inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
   {
  // DQ (11/20/2004): Modified to provide more accurate information, use the 
  // copy constructor instead of the constructor that takes a file name.
  // return new Sg_File_Info( p->get_file_info()->get_filename());

  // DQ (11/6/2006): startOfConstruct is the one Sg_File_Info that will always exist and must exist.
  // ROSE_ASSERT(p->get_file_info() != NULL);
  // Sg_File_Info* returnFileInfo = new Sg_File_Info( *( p->get_file_info() ) );
  // ROSE_ASSERT(returnFileInfo != NULL);
     ROSE_ASSERT(p->get_startOfConstruct() != NULL);
     Sg_File_Info* returnFileInfo = new Sg_File_Info( *( p->get_startOfConstruct() ) );
     ROSE_ASSERT(returnFileInfo != NULL);

  // printf ("In New_File_Info: returnFileInfo = %p \n",returnFileInfo);

     return returnFileInfo;
   }

template <class Elemtype> 
inline bool
StatementListInsertChild( SgStatement *parent, Rose_STL_Container<Elemtype*>& l,  SgStatement *target, 
                          SgStatement *n, bool inFront, bool extractFromBasicBlock, bool removeCurrent)
   {
#if 0
     printf ("In StatementListInsertChild: l.size() = %zu \n",l.size());
     printf ("In StatementListInsertChild: inFront  = %s \n",inFront ? "true" : "false");
     printf ("In StatementListInsertChild: parent   = %p \n",parent);
     printf ("In StatementListInsertChild: target   = %p \n",target);
     printf ("In StatementListInsertChild: n        = %p \n",n);
#endif

     ROSE_ASSERT(parent != NULL);
     ROSE_ASSERT(target != NULL);

  // DQ (7/19/2005): Milind says that we can comment this out (because the remove function 
  // calls the replace function which calls this insert function with n == NULL)
  // This function's name is misleading and could be more clear.
  // ROSE_ASSERT(n != NULL);

     bool targetLocated = find(l.begin(),l.end(),target) != l.end();
     if (targetLocated == false)
        {
          printf ("Error: target statement = %p not found in list of statements provided. \n",target);
          ROSE_ASSERT(false);
        }
  // ROSE_ASSERT (find(l.begin(),l.end(),target) != l.end());

     unsigned int size = l.size();
     for (unsigned int p = 0; p < size; ++p)
        {
       // printf ("Looping through the list of statements! p = %p \n",l[p]);
          if ( l[p] == target )
             {
               if (!inFront)
                    ++p;
#if 0
            // DQ (12/6/2004): This interfers with the execution of the EDG/Sage III translation!
            // DQ (12/5/2004): There should be a valid scope (set before passing the statement to this function!)
               ROSE_ASSERT(n == NULL || n->get_scope() != NULL);
#endif

               SgBasicBlock *bn = extractFromBasicBlock? isSgBasicBlock(n) : NULL; 
               if (bn == NULL)
                  {
                    assert(n == 0 || dynamic_cast<Elemtype*>(n) != 0);
                    if (n != 0)
                       {
                      // DQ (10/17/2004): We MUST set the parent here, the string based AST rewrite mechanism 
                      // requires this semantics. Previously it was removed as part of the movement toward an 
                      // initialization of the parent pointers within a post processing phase.  This post-processing
                      // phase was a result of an attempt (sucessful) to remove side-effects from the set_xxx 
                      // access functions generated by ROSETTA.  At some point parents will be be initialized within 
                      // the EDG/Sage interface, but we will be more careful how it is done and not reintroduce the 
                      // previous side-effects back into the access functions.
                         n->set_parent(parent);

                      // DQ (12/5/2004): Later in the day I discovered that this allows member functions to be defined 
                      // as have a scope which is not a class definition (which is an error caught in the unparser!).
                      // So it would be good to make the scope correctly (this could be a start at marking all other 
                      // pointers within a new node added by the rewrite system correctly!).  I think the solution is 
                      // to set the scope before it gets to this function since this is a general mechanism for inserting 
                      // statements and not one which should have such a side-effect as setting or resetting the scope 
                      // of statements containing explicit scope pointers.

                      // DQ (6/24/2006): The scope is not explicitly represented and this is not required 
                      // ("n->set_scope(parentScope);" was already commented out so this is unused code).

                      // DQ (12/5/2004): If the scope is stored explicitly then we must also set the scope of the new 
                      // statement.  But we will not know the scope, so for now derive it structureally (using the parent).
                      // But not all statements have a set_scope function, so see if this one does.
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);

                         if (parentScope == NULL)
                              parentScope = parent->get_scope();

                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         l.insert(l.begin() + p, static_cast<Elemtype*>(n));
                         parent->set_isModified(true);
                       }
                  }
                 else
                  {
                    SgStatementPtrList& nl = bn->get_statements();
                    for (SgStatementPtrList::iterator pp = nl.begin(); pp != nl.end(); ++pp)
                       {
                         SgStatement* stmt = *pp;
                         assert(dynamic_cast<Elemtype*>(stmt) != NULL);

                      // DQ (10/17/2004): We MUST set the parent here, see note in true part of conditional (above).
                         stmt->set_parent(parent);

                      // DQ (12/5/2004): We MUST set the scope here, see note in true part of conditional (above).
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);
                         if (parentScope == NULL)
                              parentScope = parent->get_scope();
                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         l.insert(l.begin() + p, static_cast<Elemtype*>(stmt));
                         parent->set_isModified(true);
                       }
                  }

               if (removeCurrent)
                  {
                 // DQ (9/27/2007): Reported as an error by STL debugging mode, fixed as part of move from std::list to std::vector uniformaly in ROSE.
                    l.erase(l.begin() + p);

                    parent->set_isModified(true);
                  }

               return true;
             }
        }

     return false;
   }

template <class Elemtype> 
inline bool
StatementReplace (SgStatement *parent, Elemtype *& cur, SgStatement *target, SgStatement *newstmt)
   {
     if (cur == target)
        {
          assert( newstmt == 0 || newstmt->variantT() == cur->variantT());
#ifndef REMOVE_SET_PARENT_FUNCTION
       // DQ (9/24/2004): Parent will be set in the AST fixup (in post-processing of the AST in AST Fixup)
       // Should not be set within EDG/Sage III connection code!
          printf ("Warning: Temporarily skipping set_parent in StatementReplace \n");
       // if (newstmt != 0)
       //    newstmt->set_parent( parent);
#endif

          cur = static_cast<Elemtype *>(newstmt);
          parent->set_isModified(true);
          return true;
        }
     return false;
   }

void
SgStatement::remove_statement(SgStatement *target)
   {
     bool r = replace_child(target, 0);
     assert(r);
   }

void
SgStatement::insert_statement(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
     bool r = insert_child( target, newstmt, inFront, false);
     assert(r);
   }

void
SgStatement::insert_statement(SgStatement* target, const SgStatementPtrList& newstmtList, bool inFront)
   {  
     SgBasicBlock tmp;
     tmp.get_statements() = newstmtList;
     bool r = insert_child( target, &tmp, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, SgStatement* newstmt)
   {
  // DQ (6/24/2006): Allow structurally oriented operations to set the parent (now that we store the scope explicitly this is OK).
     ROSE_ASSERT(newstmt != NULL);
     ROSE_ASSERT(target != NULL);
     ROSE_ASSERT(target->get_parent() != NULL);
  // ROSE_ASSERT(target->get_parent() != newstmt);
     if (newstmt->get_parent() == NULL)
          newstmt->set_parent(target->get_parent());

     bool r = replace_child(target, newstmt, false);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, const SgStatementPtrList& newstmtList)
   {
     SgBasicBlock tmp;
     tmp.get_statements() = newstmtList;
     bool r = replace_child( target, &tmp, true);
     assert(r);
   }

 // if newstmt is a basicBlock, statements inside newstmt are extracted and then inserted
void
SgStatement::insert_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
     bool r = insert_child( target, newstmt, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt)
   {
     bool r = replace_child( target, newstmt, true);
     assert(r);
   }

void
SgStatement::post_construction_initialization()
   {
   }

// DQ (12/5/2004): Support for setting scopes (only menaingful on IR statements that store the scope explicitly)
void
SgStatement::set_scope ( SgScopeStatement* newScope )
   {
     ROSE_ASSERT(this != NULL);
     printf ("Warning: It is meaningless to set the scope in this %s IR node, the scope is not explicitly stored on this IR node! \n",class_name().c_str());
     ROSE_ASSERT(false);
   }

bool
SgStatement::hasExplicitScope() const
   {
  // This function reports that this IR node (by default) does NOT store its scope explicitly.

     return false;
   }

void
SgStatement::setExtern()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatment::setExtern() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

void
SgStatement::setStatic()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatment::setStatic() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

#if 0
void
SgStatement::set_pragma()
   {
  // if(found_pragma_cnt)
  //    {
  //      add_pragma(found_pragma_cnt,found_pragma_list);
  //      found_pragma_cnt=0;
  //    }
   }
#endif

bool 
SgStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractListFromBasicBlock)
   {
     printf ("SgStatement::replace_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",sage_class_name());
     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from SgStatement::insert_child()");
     ROSE_ABORT();

     return false;
   }
 
bool
SgStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractListFromBasicBlock)
   {
     printf ("SgStatement::insert_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",sage_class_name());
     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from SgStatement::insert_child()");
     ROSE_ABORT();
   }


// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformally on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
     printf ("Error: base class of virtual SgStatement::replace_expression called by mistake for statement: %s \n",class_name().c_str());
     ROSE_ASSERT(false);
     return 0;
   }

SgScopeStatement*
SgStatement::get_scope(void) const
   {
  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Imprtant exception: The SgFunctionParameterList should have as it's scope the
  // SgFunctionDefinition, but it is a sibling of the SgFunctionDefinition (both the
  // SgFunctionParameterList and the SgFunctionDefinition have the SgFunctionDeclaration
  // as a parent.  Thus the scope of the SgFunctionParameterList is computed to be the 
  // SgGlobal (global scope) most often; which is an error).  So we handle this case 
  // explicitly.

     SgStatement *stmt = const_cast<SgStatement*>(this);
     ROSE_ASSERT (stmt != NULL);

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
     if (get_parent() == NULL)
        {
       // printf ("Error: found IR node where parent was not set = %p = %s \n",this,sage_class_name());
          printf ("Note: found IR node where parent was not set = %p = %s (may not be required) \n",this,sage_class_name());
          ROSE_ASSERT(get_file_info() != NULL);
          get_file_info()->display("Location of problematic IR node");
        }
  // ROSE_ASSERT (get_parent() != NULL);

#if 0
     printf ("In get_scope(): this = %s \n",sage_class_name());
#endif

     SgScopeStatement *returnScope = NULL;
     switch (variantT())
        {
       // DQ (11/7/03) : If we are a SgGlobal then return NULL (is this the best return value???)
       // DQ (11/25/03): If we are a SgGlobal then return "this" (I think it's more useful)
       // So the scope of global scope is now the global scope (hope this does not cause
       // any loops to never terminate!).

          case V_SgGlobal:
             {
            // returnScope = NULL;
               returnScope = isSgScopeStatement(stmt);
               ROSE_ASSERT (returnScope != NULL);
               break;
             }

       // DQ (9/24/2005): This should be handled the same as SgFunctionParameterList
          case V_SgCtorInitializerList:

       // DQ (11/21/2003): Handle special case of SgFunctionParameterList (attached to the 
       //                  SgFunctionDeclaration instead of the SgFunctionDefinition)
          case V_SgFunctionParameterList:
             {
            // Handle case of SgFunctionDeclaration or SgMemberFunctionDeclaration
               ROSE_ASSERT (stmt->get_parent() != NULL);
               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(stmt->get_parent());
               ROSE_ASSERT (functionDeclaration != NULL);
#if 0
               SgFunctionDefinition* functionDefinition = functionDeclaration->get_definition();
               if (functionDefinition != NULL)
                  {
                    returnScope = functionDefinition;
                  }
                 else
                  {
                 // scope of a SgFunctionParameterList in a forward function declaration 
                 // (without a pointer to a SgFunctionDefinition)
                 // returnScope = NULL;

                 // DQ (11/27/2003): Force SgFunctionParameterList case to use scope of function
                 //                  declaration (most often global scope of class definition scope).
                    returnScope = functionDeclaration->get_scope();
                  }
#else
            // DQ (2/12/2006): provide a consistant definition of the scope for SgFunctionParameterList
            // instead of a definition that dependes on if it is a defining or non-defining declaration.
               returnScope = functionDeclaration->get_scope();
#endif
               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#if 0
       // DQ (2/19/2006): If commented out test2004_78.C fails, if left in place then test2004_71.C fails.
       // I have concluded from this that the SgNamespaceDeclarationStatement shold have an explicitly 
       // stored scope.
       // DQ (2/10/2006): Added case that is a current problem in test2005_08.C
       // There can be many instances of a single name space but get_scope()
       // should return the scope of the first instance of each namespace.
          case V_SgNamespaceDeclarationStatement:
             {
            // Handle case of SgNamespaceDeclarationStatement
               ROSE_ASSERT (stmt != NULL);
               SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(stmt);
               ROSE_ASSERT (namespaceDeclaration != NULL);
            // printf ("namespaceDeclaration->get_firstNondefiningDeclaration() = %p namespaceDeclaration->get_definingDeclaration() = %p \n",
            //      namespaceDeclaration->get_firstNondefiningDeclaration(),namespaceDeclaration->get_definingDeclaration());
            // SgDeclarationStatement* firstDeclaration = namespaceDeclaration->get_definingDeclaration();
               SgDeclarationStatement* firstDeclaration = namespaceDeclaration->get_firstNondefiningDeclaration();
               ROSE_ASSERT(firstDeclaration != NULL);
               SgNamespaceDeclarationStatement* firstNamespaceDeclaration = isSgNamespaceDeclarationStatement(firstDeclaration);
               ROSE_ASSERT(firstNamespaceDeclaration != NULL);
               ROSE_ASSERT(firstNamespaceDeclaration->get_parent() != NULL);
               SgStatement* parentStatement = isSgStatement(firstNamespaceDeclaration->get_parent());
               ROSE_ASSERT(parentStatement != NULL);

               returnScope = parentStatement->get_scope();

               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#endif
#if 0
       // DQ (2/9/2006): Added case that is a current problem in test2004_02.C
       // This is not needed now that we have set the parent directly (hope that works!)
          case V_SgBasicBlock:
             {
            // Handle case of SgBasicBlock
               ROSE_ASSERT (stmt != NULL);
               SgBasicBlock* block = isSgBasicBlock(stmt);

            // This fails
               printf ("SgBasicBlock = %p \n",stmt);
               ROSE_ASSERT (stmt->get_parent() != NULL);

               ROSE_ASSERT (returnScope != NULL);
               break;
             }
#endif
       // DQ (11/7/03): If we are a ScopeStatment then reset the starting point for the search
       //               for the scopeStatement to the parent of the current node.
          default:
             {
               ROSE_ASSERT(stmt != NULL);
#if 0
               printf ("In SgScopeStatement::get_scope() default case: stmt = %s \n",stmt->sage_class_name());
               ROSE_ASSERT(stmt->get_parent() != NULL);
               printf ("In SgScopeStatement::get_scope() default case: stmt->get_parent() = %s \n",stmt->get_parent()->sage_class_name());
#endif

               if (isSgScopeStatement(stmt) != NULL)
                  {
                    if (stmt->get_parent() == NULL)
                       {
                         printf ("Error: SgStatement has NULL parent at node = %p = %s \n",stmt,stmt->class_name().c_str());
                         stmt->get_file_info()->display("Error: SgStatement has NULL parent");
                       }
                    ROSE_ASSERT(stmt->get_parent() != NULL);
                    // JJW (10/10/2007) -- the non-NULL parent of a statement
                    // may not be a statement in the case of a statement
                    // expression (test case is
                    // tests/CompileTests/Cxx_tests/test2006_148.C), so we need
                    // to skip over non-statements
                    SgNode* stmtTemp = stmt;
                    do {
                      stmtTemp = stmtTemp->get_parent();
                    } while (stmtTemp && !isSgStatement(stmtTemp));
                    ROSE_ASSERT (stmtTemp);
                    stmt = isSgStatement(stmtTemp);
                  }
               ROSE_ASSERT(stmt != NULL);

               int counter = 0;
               while(stmt && !(returnScope = isSgScopeStatement(stmt)))
                  {
#if 0
                    printf ("stmt->sage_class_name() = %s \n",stmt->sage_class_name());
#endif
                    ROSE_ASSERT (stmt->get_parent() != NULL);
#if 0
                    printf ("stmt->get_parent()->sage_class_name() = %s \n",stmt->get_parent()->sage_class_name());
#endif

                 // stmt = isSgStatement(stmt->get_parent());
                    SgInitializedName* initializedName = isSgInitializedName(stmt->get_parent());
                    if (initializedName != NULL)
                       {
#if 0
                         printf ("Get the stmt pointer from the initializedName->get_parent() = %p = %s \n",initializedName->get_parent(),initializedName->get_parent()->class_name().c_str());
#endif
                         stmt = isSgStatement(initializedName->get_parent());
                       }
                      else
                       {
                         stmt = isSgStatement(stmt->get_parent());
                       }
                    ROSE_ASSERT(stmt != NULL);

                 // DQ (9/23/2004): Avoid infinite loops, break out (abort) after some reasonable scope depth!
                    counter++;
                    if (counter > 1000)
                       {
                         printf ("Error max nesting depth exceeded, this is likely an error of some sort for a %s \n",sage_class_name());
                         printf ("\"this\" IR node %p = %s \n",this,sage_class_name());
                         get_file_info()->display("Error max nesting depth exceeded");
                         printf ("         stmt is %p = %s \n",stmt,stmt->sage_class_name());
                         stmt->get_file_info()->display("Error max nesting depth exceeded");
                         printf ("    has a parent %p = %s \n",stmt->get_parent(),stmt->get_parent()->sage_class_name());
                         ROSE_ASSERT(false);
                       }
                  }
               break;
             }
        }

  // DQ (11/25/2003): I think we can now assert this to be true!
  // DQ (11/27/2003): SgFunctionParameterList in a function prototype will cause 
  //                  returnScope == NULL.  So we can't assert this.
  // DQ (11/27/2003): Force SgFunctionParameterList case to use scope of the 
  //                  function declaration
     ROSE_ASSERT (returnScope != NULL);

  // Error checking!
     SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(returnScope);
     if (defn != NULL)
        {
          SgTemplateInstantiationDecl * decl = isSgTemplateInstantiationDecl(defn->get_declaration());
          ROSE_ASSERT(decl != NULL);
          if (decl->get_nameResetFromMangledForm() == false)
             {
#if PRINT_DEVELOPER_WARNINGS
               printf ("In get_scope(): Found template definition containing template declaration (%s) with nameResetFromMangledForm == false \n",decl->get_name().str());
#endif
#if 0
            // Uncomment this to find out where this construct is located in teh source code
               decl->get_file_info()->display("In SgStatement::get_scope(): debug");
#endif
             }
        }


#if 0
     printf ("In SgStatement::get_scope(): returnScope->sage_class_name() = %s \n",returnScope->sage_class_name());
#endif

     return returnScope;
   }

unsigned int
SgStatement::cfgIndexForEnd() const {
    std::cerr << "Bad statement case " << this->class_name() << " in cfgIndexForEnd()" << std::endl;
    ROSE_ASSERT (false);
    return 0;
  }

bool
SgStatement::cfgIsIndexInteresting(unsigned int idx) const {
    // Default -- overridden in some cases
    return idx == this->cfgIndexForEnd();
  }

unsigned int
SgStatement::cfgFindChildIndex(SgNode* n) {
    // Default -- overridden in some cases
    // FIXME -- should override with something faster than this code, even when
    // it works
    vector<SgNode*> succs = this->get_traversalSuccessorContainer();
    size_t idx = std::find(succs.begin(), succs.end(), n) - succs.begin();
    ROSE_ASSERT (idx != succs.size());
    return idx;
  }

unsigned int
SgStatement::cfgFindNextChildIndex(SgNode* n) {
    // Default -- overridden in some cases
    return this->cfgFindChildIndex(n) + 1;
  }

std::vector<VirtualCFG::CFGEdge>
SgStatement::cfgOutEdges(unsigned int) {
    std::cerr << "Bad statement case " << this->class_name() << " in cfgOutEdges()" << std::endl;
    ROSE_ASSERT (false);
    return std::vector<VirtualCFG::CFGEdge>();
  }

std::vector<VirtualCFG::CFGEdge>
SgStatement::cfgInEdges(unsigned int) {
    std::cerr << "Bad statement case " << this->class_name() << " in cfgInEdges()" << std::endl;
    ROSE_ASSERT (false);
    return std::vector<VirtualCFG::CFGEdge>();
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStatement::variantT() const {
  return V_SgStatement;
}

#if 0
int
SgStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return StatementTag;
   }
#endif

const char*
SgStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStatement";  
   }

std::string
SgStatement::class_name() const
   {
     assert(this != NULL);
     return "SgStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != StatementTag)
        {
          printf ("Error in SgStatement::error(): SgStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == StatementTag);
     return SgLocatedNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStatement::variant() const \n");
#endif
     assert(this != NULL);
     return StatementTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStatement* isSgStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStatement* isSgStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStatement::~SgStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgStatement::~SgStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for numeric_label
     p_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStatement::SgStatement ( Sg_File_Info* startOfConstruct )
   : SgLocatedNode(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgStatement::SgStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(StatementTag == variant());
     post_construction_initialization();

  // Test the isSgStatement() function since it has been problematic
     assert(isSgStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgSymbolTable* 
SgFunctionTypeTable::get_function_type_table () const
   {
     assert (this != NULL);
     return p_function_type_table;
   }

void
SgFunctionTypeTable::set_function_type_table ( SgSymbolTable* function_type_table )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_function_type_table != NULL && function_type_table != NULL && p_function_type_table != function_type_table)
        {
          printf ("Warning: function_type_table = %p overwriting valid pointer p_function_type_table = %p \n",function_type_table,p_function_type_table);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_function_type_table != NULL && function_type_table != NULL && p_function_type_table != function_type_table) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_function_type_table = function_type_table;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4257 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


/* \brief Hash table of function types (table is stored on global scope).

   Hash table of function types (table is stored on global scope and includes data
   from all scopes). Function types are placed into and retrived from this data 
   base (simgle hash table) of function types.
 */
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgFunctionTypeTable Sgfunc_type_table;

SgFunctionTypeTable::SgFunctionTypeTable ()
// DQ (8/31/2006): Use an empty name for the fileInfo so that we can support testing for absolute paths for filenames.
// : SgStatement( new Sg_File_Info ("SgFunctionTypeTable::SgFunctionTypeTable",0,0) )
   : SgStatement( new Sg_File_Info ("",0,0) )
   {
  // DQ (2/19/2007): Use a much larger size symbol table for the function types!
  // p_function_type_table = new SgSymbolTable();
     p_function_type_table = new SgSymbolTable(1001);
     ROSE_ASSERT(p_function_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_function_type_table->set_parent(this);

  // Set the parent of the Sg_File_Info object
     ROSE_ASSERT(get_file_info() != NULL);
     get_file_info()->set_parent(this);
  // p_startOfConstruct->set_parent(this);
   }

// DQ (2/19/2007): This appears to not be called but is here because 
// the ROSETTA code requires it (I think).
void
SgFunctionTypeTable::post_construction_initialization()
   {
   }

void
SgFunctionTypeTable::print_functypetable(std::ostream& os)
   {
  // printf ("ERROR: Sage SgFunctionTypeTable::print_functypetable function called! \n");
  // abort();

     os << endl << "...FuncTypeTbl..." << endl;
  // p_function_type_table.print(os);

     ROSE_ASSERT(p_function_type_table != NULL);
  // p_function_type_table->print(os);
     p_function_type_table->print("Called from SgFunctionTypeTable::print_functypetable");
   }

void
SgFunctionTypeTable::insert_function_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     ROSE_ASSERT (t != NULL);

     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);
#if 0
     printf ("Inside of SgFunctionTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s = %s \n",
          n.str(),t->sage_class_name(),t->unparseToString().c_str());
#endif
  // printf ("Is the qualified name being used! \n");
  // ROSE_ASSERT(false);

     p_function_type_table->insert(n, newSymbol);
  // p_function_type_table->insert(n, new SgFunctionTypeSymbol(n,t));
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgFunctionTypeTable::remove_function_type(const SgName& n)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     p_function_type_table->remove_function_type(n);
   }

#if 0
// see if this is ever used!
void
SgFunctionTypeTable::insert_function_type(const SgFunctionDeclaration *fdecl)
   {
     assert(fdecl != NULL);
     printf ("Inside of SgFunctionTypeTable::insert_function_type(SgFunctionDeclaration = %s) \n",fdecl->get_name().str());
     SgFunctionType* type = isSgFunctionType(fdecl->get_type());
     ROSE_ASSERT(type != NULL);

     SgName n = type->get_mangled_type();
  // printf ("Using function name = %s  should be using qualified function type name \n",n.str());

     printf ("Looking up %s in function table \n",n.str());
     if (lookup_function_type(n) != NULL)
        {
          printf ("Found function %s (skip reinsertion) \n",n.str());
       // return; // DQ: no need for multiple return!
        }
       else
        {
       // printf ("Function NOT Found: so insert in table %s \n",n.str());
          insert_function_type(n,type);
        }
   }
#endif

SgType*
SgFunctionTypeTable::lookup_function_type(const SgName& n)
   {
  // printf ("In SgFunctionTypeTable::lookup_function_type: Looking for %s \n",n.str());
     ROSE_ASSERT (p_function_type_table != NULL);
  // SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(p_function_type_table->findfunctype(n));
     SgSymbol *symbol = p_function_type_table->find_function_type(n);
     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);
     SgType* returnType = NULL;

     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
       // printf ("In SgFunctionTypeTable::lookup_function_type(): found function type %s \n",returnType->class_name().c_str());
        }

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionTypeTable::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionTypeTable::variantT() const {
  return V_SgFunctionTypeTable;
}

#if 0
int
SgFunctionTypeTable::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNC_TBL_STMT;
   }
#endif

const char*
SgFunctionTypeTable::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionTypeTable";  
   }

std::string
SgFunctionTypeTable::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionTypeTable";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionTypeTable::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionTypeTable::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNC_TBL_STMT)
        {
          printf ("Error in SgFunctionTypeTable::error(): SgFunctionTypeTable object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionTypeTable::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNC_TBL_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionTypeTable::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionTypeTable::variant() const \n");
#endif
     assert(this != NULL);
     return FUNC_TBL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionTypeTable* isSgFunctionTypeTable ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionTypeTable*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionTypeTable* isSgFunctionTypeTable ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionTypeTable*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionTypeTable::~SgFunctionTypeTable ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionTypeTable::~SgFunctionTypeTable (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_function_type_table;

  // case: not a listType for function_type_table
     p_function_type_table = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgExprStatement::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgExprStatement::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10736 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgExprStatement::cfgIndexForEnd() const {
  return 1;
}

std::vector<VirtualCFG::CFGEdge> SgExprStatement::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
 // case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_expression_root()->cfgForBeginning(), result); break;
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_expression()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgExprStatement");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgExprStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
 // case 1: makeEdge(this->get_expression_root()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_expression()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    default: ROSE_ASSERT (!"Bad index for SgExprStatement");
  }
  return result;
}

// QY: 9/30/2004   removed the expr_i pointer in exprStatement. Use exprRoot directly as constructor parameter
void
SgExprStatement::post_construction_initialization() 
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != NULL)
  //      get_expression_root()->set_statement(this);

  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.
     if (get_expression() != NULL)
          get_expression()->set_parent(this);
   }

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformally on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgExprStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgExprStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgExprStatement::variantT() const {
  return V_SgExprStatement;
}

#if 0
int
SgExprStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPR_STMT;
   }
#endif

const char*
SgExprStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgExprStatement";  
   }

std::string
SgExprStatement::class_name() const
   {
     assert(this != NULL);
     return "SgExprStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgExprStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgExprStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPR_STMT)
        {
          printf ("Error in SgExprStatement::error(): SgExprStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgExprStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPR_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgExprStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgExprStatement::variant() const \n");
#endif
     assert(this != NULL);
     return EXPR_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgExprStatement* isSgExprStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgExprStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgExprStatement* isSgExprStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgExprStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgExprStatement::~SgExprStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgExprStatement::~SgExprStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for expression
     p_expression = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgExprStatement::SgExprStatement ( Sg_File_Info* startOfConstruct, SgExpression* expression )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgExprStatement::SgExprStatement (Sg_File_Info* startOfConstruct, SgExpression* expression) sage_class_name() = %s \n",sage_class_name());
#endif

     p_expression = expression;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(EXPR_STMT == variant());
     post_construction_initialization();

  // Test the isSgExprStatement() function since it has been problematic
     assert(isSgExprStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgLabelStatement::get_label () const
   {
     assert (this != NULL);
     return p_label;
   }

void
SgLabelStatement::set_label ( SgName label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_label = label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgLabelStatement::get_statement () const
   {
     assert (this != NULL);
     return p_statement;
   }

void
SgLabelStatement::set_statement ( SgStatement* statement )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_statement != NULL && statement != NULL && p_statement != statement)
        {
          printf ("Warning: statement = %p overwriting valid pointer p_statement = %p \n",statement,p_statement);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_statement != NULL && statement != NULL && p_statement != statement) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_statement = statement;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10806 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgLabelStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
#if DEBUG_FIXUP_COPY
     printf ("Inside of SgLabelStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

     SgLabelStatement* labelStatement_copy = isSgLabelStatement(copy);
     ROSE_ASSERT(labelStatement_copy != NULL);

  // I don't think there is anything to do here since we already make sure that there is a new SgLabelSymbol
  // and it is the SgGotoStatement that has to have it's reference to the label fixed up if the label and the
  // goto statement have been copied.

#if 0
  // DQ (10/15/2007): We now insert everything into the map so that we can reference IR nodes later and find 
  // their associated node in the copy of the AST.

  // DQ (10/13/2007): Record that we made a copy of this label so that any goto statements that reference 
  // it can be fixed up if they are also copied.
     help.insertCopiedNodePair(this,labelStatement_copy);
#endif

  // Also call the base class version of the fixupCopycopy() member function
     SgStatement::fixupCopy(copy,help);
   }
#endif

unsigned int
SgLabelStatement::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge> SgLabelStatement::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
          default: ROSE_ASSERT (!"Bad index for SgLabelStatement");
        }

     return result;
   }

std::vector<VirtualCFG::CFGEdge> SgLabelStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
      // Find all gotos to this label, functionwide
      SgFunctionDefinition* thisFunction = getEnclosingProcedure(this);
      std::vector<SgGotoStatement*> gotos = findGotos(thisFunction, this);
      for (unsigned int i = 0; i < gotos.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(gotos[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgLabelStatement");
  }
  return result;
}

void
SgLabelStatement::post_construction_initialization()
   {
   }

SgName
SgLabelStatement::get_name() const 
   {
     return get_label();
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgLabelStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLabelStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLabelStatement::variantT() const {
  return V_SgLabelStatement;
}

#if 0
int
SgLabelStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LABEL_STMT;
   }
#endif

const char*
SgLabelStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLabelStatement";  
   }

std::string
SgLabelStatement::class_name() const
   {
     assert(this != NULL);
     return "SgLabelStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLabelStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLabelStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LABEL_STMT)
        {
          printf ("Error in SgLabelStatement::error(): SgLabelStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLabelStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LABEL_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLabelStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLabelStatement::variant() const \n");
#endif
     assert(this != NULL);
     return LABEL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLabelStatement* isSgLabelStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLabelStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLabelStatement* isSgLabelStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLabelStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLabelStatement::~SgLabelStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgLabelStatement::~SgLabelStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for label
     p_label = ""; // non list case 
  // case: not a listType for statement
     p_statement = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLabelStatement::SgLabelStatement ( Sg_File_Info* startOfConstruct, SgName label, SgStatement* statement )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgLabelStatement::SgLabelStatement (Sg_File_Info* startOfConstruct, SgName label, SgStatement* statement) sage_class_name() = %s \n",sage_class_name());
#endif

     p_label = label;
     p_statement = statement;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LABEL_STMT == variant());
     post_construction_initialization();

  // Test the isSgLabelStatement() function since it has been problematic
     assert(isSgLabelStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgCaseOptionStmt::get_key () const
   {
     assert (this != NULL);
     return p_key;
   }

void
SgCaseOptionStmt::set_key ( SgExpression* key )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_key != NULL && key != NULL && p_key != key)
        {
          printf ("Warning: key = %p overwriting valid pointer p_key = %p \n",key,p_key);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_key != NULL && key != NULL && p_key != key) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_key = key;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgCaseOptionStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgCaseOptionStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgCaseOptionStmt::get_key_range_end () const
   {
     assert (this != NULL);
     return p_key_range_end;
   }

void
SgCaseOptionStmt::set_key_range_end ( SgExpression* key_range_end )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_key_range_end != NULL && key_range_end != NULL && p_key_range_end != key_range_end)
        {
          printf ("Warning: key_range_end = %p overwriting valid pointer p_key_range_end = %p \n",key_range_end,p_key_range_end);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_key_range_end != NULL && key_range_end != NULL && p_key_range_end != key_range_end) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_key_range_end = key_range_end;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11210 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgCaseOptionStmt::cfgIndexForEnd() const {
  return 1;
}


bool SgCaseOptionStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0;
}

unsigned int SgCaseOptionStmt::cfgFindChildIndex(SgNode* n) {
  ROSE_ASSERT (n == this->get_body());
  return 0;
}

std::vector<VirtualCFG::CFGEdge> SgCaseOptionStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgCaseOptionStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgCaseOptionStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
      SgSwitchStatement* mySwitch = findEnclosingSwitch(this);
      makeEdge(VirtualCFG::CFGNode(mySwitch, 1), VirtualCFG::CFGNode(this, idx), result);
      break;
    }
    case 1: makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    default: ROSE_ASSERT (!"Bad index for SgCaseOptionStmt");
  }
  return result;
}

void
SgCaseOptionStmt::post_construction_initialization() 
   {
  // if (get_key_root() != 0)
  //      get_key_root()->set_statement(this);
   }

bool
SgCaseOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCaseOptionStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCaseOptionStmt::variantT() const {
  return V_SgCaseOptionStmt;
}

#if 0
int
SgCaseOptionStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CASE_STMT;
   }
#endif

const char*
SgCaseOptionStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCaseOptionStmt";  
   }

std::string
SgCaseOptionStmt::class_name() const
   {
     assert(this != NULL);
     return "SgCaseOptionStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCaseOptionStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCaseOptionStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CASE_STMT)
        {
          printf ("Error in SgCaseOptionStmt::error(): SgCaseOptionStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCaseOptionStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CASE_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCaseOptionStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCaseOptionStmt::variant() const \n");
#endif
     assert(this != NULL);
     return CASE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCaseOptionStmt* isSgCaseOptionStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCaseOptionStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCaseOptionStmt* isSgCaseOptionStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCaseOptionStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCaseOptionStmt::~SgCaseOptionStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgCaseOptionStmt::~SgCaseOptionStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for key
     p_key = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for key_range_end
     p_key_range_end  = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCaseOptionStmt::SgCaseOptionStmt ( Sg_File_Info* startOfConstruct, SgExpression* key, SgBasicBlock* body )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCaseOptionStmt::SgCaseOptionStmt (Sg_File_Info* startOfConstruct, SgExpression* key, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_key = key;
     p_body = body;
     p_key_range_end  = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CASE_STMT == variant());
     post_construction_initialization();

  // Test the isSgCaseOptionStmt() function since it has been problematic
     assert(isSgCaseOptionStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgTryStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgTryStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgCatchStatementSeq* 
SgTryStmt::get_catch_statement_seq_root () const
   {
     assert (this != NULL);
     return p_catch_statement_seq_root;
   }

void
SgTryStmt::set_catch_statement_seq_root ( SgCatchStatementSeq* catch_statement_seq_root )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_catch_statement_seq_root != NULL && catch_statement_seq_root != NULL && p_catch_statement_seq_root != catch_statement_seq_root)
        {
          printf ("Warning: catch_statement_seq_root = %p overwriting valid pointer p_catch_statement_seq_root = %p \n",catch_statement_seq_root,p_catch_statement_seq_root);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_catch_statement_seq_root != NULL && catch_statement_seq_root != NULL && p_catch_statement_seq_root != catch_statement_seq_root) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_catch_statement_seq_root = catch_statement_seq_root;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11269 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgTryStmt::cfgIndexForEnd() const {
  return 1;
}

bool SgTryStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return true;
}

std::vector<VirtualCFG::CFGEdge> SgTryStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgTryStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgTryStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    default: ROSE_ASSERT (!"Bad index for SgTryStmt");
  }
  return result;
}

void
SgTryStmt::post_construction_initialization()
   {
  // MS: C++98: compound-statement (SgBasicBlock in SAGE)
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_body())
          get_body()->set_parent(this);
#endif

     // MS: moved catch_statement_seq to CatchStatementSeq, therefore we need to init it here now
     if (get_catch_statement_seq_root() == NULL)
        {
          Sg_File_Info* fileInfo = NULL;
          if (this->get_file_info() != NULL)
             {
            // Get a copy of this to avoid sharing!
               fileInfo = new Sg_File_Info( *(this->get_file_info()) );
             }
       // assert (fileInfo != NULL);
          SgCatchStatementSeq* catchStatement = NULL;
          if (fileInfo != NULL)
             {
            // DQ (10/16/2007): This appears to be set to the wrong parent.
            // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
               fileInfo->set_parent(this);

            // DQ (10/31/2006): Set the end of source for the SgCatchStatementSeq
            // set_catch_statement_seq_root( new SgCatchStatementSeq(fileInfo));
               catchStatement = new SgCatchStatementSeq(fileInfo);

            // DQ (10/16/2007): Set the parent of the fileInfo used for the SgCatchStatementSeq to the catchStatement
               fileInfo->set_parent(catchStatement);

               catchStatement->set_endOfConstruct(New_File_Info(catchStatement));

            // DQ (10/16/2007): Set the parent
               catchStatement->get_endOfConstruct()->set_parent(catchStatement);
             }
            else
             {
               catchStatement = new SgCatchStatementSeq();
             }

          set_catch_statement_seq_root( catchStatement );
        }
   }

bool
SgTryStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_body, target, newstmt) == true )
          return true;
       else
          return ( StatementReplace( this, p_catch_statement_seq_root, target, newstmt) == true );
   }


// MS: C++98: handler_seq (catch_statement_seq in SAGE)
SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler_seq (catch_statement_seq in SAGE)
const SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() const {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::append_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq_root()->append_catch_statement(what);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::prepend_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq_root()->prepend_catch_statement(what);
   }


// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq_root()->insert_catch_statement(where,what);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTryStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTryStmt::variantT() const {
  return V_SgTryStmt;
}

#if 0
int
SgTryStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TRY_STMT;
   }
#endif

const char*
SgTryStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTryStmt";  
   }

std::string
SgTryStmt::class_name() const
   {
     assert(this != NULL);
     return "SgTryStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTryStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTryStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TRY_STMT)
        {
          printf ("Error in SgTryStmt::error(): SgTryStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTryStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TRY_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTryStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTryStmt::variant() const \n");
#endif
     assert(this != NULL);
     return TRY_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTryStmt* isSgTryStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTryStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTryStmt* isSgTryStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTryStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTryStmt::~SgTryStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgTryStmt::~SgTryStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for catch_statement_seq_root
     p_catch_statement_seq_root = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTryStmt::SgTryStmt ( Sg_File_Info* startOfConstruct, SgBasicBlock* body )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTryStmt::SgTryStmt (Sg_File_Info* startOfConstruct, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_body = body;
     p_catch_statement_seq_root = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TRY_STMT == variant());
     post_construction_initialization();

  // Test the isSgTryStmt() function since it has been problematic
     assert(isSgTryStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgDefaultOptionStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgDefaultOptionStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11557 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgDefaultOptionStmt::cfgIndexForEnd() const {
  return 1;
}

bool SgDefaultOptionStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0;
}

std::vector<VirtualCFG::CFGEdge> SgDefaultOptionStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgDefaultOptionStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgDefaultOptionStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
      SgSwitchStatement* mySwitch = findEnclosingSwitch(this);
      makeEdge(VirtualCFG::CFGNode(mySwitch, 1), VirtualCFG::CFGNode(this, idx), result);
      break;
    }
    case 1: makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    default: ROSE_ASSERT (!"Bad index for SgDefaultOptionStmt");
  }
  return result;
}

void
SgDefaultOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgDefaultOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgDefaultOptionStmt::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_body();
        }
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDefaultOptionStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDefaultOptionStmt::variantT() const {
  return V_SgDefaultOptionStmt;
}

#if 0
int
SgDefaultOptionStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DEFAULT_STMT;
   }
#endif

const char*
SgDefaultOptionStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDefaultOptionStmt";  
   }

std::string
SgDefaultOptionStmt::class_name() const
   {
     assert(this != NULL);
     return "SgDefaultOptionStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDefaultOptionStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDefaultOptionStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DEFAULT_STMT)
        {
          printf ("Error in SgDefaultOptionStmt::error(): SgDefaultOptionStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDefaultOptionStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DEFAULT_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDefaultOptionStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDefaultOptionStmt::variant() const \n");
#endif
     assert(this != NULL);
     return DEFAULT_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDefaultOptionStmt* isSgDefaultOptionStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDefaultOptionStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDefaultOptionStmt* isSgDefaultOptionStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDefaultOptionStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDefaultOptionStmt::~SgDefaultOptionStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgDefaultOptionStmt::~SgDefaultOptionStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for body
     p_body = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDefaultOptionStmt::SgDefaultOptionStmt ( Sg_File_Info* startOfConstruct, SgBasicBlock* body )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDefaultOptionStmt::SgDefaultOptionStmt (Sg_File_Info* startOfConstruct, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_body = body;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DEFAULT_STMT == variant());
     post_construction_initialization();

  // Test the isSgDefaultOptionStmt() function since it has been problematic
     assert(isSgDefaultOptionStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 11627 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgBreakStmt::cfgIndexForEnd() const {
  return 1; // So the end of this construct will be an unreachable node
}

bool SgBreakStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0;
}

std::vector<VirtualCFG::CFGEdge> SgBreakStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      SgStatement* enc = this;
      while (enc && !isSgDoWhileStmt(enc) && !isSgForStatement(enc) &&
	     !isSgWhileStmt(enc) && !isSgSwitchStatement(enc)) {
	enc = isSgStatement(enc->get_parent());
      }
      ROSE_ASSERT (enc);
      unsigned int newIndex;
      switch (enc->variantT()) {
	case V_SgDoWhileStmt: newIndex = 3; break;
	case V_SgForStatement: newIndex = 4; break;
	case V_SgWhileStmt: newIndex = 2; break;
	case V_SgSwitchStatement: newIndex = 2; break;
	default: ROSE_ASSERT (false);
      }
      makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(enc, newIndex), result);
      break;
    }
    case 1: /* No out edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgBreakStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgBreakStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: /* No in edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgBreakStmt");
  }
  return result;
}

void
SgBreakStmt::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBreakStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBreakStmt::variantT() const {
  return V_SgBreakStmt;
}

#if 0
int
SgBreakStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BREAK_STMT;
   }
#endif

const char*
SgBreakStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBreakStmt";  
   }

std::string
SgBreakStmt::class_name() const
   {
     assert(this != NULL);
     return "SgBreakStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBreakStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBreakStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BREAK_STMT)
        {
          printf ("Error in SgBreakStmt::error(): SgBreakStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBreakStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BREAK_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBreakStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBreakStmt::variant() const \n");
#endif
     assert(this != NULL);
     return BREAK_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBreakStmt* isSgBreakStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBreakStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBreakStmt* isSgBreakStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBreakStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBreakStmt::~SgBreakStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgBreakStmt::~SgBreakStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBreakStmt::SgBreakStmt ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgBreakStmt::SgBreakStmt (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(BREAK_STMT == variant());
     post_construction_initialization();

  // Test the isSgBreakStmt() function since it has been problematic
     assert(isSgBreakStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 11682 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgContinueStmt::cfgIndexForEnd() const {
  return 1; // So the end of this construct will be an unreachable node
}

bool SgContinueStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0;
}

std::vector<VirtualCFG::CFGEdge> SgContinueStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      SgStatement* loop = this;
      while (loop && !isSgDoWhileStmt(loop) && !isSgForStatement(loop) &&
	     !isSgWhileStmt(loop)) {
	loop = isSgStatement(loop->get_parent());
      }
      ROSE_ASSERT (loop);
      unsigned int newIndex;
      switch (loop->variantT()) {
	case V_SgDoWhileStmt: newIndex = 1; break;
	case V_SgForStatement: newIndex = 3; break;
	case V_SgWhileStmt: newIndex = 0; break;
	default: ROSE_ASSERT (false);
      }
      makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(loop, newIndex), result);
      break;
    }
    case 1: /* No out edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgContinueStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgContinueStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: /* No in edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgContinueStmt");
  }
  return result;
}

void
SgContinueStmt::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgContinueStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgContinueStmt::variantT() const {
  return V_SgContinueStmt;
}

#if 0
int
SgContinueStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CONTINUE_STMT;
   }
#endif

const char*
SgContinueStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgContinueStmt";  
   }

std::string
SgContinueStmt::class_name() const
   {
     assert(this != NULL);
     return "SgContinueStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgContinueStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgContinueStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CONTINUE_STMT)
        {
          printf ("Error in SgContinueStmt::error(): SgContinueStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgContinueStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CONTINUE_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgContinueStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgContinueStmt::variant() const \n");
#endif
     assert(this != NULL);
     return CONTINUE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgContinueStmt* isSgContinueStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgContinueStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgContinueStmt* isSgContinueStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgContinueStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgContinueStmt::~SgContinueStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgContinueStmt::~SgContinueStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgContinueStmt::SgContinueStmt ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgContinueStmt::SgContinueStmt (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(CONTINUE_STMT == variant());
     post_construction_initialization();

  // Test the isSgContinueStmt() function since it has been problematic
     assert(isSgContinueStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgReturnStmt::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgReturnStmt::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11737 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgReturnStmt::cfgIndexForEnd() const
   {
  // return this->get_expression_root() ? 1 : 0;
     return this->get_expression() ? 1 : 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgReturnStmt::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
  // bool hasReturnValue = this->get_expression_root();
     bool hasReturnValue = this->get_expression();
     bool exitingFunctionNow = idx == 1 || (idx == 0 && !hasReturnValue);
     if (exitingFunctionNow)
        {
          SgFunctionDefinition* enclosingFunc = getEnclosingProcedure(this);
          makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(enclosingFunc, 2), result);
        }
       else
        {
          makeEdge(VirtualCFG::CFGNode(this, idx), this->get_expression()->cfgForBeginning(), result);
        }
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgReturnStmt::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
          case 1: ROSE_ASSERT (this->get_expression());
	            makeEdge(this->get_expression()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
          default: ROSE_ASSERT (!"Bad index for SgReturnStmt");
        }
     return result;
   }

void
SgReturnStmt::post_construction_initialization()
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != 0)
  //    get_expression_root()->set_statement(this);
   }

// DQ (12/15/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformally on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgReturnStmt::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgReturnStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgReturnStmt::variantT() const {
  return V_SgReturnStmt;
}

#if 0
int
SgReturnStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return RETURN_STMT;
   }
#endif

const char*
SgReturnStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgReturnStmt";  
   }

std::string
SgReturnStmt::class_name() const
   {
     assert(this != NULL);
     return "SgReturnStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgReturnStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgReturnStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != RETURN_STMT)
        {
          printf ("Error in SgReturnStmt::error(): SgReturnStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgReturnStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == RETURN_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgReturnStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgReturnStmt::variant() const \n");
#endif
     assert(this != NULL);
     return RETURN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgReturnStmt* isSgReturnStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgReturnStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgReturnStmt* isSgReturnStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgReturnStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgReturnStmt::~SgReturnStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgReturnStmt::~SgReturnStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for expression
     p_expression = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgReturnStmt::SgReturnStmt ( Sg_File_Info* startOfConstruct, SgExpression* expression )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgReturnStmt::SgReturnStmt (Sg_File_Info* startOfConstruct, SgExpression* expression) sage_class_name() = %s \n",sage_class_name());
#endif

     p_expression = expression;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(RETURN_STMT == variant());
     post_construction_initialization();

  // Test the isSgReturnStmt() function since it has been problematic
     assert(isSgReturnStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgGotoStatement::get_label () const
   {
     assert (this != NULL);
     return p_label;
   }

void
SgGotoStatement::set_label ( SgLabelStatement* label )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_label != NULL && label != NULL && p_label != label)
        {
          printf ("Warning: label = %p overwriting valid pointer p_label = %p \n",label,p_label);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_label != NULL && label != NULL && p_label != label) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_label = label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11815 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgGotoStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
#if DEBUG_FIXUP_COPY
     printf ("Inside of SgGotoStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

     SgGotoStatement* gotoStatement_copy = isSgGotoStatement(copy);
     ROSE_ASSERT(gotoStatement_copy != NULL);

     SgLabelStatement* labelStatement_original = get_label();

     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(labelStatement_original);

  // printf ("Inside of SgGotoStatement::fixupCopy(): i != help.get_copiedNodeMap().end() = %s \n",(i != help.get_copiedNodeMap().end()) ? "true" : "false");

  // If the declaration is in the map then it is because we have copied it previously
  // and thus it should be updated to reflect the copied declaration.
     if (i != help.get_copiedNodeMap().end())
        {
          SgLabelStatement* labelStatement_copy = isSgLabelStatement(i->second);
          ROSE_ASSERT(labelStatement_copy != NULL);
          gotoStatement_copy->set_label(labelStatement_copy);
        }

  // Also call the base class version of the fixupCopycopy() member function
     SgStatement::fixupCopy(copy,help);
   }
#endif

unsigned int
SgGotoStatement::cfgIndexForEnd() const {
  return 1; // So the end of this construct will be an unreachable node
}

bool SgGotoStatement::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0;
}

std::vector<VirtualCFG::CFGEdge> SgGotoStatement::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_label()->cfgForBeginning(), result); break;
    case 1: /* No out edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgGotoStatement");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgGotoStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: /* No in edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgGotoStatement");
  }
  return result;
}

void
SgGotoStatement::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_label())
        {
          get_label()->set_parent(this);
        }
#endif
   }

bool
SgGotoStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_label, target, newstmt) == true );
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGotoStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGotoStatement::variantT() const {
  return V_SgGotoStatement;
}

#if 0
int
SgGotoStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GOTO_STMT;
   }
#endif

const char*
SgGotoStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGotoStatement";  
   }

std::string
SgGotoStatement::class_name() const
   {
     assert(this != NULL);
     return "SgGotoStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGotoStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGotoStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GOTO_STMT)
        {
          printf ("Error in SgGotoStatement::error(): SgGotoStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGotoStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GOTO_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGotoStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGotoStatement::variant() const \n");
#endif
     assert(this != NULL);
     return GOTO_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGotoStatement* isSgGotoStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGotoStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGotoStatement* isSgGotoStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGotoStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGotoStatement::~SgGotoStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgGotoStatement::~SgGotoStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for label
     p_label = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGotoStatement::SgGotoStatement ( Sg_File_Info* startOfConstruct, SgLabelStatement* label )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgGotoStatement::SgGotoStatement (Sg_File_Info* startOfConstruct, SgLabelStatement* label) sage_class_name() = %s \n",sage_class_name());
#endif

     p_label = label;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(GOTO_STMT == variant());
     post_construction_initialization();

  // Test the isSgGotoStatement() function since it has been problematic
     assert(isSgGotoStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionCallExp* 
SgSpawnStmt::get_the_func () const
   {
     assert (this != NULL);
     return p_the_func;
   }

void
SgSpawnStmt::set_the_func ( SgFunctionCallExp* the_func )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_the_func != NULL && the_func != NULL && p_the_func != the_func)
        {
          printf ("Warning: the_func = %p overwriting valid pointer p_the_func = %p \n",the_func,p_the_func);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_the_func != NULL && the_func != NULL && p_the_func != the_func) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_the_func = the_func;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11986 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgSpawnStmt::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSpawnStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSpawnStmt::variantT() const {
  return V_SgSpawnStmt;
}

#if 0
int
SgSpawnStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SPAWN_STMT;
   }
#endif

const char*
SgSpawnStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSpawnStmt";  
   }

std::string
SgSpawnStmt::class_name() const
   {
     assert(this != NULL);
     return "SgSpawnStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSpawnStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSpawnStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SPAWN_STMT)
        {
          printf ("Error in SgSpawnStmt::error(): SgSpawnStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSpawnStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SPAWN_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSpawnStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSpawnStmt::variant() const \n");
#endif
     assert(this != NULL);
     return SPAWN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSpawnStmt* isSgSpawnStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSpawnStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSpawnStmt* isSgSpawnStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSpawnStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSpawnStmt::~SgSpawnStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgSpawnStmt::~SgSpawnStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for the_func
     p_the_func = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSpawnStmt::SgSpawnStmt ( Sg_File_Info* startOfConstruct, SgFunctionCallExp* the_func )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSpawnStmt::SgSpawnStmt (Sg_File_Info* startOfConstruct, SgFunctionCallExp* the_func) sage_class_name() = %s \n",sage_class_name());
#endif

     p_the_func = the_func;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SPAWN_STMT == variant());
     post_construction_initialization();

  // Test the isSgSpawnStmt() function since it has been problematic
     assert(isSgSpawnStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 11995 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgNullStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNullStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNullStatement::variantT() const {
  return V_SgNullStatement;
}

#if 0
int
SgNullStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NULL_STMT;
   }
#endif

const char*
SgNullStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNullStatement";  
   }

std::string
SgNullStatement::class_name() const
   {
     assert(this != NULL);
     return "SgNullStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNullStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNullStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NULL_STMT)
        {
          printf ("Error in SgNullStatement::error(): SgNullStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNullStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NULL_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNullStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNullStatement::variant() const \n");
#endif
     assert(this != NULL);
     return NULL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNullStatement* isSgNullStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNullStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNullStatement* isSgNullStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNullStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNullStatement::~SgNullStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgNullStatement::~SgNullStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNullStatement::SgNullStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNullStatement::SgNullStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(NULL_STMT == variant());
     post_construction_initialization();

  // Test the isSgNullStatement() function since it has been problematic
     assert(isSgNullStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 12004 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgVariantStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVariantStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVariantStatement::variantT() const {
  return V_SgVariantStatement;
}

#if 0
int
SgVariantStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VARIANT_STMT;
   }
#endif

const char*
SgVariantStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVariantStatement";  
   }

std::string
SgVariantStatement::class_name() const
   {
     assert(this != NULL);
     return "SgVariantStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVariantStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVariantStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VARIANT_STMT)
        {
          printf ("Error in SgVariantStatement::error(): SgVariantStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVariantStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VARIANT_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVariantStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVariantStatement::variant() const \n");
#endif
     assert(this != NULL);
     return VARIANT_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVariantStatement* isSgVariantStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVariantStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVariantStatement* isSgVariantStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVariantStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVariantStatement::~SgVariantStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgVariantStatement::~SgVariantStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVariantStatement::SgVariantStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVariantStatement::SgVariantStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(VARIANT_STMT == variant());
     post_construction_initialization();

  // Test the isSgVariantStatement() function since it has been problematic
     assert(isSgVariantStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgStatementPtrList &
SgForInitStatement::get_init_stmt () const
   {
     assert (this != NULL);
     return p_init_stmt;
   }

SgStatementPtrList &
SgForInitStatement::get_init_stmt () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_init_stmt;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 6575 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgForInitStatement::cfgIndexForEnd() const {
  return this->get_init_stmt().size();
}

std::vector<VirtualCFG::CFGEdge>
SgForInitStatement::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == this->get_init_stmt().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  } else if (idx < this->get_init_stmt().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), this->get_init_stmt()[idx]->cfgForBeginning(), result);
  } else ROSE_ASSERT (!"Bad index for SgForInitStatement");
  return result;
}

std::vector<VirtualCFG::CFGEdge>
SgForInitStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == 0) {
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  } else if (idx <= this->get_init_stmt().size()) {
    makeEdge(this->get_init_stmt()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
  } else ROSE_ASSERT (!"Bad index for SgForInitStatement");
  return result;
}

void
SgForInitStatement::post_construction_initialization()
   {
   }

void
SgForInitStatement::append_init_stmt(SgStatement * what)
   {
     insert_init_stmt(get_init_stmt().end(),what);
   }

void
SgForInitStatement::prepend_init_stmt(SgStatement * what)
   {
     insert_init_stmt(get_init_stmt().begin(),what);
   }

void
SgForInitStatement::insert_init_stmt(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

  // DQ (6/24/2006): This is a structural operation so it is OK to set the parent
     what->set_parent(this);

     get_init_stmt().insert(where,what);
   }

bool
SgForInitStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_init_stmt, target, newstmt, true, extractBasicBlock, true);
   }

bool 
SgForInitStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_init_stmt, target, newstmt, inFront, extractBasicBlock, false);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgForInitStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgForInitStatement::variantT() const {
  return V_SgForInitStatement;
}

#if 0
int
SgForInitStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FOR_INIT_STMT;
   }
#endif

const char*
SgForInitStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgForInitStatement";  
   }

std::string
SgForInitStatement::class_name() const
   {
     assert(this != NULL);
     return "SgForInitStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgForInitStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgForInitStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FOR_INIT_STMT)
        {
          printf ("Error in SgForInitStatement::error(): SgForInitStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgForInitStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FOR_INIT_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgForInitStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgForInitStatement::variant() const \n");
#endif
     assert(this != NULL);
     return FOR_INIT_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgForInitStatement* isSgForInitStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgForInitStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgForInitStatement* isSgForInitStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgForInitStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgForInitStatement::~SgForInitStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgForInitStatement::~SgForInitStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgForInitStatement::SgForInitStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgForInitStatement::SgForInitStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(FOR_INIT_STMT == variant());
     post_construction_initialization();

  // Test the isSgForInitStatement() function since it has been problematic
     assert(isSgForInitStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgStatementPtrList &
SgCatchStatementSeq::get_catch_statement_seq () const
   {
     assert (this != NULL);
     return p_catch_statement_seq;
   }

SgStatementPtrList &
SgCatchStatementSeq::get_catch_statement_seq () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_catch_statement_seq;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11397 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgCatchStatementSeq::cfgIndexForEnd() const {
  return this->get_catch_statement_seq().size();
}

bool SgCatchStatementSeq::cfgIsIndexInteresting(unsigned int idx) const {
  return false;
}

std::vector<VirtualCFG::CFGEdge> SgCatchStatementSeq::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  // FIXME
  if (idx == this->get_catch_statement_seq().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  } else if (idx < this->get_catch_statement_seq().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), this->get_catch_statement_seq()[idx]->cfgForBeginning(), result);
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgCatchStatementSeq::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  // FIXME
  if (idx == 0) {
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  } else if (idx <= this->get_catch_statement_seq().size()) {
    makeEdge(this->get_catch_statement_seq()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
  } else ROSE_ASSERT (!"Bad index for SgCatchStatementSeq");
  return result;
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::post_construction_initialization() {
  SgStatementPtrList::iterator p = get_catch_statement_seq().begin();
  for (p = get_catch_statement_seq().begin(); p != get_catch_statement_seq().end(); p++)
    {
      ROSE_ASSERT((*p) != NULL);
      delete (*p);
      (*p) = NULL;
    }
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::append_catch_statement(SgStatement * what)
   {
     insert_catch_statement(get_catch_statement_seq().end(),what);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::prepend_catch_statement(SgStatement * what)
   {
     insert_catch_statement(get_catch_statement_seq().begin(),what);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq().insert(where,what);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCatchStatementSeq::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCatchStatementSeq::variantT() const {
  return V_SgCatchStatementSeq;
}

#if 0
int
SgCatchStatementSeq::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CATCH_STATEMENT_SEQ;
   }
#endif

const char*
SgCatchStatementSeq::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCatchStatementSeq";  
   }

std::string
SgCatchStatementSeq::class_name() const
   {
     assert(this != NULL);
     return "SgCatchStatementSeq";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCatchStatementSeq::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCatchStatementSeq::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CATCH_STATEMENT_SEQ)
        {
          printf ("Error in SgCatchStatementSeq::error(): SgCatchStatementSeq object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCatchStatementSeq::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CATCH_STATEMENT_SEQ);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCatchStatementSeq::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCatchStatementSeq::variant() const \n");
#endif
     assert(this != NULL);
     return CATCH_STATEMENT_SEQ;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCatchStatementSeq* isSgCatchStatementSeq ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCatchStatementSeq*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCatchStatementSeq* isSgCatchStatementSeq ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCatchStatementSeq*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCatchStatementSeq::~SgCatchStatementSeq ()
   {
#if 0
  // debugging information!
     printf ("In SgCatchStatementSeq::~SgCatchStatementSeq (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCatchStatementSeq::SgCatchStatementSeq ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCatchStatementSeq::SgCatchStatementSeq (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(CATCH_STATEMENT_SEQ == variant());
     post_construction_initialization();

  // Test the isSgCatchStatementSeq() function since it has been problematic
     assert(isSgCatchStatementSeq(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgInterfaceStatement::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgInterfaceStatement::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgInterfaceStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgInterfaceStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgInterfaceStatement::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgInterfaceStatement::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgInterfaceStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgInterfaceStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13509 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgInterfaceStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInterfaceStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInterfaceStatement::variantT() const {
  return V_SgInterfaceStatement;
}

#if 0
int
SgInterfaceStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INTERFACE_STATEMENT;
   }
#endif

const char*
SgInterfaceStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInterfaceStatement";  
   }

std::string
SgInterfaceStatement::class_name() const
   {
     assert(this != NULL);
     return "SgInterfaceStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInterfaceStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInterfaceStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INTERFACE_STATEMENT)
        {
          printf ("Error in SgInterfaceStatement::error(): SgInterfaceStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInterfaceStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INTERFACE_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInterfaceStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInterfaceStatement::variant() const \n");
#endif
     assert(this != NULL);
     return INTERFACE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInterfaceStatement* isSgInterfaceStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInterfaceStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInterfaceStatement* isSgInterfaceStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInterfaceStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInterfaceStatement::~SgInterfaceStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgInterfaceStatement::~SgInterfaceStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInterfaceStatement::SgInterfaceStatement ( Sg_File_Info* startOfConstruct, SgName name, SgBasicBlock* body, SgScopeStatement* scope )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgInterfaceStatement::SgInterfaceStatement (Sg_File_Info* startOfConstruct, SgName name, SgBasicBlock* body, SgScopeStatement* scope) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_body = body;
     p_scope = scope;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INTERFACE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgInterfaceStatement() function since it has been problematic
     assert(isSgInterfaceStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgModuleStatement::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgModuleStatement::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgModuleStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgModuleStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgModuleStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgModuleStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13396 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgModuleStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModuleStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModuleStatement::variantT() const {
  return V_SgModuleStatement;
}

#if 0
int
SgModuleStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MODULE_STATEMENT;
   }
#endif

const char*
SgModuleStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModuleStatement";  
   }

std::string
SgModuleStatement::class_name() const
   {
     assert(this != NULL);
     return "SgModuleStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModuleStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModuleStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MODULE_STATEMENT)
        {
          printf ("Error in SgModuleStatement::error(): SgModuleStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModuleStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MODULE_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModuleStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModuleStatement::variant() const \n");
#endif
     assert(this != NULL);
     return MODULE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModuleStatement* isSgModuleStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModuleStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModuleStatement* isSgModuleStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModuleStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModuleStatement::~SgModuleStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgModuleStatement::~SgModuleStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModuleStatement::SgModuleStatement ( Sg_File_Info* startOfConstruct, SgName name, SgBasicBlock* body )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgModuleStatement::SgModuleStatement (Sg_File_Info* startOfConstruct, SgName name, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_body = body;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(MODULE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgModuleStatement() function since it has been problematic
     assert(isSgModuleStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgUseStatement::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgUseStatement::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgUseStatement::get_rename_list () const
   {
     assert (this != NULL);
     return p_rename_list;
   }

void
SgUseStatement::set_rename_list ( SgExprListExp* rename_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_rename_list != NULL && rename_list != NULL && p_rename_list != rename_list)
        {
          printf ("Warning: rename_list = %p overwriting valid pointer p_rename_list = %p \n",rename_list,p_rename_list);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_rename_list != NULL && rename_list != NULL && p_rename_list != rename_list) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_rename_list = rename_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgUseOnlyExpression* 
SgUseStatement::get_use_only () const
   {
     assert (this != NULL);
     return p_use_only;
   }

void
SgUseStatement::set_use_only ( SgUseOnlyExpression* use_only )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_use_only != NULL && use_only != NULL && p_use_only != use_only)
        {
          printf ("Warning: use_only = %p overwriting valid pointer p_use_only = %p \n",use_only,p_use_only);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_use_only != NULL && use_only != NULL && p_use_only != use_only) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_use_only = use_only;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13412 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgUseStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUseStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUseStatement::variantT() const {
  return V_SgUseStatement;
}

#if 0
int
SgUseStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return USE_STATEMENT;
   }
#endif

const char*
SgUseStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUseStatement";  
   }

std::string
SgUseStatement::class_name() const
   {
     assert(this != NULL);
     return "SgUseStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUseStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUseStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != USE_STATEMENT)
        {
          printf ("Error in SgUseStatement::error(): SgUseStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUseStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == USE_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUseStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUseStatement::variant() const \n");
#endif
     assert(this != NULL);
     return USE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUseStatement* isSgUseStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUseStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUseStatement* isSgUseStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUseStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUseStatement::~SgUseStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgUseStatement::~SgUseStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for rename_list
     p_rename_list = NULL; // non list case 
  // case: not a listType for use_only
     p_use_only = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUseStatement::SgUseStatement ( Sg_File_Info* startOfConstruct, SgName name, SgExprListExp* rename_list, SgUseOnlyExpression* use_only )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUseStatement::SgUseStatement (Sg_File_Info* startOfConstruct, SgName name, SgExprListExp* rename_list, SgUseOnlyExpression* use_only) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_rename_list = rename_list;
     p_use_only = use_only;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(USE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgUseStatement() function since it has been problematic
     assert(isSgUseStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStopOrPauseStatement::stop_or_pause_enum 
SgStopOrPauseStatement::get_stop_or_pause () const
   {
     assert (this != NULL);
     return p_stop_or_pause;
   }

void
SgStopOrPauseStatement::set_stop_or_pause ( SgStopOrPauseStatement::stop_or_pause_enum stop_or_pause )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_stop_or_pause = stop_or_pause;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgStopOrPauseStatement::get_code () const
   {
     assert (this != NULL);
     return p_code;
   }

void
SgStopOrPauseStatement::set_code ( SgName code )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_code = code;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13420 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgStopOrPauseStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStopOrPauseStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStopOrPauseStatement::variantT() const {
  return V_SgStopOrPauseStatement;
}

#if 0
int
SgStopOrPauseStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return STOP_OR_PAUSE_STATEMENT;
   }
#endif

const char*
SgStopOrPauseStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStopOrPauseStatement";  
   }

std::string
SgStopOrPauseStatement::class_name() const
   {
     assert(this != NULL);
     return "SgStopOrPauseStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStopOrPauseStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStopOrPauseStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != STOP_OR_PAUSE_STATEMENT)
        {
          printf ("Error in SgStopOrPauseStatement::error(): SgStopOrPauseStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStopOrPauseStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == STOP_OR_PAUSE_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStopOrPauseStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStopOrPauseStatement::variant() const \n");
#endif
     assert(this != NULL);
     return STOP_OR_PAUSE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStopOrPauseStatement* isSgStopOrPauseStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStopOrPauseStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStopOrPauseStatement* isSgStopOrPauseStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStopOrPauseStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStopOrPauseStatement::~SgStopOrPauseStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgStopOrPauseStatement::~SgStopOrPauseStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for stop_or_pause
     p_stop_or_pause = SgStopOrPauseStatement::e_unknown; // non list case 
  // case: not a listType for code
     p_code = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStopOrPauseStatement::SgStopOrPauseStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgStopOrPauseStatement::SgStopOrPauseStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_stop_or_pause = SgStopOrPauseStatement::e_unknown;
     p_code = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(STOP_OR_PAUSE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgStopOrPauseStatement() function since it has been problematic
     assert(isSgStopOrPauseStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgIOStatement::io_statement_enum 
SgIOStatement::get_io_statement () const
   {
     assert (this != NULL);
     return p_io_statement;
   }

void
SgIOStatement::set_io_statement ( SgIOStatement::io_statement_enum io_statement )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_io_statement = io_statement;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgIOStatement::get_io_stmt_list () const
   {
     assert (this != NULL);
     return p_io_stmt_list;
   }

void
SgIOStatement::set_io_stmt_list ( SgExprListExp* io_stmt_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_io_stmt_list != NULL && io_stmt_list != NULL && p_io_stmt_list != io_stmt_list)
        {
          printf ("Warning: io_stmt_list = %p overwriting valid pointer p_io_stmt_list = %p \n",io_stmt_list,p_io_stmt_list);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_io_stmt_list != NULL && io_stmt_list != NULL && p_io_stmt_list != io_stmt_list) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_io_stmt_list = io_stmt_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgIOControlStatement* 
SgIOStatement::get_io_control () const
   {
     assert (this != NULL);
     return p_io_control;
   }

void
SgIOStatement::set_io_control ( SgIOControlStatement* io_control )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_io_control != NULL && io_control != NULL && p_io_control != io_control)
        {
          printf ("Warning: io_control = %p overwriting valid pointer p_io_control = %p \n",io_control,p_io_control);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_io_control != NULL && io_control != NULL && p_io_control != io_control) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_io_control = io_control;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13428 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgIOStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIOStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIOStatement::variantT() const {
  return V_SgIOStatement;
}

#if 0
int
SgIOStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IO_STATEMENT;
   }
#endif

const char*
SgIOStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIOStatement";  
   }

std::string
SgIOStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIOStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIOStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIOStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IO_STATEMENT)
        {
          printf ("Error in SgIOStatement::error(): SgIOStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIOStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IO_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIOStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIOStatement::variant() const \n");
#endif
     assert(this != NULL);
     return IO_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIOStatement* isSgIOStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIOStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIOStatement* isSgIOStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIOStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIOStatement::~SgIOStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIOStatement::~SgIOStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for io_statement
     p_io_statement = SgIOStatement::e_unknown; // non list case 
  // case: not a listType for io_stmt_list
     p_io_stmt_list = NULL; // non list case 
  // case: not a listType for io_control
     p_io_control = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIOStatement::SgIOStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIOStatement::SgIOStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_io_statement = SgIOStatement::e_unknown;
     p_io_stmt_list = NULL;
     p_io_control = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IO_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgIOStatement() function since it has been problematic
     assert(isSgIOStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgAttributeSpecificationStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgAttributeSpecificationStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13610 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgAttributeSpecificationStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAttributeSpecificationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAttributeSpecificationStatement::variantT() const {
  return V_SgAttributeSpecificationStatement;
}

#if 0
int
SgAttributeSpecificationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Attribute_Specification_Statement;
   }
#endif

const char*
SgAttributeSpecificationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAttributeSpecificationStatement";  
   }

std::string
SgAttributeSpecificationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgAttributeSpecificationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAttributeSpecificationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAttributeSpecificationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Attribute_Specification_Statement)
        {
          printf ("Error in SgAttributeSpecificationStatement::error(): SgAttributeSpecificationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAttributeSpecificationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Attribute_Specification_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAttributeSpecificationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAttributeSpecificationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Attribute_Specification_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAttributeSpecificationStatement* isSgAttributeSpecificationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAttributeSpecificationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAttributeSpecificationStatement* isSgAttributeSpecificationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAttributeSpecificationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAttributeSpecificationStatement::~SgAttributeSpecificationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgAttributeSpecificationStatement::~SgAttributeSpecificationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAttributeSpecificationStatement::SgAttributeSpecificationStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAttributeSpecificationStatement::SgAttributeSpecificationStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Attribute_Specification_Statement == variant());
     post_construction_initialization();

  // Test the isSgAttributeSpecificationStatement() function since it has been problematic
     assert(isSgAttributeSpecificationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgWhereStatement::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgWhereStatement::set_condition ( SgExpression* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgWhereStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgWhereStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgElseWhereStatement* 
SgWhereStatement::get_elsewhere () const
   {
     assert (this != NULL);
     return p_elsewhere;
   }

void
SgWhereStatement::set_elsewhere ( SgElseWhereStatement* elsewhere )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_elsewhere != NULL && elsewhere != NULL && p_elsewhere != elsewhere)
        {
          printf ("Warning: elsewhere = %p overwriting valid pointer p_elsewhere = %p \n",elsewhere,p_elsewhere);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_elsewhere != NULL && elsewhere != NULL && p_elsewhere != elsewhere) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_elsewhere = elsewhere;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgWhereStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgWhereStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13562 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgWhereStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgWhereStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgWhereStatement::variantT() const {
  return V_SgWhereStatement;
}

#if 0
int
SgWhereStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Where_Statement;
   }
#endif

const char*
SgWhereStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgWhereStatement";  
   }

std::string
SgWhereStatement::class_name() const
   {
     assert(this != NULL);
     return "SgWhereStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgWhereStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgWhereStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Where_Statement)
        {
          printf ("Error in SgWhereStatement::error(): SgWhereStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgWhereStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Where_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgWhereStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgWhereStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Where_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgWhereStatement* isSgWhereStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgWhereStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgWhereStatement* isSgWhereStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgWhereStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgWhereStatement::~SgWhereStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgWhereStatement::~SgWhereStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for condition
     p_condition = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for elsewhere
     p_elsewhere = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgWhereStatement::SgWhereStatement ( Sg_File_Info* startOfConstruct, SgExpression* condition, SgBasicBlock* body, SgElseWhereStatement* elsewhere )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgWhereStatement::SgWhereStatement (Sg_File_Info* startOfConstruct, SgExpression* condition, SgBasicBlock* body, SgElseWhereStatement* elsewhere) sage_class_name() = %s \n",sage_class_name());
#endif

     p_condition = condition;
     p_body = body;
     p_elsewhere = elsewhere;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Where_Statement == variant());
     post_construction_initialization();

  // Test the isSgWhereStatement() function since it has been problematic
     assert(isSgWhereStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgElseWhereStatement::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgElseWhereStatement::set_condition ( SgExpression* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgElseWhereStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgElseWhereStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgElseWhereStatement* 
SgElseWhereStatement::get_elsewhere () const
   {
     assert (this != NULL);
     return p_elsewhere;
   }

void
SgElseWhereStatement::set_elsewhere ( SgElseWhereStatement* elsewhere )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_elsewhere != NULL && elsewhere != NULL && p_elsewhere != elsewhere)
        {
          printf ("Warning: elsewhere = %p overwriting valid pointer p_elsewhere = %p \n",elsewhere,p_elsewhere);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_elsewhere != NULL && elsewhere != NULL && p_elsewhere != elsewhere) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_elsewhere = elsewhere;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13569 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgElseWhereStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgElseWhereStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgElseWhereStatement::variantT() const {
  return V_SgElseWhereStatement;
}

#if 0
int
SgElseWhereStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Else_Where_Statement;
   }
#endif

const char*
SgElseWhereStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgElseWhereStatement";  
   }

std::string
SgElseWhereStatement::class_name() const
   {
     assert(this != NULL);
     return "SgElseWhereStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgElseWhereStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgElseWhereStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Else_Where_Statement)
        {
          printf ("Error in SgElseWhereStatement::error(): SgElseWhereStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgElseWhereStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Else_Where_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgElseWhereStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgElseWhereStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Else_Where_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgElseWhereStatement* isSgElseWhereStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgElseWhereStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgElseWhereStatement* isSgElseWhereStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgElseWhereStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgElseWhereStatement::~SgElseWhereStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgElseWhereStatement::~SgElseWhereStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for condition
     p_condition = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for elsewhere
     p_elsewhere = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgElseWhereStatement::SgElseWhereStatement ( Sg_File_Info* startOfConstruct, SgExpression* condition, SgBasicBlock* body, SgElseWhereStatement* elsewhere )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgElseWhereStatement::SgElseWhereStatement (Sg_File_Info* startOfConstruct, SgExpression* condition, SgBasicBlock* body, SgElseWhereStatement* elsewhere) sage_class_name() = %s \n",sage_class_name());
#endif

     p_condition = condition;
     p_body = body;
     p_elsewhere = elsewhere;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Else_Where_Statement == variant());
     post_construction_initialization();

  // Test the isSgElseWhereStatement() function since it has been problematic
     assert(isSgElseWhereStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgNullifyStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgNullifyStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13576 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgNullifyStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNullifyStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNullifyStatement::variantT() const {
  return V_SgNullifyStatement;
}

#if 0
int
SgNullifyStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Nullify_Statement;
   }
#endif

const char*
SgNullifyStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNullifyStatement";  
   }

std::string
SgNullifyStatement::class_name() const
   {
     assert(this != NULL);
     return "SgNullifyStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNullifyStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNullifyStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Nullify_Statement)
        {
          printf ("Error in SgNullifyStatement::error(): SgNullifyStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNullifyStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Nullify_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNullifyStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNullifyStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Nullify_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNullifyStatement* isSgNullifyStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNullifyStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNullifyStatement* isSgNullifyStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNullifyStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNullifyStatement::~SgNullifyStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgNullifyStatement::~SgNullifyStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNullifyStatement::SgNullifyStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNullifyStatement::SgNullifyStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Nullify_Statement == variant());
     post_construction_initialization();

  // Test the isSgNullifyStatement() function since it has been problematic
     assert(isSgNullifyStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgArithmeticIfStatement::get_conditional () const
   {
     assert (this != NULL);
     return p_conditional;
   }

void
SgArithmeticIfStatement::set_conditional ( SgExpression* conditional )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_conditional != NULL && conditional != NULL && p_conditional != conditional)
        {
          printf ("Warning: conditional = %p overwriting valid pointer p_conditional = %p \n",conditional,p_conditional);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_conditional != NULL && conditional != NULL && p_conditional != conditional) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_conditional = conditional;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgArithmeticIfStatement::get_label_1 () const
   {
     assert (this != NULL);
     return p_label_1;
   }

void
SgArithmeticIfStatement::set_label_1 ( SgLabelStatement* label_1 )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_label_1 != NULL && label_1 != NULL && p_label_1 != label_1)
        {
          printf ("Warning: label_1 = %p overwriting valid pointer p_label_1 = %p \n",label_1,p_label_1);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_label_1 != NULL && label_1 != NULL && p_label_1 != label_1) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_label_1 = label_1;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgArithmeticIfStatement::get_label_2 () const
   {
     assert (this != NULL);
     return p_label_2;
   }

void
SgArithmeticIfStatement::set_label_2 ( SgLabelStatement* label_2 )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_label_2 != NULL && label_2 != NULL && p_label_2 != label_2)
        {
          printf ("Warning: label_2 = %p overwriting valid pointer p_label_2 = %p \n",label_2,p_label_2);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_label_2 != NULL && label_2 != NULL && p_label_2 != label_2) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_label_2 = label_2;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgArithmeticIfStatement::get_label_3 () const
   {
     assert (this != NULL);
     return p_label_3;
   }

void
SgArithmeticIfStatement::set_label_3 ( SgLabelStatement* label_3 )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_label_3 != NULL && label_3 != NULL && p_label_3 != label_3)
        {
          printf ("Warning: label_3 = %p overwriting valid pointer p_label_3 = %p \n",label_3,p_label_3);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_label_3 != NULL && label_3 != NULL && p_label_3 != label_3) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_label_3 = label_3;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13646 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgArithmeticIfStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgArithmeticIfStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgArithmeticIfStatement::variantT() const {
  return V_SgArithmeticIfStatement;
}

#if 0
int
SgArithmeticIfStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Arithmetic_If_Statement;
   }
#endif

const char*
SgArithmeticIfStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgArithmeticIfStatement";  
   }

std::string
SgArithmeticIfStatement::class_name() const
   {
     assert(this != NULL);
     return "SgArithmeticIfStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgArithmeticIfStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgArithmeticIfStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Arithmetic_If_Statement)
        {
          printf ("Error in SgArithmeticIfStatement::error(): SgArithmeticIfStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgArithmeticIfStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Arithmetic_If_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgArithmeticIfStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgArithmeticIfStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Arithmetic_If_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgArithmeticIfStatement* isSgArithmeticIfStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgArithmeticIfStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgArithmeticIfStatement* isSgArithmeticIfStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgArithmeticIfStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgArithmeticIfStatement::~SgArithmeticIfStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgArithmeticIfStatement::~SgArithmeticIfStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for conditional
     p_conditional = NULL; // non list case 
  // case: not a listType for label_1
     p_label_1 = NULL; // non list case 
  // case: not a listType for label_2
     p_label_2 = NULL; // non list case 
  // case: not a listType for label_3
     p_label_3 = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgArithmeticIfStatement::SgArithmeticIfStatement ( Sg_File_Info* startOfConstruct, SgExpression* conditional, SgLabelStatement* label_1, SgLabelStatement* label_2, SgLabelStatement* label_3 )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgArithmeticIfStatement::SgArithmeticIfStatement (Sg_File_Info* startOfConstruct, SgExpression* conditional, SgLabelStatement* label_1, SgLabelStatement* label_2, SgLabelStatement* label_3) sage_class_name() = %s \n",sage_class_name());
#endif

     p_conditional = conditional;
     p_label_1 = label_1;
     p_label_2 = label_2;
     p_label_3 = label_3;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Arithmetic_If_Statement == variant());
     post_construction_initialization();

  // Test the isSgArithmeticIfStatement() function since it has been problematic
     assert(isSgArithmeticIfStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgAssignStatement::get_label () const
   {
     assert (this != NULL);
     return p_label;
   }

void
SgAssignStatement::set_label ( SgLabelStatement* label )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_label != NULL && label != NULL && p_label != label)
        {
          printf ("Warning: label = %p overwriting valid pointer p_label = %p \n",label,p_label);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_label != NULL && label != NULL && p_label != label) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_label = label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgAssignStatement::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgAssignStatement::set_value ( SgExpression* value )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_value != NULL && value != NULL && p_value != value)
        {
          printf ("Warning: value = %p overwriting valid pointer p_value = %p \n",value,p_value);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_value != NULL && value != NULL && p_value != value) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13653 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgAssignStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAssignStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAssignStatement::variantT() const {
  return V_SgAssignStatement;
}

#if 0
int
SgAssignStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Assign_Statement;
   }
#endif

const char*
SgAssignStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAssignStatement";  
   }

std::string
SgAssignStatement::class_name() const
   {
     assert(this != NULL);
     return "SgAssignStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAssignStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAssignStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Assign_Statement)
        {
          printf ("Error in SgAssignStatement::error(): SgAssignStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAssignStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Assign_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAssignStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAssignStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Assign_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAssignStatement* isSgAssignStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAssignStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAssignStatement* isSgAssignStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAssignStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAssignStatement::~SgAssignStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgAssignStatement::~SgAssignStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for label
     p_label = NULL; // non list case 
  // case: not a listType for value
     p_value = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAssignStatement::SgAssignStatement ( Sg_File_Info* startOfConstruct, SgLabelStatement* label, SgExpression* value )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAssignStatement::SgAssignStatement (Sg_File_Info* startOfConstruct, SgLabelStatement* label, SgExpression* value) sage_class_name() = %s \n",sage_class_name());
#endif

     p_label = label;
     p_value = value;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Assign_Statement == variant());
     post_construction_initialization();

  // Test the isSgAssignStatement() function since it has been problematic
     assert(isSgAssignStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatementPtrList 
SgComputedGotoStatement::get_labels () const
   {
     assert (this != NULL);
     return p_labels;
   }

void
SgComputedGotoStatement::set_labels ( SgStatementPtrList labels )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_labels = labels;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgComputedGotoStatement::get_conditional () const
   {
     assert (this != NULL);
     return p_conditional;
   }

void
SgComputedGotoStatement::set_conditional ( SgExpression* conditional )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_conditional != NULL && conditional != NULL && p_conditional != conditional)
        {
          printf ("Warning: conditional = %p overwriting valid pointer p_conditional = %p \n",conditional,p_conditional);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_conditional != NULL && conditional != NULL && p_conditional != conditional) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_conditional = conditional;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13660 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgComputedGotoStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgComputedGotoStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgComputedGotoStatement::variantT() const {
  return V_SgComputedGotoStatement;
}

#if 0
int
SgComputedGotoStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Computed_Goto_Statement;
   }
#endif

const char*
SgComputedGotoStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgComputedGotoStatement";  
   }

std::string
SgComputedGotoStatement::class_name() const
   {
     assert(this != NULL);
     return "SgComputedGotoStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgComputedGotoStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgComputedGotoStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Computed_Goto_Statement)
        {
          printf ("Error in SgComputedGotoStatement::error(): SgComputedGotoStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgComputedGotoStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Computed_Goto_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgComputedGotoStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgComputedGotoStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Computed_Goto_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgComputedGotoStatement* isSgComputedGotoStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgComputedGotoStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgComputedGotoStatement* isSgComputedGotoStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgComputedGotoStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgComputedGotoStatement::~SgComputedGotoStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgComputedGotoStatement::~SgComputedGotoStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for conditional
     p_conditional = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgComputedGotoStatement::SgComputedGotoStatement ( Sg_File_Info* startOfConstruct, SgStatementPtrList labels, SgExpression* conditional )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgComputedGotoStatement::SgComputedGotoStatement (Sg_File_Info* startOfConstruct, SgStatementPtrList labels, SgExpression* conditional) sage_class_name() = %s \n",sage_class_name());
#endif

     p_labels = labels;
     p_conditional = conditional;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Computed_Goto_Statement == variant());
     post_construction_initialization();

  // Test the isSgComputedGotoStatement() function since it has been problematic
     assert(isSgComputedGotoStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgAssignedGotoStatement::get_targets () const
   {
     assert (this != NULL);
     return p_targets;
   }

void
SgAssignedGotoStatement::set_targets ( SgExprListExp* targets )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_targets != NULL && targets != NULL && p_targets != targets)
        {
          printf ("Warning: targets = %p overwriting valid pointer p_targets = %p \n",targets,p_targets);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_targets != NULL && targets != NULL && p_targets != targets) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_targets = targets;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13667 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgAssignedGotoStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAssignedGotoStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAssignedGotoStatement::variantT() const {
  return V_SgAssignedGotoStatement;
}

#if 0
int
SgAssignedGotoStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Assigned_Goto_Statement;
   }
#endif

const char*
SgAssignedGotoStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAssignedGotoStatement";  
   }

std::string
SgAssignedGotoStatement::class_name() const
   {
     assert(this != NULL);
     return "SgAssignedGotoStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAssignedGotoStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAssignedGotoStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Assigned_Goto_Statement)
        {
          printf ("Error in SgAssignedGotoStatement::error(): SgAssignedGotoStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAssignedGotoStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Assigned_Goto_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAssignedGotoStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAssignedGotoStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Assigned_Goto_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAssignedGotoStatement* isSgAssignedGotoStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAssignedGotoStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAssignedGotoStatement* isSgAssignedGotoStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAssignedGotoStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAssignedGotoStatement::~SgAssignedGotoStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgAssignedGotoStatement::~SgAssignedGotoStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for targets
     p_targets = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAssignedGotoStatement::SgAssignedGotoStatement ( Sg_File_Info* startOfConstruct, SgExprListExp* targets )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAssignedGotoStatement::SgAssignedGotoStatement (Sg_File_Info* startOfConstruct, SgExprListExp* targets) sage_class_name() = %s \n",sage_class_name());
#endif

     p_targets = targets;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Assigned_Goto_Statement == variant());
     post_construction_initialization();

  // Test the isSgAssignedGotoStatement() function since it has been problematic
     assert(isSgAssignedGotoStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgAllocateStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgAllocateStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13617 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgAllocateStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAllocateStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAllocateStatement::variantT() const {
  return V_SgAllocateStatement;
}

#if 0
int
SgAllocateStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Allocate_Statement;
   }
#endif

const char*
SgAllocateStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAllocateStatement";  
   }

std::string
SgAllocateStatement::class_name() const
   {
     assert(this != NULL);
     return "SgAllocateStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAllocateStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAllocateStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Allocate_Statement)
        {
          printf ("Error in SgAllocateStatement::error(): SgAllocateStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAllocateStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Allocate_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAllocateStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAllocateStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Allocate_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAllocateStatement* isSgAllocateStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAllocateStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAllocateStatement* isSgAllocateStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAllocateStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAllocateStatement::~SgAllocateStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgAllocateStatement::~SgAllocateStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAllocateStatement::SgAllocateStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAllocateStatement::SgAllocateStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Allocate_Statement == variant());
     post_construction_initialization();

  // Test the isSgAllocateStatement() function since it has been problematic
     assert(isSgAllocateStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgDeallocateStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgDeallocateStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13624 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgDeallocateStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDeallocateStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDeallocateStatement::variantT() const {
  return V_SgDeallocateStatement;
}

#if 0
int
SgDeallocateStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Deallocate_Statement;
   }
#endif

const char*
SgDeallocateStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDeallocateStatement";  
   }

std::string
SgDeallocateStatement::class_name() const
   {
     assert(this != NULL);
     return "SgDeallocateStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDeallocateStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDeallocateStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Deallocate_Statement)
        {
          printf ("Error in SgDeallocateStatement::error(): SgDeallocateStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDeallocateStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Deallocate_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDeallocateStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDeallocateStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Deallocate_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDeallocateStatement* isSgDeallocateStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDeallocateStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDeallocateStatement* isSgDeallocateStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDeallocateStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDeallocateStatement::~SgDeallocateStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgDeallocateStatement::~SgDeallocateStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDeallocateStatement::SgDeallocateStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDeallocateStatement::SgDeallocateStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Deallocate_Statement == variant());
     post_construction_initialization();

  // Test the isSgDeallocateStatement() function since it has been problematic
     assert(isSgDeallocateStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgContainsStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgContainsStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13404 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgContainsStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgContainsStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgContainsStatement::variantT() const {
  return V_SgContainsStatement;
}

#if 0
int
SgContainsStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Contains_Statement;
   }
#endif

const char*
SgContainsStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgContainsStatement";  
   }

std::string
SgContainsStatement::class_name() const
   {
     assert(this != NULL);
     return "SgContainsStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgContainsStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgContainsStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Contains_Statement)
        {
          printf ("Error in SgContainsStatement::error(): SgContainsStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgContainsStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Contains_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgContainsStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgContainsStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Contains_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgContainsStatement* isSgContainsStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgContainsStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgContainsStatement* isSgContainsStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgContainsStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgContainsStatement::~SgContainsStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgContainsStatement::~SgContainsStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgContainsStatement::SgContainsStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgContainsStatement::SgContainsStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Contains_Statement == variant());
     post_construction_initialization();

  // Test the isSgContainsStatement() function since it has been problematic
     assert(isSgContainsStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedNamePtrList 
SgSequenceStatement::get_pointer_list () const
   {
     assert (this != NULL);
     return p_pointer_list;
   }

void
SgSequenceStatement::set_pointer_list ( SgInitializedNamePtrList pointer_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pointer_list = pointer_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13638 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgSequenceStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSequenceStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSequenceStatement::variantT() const {
  return V_SgSequenceStatement;
}

#if 0
int
SgSequenceStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Sequence_Statement;
   }
#endif

const char*
SgSequenceStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSequenceStatement";  
   }

std::string
SgSequenceStatement::class_name() const
   {
     assert(this != NULL);
     return "SgSequenceStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSequenceStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSequenceStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Sequence_Statement)
        {
          printf ("Error in SgSequenceStatement::error(): SgSequenceStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSequenceStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Sequence_Statement);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSequenceStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSequenceStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Sequence_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSequenceStatement* isSgSequenceStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSequenceStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSequenceStatement* isSgSequenceStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSequenceStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSequenceStatement::~SgSequenceStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgSequenceStatement::~SgSequenceStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSequenceStatement::SgSequenceStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSequenceStatement::SgSequenceStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMP_Sequence_Statement == variant());
     post_construction_initialization();

  // Test the isSgSequenceStatement() function since it has been problematic
     assert(isSgSequenceStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgFortranDo::get_initialization () const
   {
     assert (this != NULL);
     return p_initialization;
   }

void
SgFortranDo::set_initialization ( SgExpression* initialization )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_initialization != NULL && initialization != NULL && p_initialization != initialization)
        {
          printf ("Warning: initialization = %p overwriting valid pointer p_initialization = %p \n",initialization,p_initialization);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_initialization != NULL && initialization != NULL && p_initialization != initialization) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_initialization = initialization;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgFortranDo::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgFortranDo::set_condition ( SgExpression* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgFortranDo::get_increment () const
   {
     assert (this != NULL);
     return p_increment;
   }

void
SgFortranDo::set_increment ( SgExpression* increment )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_increment != NULL && increment != NULL && p_increment != increment)
        {
          printf ("Warning: increment = %p overwriting valid pointer p_increment = %p \n",increment,p_increment);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_increment != NULL && increment != NULL && p_increment != increment) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_increment = increment;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgFortranDo::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgFortranDo::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgFortranDo::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgFortranDo::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13491 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgFortranDo::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFortranDo::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFortranDo::variantT() const {
  return V_SgFortranDo;
}

#if 0
int
SgFortranDo::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FORTRAN_DO;
   }
#endif

const char*
SgFortranDo::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFortranDo";  
   }

std::string
SgFortranDo::class_name() const
   {
     assert(this != NULL);
     return "SgFortranDo";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFortranDo::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFortranDo::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FORTRAN_DO)
        {
          printf ("Error in SgFortranDo::error(): SgFortranDo object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFortranDo::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FORTRAN_DO);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFortranDo::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFortranDo::variant() const \n");
#endif
     assert(this != NULL);
     return FORTRAN_DO;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFortranDo* isSgFortranDo ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFortranDo*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFortranDo* isSgFortranDo ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFortranDo*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFortranDo::~SgFortranDo ()
   {
#if 0
  // debugging information!
     printf ("In SgFortranDo::~SgFortranDo (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for initialization
     p_initialization = NULL; // non list case 
  // case: not a listType for condition
     p_condition = NULL; // non list case 
  // case: not a listType for increment
     p_increment = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFortranDo::SgFortranDo ( Sg_File_Info* startOfConstruct, SgExpression* initialization, SgExpression* condition, SgExpression* increment, SgBasicBlock* body )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFortranDo::SgFortranDo (Sg_File_Info* startOfConstruct, SgExpression* initialization, SgExpression* condition, SgExpression* increment, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_initialization = initialization;
     p_condition = condition;
     p_increment = increment;
     p_body = body;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FORTRAN_DO == variant());
     post_construction_initialization();

  // Test the isSgFortranDo() function since it has been problematic
     assert(isSgFortranDo(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgFortranNonblockedDo::get_end_statement () const
   {
     assert (this != NULL);
     return p_end_statement;
   }

void
SgFortranNonblockedDo::set_end_statement ( SgStatement* end_statement )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_end_statement != NULL && end_statement != NULL && p_end_statement != end_statement)
        {
          printf ("Warning: end_statement = %p overwriting valid pointer p_end_statement = %p \n",end_statement,p_end_statement);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_end_statement != NULL && end_statement != NULL && p_end_statement != end_statement) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_end_statement = end_statement;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13500 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgFortranNonblockedDo::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFortranNonblockedDo::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFortranNonblockedDo::variantT() const {
  return V_SgFortranNonblockedDo;
}

#if 0
int
SgFortranNonblockedDo::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FORTRAN_NONBLOCKED_DO;
   }
#endif

const char*
SgFortranNonblockedDo::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFortranNonblockedDo";  
   }

std::string
SgFortranNonblockedDo::class_name() const
   {
     assert(this != NULL);
     return "SgFortranNonblockedDo";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFortranNonblockedDo::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFortranNonblockedDo::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FORTRAN_NONBLOCKED_DO)
        {
          printf ("Error in SgFortranNonblockedDo::error(): SgFortranNonblockedDo object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFortranNonblockedDo::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FORTRAN_NONBLOCKED_DO);
     return SgFortranDo::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFortranNonblockedDo::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFortranNonblockedDo::variant() const \n");
#endif
     assert(this != NULL);
     return FORTRAN_NONBLOCKED_DO;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFortranNonblockedDo* isSgFortranNonblockedDo ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFortranNonblockedDo*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFortranNonblockedDo* isSgFortranNonblockedDo ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFortranNonblockedDo*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFortranNonblockedDo::~SgFortranNonblockedDo ()
   {
#if 0
  // debugging information!
     printf ("In SgFortranNonblockedDo::~SgFortranNonblockedDo (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for end_statement
     p_end_statement = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFortranNonblockedDo::SgFortranNonblockedDo ( Sg_File_Info* startOfConstruct, SgExpression* initialization, SgExpression* condition, SgExpression* increment, SgBasicBlock* body, SgStatement* end_statement )
   : SgFortranDo(startOfConstruct, initialization, condition, increment, body)
   {
#ifdef DEBUG
  // printf ("In SgFortranNonblockedDo::SgFortranNonblockedDo (Sg_File_Info* startOfConstruct, SgExpression* initialization, SgExpression* condition, SgExpression* increment, SgBasicBlock* body, SgStatement* end_statement) sage_class_name() = %s \n",sage_class_name());
#endif

     p_end_statement = end_statement;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FORTRAN_NONBLOCKED_DO == variant());
     post_construction_initialization();

  // Test the isSgFortranNonblockedDo() function since it has been problematic
     assert(isSgFortranNonblockedDo(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOControlStatement::get_unit () const
   {
     assert (this != NULL);
     return p_unit;
   }

void
SgIOControlStatement::set_unit ( SgExpression* unit )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_unit != NULL && unit != NULL && p_unit != unit)
        {
          printf ("Warning: unit = %p overwriting valid pointer p_unit = %p \n",unit,p_unit);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_unit != NULL && unit != NULL && p_unit != unit) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_unit = unit;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOControlStatement::get_err_label () const
   {
     assert (this != NULL);
     return p_err_label;
   }

void
SgIOControlStatement::set_err_label ( SgExpression* err_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_err_label != NULL && err_label != NULL && p_err_label != err_label)
        {
          printf ("Warning: err_label = %p overwriting valid pointer p_err_label = %p \n",err_label,p_err_label);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_err_label != NULL && err_label != NULL && p_err_label != err_label) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_err_label = err_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOControlStatement::get_iostat () const
   {
     assert (this != NULL);
     return p_iostat;
   }

void
SgIOControlStatement::set_iostat ( SgExpression* iostat )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_iostat != NULL && iostat != NULL && p_iostat != iostat)
        {
          printf ("Warning: iostat = %p overwriting valid pointer p_iostat = %p \n",iostat,p_iostat);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_iostat != NULL && iostat != NULL && p_iostat != iostat) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_iostat = iostat;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13437 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgIOControlStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIOControlStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIOControlStatement::variantT() const {
  return V_SgIOControlStatement;
}

#if 0
int
SgIOControlStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IO_CONTROL_STATEMENT;
   }
#endif

const char*
SgIOControlStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIOControlStatement";  
   }

std::string
SgIOControlStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIOControlStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIOControlStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIOControlStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IO_CONTROL_STATEMENT)
        {
          printf ("Error in SgIOControlStatement::error(): SgIOControlStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIOControlStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IO_CONTROL_STATEMENT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIOControlStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIOControlStatement::variant() const \n");
#endif
     assert(this != NULL);
     return IO_CONTROL_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIOControlStatement* isSgIOControlStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIOControlStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIOControlStatement* isSgIOControlStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIOControlStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIOControlStatement::~SgIOControlStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIOControlStatement::~SgIOControlStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for unit
     p_unit = NULL; // non list case 
  // case: not a listType for err_label
     p_err_label = NULL; // non list case 
  // case: not a listType for iostat
     p_iostat = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIOControlStatement::SgIOControlStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIOControlStatement::SgIOControlStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_unit = NULL;
     p_err_label = NULL;
     p_iostat = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IO_CONTROL_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgIOControlStatement() function since it has been problematic
     assert(isSgIOControlStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgVarRefExp* 
SgInputOutputStatement::get_format () const
   {
     assert (this != NULL);
     return p_format;
   }

void
SgInputOutputStatement::set_format ( SgVarRefExp* format )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_format != NULL && format != NULL && p_format != format)
        {
          printf ("Warning: format = %p overwriting valid pointer p_format = %p \n",format,p_format);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_format != NULL && format != NULL && p_format != format) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_format = format;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgVarRefExp* 
SgInputOutputStatement::get_namelist_nm () const
   {
     assert (this != NULL);
     return p_namelist_nm;
   }

void
SgInputOutputStatement::set_namelist_nm ( SgVarRefExp* namelist_nm )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_namelist_nm != NULL && namelist_nm != NULL && p_namelist_nm != namelist_nm)
        {
          printf ("Warning: namelist_nm = %p overwriting valid pointer p_namelist_nm = %p \n",namelist_nm,p_namelist_nm);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_namelist_nm != NULL && namelist_nm != NULL && p_namelist_nm != namelist_nm) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_namelist_nm = namelist_nm;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgInputOutputStatement::get_advance () const
   {
     assert (this != NULL);
     return p_advance;
   }

void
SgInputOutputStatement::set_advance ( SgExpression* advance )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_advance != NULL && advance != NULL && p_advance != advance)
        {
          printf ("Warning: advance = %p overwriting valid pointer p_advance = %p \n",advance,p_advance);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_advance != NULL && advance != NULL && p_advance != advance) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_advance = advance;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgInputOutputStatement::get_end_label () const
   {
     assert (this != NULL);
     return p_end_label;
   }

void
SgInputOutputStatement::set_end_label ( SgExpression* end_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_end_label != NULL && end_label != NULL && p_end_label != end_label)
        {
          printf ("Warning: end_label = %p overwriting valid pointer p_end_label = %p \n",end_label,p_end_label);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_end_label != NULL && end_label != NULL && p_end_label != end_label) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_end_label = end_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgInputOutputStatement::get_eor_label () const
   {
     assert (this != NULL);
     return p_eor_label;
   }

void
SgInputOutputStatement::set_eor_label ( SgExpression* eor_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_eor_label != NULL && eor_label != NULL && p_eor_label != eor_label)
        {
          printf ("Warning: eor_label = %p overwriting valid pointer p_eor_label = %p \n",eor_label,p_eor_label);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_eor_label != NULL && eor_label != NULL && p_eor_label != eor_label) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_eor_label = eor_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgInputOutputStatement::get_rec () const
   {
     assert (this != NULL);
     return p_rec;
   }

void
SgInputOutputStatement::set_rec ( SgExpression* rec )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_rec != NULL && rec != NULL && p_rec != rec)
        {
          printf ("Warning: rec = %p overwriting valid pointer p_rec = %p \n",rec,p_rec);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_rec != NULL && rec != NULL && p_rec != rec) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_rec = rec;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgInputOutputStatement::get_size () const
   {
     assert (this != NULL);
     return p_size;
   }

void
SgInputOutputStatement::set_size ( SgExpression* size )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_size != NULL && size != NULL && p_size != size)
        {
          printf ("Warning: size = %p overwriting valid pointer p_size = %p \n",size,p_size);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_size != NULL && size != NULL && p_size != size) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_size = size;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13446 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgInputOutputStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInputOutputStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInputOutputStatement::variantT() const {
  return V_SgInputOutputStatement;
}

#if 0
int
SgInputOutputStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INPUT_OUTPUT_STATEMENT;
   }
#endif

const char*
SgInputOutputStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInputOutputStatement";  
   }

std::string
SgInputOutputStatement::class_name() const
   {
     assert(this != NULL);
     return "SgInputOutputStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInputOutputStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInputOutputStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INPUT_OUTPUT_STATEMENT)
        {
          printf ("Error in SgInputOutputStatement::error(): SgInputOutputStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInputOutputStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INPUT_OUTPUT_STATEMENT);
     return SgIOControlStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInputOutputStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInputOutputStatement::variant() const \n");
#endif
     assert(this != NULL);
     return INPUT_OUTPUT_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInputOutputStatement* isSgInputOutputStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInputOutputStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInputOutputStatement* isSgInputOutputStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInputOutputStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInputOutputStatement::~SgInputOutputStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgInputOutputStatement::~SgInputOutputStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for format
     p_format = NULL; // non list case 
  // case: not a listType for namelist_nm
     p_namelist_nm = NULL; // non list case 
  // case: not a listType for advance
     p_advance = NULL; // non list case 
  // case: not a listType for end_label
     p_end_label = NULL; // non list case 
  // case: not a listType for eor_label
     p_eor_label = NULL; // non list case 
  // case: not a listType for rec
     p_rec = NULL; // non list case 
  // case: not a listType for size
     p_size = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInputOutputStatement::SgInputOutputStatement ( Sg_File_Info* startOfConstruct )
   : SgIOControlStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgInputOutputStatement::SgInputOutputStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_format = NULL;
     p_namelist_nm = NULL;
     p_advance = NULL;
     p_end_label = NULL;
     p_eor_label = NULL;
     p_rec = NULL;
     p_size = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INPUT_OUTPUT_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgInputOutputStatement() function since it has been problematic
     assert(isSgInputOutputStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 13455 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgOpenStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgOpenStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgOpenStatement::variantT() const {
  return V_SgOpenStatement;
}

#if 0
int
SgOpenStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return OPEN_STATEMENT;
   }
#endif

const char*
SgOpenStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgOpenStatement";  
   }

std::string
SgOpenStatement::class_name() const
   {
     assert(this != NULL);
     return "SgOpenStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgOpenStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgOpenStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != OPEN_STATEMENT)
        {
          printf ("Error in SgOpenStatement::error(): SgOpenStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgOpenStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == OPEN_STATEMENT);
     return SgIOControlStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgOpenStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgOpenStatement::variant() const \n");
#endif
     assert(this != NULL);
     return OPEN_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgOpenStatement* isSgOpenStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgOpenStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgOpenStatement* isSgOpenStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgOpenStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgOpenStatement::~SgOpenStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgOpenStatement::~SgOpenStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgOpenStatement::SgOpenStatement ( Sg_File_Info* startOfConstruct )
   : SgIOControlStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgOpenStatement::SgOpenStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(OPEN_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgOpenStatement() function since it has been problematic
     assert(isSgOpenStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 13464 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgCloseStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCloseStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCloseStatement::variantT() const {
  return V_SgCloseStatement;
}

#if 0
int
SgCloseStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CLOSE_STATEMENT;
   }
#endif

const char*
SgCloseStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCloseStatement";  
   }

std::string
SgCloseStatement::class_name() const
   {
     assert(this != NULL);
     return "SgCloseStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCloseStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCloseStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CLOSE_STATEMENT)
        {
          printf ("Error in SgCloseStatement::error(): SgCloseStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCloseStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CLOSE_STATEMENT);
     return SgIOControlStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCloseStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCloseStatement::variant() const \n");
#endif
     assert(this != NULL);
     return CLOSE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCloseStatement* isSgCloseStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCloseStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCloseStatement* isSgCloseStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCloseStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCloseStatement::~SgCloseStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgCloseStatement::~SgCloseStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCloseStatement::SgCloseStatement ( Sg_File_Info* startOfConstruct )
   : SgIOControlStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCloseStatement::SgCloseStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(CLOSE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgCloseStatement() function since it has been problematic
     assert(isSgCloseStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 13473 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgInquireStatement::post_construction_initialization()
   {}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInquireStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInquireStatement::variantT() const {
  return V_SgInquireStatement;
}

#if 0
int
SgInquireStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INQUIRE_STATEMENT;
   }
#endif

const char*
SgInquireStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInquireStatement";  
   }

std::string
SgInquireStatement::class_name() const
   {
     assert(this != NULL);
     return "SgInquireStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInquireStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInquireStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INQUIRE_STATEMENT)
        {
          printf ("Error in SgInquireStatement::error(): SgInquireStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInquireStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INQUIRE_STATEMENT);
     return SgIOControlStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInquireStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInquireStatement::variant() const \n");
#endif
     assert(this != NULL);
     return INQUIRE_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInquireStatement* isSgInquireStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInquireStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInquireStatement* isSgInquireStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInquireStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInquireStatement::~SgInquireStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgInquireStatement::~SgInquireStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInquireStatement::SgInquireStatement ( Sg_File_Info* startOfConstruct )
   : SgIOControlStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgInquireStatement::SgInquireStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(INQUIRE_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgInquireStatement() function since it has been problematic
     assert(isSgInquireStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 13482 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgIOFileControlStmt::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIOFileControlStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIOFileControlStmt::variantT() const {
  return V_SgIOFileControlStmt;
}

#if 0
int
SgIOFileControlStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IO_FILE_CONTROL_STMT;
   }
#endif

const char*
SgIOFileControlStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIOFileControlStmt";  
   }

std::string
SgIOFileControlStmt::class_name() const
   {
     assert(this != NULL);
     return "SgIOFileControlStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIOFileControlStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIOFileControlStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IO_FILE_CONTROL_STMT)
        {
          printf ("Error in SgIOFileControlStmt::error(): SgIOFileControlStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIOFileControlStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IO_FILE_CONTROL_STMT);
     return SgIOControlStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIOFileControlStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIOFileControlStmt::variant() const \n");
#endif
     assert(this != NULL);
     return IO_FILE_CONTROL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIOFileControlStmt* isSgIOFileControlStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIOFileControlStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIOFileControlStmt* isSgIOFileControlStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIOFileControlStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIOFileControlStmt::~SgIOFileControlStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgIOFileControlStmt::~SgIOFileControlStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIOFileControlStmt::SgIOFileControlStmt ( Sg_File_Info* startOfConstruct )
   : SgIOControlStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIOFileControlStmt::SgIOFileControlStmt (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(IO_FILE_CONTROL_STMT == variant());
     post_construction_initialization();

  // Test the isSgIOFileControlStmt() function since it has been problematic
     assert(isSgIOFileControlStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned int 
SgDeclarationStatement::get_decl_attributes () const
   {
     assert (this != NULL);
     return p_decl_attributes;
   }

void
SgDeclarationStatement::set_decl_attributes ( unsigned int decl_attributes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_decl_attributes = decl_attributes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgDeclarationStatement::get_linkage () const
   {
     assert (this != NULL);
     return p_linkage;
   }

void
SgDeclarationStatement::set_linkage ( std::string linkage )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_linkage = linkage;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgDeclarationModifier &
SgDeclarationStatement::get_declarationModifier () const
   {
     assert (this != NULL);
     return p_declarationModifier;
   }

SgDeclarationModifier &
SgDeclarationStatement::get_declarationModifier () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_declarationModifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgDeclarationStatement::get_nameOnly () const
   {
     assert (this != NULL);
     return p_nameOnly;
   }

void
SgDeclarationStatement::set_nameOnly ( bool nameOnly )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nameOnly = nameOnly;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgDeclarationStatement::get_forward () const
   {
     assert (this != NULL);
     return p_forward;
   }

void
SgDeclarationStatement::set_forward ( bool forward )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_forward = forward;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgDeclarationStatement::get_externBrace () const
   {
     assert (this != NULL);
     return p_externBrace;
   }

void
SgDeclarationStatement::set_externBrace ( bool externBrace )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_externBrace = externBrace;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgDeclarationStatement::get_skipElaborateType () const
   {
     assert (this != NULL);
     return p_skipElaborateType;
   }

void
SgDeclarationStatement::set_skipElaborateType ( bool skipElaborateType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_skipElaborateType = skipElaborateType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgDeclarationStatement::get_definingDeclaration () const
   {
     assert (this != NULL);
     return p_definingDeclaration;
   }

void
SgDeclarationStatement::set_definingDeclaration ( SgDeclarationStatement* definingDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_definingDeclaration != NULL && definingDeclaration != NULL && p_definingDeclaration != definingDeclaration)
        {
          printf ("Warning: definingDeclaration = %p overwriting valid pointer p_definingDeclaration = %p \n",definingDeclaration,p_definingDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_definingDeclaration != NULL && definingDeclaration != NULL && p_definingDeclaration != definingDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_definingDeclaration = definingDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgDeclarationStatement::get_firstNondefiningDeclaration () const
   {
     assert (this != NULL);
     return p_firstNondefiningDeclaration;
   }

void
SgDeclarationStatement::set_firstNondefiningDeclaration ( SgDeclarationStatement* firstNondefiningDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_firstNondefiningDeclaration != NULL && firstNondefiningDeclaration != NULL && p_firstNondefiningDeclaration != firstNondefiningDeclaration)
        {
          printf ("Warning: firstNondefiningDeclaration = %p overwriting valid pointer p_firstNondefiningDeclaration = %p \n",firstNondefiningDeclaration,p_firstNondefiningDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_firstNondefiningDeclaration != NULL && firstNondefiningDeclaration != NULL && p_firstNondefiningDeclaration != firstNondefiningDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_firstNondefiningDeclaration = firstNondefiningDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 4618 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgDeclarationStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
  // printf ("Inside of SgDeclarationStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgDeclarationStatement::fixupCopy() for %p = %s copy = %p (defining = %p firstNondefining = %p) \n",
          this,this->class_name().c_str(),copy,this->get_definingDeclaration(),this->get_firstNondefiningDeclaration());
#endif

  // Need to fixup the scopes and defining and non-defining declaration.

     SgDeclarationStatement* copyDeclarationStatement = isSgDeclarationStatement(copy);
     ROSE_ASSERT(copyDeclarationStatement != NULL);

  // If this is a declaration which is a defining declaration, then the copy should be as well.
     if (this->get_definingDeclaration() == this)
        {
       // printf ("This is a DEFINING declaration \n");
          copyDeclarationStatement->set_definingDeclaration(copyDeclarationStatement);
        }

  // DQ (10/12/2007): It is not always clear if this is a great idea.  This uncovered a bug in the 
  // SageInterface::isOverloaded() function. Having two declarations marked as the firstNondefiningDeclaration
  // could be a problem at some point.  But for now this preserves the concept of an exact copy, so I am 
  // leaving it as is.

  // If this is a declaration which is a nondefining declaration, then the copy should be as well.
     if (this->get_firstNondefiningDeclaration() == this)
        {
       // printf ("This is the FIRST-NON-DEFINING declaration \n");
          copyDeclarationStatement->set_firstNondefiningDeclaration(copyDeclarationStatement);
        }

#if 0
  // DQ (10/15/2007): We now insert everything into the map so that we can reference IR nodes later and find 
  // their associated node in the copy of the AST.

  // DQ (10/12/2007): Incrementally we can add more declarations and scopes (and everything else if we want) 
  // to the history of what has been copied. At first we have only need those declarations required to fixup 
  // references to symbols.  But we might want scopes next.
  // DQ (10/8/2007): Support for fixing up references (e.g. variable references, function references, member function references, labels)
     if (this->hasAssociatedSymbol() == true)
        {
       // Save the association between this declaration and the copy of this declaration so that we can use 
       // it to build a new symbol for any references to it later.
          printf ("Adding the original and copy IR nodes to help.insertCopiedNodePair() for %s \n",this->class_name().c_str());
          help.insertCopiedNodePair(this,copy);
        }
#endif

  // DQ (10/12/2007): Set the scope for those SgDeclarationStatements which store their scope explicitly.
     if (this->hasExplicitScope() == true)
        {
       // We need to reset the scope
          if (copyDeclarationStatement->get_scope() == this->get_scope())
             {
            // This is certainly the wrong scope
            // printf ("The scope of this SgDeclarationStatement is wrong this = %p = %s \n",this,this->class_name().c_str());

#if 0
            // DQ (10/15/2007): This was becoming too complex...

            // Because there are different rules for defining and nondefining declarations by IR node, we have to separate 
            // out the different cases!
               switch (copyDeclarationStatement->variantT())
                  {
                 // These can't be declared in alternative scopes so we can use the structure to interpret the scope, I think!
                 // I expect that this might mean that they should not have an explicit scope, but it does current within ROSE.
                    case V_SgTypedefDeclaration:
                    case V_SgEnumDeclaration:
                       {
                      // Compute the scope from the parent information
                         ROSE_ASSERT(copyDeclarationStatement->get_parent() != NULL);
                         SgScopeStatement* parentScope = isSgScopeStatement(copyDeclarationStatement->get_parent());
                         ROSE_ASSERT(parentScope != NULL);
                         printf ("Setting scope of %p = %s to %p = %s \n",copyDeclarationStatement,copyDeclarationStatement->class_name().c_str(),
                              parentScope,parentScope->class_name().c_str());
                         copyDeclarationStatement->set_scope(parentScope);
                         break;
                       }

                    case V_SgFunctionDeclaration:
                    case V_SgTemplateDeclaration:
                    case V_SgClassDeclaration:
                    case V_SgTemplateInstantiationFunctionDecl:
                    case V_SgTemplateInstantiationMemberFunctionDecl:
                       {
                      // Use the parent of the defining declaration!  Will this be a problem for 
                      // forward declaration!  It might be that we have to first process the defining declaration and then the 
                      // non-defining declarations!

                      // Compute the scope from the parent information
                      // ROSE_ASSERT(copyDeclarationStatement->get_parent() != NULL);
                         SgDeclarationStatement* definingDeclaration = copyDeclarationStatement->get_definingDeclaration();
                         if (definingDeclaration != NULL)
                            {
                              printf ("Using the defining declaration as a guide to get the scope: definingDeclaration = %p = %s \n",definingDeclaration,definingDeclaration->class_name().c_str());
                              printf ("Setting the scope of the defining declaration for %p = %s \n",copyDeclarationStatement,copyDeclarationStatement->class_name().c_str());
                              SgScopeStatement* parentScope = isSgScopeStatement(definingDeclaration->get_parent());
                           // ROSE_ASSERT(parentScope != NULL);
                              if (parentScope != NULL)
                                 {
                                   SgScopeStatement* alternativeParentScope = parentScope;
                                   printf ("   (using the defining declaration) setting scope of %p = %s to %p = %s \n",copyDeclarationStatement,
                                        copyDeclarationStatement->class_name().c_str(),alternativeParentScope,alternativeParentScope->class_name().c_str());
                                   copyDeclarationStatement->set_scope(alternativeParentScope);
                                 }
                                else
                                 {
                                // SgScopeStatement* alternativeParentScope = definingDeclaration->get_scope();
                                   SgDeclarationStatement* parentOfDefiningDeclaration = isSgDeclarationStatement(definingDeclaration->get_parent());
                                   ROSE_ASSERT(parentOfDefiningDeclaration != NULL);
                                // SgScopeStatement* alternativeParentScope = isSgScopeStatement(definingDeclaration->get_parent());
                                   SgScopeStatement* alternativeParentScope = parentOfDefiningDeclaration->get_scope();
                                   ROSE_ASSERT(alternativeParentScope != NULL);
                                // ROSE_ASSERT(alternativeParentScope == definingDeclaration->get_parent());
                                   printf ("   (parentScope == NULL) definingDeclaration->get_parent() = %p = %s setting scope of %p = %s to %p = %s \n",
                                        definingDeclaration->get_parent(),definingDeclaration->get_parent()->class_name().c_str(),
                                        copyDeclarationStatement,copyDeclarationStatement->class_name().c_str(),
                                        alternativeParentScope,alternativeParentScope->class_name().c_str());

                                   copyDeclarationStatement->set_scope(alternativeParentScope);
                                 }
                            }
                           else
                            {
                           // Use the non-defining declaration if there was no defining declaration, this uses the structural 
                           // representation of the non-defining declaration which might not work, I think.
                              if (copyDeclarationStatement->get_parent() != NULL)
                                 {
                                   ROSE_ASSERT(copyDeclarationStatement->get_parent() != NULL);
                                   printf ("copyDeclarationStatement->get_parent() = %p = %s \n",copyDeclarationStatement->get_parent(),copyDeclarationStatement->get_parent()->class_name().c_str());
                                   SgScopeStatement* parentScope = isSgScopeStatement(copyDeclarationStatement->get_parent());
                                   ROSE_ASSERT(parentScope != NULL);
                                   printf ("   (defining declaration was NOT available) setting scope of %p = %s to %p = %s \n",copyDeclarationStatement,
                                        copyDeclarationStatement->class_name().c_str(),parentScope,parentScope->class_name().c_str());
                                   copyDeclarationStatement->set_scope(parentScope);
                                 }
                                else
                                 {
                                // This might be OK if the copyDeclarationStatement is the root of the AST copy!
                                   printf ("WARNING: copyDeclarationStatement->get_parent() == NULL \n");
                                 }
                            }
                         break;
                       }

                    default:
                       {
                         printf ("Error: default reached = %p = %s \n",copyDeclarationStatement,copyDeclarationStatement->class_name().c_str());
                         ROSE_ASSERT(false);
                       }
                  }
#else
            // DQ (10/15/2007): This is a simpler approach using the map stored in the SgCopyHelp object.
               SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(this->get_scope());
               if (i != help.get_copiedNodeMap().end())
                  {
                 // Use the associated value from the map as the scope.
                    SgNode* scopeNode_copy = i->second;
                    ROSE_ASSERT(scopeNode_copy != NULL);
                    SgScopeStatement* scope_copy = isSgScopeStatement(scopeNode_copy);
                    ROSE_ASSERT(scope_copy != NULL);
                    copyDeclarationStatement->set_scope(scope_copy);
                  }
                 else
                  {
                 // Else set the scope in the copyDeclarationStatement to be the same as this->get_scope()
                    SgScopeStatement* currentScope = this->get_scope();
                    ROSE_ASSERT(currentScope != NULL);
                    printf ("In SgDeclarationStatement::fixupCopy() this = %p = %s this->get_scope() = %p = %s \n",this,this->class_name().c_str(),currentScope,currentScope->class_name().c_str());
                    copyDeclarationStatement->set_scope(currentScope);
                  }
#endif
             }

       // ROSE_ASSERT(copyDeclarationStatement->get_scope() != this->get_scope());
          if (copyDeclarationStatement->get_scope() == this->get_scope())
             {
               printf ("##########  ERROR: SCOPES NOT SET CORRECTLY! (%p = %s)  ########## \n",copy,copy->class_name().c_str());
             }

       // Make sure that the copy sets the scopes to be the same type
          ROSE_ASSERT(copyDeclarationStatement->get_scope()->variantT() == this->get_scope()->variantT());
        }

  // Call the base class fixupCopy member function
     SgStatement::fixupCopy(copy,help);
   }
#endif


// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgDeclarationStatement::p_defaultQualifiedNamePtrList;

SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgDeclarationStatement::set_qualifiedNameList( const SgQualifiedNamePtrList & x )
   {
     p_qualifiedNameList = x;
   }

void
SgDeclarationStatement::post_construction_initialization()
   {}

int
SgDeclarationStatement::isForward() const 
   { return get_forward(); }

void
SgDeclarationStatement::setForward() 
   { set_forward(true); }

void
SgDeclarationStatement::unsetForward() 
   { set_forward(false); }

int
SgDeclarationStatement::isNameOnly() const 
   { return get_nameOnly(); }

void
SgDeclarationStatement::setNameOnly() 
   { set_nameOnly(true); }

void
SgDeclarationStatement::unsetNameOnly() 
   { set_nameOnly(false); }

int
SgDeclarationStatement::isExternBrace() const 
   { return get_externBrace(); }

void
SgDeclarationStatement::setExternBrace() 
   { set_externBrace(true); }

void
SgDeclarationStatement::unsetExternBrace() 
   { set_externBrace(false); }

int
SgDeclarationStatement::skipElaborateType() const 
   { return get_skipElaborateType(); }

void
SgDeclarationStatement::setSkipElaborateType() 
   { set_skipElaborateType(true); }

void
SgDeclarationStatement::unsetSkipElaborateType() 
   { set_skipElaborateType(false); }


void
SgDeclarationStatement::testForBadGenerateTemplateName( const std::string & name ) 
   {
  // DQ (2/20/2005): Error checking on existance of substrings that can be common
  // in building template name and which are a source of errors in generated code.
     if ( (name.find("<<") != string::npos) || (name.find(">>") != string::npos) )
        {
       // This could just be the input or output operators so make sure this is not that case!
          if ( (name.find("operator<<") == string::npos) && (name.find("operator>>") == string::npos) )
             {
            // OK, we have some sort of error to report!
               printf ("\n\n");
               printf ("Error: \"<<\" or \">>\" found in generated name, this could lead to an error in compiling the generated code later \n");
               printf ("..... name generated in processing a %s IR node \n",sage_class_name());
               printf ("..... generated name = %s \n",name.c_str());
               printf ("\n\n");
               ROSE_ASSERT (false);
            // ROSE_ASSERT (returnName.find("<<") == string::npos);
            // ROSE_ASSERT (returnName.find(">>") == string::npos);
             }
        }

  // Search for common substring of unconverted EDG generated typenames...
     if ( name.find("____") != string::npos )
        {
          printf ("Error: \"____\" found in ROSE generated type name = %s (likely and unconverted EDG name) \n",name.c_str());
          ROSE_ASSERT (false);
        }
   }


bool
SgDeclarationStatement::skipEmptyTemplateArgumentListTest ( SgFunctionDeclaration* functionDeclaration )
   {
  // DQ (4/13/2005): Avoid output of empty lists of template arguments in function names
  // as in "endl<>" (which is a bug in g++ version 3.4, see test2005_55.C).  This
  // should only apply to function and member functions since they alown can skip the output of "<>".
  // What we do below is skip the "<" and ">" when the list of template arguments would be empty.
  // It would be empty when either there are no arguments or non were explicitly specified in the 
  // source code.

  // Note that this function can only be applied to functions (since only they are explicitly 
  // mark with if there template arguments are specified or not!)

     ROSE_ASSERT(functionDeclaration != NULL);

  // default is true, so empty lists are not output (could this be an error?)
     bool skipEmptyTemplateArgumentList = true;

     string functionName;
     SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;

  // One or the other of these are valie pointers, but not both!
     SgTemplateInstantiationFunctionDecl       *templateInstantiationFunctionDeclaration       = 
          isSgTemplateInstantiationFunctionDecl(functionDeclaration);
     SgTemplateInstantiationMemberFunctionDecl *templateInstantiationMemberFunctionDeclaration = 
          isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);

     if (templateInstantiationFunctionDeclaration != NULL)
        {
          functionName       = templateInstantiationFunctionDeclaration->get_templateName().str();
          templateArgListPtr = templateInstantiationFunctionDeclaration->get_templateArguments();
        }
       else
        {
          ROSE_ASSERT(templateInstantiationMemberFunctionDeclaration != NULL);
          functionName       = templateInstantiationMemberFunctionDeclaration->get_templateName().str();
          templateArgListPtr = templateInstantiationMemberFunctionDeclaration->get_templateArguments();
        }

#if 0
     printf ("In skipEmptyTemplateArgumentListTest: Handling function name = %s \n",functionName.c_str());
#endif

     ROSE_ASSERT(templateArgListPtr != NULL);

     SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
     while (i != templateArgListPtr->end())
        {
#if 0
          printf ("templateArgList element *i = %s \n",(*i)->sage_class_name());
#endif

       // DQ (2/27/2005): Added support for output of only template arguments 
       // that were explicit in the source code.  Only meaningful for function 
       // and member function template arguments.
          bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
          bool outputTemplateArgument = false;
          if ( templateArgumentWasExplicitlySpecified == true )
             {
               outputTemplateArgument = true;
               skipEmptyTemplateArgumentList = false;
             }
          
#if 0
          printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif

          i++;
        }

#if 0
     printf ("skipEmptyTemplateArgumentList = %s \n",(skipEmptyTemplateArgumentList == true) ? "true" : "false");
#endif

     return skipEmptyTemplateArgumentList;
   }


void
resetTemplateNamesInScope ( SgScopeStatement* scope )
   {
  // DQ (8/11/2005): This function loops over all parent scopes to reset
  // any possibly unset names in instantiatied templated classes.

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(scope != NULL);

  // printf ("In resetTemplateNamesInScope: traversing through parent scopes (scope = %p = %s) \n",scope,scope->class_name().c_str());

     while ( scope != NULL && isSgGlobal(scope) == NULL )
        {
       // printf ("In resetTemplateNamesInScope(%s) \n",scope->class_name().c_str());

          switch(scope->variantT())
             {
               case V_SgFunctionDefinition:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

               case V_SgGlobal:
               case V_SgBasicBlock:
               case V_SgCatchOptionStmt:
               case V_SgSwitchStatement:
               case V_SgIfStmt:
               case V_SgWhileStmt:
               case V_SgDoWhileStmt:
               case V_SgForStatement:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

               case V_SgClassDefinition:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgClassDefinition(scope)->get_declaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

            // This turns out to be the only important case!
               case V_SgTemplateInstantiationDefn:
                  {
                    SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(scope);
                    ROSE_ASSERT(defn != NULL);
                    ROSE_ASSERT(defn->get_declaration() != NULL);
                    SgTemplateInstantiationDecl *decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                    ROSE_ASSERT(decl != NULL);
                    decl->resetTemplateName();
                    break;
                  }

               case V_SgNamespaceDefinitionStatement:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgNamespaceDefinitionStatement(scope)->get_namespaceDeclaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

               default:
                    printf ("Error: default reached in evaluation of scope within resetTemplateNamesInScope scope = %s \n",
                         scope->sage_class_name());
                    ROSE_ASSERT(false);
             }

          scope = scope->get_scope();
        }
   }



// DQ (2/15/2005): This is the former SgTemplateInstantitionDecl::resetTemplateName()
// member function.  It has been moved to a global supporting function so that similar
// support can be added to the SgTemplateInstantiationFunctionDecl and the 
// SgTemplateInstantiationMemberFunctionDecl IR nodes.  With this design function names
// are not known, except through their mangled names, until after the AST fixup phase.
// I think that this will not be an issue within ROSE.  
// Several input parameters are passed, these are the private variables within the 
// IR nodes.
// void SgDeclarationStatement::resetTemplateName ()
void
SgDeclarationStatement::resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name )
   {
  // This function generates the full template name (e.g. "ABC<int>") instead of the mangled name
  // stored in the p_name variable.  Note that the templateArguments must be defined, we can't
  // seem to just set this in the EDG interface since not all the pieces are in place as SAGE III
  // IR nodes. It resets the mangled name in p_name to the full template name.

  // DQ (9/27/2004) Note: This is the only place within the construction of the Sage III AST (from EDG)
  // where the unparser is called.  It is in general unsafe to do this and it may be that this should 
  // be reserved for after the Sage III AST is fully constructed and all post processing fixup 
  // (currently limited to setting all parent pointers) is complete.

     ROSE_ASSERT (this != NULL);
     string returnName;

#if 0
  // DQ (9/25/2007): Old test, no longer valid.
  // DQ (10/11/2004): Error checking for infinite recursion (just in case it could happen)
     static int counter = 0;
     if (counter > 10000)
        {
          printf ("resetTemplateNameSupport could be in endless recursion ... \n");
          ROSE_ASSERT(false);
        }
#endif

  // DQ (11/23/2004): Check any possible template declarations in higher-level scopes 
  // (in which this declaration may be nested).  Such unreset names show up in qualified 
  // names that may be generated.  Note that this should be an explicit loop over all 
  // parent scopes since any non-template parent scope would break the handling of all 
  // templates between here and the global scope!  Handle this case after we debug the 
  // current simpler case!
#if 0
     printf ("Implementation of resetTemplateNameSupport() requires loop over parent scopes!!! \n");
#endif

     SgScopeStatement* parentScope = get_scope();
#if 0
     printf ("In resetTemplateNameSupport(): At %s parentScope = %s \n",sage_class_name(),parentScope->sage_class_name());
#endif

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(parentScope != NULL);

  // This function loops over all parent scopes
     resetTemplateNamesInScope(parentScope);

  // If the name has not been reset to the form "ABC<int>" then reset it now!
  // DQ (2/15/2005): Modified to reference input parameters
  // if (get_nameResetFromMangledForm() == false)
     if (nameResetFromMangledForm == false)
        {
       // returnName = get_templateName().str();
       // SgTemplateArgumentPtrListPtr templateArgListPtr = get_templateArguments();

          bool appendTemplateArguments   = true;

          bool skipEmptyTemplateArgumentList = false;

       // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
          bool functionTemplateArguments = false;
          SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;
          switch(variantT())
             {
               case V_SgTemplateInstantiationDecl:
                  {
                    SgTemplateInstantiationDecl* node = isSgTemplateInstantiationDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = node->get_templateArguments();

                 // DQ (2/21/2005): Error checking on existance of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }

            // DQ (4/13/2005): Combine these two cases since they are identical (error: both cases must be seperate!)
               case V_SgTemplateInstantiationFunctionDecl:
            // case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationFunctionDecl* node = isSgTemplateInstantiationFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>" 
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
                 // printf ("function name = %s \n",returnName.c_str());
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
                      // printf ("Skipping appending the templates arguments to this overloaded operator \n");
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existance of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#if 1
               case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationMemberFunctionDecl* node = isSgTemplateInstantiationMemberFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);

                 // printf ("node = %p = (templateName) %s = (name) %s \n",node,node->get_templateName().str(),node->get_name().str());

                    returnName         = node->get_templateName().str();
                    templateArgListPtr = node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>" 
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
                 // printf ("member function name = %s \n",returnName.c_str());
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
                      // printf ("Skipping appending the templates arguments to this overloaded operator \n");
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existance of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#endif
               default:
                  {
                 // ... nothing to do here
                  }
             }

          ROSE_ASSERT(templateArgListPtr != NULL);

       // DQ (4/13/2005): Sometimes template parameters are present but were not specificed in the source code and if so we 
       // should also not output "<>".  This is a stronger test than that implemented previously (fixes output of "std::endl<>" as well).
       // DQ (2/17/2005): We want to avoid "<>" appearing where template arguments are ment to be used (e.g. in function names)
       // if (templateArgListPtr != NULL)
       // if ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) )
          if ( ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) ) && (skipEmptyTemplateArgumentList == false) )
             {
#if 0
               printf ("In SgDeclarationStatement::resetTemplateName(): templateArgListPtr->size() = %zu \n",templateArgListPtr->size());
#endif

               returnName += " < ";
               SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
               while (i != templateArgListPtr->end())
                  {
#if 0
                    printf ("templateArgList element *i = %s \n",(*i)->sage_class_name());
#endif

                 // DQ (2/27/2005): Added support for output of only template arguments 
                 // that were explicit in the source code.  Only meaningful for function 
                 // and member function template arguments.
                    bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
                 // bool templateArgumentWasExplicitlySpecified = true;
                 // if (templateArgumentWasExplicitlySpecified == true)
                    bool outputTemplateArgument = false;
                    if ( (functionTemplateArguments == false) || 
                         ( (functionTemplateArguments == true) && (templateArgumentWasExplicitlySpecified == true) ) )
                       {
                         outputTemplateArgument = true;
                       }
#if 0
                    printf ("functionTemplateArguments = %s \n",(functionTemplateArguments == true) ? "true" : "false");
                    printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif
                    if (outputTemplateArgument == true)
                       {
                         ROSE_ASSERT( *i != NULL);
#if 0
                         printf ("In SgDeclarationStatement::resetTemplateName(): (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
#endif
                         switch((*i)->get_argumentType())
                            {
                              case SgTemplateArgument::argument_undefined:
                                 {
                                   printf ("Error: SgTemplateArgument::argument_undefined not allowed \n");
                                   ROSE_ASSERT(false);
                                   break;
                                 }
                              case SgTemplateArgument::type_argument:
                                 {
                                   ROSE_ASSERT((*i)->get_type() != NULL);
                                   SgType* argumentType = (*i)->get_type();
#if 0
                                   printf ("SgTemplateArgument::type_argument: argumentType = %p = %s \n",argumentType,argumentType->sage_class_name());
#endif
                                   switch(argumentType->variantT())
                                      {
                                        case V_SgClassType:
                                           {
                                          // DQ (10/13/2004): If this is a template declaration then we might have to reset its name
                                             SgClassType* classType = isSgClassType(argumentType);
                                          // printf ("Found a class declaration ... \n");
                                             SgDeclarationStatement* declaration = classType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                                             ROSE_ASSERT(classDeclaration != NULL);
                                             SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
                                             if (templateClassDeclaration != NULL)
                                                {
                                               // printf ("Found a template instantiation declaration  (call resetTemplateName) ... \n");
                                                  templateClassDeclaration->resetTemplateName();
                                                }
                                             break;
                                           }
                                        case V_SgTypedefType:
                                           {
                                             SgTypedefType* typedefType = isSgTypedefType(argumentType);
                                          // printf ("Found a typedef declaration ... \n");
                                             SgDeclarationStatement* declaration = typedefType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(declaration);
                                             ROSE_ASSERT(typedefDeclaration != NULL);
                                             SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(typedefDeclaration->get_scope());
                                             if (defn != NULL)
                                                {
                                               // If we start the resetTemplateName() function here in the parent scope of the typedef 
                                               // type's declaration then it should continue to call resetTemplateName() through the 
                                               // rest of the scopes to the root (global scope).  Unless there is a non-template in the
                                               // chain!  So I guess the code above must be an explicit loop over all parent scopes 
                                               // until we reach global scope!
                                                  SgTemplateInstantiationDecl* decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                                                  ROSE_ASSERT(decl != NULL);
                                                  decl->resetTemplateName();
                                                }
                                             break;
                                           }

                                     // DQ (9/11/2005): Handle these cases together
                                        case V_SgPointerType:
                                        case V_SgModifierType:
                                        case V_SgReferenceType:
                                           {
                                          // Need to reach in and see if this is a template instantiation of a class type and then reset its name
                                          // SgModifierType* modifierType = isSgModifierType(argumentType);
                                          // ROSE_ASSERT(modifierType != NULL);
                                          // SgType* strippedType = modifierType->stripType();

                                          // printf ("Case of SgPointerType, SgModifierType, SgReferenceType \n");
#if 0
                                          // This passes by too many places where (within typedefs for example) template names could be reset
                                             SgType* strippedType = argumentType->stripType()
#else
                                          // Handle this explicitly so that we can see the full type chain (in case there is a unset template name in the chain!)
                                             SgType* currentType = argumentType;

                                             SgModifierType*  modType     = NULL;
                                             SgPointerType*   pointType   = NULL;
                                             SgReferenceType* refType     = NULL;
                                             SgArrayType*     arrayType   = NULL;
                                             SgTypedefType*   typedefType = NULL;

                                          // Loop through the chain of types (modifiers, references, pointers, array types, and typedefs
                                             while (true)
                                                {
                                                  if ( (modType = isSgModifierType(currentType)) )
                                                     {
                                                       currentType = modType->get_base_type();
                                                     }
                                                    else
                                                     {
                                                       if ( (refType = isSgReferenceType(currentType)) )
                                                          {
                                                            currentType = refType->get_base_type();
                                                          }
                                                         else
                                                          {
                                                            if ( (pointType = isSgPointerType(currentType)) )
                                                               {
                                                                 currentType = pointType->get_base_type();
                                                               }
                                                              else
                                                               {
                                                                 if ( (arrayType = isSgArrayType(currentType)) )
                                                                    {
                                                                      currentType = arrayType->get_base_type();
                                                                    }
                                                                   else
                                                                    {
                                                                   // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
                                                                      if ( (typedefType = isSgTypedefType(currentType)) )
                                                                         {
                                                                           currentType = typedefType->get_base_type();
                                                                         }
                                                                        else
                                                                         {
                                                                        // Exit the while(true){} loop!
                                                                           break;
                                                                         }
                                                                    }
                                                               }
                                                          }
                                                     }

                                               // printf ("In resetTemplateName: stripping type - currentType = %s hidden behind this = %s \n",
                                               //      currentType->sage_class_name(),argumentType->sage_class_name());

                                               // Check all typedefs that we find along the way (in this while loop through the modifiers)!
                                                  if (typedefType != NULL)
                                                     {
#if 1
                                                       SgDeclarationStatement* likelyTypedefDeclaration = typedefType->get_declaration();
                                                       ROSE_ASSERT( likelyTypedefDeclaration != NULL);
                                                       SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(likelyTypedefDeclaration);
                                                       ROSE_ASSERT( typedefDeclaration != NULL);
                                                    // printf ("In resetTemplateName: In loop over typedefs, modifiers, etc. found a typedef = %s \n",typedefDeclaration->get_name().str());
#endif
                                                       SgType* baseType = typedefType->get_base_type();
                                                       ROSE_ASSERT(currentType == baseType);
                                                       ROSE_ASSERT(baseType != NULL);
                                                       SgClassType* classType = isSgClassType(baseType);
                                                       if (classType != NULL)
                                                          {
                                                         // printf ("In loop over typedefs, modifiers, etc. found a class type \n");
                                                            SgDeclarationStatement* declaration = classType->get_declaration();
                                                            ROSE_ASSERT(declaration != NULL);
                                                            SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                            if (classTemplateInstantiation != NULL)
                                                               {
                                                              // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                              //      classTemplateInstantiation->get_name().str());
                                                                 classTemplateInstantiation->resetTemplateName();
                                                               }
                                                          }

                                                    // ROSE_ASSERT(typedefType->get_declaration() != NULL);
                                                    // ROSE_ASSERT(isSgTypedefDeclaration(typedefType->get_declaration()) != NULL);
                                                    // SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(typedefType->get_declaration());
                                                       SgScopeStatement* typedefScope = typedefDeclaration->get_scope();
                                                       ROSE_ASSERT(typedefScope != NULL);
                                                    // printf ("In resetTemplateName: traversing through parent scopes to resent any instnatiated template names \n");
                                                       resetTemplateNamesInScope(typedefScope);
                                                     }

                                               // reset these to NULL (to avoid saving a history, this allows the typedefType to be checked)
                                                  modType     = NULL;
                                                  refType     = NULL;
                                                  pointType   = NULL;
                                                  arrayType   = NULL;
                                                  typedefType = NULL;
                                                }

                                             SgType* strippedType = currentType;
#endif
                                             ROSE_ASSERT(strippedType != NULL);
                                             SgClassType* classType = isSgClassType(strippedType);
                                             if (classType != NULL)
                                                {
                                               // printf ("Found a class type \n");
                                                  SgDeclarationStatement* declaration = classType->get_declaration();
                                                  ROSE_ASSERT(declaration != NULL);
                                                  SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                  if (classTemplateInstantiation != NULL)
                                                     {
                                                    // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                    //      classTemplateInstantiation->get_name().str());
                                                       classTemplateInstantiation->resetTemplateName();
                                                     }
                                                }
                                             break;
                                           }

                                     // DQ (2/28/2005): List of types used in compiling Kull
                                        case V_SgTypeChar:
                                        case V_SgTypeWchar:
                                        case V_SgTypeBool:
                                        case V_SgTypeSignedChar:
                                        case V_SgTypeUnsignedChar:
                                        case V_SgTypeShort:
                                        case V_SgTypeUnsignedShort:
                                        case V_SgTypeUnsignedInt:
                                        case V_SgTypeLong:
                                        case V_SgTypeUnsignedLong:
                                        case V_SgTypeLongLong:
                                        case V_SgTypeUnsignedLongLong:
                                        case V_SgTypeFloat:
                                        case V_SgTypeDouble:
                                        case V_SgTypeLongDouble:
                                        case V_SgTypeVoid:
                                        case V_SgTypeInt:
                                        case V_SgEnumType:
                                           {
                                          // Nothing to do here with these primative types (listed explicitly to avoid compiler warnings)
                                             break;
                                           }

                                         default:
                                           {
                                             printf ("Default reached in switch over SgTemplateArgument::type_argument (argumentType = %p = %s) \n",argumentType,argumentType->sage_class_name());
                                          // ROSE_ASSERT(false);
                                           }
                                      }
                                   break;
                                 }

                              case SgTemplateArgument::nontype_argument:
                                 {
                                // These can be boolean or integer values, for example.
                                   ROSE_ASSERT((*i)->get_expression() != NULL);
#if 0
                                   SgExpression* argumentExpression = (*i)->get_expression();
                                   printf ("SgTemplateArgument::nontype_argument: argumentExpression = %p = %s \n",
                                        argumentExpression,argumentExpression->sage_class_name());
#endif
                                   break;
                                 }

                              case SgTemplateArgument::template_template_argument:
                                 {
                                // DQ (8/24/2006): This is not a name that needs to be reset,
                                // so I think there is nothing to do here!
                                   ROSE_ASSERT((*i)->get_templateDeclaration() != NULL);

                                // printf ("Warning: SgTemplateArgument::template_template_argument not implemented \n");
                                // ROSE_ASSERT(false);
                                   break;
                                 }

                              default:
                                 {
                                   printf ("Default reached in switch over (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
                                   ROSE_ASSERT(false);
                                 }
                            }

                      // DQ (2/21/2005): Error checking on existance of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);

                      // DQ (2/28/2005): Pass in an explicit unparse info object to control (and turn off) the 
                      // unparsing of definitions within the unparsing of types used as template arguments.
                      // This avoids generation of bad code like "x6.foo<const enum values {zero,nonzero}>();"
                      // (see test2005_13.C for details on this bug).
                         SgUnparse_Info unparseInfo;
                         unparseInfo.set_SkipDefinition();
                         ROSE_ASSERT (unparseInfo.SkipDefinition() == true);

                      // DQ (2/28/2005): Set these to be consistant with unparseToString
                      // Skip all comments in unparsing
                         unparseInfo.set_SkipComments();
                         ROSE_ASSERT (unparseInfo.SkipComments() == true);
                      // Skip all whitespace in unparsing (removed in generated string)
                         unparseInfo.set_SkipWhitespaces();
                         ROSE_ASSERT (unparseInfo.SkipWhitespaces() == true);

                      // Skip all directives (macros are already substituted by the front-end, so this has no effect on those)
                         unparseInfo.set_SkipCPPDirectives();
                         ROSE_ASSERT (unparseInfo.SkipCPPDirectives() == true);

                      // DQ (6/9/2007): Set the scope from which the name qualification for the template arguments should be computed!
                         ROSE_ASSERT(*i != NULL);
                         SgScopeStatement* localScope = (*i)->get_scope();
                         unparseInfo.set_current_scope(localScope);

                      // DQ (2/28/2005): Call globalUnparseToString() so tht we can specify 
                      // greater control over unparsing.
                      // DQ (10/12/2004): This can be called now the this function is called after the 
                      // post-processing fixup of the parent nodes in the AST (after the EDG/Sage III translation).
                      // This simplifies the implementation and permits the unparser to call the functions 
                      // required to generate qualified names (which require that the parent pointers be set).
                      // returnName += (*i)->unparseToString(unparseInfo);

                      // printf ("Before globalUnparseToString: returnName = %s \n",returnName.c_str());
                         returnName += globalUnparseToString(*i,&unparseInfo);
                      // printf ("After globalUnparseToString: returnName = %s \n",returnName.c_str());

                      // DQ (2/21/2005): Error checking on existance of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);
                       }

                 // DQ (2/27/2005): Added support for output of only template arguments 
                 // that were explicit in the source code.
                 // if (templateArgumentWasExplicitlySpecified == true)
                    if (outputTemplateArgument == true)
                       {
                      // Increment to next template argument
                         i++;

                         if (i != templateArgListPtr->end())
                            returnName += " , ";
                       }
                      else
                       {
                      // Increment to next template argument
                         i++;
                       }
                  }

            // Close off the template argument list
               returnName += " > ";

#if 0
            // DQ (2/20/2005): Error checking on existance of substrings that can be common
            // in building template name and which are a source of errors in generated code.
               if ( (returnName.find("<<") != string::npos) || (returnName.find(">>") != string::npos) )
                  {
                    printf ("returnName = %s \n",returnName.c_str());
                  }
               ROSE_ASSERT (returnName.find("<<") == string::npos);
               ROSE_ASSERT (returnName.find(">>") == string::npos);
#endif
             }
            else
             {
            // DQ (2/17/2005): This can be the case of a member function of a templated class which 
            // would of course not have any template arguments specific to it as a function.
            // printf ("Error in resetTemplateName(): No valid template argument list \n");
            // ROSE_ASSERT(false);
             }

       // printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
       // SageInterface::outputLocalSymbolTables(parentScope);
#if 0
       // DQ (2/10/2007): Unload the associated symbol using the old name and reload it into the symbol table using the new name!
          printf ("\n\nCalling this->get_symbol_from_symbol_table() on %s parentScope = %p = %s name = %s count = %ld \n",
               this->class_name().c_str(),parentScope,parentScope->class_name().c_str(),name.str(),parentScope->count_symbol(name));
          printf ("     this = %p = %s definingDeclaration         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
          printf ("     this = %p = %s firstNondefiningDeclaration = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(this);
          if (templateInstantiation != NULL)
             {
               printf ("templateInstantiation->get_name()  = %s get_templateName() = %s \n",templateInstantiation->get_name().str(),templateInstantiation->get_templateName().str());
               printf ("templateInstantiation->get_scope() = %p = %s \n",templateInstantiation->get_scope(),templateInstantiation->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationFunctionDecl* templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(this);
          if (templateInstantiationFunction != NULL)
             {
               printf ("templateInstantiationFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationFunction->get_name().str(),templateInstantiationFunction->get_templateName().str());
               printf ("templateInstantiationFunction->get_scope() = %p = %s \n",templateInstantiationFunction->get_scope(),templateInstantiationFunction->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateInstantiationMemberFunction != NULL)
             {
               printf ("templateInstantiationMemberFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationMemberFunction->get_name().str(),templateInstantiationMemberFunction->get_templateName().str());
               printf ("templateInstantiationMemberFunction->get_scope() = %p = %s \n",templateInstantiationMemberFunction->get_scope(),templateInstantiationMemberFunction->get_scope()->class_name().c_str());
             }
#endif
          SgSymbol* symbol = this->get_symbol_from_symbol_table();
          if (symbol == NULL)
             {
            // If searching for the old name returned a null symbol pointer then make sure that there is an entry for the new name
            // printf ("Searching for returnName = %s \n",returnName.c_str());
#if 0
               if (parentScope->count_symbol(returnName) >= 1)
                  {
                    printf ("Warning: symbol for returnName = %s is already in the symbol table but not associated with this = %p = %s count = %ld \n",
                         returnName.c_str(),this,this->class_name().c_str(),parentScope->count_symbol(returnName));
                    printf ("     (count too large) this = %p = %s this->get_definingDeclaration()         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
                    printf ("     (count too large) this = %p = %s this->get_firstNondefiningDeclaration() = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
                  }
#endif
            // ROSE_ASSERT(parentScope->count_symbol(returnName) >= 1);
#if 0
               printf ("There are a number of reasons why we could not have a valid symbol at this point: (parentScope = %p = %s = %s) \n",
                    parentScope,parentScope->class_name().c_str(),SageInterface::get_name(parentScope).c_str());
               printf ("   1) template used as base class in SgCtorInitializerList \n");
               printf ("   2) template used as in a type \n");
               printf ("   3) Either the processing of the defining or non-defining declaration already removed the symbol using the old name \n");
               printf ("******************** START **********************\n");
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
               SageInterface::outputLocalSymbolTables(parentScope);
               printf ("******************** DONE ***********************\n");
#endif
             }
            else
             {
            // Remove the symbol (previously inserted under the old name and hashed accordingly) 
            // so that we can reinsert it into the symbol table after we change the name.
#if 0
               printf ("Removing the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);
               if (classSymbol != NULL)
                  {
                    printf ("classSymbol->get_declaration() = %p = %s name = %s \n",classSymbol->get_declaration(),classSymbol->get_declaration()->class_name().c_str(),classSymbol->get_declaration()->get_name().str());
                  }
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);
               if (functionSymbol != NULL)
                  {
                    printf ("functionSymbol->get_declaration() = %p = %s name = %s \n",functionSymbol->get_declaration(),functionSymbol->get_declaration()->class_name().c_str(),functionSymbol->get_declaration()->get_name().str());
                  }
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);
               if (memberFunctionSymbol != NULL)
                  {
                    printf ("memberFunctionSymbol->get_declaration() = %p = %s name = %s \n",memberFunctionSymbol->get_declaration(),memberFunctionSymbol->get_declaration()->class_name().c_str(),memberFunctionSymbol->get_declaration()->get_name().str());
                  }
#endif
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): removing symbol = %p = %s for symbol_basis = %p = %s \n",
                    symbol,symbol->class_name().c_str(),symbol->get_symbol_basis(),symbol->get_symbol_basis()->class_name().c_str());
#endif
            // ROSE_ASSERT(false);

               parentScope->remove_symbol(symbol);
             }

       // DQ (2/15/2005): Modified to reference input parameters ("name" is an input parameter to this function!)
       // set_name( returnName.c_str());
          name = returnName.c_str();
       // DQ (2/10/2007): If we have a symbol then reinsert it into the symbol table using the new name
          if (symbol != NULL)
             {
            // printf ("Inserting the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               parentScope->insert_symbol(name,symbol);
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table: \n");
               SageInterface::outputLocalSymbolTables(parentScope);
#endif
             }
       // DQ (2/15/2005): Modified to reference input parameters
       // DQ (10/11/2004): Removed call to unparser since it often requires that the parents
       // be set.  Now we have to mark this template as no long contining a mangled name
       // set_nameResetFromMangledForm(true);
          nameResetFromMangledForm = true;

       // DQ (2/20/2005): Error checking on existance of substrings that can be common
       // in building template name and which are a source of errors in generated code.
          testForBadGenerateTemplateName(returnName);
        }
   }

// This is a local file scope (support) function
static void
stringSupport ( string & sourceString, const string & targetString, const string & replacementString )
   {
     if (sourceString.find(targetString) != string::npos)
        {
          sourceString.replace(sourceString.find(targetString),targetString.size(),replacementString);
        }
   }

// SgName SgDeclarationStatement::fixupTemplateNameForMangledNameSupport( const SgName & name) const
static SgName fixupTemplateNameForMangledNameSupport( const SgName & name)
   {
  // Where template names are reset to the form "foo < int >" we can look for just
  // the " < " and " > " substrings which are qarenteed to exist by construction!
     string s = name.str();

  // printf ("In fixupTemplateNameForMangledNameSupport(): Before filtering s = %s \n",s.c_str());

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // To safely fixup all template syntax (e.g. "<x>") to remove the "<" and ">" we have to take care to not 
  // change the name of any operator (such as "operator<<", "operator>>", "operator<", "operator>", 
  // "operator<=", and "operator>="
  // Note that this is a current bug for:
  // __copy_backward_dispatch<std::vector <int,std::allocator<int>>::value_type*,std::vector<int,std::allocator<int>>::value_type*,__type_traits<int>::has_trivial_assignment_operator>

#if 0
     if (s.find("_operator>") != string::npos)
        {
          printf ("This name constains the substring \"_operator>\" which will not be translated into a mangled name correctly! \n");
          printf ("   Original name = %s \n",s.c_str());
       // ROSE_ASSERT(false);
        }
#endif

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator>","_operator?");

     stringSupport (s,"operator>>","operator??");
     stringSupport (s,"operator<<","operator$$");
     stringSupport (s,"operator>","operator?");
     stringSupport (s,"operator<","operator$");
     stringSupport (s,"operator*","operator@");

     string templateMarkerStart = "<";
     int length = templateMarkerStart.size();
     while (s.find(templateMarkerStart) != string::npos)
        {
       // s.replace(s.find(templateMarkerStart),3,"__templateArgs__");
          s.replace(s.find(templateMarkerStart),length,"__tas__"); // Template Arguments Start (TAS)
        }

     string templateMarkerEnd   = ">";
     length = templateMarkerEnd.size();
     while (s.find(templateMarkerEnd) != string::npos)
        {
       // s.replace(s.find(templateMarkerEnd),3,"__");
          s.replace(s.find(templateMarkerEnd),length,"__tae__"); // Template Arguments End (TAE)
        }

     string scopeOperator       = "::";
     length = scopeOperator.size();
     while (s.find(scopeOperator) != string::npos)
        {
          s.replace(s.find(scopeOperator),length,"__scope__"); // replace scope operator in qualified names
        }

     string commaSeparator      = ",";
     length = commaSeparator.size();
     while (s.find(commaSeparator) != string::npos)
        {
          s.replace(s.find(commaSeparator),length,"__comma__"); // replace the comma separator between template arguments
        }

     string referenceMarker     = "&";
     length = referenceMarker.size();
     while (s.find(referenceMarker) != string::npos)
        {
          s.replace(s.find(referenceMarker),length,"__ref__"); // replace the comma separator between template arguments
        }

     string pointerMarker       = "*";
     length = pointerMarker.size();
     while (s.find(pointerMarker) != string::npos)
        {
          s.replace(s.find(pointerMarker),length,"__ptr__"); // replace the comma separator between template arguments
        }

  // DQ (8/10/2005): This is a fix for a bug where a "-" shows up in some template 
  // arguments within names generated from compiling boost (boost/mpl/if.hpp).
  // I think that is shows up with "-1" is passed as an argument to a template.
     string minusMarker         = "_-";
     length = minusMarker.size();
     while (s.find(minusMarker) != string::npos)
        {
          s.replace(s.find(minusMarker),length,"__minus__"); // replace the minus operator between template arguments
        }

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator?","_operator__tae__");

     stringSupport (s,"operator??","operator>>");
     stringSupport (s,"operator$$","operator<<");
     stringSupport (s,"operator?","operator>");
     stringSupport (s,"operator$","operator<");
     stringSupport (s,"operator@","operator*");

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // printf ("In fixupTemplateNameForMangledNameSupport(): after filtering s = %s \n",s.c_str());

     ROSE_ASSERT (s.find("::") == string::npos);
     if (s.find(":") != string::npos)
        {
       // sleep(2);
          printf ("Error: failed test for embedded \":\" in template name = %s \n",s.c_str());
        }
     ROSE_ASSERT (s.find(":") == string::npos);
     ROSE_ASSERT (s.find(",") == string::npos);

     return s;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgDeclarationStatement::get_mangled_name(void) const
   {
  // printf ("In SgDeclarationStatement::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

     returnName = "Not_yet_defined_mangled_name";

     printf ("Warning: mangled name for %s not yet defined, base class SgDeclarationStatement::get_mangled_name called \n",class_name().c_str());
     ROSE_ASSERT(false);

     return returnName;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope ( SgScopeStatement* scope ) const
   {
     SgName name;

     ROSE_ASSERT(scope != NULL);

  // First setup the prefix for the generated name
     switch (scope->variantT())
        {
          case V_SgGlobal:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how 
            // to assign them unique names.  See the examples for each case below.
            // SgGlobal* definition = isSgGlobal(parent);

               name = string("unnamed_class_declaration_in_global_definition_");
               break;
             }
             
          case V_SgClassDefinition:
             {
               name = string("unnamed_class_declaration_in_class_definition_");
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               name = string("unnamed_class_declaration_in_class_template_definition_");
               break;
             }
             
          case V_SgBasicBlock:
             {
               name = string("unnamed_class_declaration_in_basic_block_");
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* definition = isSgNamespaceDefinitionStatement(scope);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_namespace_definition_") + definition->get_mangled_name();
#if 0
               printf ("This case should be implemented the same as for the SgGlobal case above \n");
               ROSE_ASSERT(false);
#endif
               break;
             }

          default:
             {
               printf ("Default reached in un-named declaration within parent = %p = %s \n",scope,scope->class_name().c_str());
               get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(scope->get_file_info() != NULL);
               scope->get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(false);
             }

        }

  // Now generate the unique string for the declaration (use the data/enum members where possible)
     switch(variantT())
        {
          case V_SgClassDeclaration:
             {
            // case of "class { int x; }; in global scope
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(this);
               ROSE_ASSERT(classDeclaration != NULL);
               const SgClassDefinition* classDefinition = isSgClassDefinition(this);
            // ROSE_ASSERT(classDefinition != NULL);
               if (classDefinition != NULL)
                  {
                    name = name + "defining_declaration";
                    const SgDeclarationStatementPtrList & l = classDefinition->get_members();
                    SgDeclarationStatementPtrList::const_iterator i = l.begin();
                    while (i != l.end())
                       {
                      // name += (*i)->get_name() + "_class_member_";
                         name += (*i)->get_mangled_name() + "_class_member_";
                         i++;
                       }
                  }
                 else
                  {
                    name = name + "nondefining_declaration";
                  }
               break;
             }

          case V_SgEnumDeclaration:
             {
            // case of "enum { x,y,z; }; in global scope
               name = string("unnamed_enum_declaration_in_global_definition_");

               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(this);
               ROSE_ASSERT(enumDeclaration != NULL);
               const SgInitializedNamePtrList & l = enumDeclaration->get_enumerators();
               SgInitializedNamePtrList::const_iterator i = l.begin();
               while (i != l.end())
                  {
                    name += (*i)->get_name() + "_enum_field_";
                    i++;
                  }
               break;
             }

          default:
             {
               printf ("Default reached in SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope (this = %p = %s) \n",
                    this,class_name().c_str());
               break;
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope() returning name = %s \n",name.str());

     return name;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration ( SgNode* parent ) const
   {
  // This function generates a name for a class, enum, or typedef (maybe) where the declaration 
  // is not provided a name in the source code.  Examples include:
  //    typedef struct { int state;} my_struct_typedef;
  //    typedef enum { zero_enum_in_typedef } mynumbers_typedef;
  //    class { int x } variable_from_anonymous_class_declaration;
  //    enum { zero_enum_field } mynumbers_enum;
  // Without this feature different classes can be mangled to the same (empty) names.

     ROSE_ASSERT(parent != NULL);

     SgName name;

     switch (parent->variantT())
        {
          case V_SgVariableDeclaration:
             { 
            // SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration should also be true, I think.
               SgVariableDeclaration* declaration = isSgVariableDeclaration(parent);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_variable_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
            // SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration should also be true, I think.
               SgTypedefDeclaration* declaration = isSgTypedefDeclaration(parent);
            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_typedef_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgGlobal:
          case V_SgBasicBlock:
          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how 
            // to assign them unique names.  See the examples for each case below.
            // printf ("Unnamed declaration appears in a scope (instead of another declaration) \n");
               SgScopeStatement* scope = isSgScopeStatement(parent);
               ROSE_ASSERT(scope != NULL);
               name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope(scope);
               break;
             }

          default:
             {
               printf ("Default reached in un-named declaration within parent = %p = %s \n",parent,parent->class_name().c_str());
               get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(parent->get_file_info() != NULL);
               parent->get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(false);
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration() returning name = %s \n",name.str());

     return name;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgDeclarationStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgDeclarationStatement::get_symbol_from_symbol_table() called on base class SgDeclarationStatement this = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
     return NULL;
   }

SgSymbol*
SgDeclarationStatement::search_for_symbol_from_symbol_table() const
   {
     SgDeclarationStatement* declaration = get_declaration_associated_with_symbol();
     if (declaration == NULL)
        {
          printf ("Error: in SgDeclarationStatement::search_for_symbol_from_symbol_table(): declaration == NULL \n");
          printf ("     this = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
        }
     ROSE_ASSERT(declaration != NULL);
     SgSymbol* symbol = declaration->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol != NULL);
     return symbol;
   }

// DQ (7/4/2007): Search for the declaration that would identify the associated symbol
SgDeclarationStatement*
SgDeclarationStatement::get_declaration_associated_with_symbol() const
   {
#if 0
     SgScopeStatement* scope = this->get_scope();
     printf ("In get_declaration_associated_with_symbol(): this = %p = %s = %s scope = %p = %s \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),scope,scope->class_name().c_str());
     printf ("this = %p this->get_firstNondefiningDeclaration() = %p this->get_definingDeclaration() = %p \n",
          this,this->get_firstNondefiningDeclaration(),this->get_definingDeclaration());
     printf ("this->get_symbol_from_symbol_table() = %p this->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() = %p this->get_definingDeclaration()->get_symbol_from_symbol_table() = %p \n",
          this->get_symbol_from_symbol_table(),
          this->get_firstNondefiningDeclaration() != NULL ? this->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table() : NULL,
          this->get_definingDeclaration() != NULL ? this->get_definingDeclaration()->get_symbol_from_symbol_table() : NULL);
#endif

     SgDeclarationStatement* declarationAssociatedWithSymbol = NULL;
     declarationAssociatedWithSymbol = this->get_firstNondefiningDeclaration();

  // Else it used the defining declaration
     if (declarationAssociatedWithSymbol == NULL)
        {
          declarationAssociatedWithSymbol = this->get_definingDeclaration();
       // declarationAssociatedWithSymbol = this->get_firstNondefiningDeclaration();
       // printf ("this->get_firstNondefiningDeclaration() == NULL so use definingDeclaration = %p \n",declarationAssociatedWithSymbol);

       // DQ (6/25/2007): As a special case the friend function in test2005_06.C is defined in the 
       // class and has a forward declaration outside of the class in global scope.  
          if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
             {
            // printf ("Using this->get_definingDeclaration(): declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");

               declarationAssociatedWithSymbol = const_cast<SgDeclarationStatement*>(this);

               if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
                  {
                    printf ("Using original this declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL: declarationAssociatedWithSymbol = %p = %s = %s \n",
                         declarationAssociatedWithSymbol,declarationAssociatedWithSymbol->class_name().c_str(),SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                    SgScopeStatement* scope = declarationAssociatedWithSymbol->get_scope();
                    printf ("declarationAssociatedWithSymbol scope = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                    scope->get_symbol_table()->print("declarationAssociatedWithSymbol");
                  }
               ROSE_ASSERT(declarationAssociatedWithSymbol->get_symbol_from_symbol_table() != NULL);
             }
        }
       else
        {
          ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);
       // printf ("declarationAssociatedWithSymbol != NULL: this = %p = %s \n",declarationAssociatedWithSymbol,this->class_name().c_str());
          if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
             {
            // printf ("declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");

               SgDeclarationStatement* previousDeclarationAssociatedWithSymbol = declarationAssociatedWithSymbol;

               declarationAssociatedWithSymbol = this->get_definingDeclaration();

            // If this is NULL then we should have found the symbol  using the firstNondefiningDeclaration
               if (declarationAssociatedWithSymbol == NULL)
                  {
                 // DQ (6/30/2007): Test if the this pointer has an associqated symbol.
                    printf ("Error: problem this = %p = %s = %s \n",
                         this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
                    ROSE_ASSERT(this->get_symbol_from_symbol_table() == NULL);
                    this->get_startOfConstruct()->display("declarationAssociatedWithSymbol == NULL: debug");

                    this->get_scope()->print_symboltable("declarationAssociatedWithSymbol == NULL");
                  }
            // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);
               if (declarationAssociatedWithSymbol == NULL)
                  {
                    printf ("In SgDeclarationStatement::get_declaration_associated_with_symbol(): declarationAssociatedWithSymbol == NULL no associated symbol for this declaration = %p = %s = %s \n",
                         previousDeclarationAssociatedWithSymbol,previousDeclarationAssociatedWithSymbol->class_name().c_str(),
                         SageInterface::get_name(previousDeclarationAssociatedWithSymbol).c_str());
                  }

               if ( (declarationAssociatedWithSymbol != NULL) && (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL) )
                  {
                    printf ("Error: declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL \n");
                    printf ("     declarationAssociatedWithSymbol = %p = %s = %s \n",
                         declarationAssociatedWithSymbol,
                         declarationAssociatedWithSymbol->class_name().c_str(),
                         SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                  }

               if ( (declarationAssociatedWithSymbol != NULL) && (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL) )
                  {
                    this->get_startOfConstruct()->display("this");
                    declarationAssociatedWithSymbol->get_startOfConstruct()->display("declarationAssociatedWithSymbol");
                    SgTemplateInstantiationDecl* templateInstantiationClassDeclaration = isSgTemplateInstantiationDecl(declarationAssociatedWithSymbol);
                    if (templateInstantiationClassDeclaration != NULL)
                       {
                         SgScopeStatement* scope = templateInstantiationClassDeclaration->get_scope();
                         printf ("templateInstantiationClassDeclaration->get_scope() = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                         ROSE_ASSERT(templateInstantiationClassDeclaration->get_templateDeclaration() != NULL);
                         templateInstantiationClassDeclaration->get_templateDeclaration()->get_startOfConstruct()->display("template");
                         printf ("templateInstantiationClassDeclaration->get_definingDeclaration()         = %p \n",templateInstantiationClassDeclaration->get_definingDeclaration());
                         printf ("templateInstantiationClassDeclaration->get_firstNondefiningDeclaration() = %p \n",templateInstantiationClassDeclaration->get_firstNondefiningDeclaration());
                       }
                  }

            // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);

               if (declarationAssociatedWithSymbol != NULL)
                  {
                    if (declarationAssociatedWithSymbol->get_symbol_from_symbol_table() == NULL)
                       {
                         printf ("declarationAssociatedWithSymbol = %p = %s = %s \n",
                              declarationAssociatedWithSymbol,declarationAssociatedWithSymbol->class_name().c_str(),
                              SageInterface::get_name(declarationAssociatedWithSymbol).c_str());
                         SgScopeStatement* scope = declarationAssociatedWithSymbol->get_scope();
                         printf ("declarationAssociatedWithSymbol scope = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                         scope->get_symbol_table()->print("declarationAssociatedWithSymbol");
                       }
                    ROSE_ASSERT(declarationAssociatedWithSymbol->get_symbol_from_symbol_table() != NULL);
                  }
             }
        }

  // ROSE_ASSERT(declarationAssociatedWithSymbol != NULL);

     return declarationAssociatedWithSymbol;
   }

// DQ (7/22/2007): This should be a member function of SgDeclarationStatement
bool
SgDeclarationStatement::hasAssociatedSymbol() const
   {
     bool returnValue = true;

  // SgFunctionParameterList should likely not even be a declaration, but at least it has 
  // not associated symbol in the symbol table. SgVariableDeclaration contain a list of
  // SgInitializedName objects and those have associated symbols, the SgVariableDeclaration
  // does not have an associated symbol.
     if (isSgFunctionParameterList(this) != NULL || 
         isSgCtorInitializerList(this)   != NULL ||
         isSgPragmaDeclaration(this)     != NULL ||
         isSgVariableDeclaration(this)   != NULL ||
         isSgVariableDefinition(this)    != NULL )
        {
          returnValue = false;
        }

     return returnValue;
   }





// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDeclarationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDeclarationStatement::variantT() const {
  return V_SgDeclarationStatement;
}

#if 0
int
SgDeclarationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DECL_STMT;
   }
#endif

const char*
SgDeclarationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDeclarationStatement";  
   }

std::string
SgDeclarationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgDeclarationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDeclarationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDeclarationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DECL_STMT)
        {
          printf ("Error in SgDeclarationStatement::error(): SgDeclarationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDeclarationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DECL_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDeclarationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDeclarationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDeclarationStatement* isSgDeclarationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDeclarationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDeclarationStatement* isSgDeclarationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDeclarationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDeclarationStatement::~SgDeclarationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgDeclarationStatement::~SgDeclarationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for decl_attributes
     p_decl_attributes = 0; // non list case 
  // case: not a listType for nameOnly
     p_nameOnly = false; // non list case 
  // case: not a listType for forward
     p_forward = false; // non list case 
  // case: not a listType for externBrace
     p_externBrace = false; // non list case 
  // case: not a listType for skipElaborateType
     p_skipElaborateType = false; // non list case 
  // case: not a listType for definingDeclaration
     p_definingDeclaration = NULL; // non list case 
  // case: not a listType for firstNondefiningDeclaration
     p_firstNondefiningDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDeclarationStatement::SgDeclarationStatement ( Sg_File_Info* startOfConstruct )
   : SgStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDeclarationStatement::SgDeclarationStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_decl_attributes = 0;
     p_nameOnly = false;
     p_forward = false;
     p_externBrace = false;
     p_skipElaborateType = false;
     p_definingDeclaration = NULL;
     p_firstNondefiningDeclaration = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgDeclarationStatement() function since it has been problematic
     assert(isSgDeclarationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgVariableDeclaration::get_variables () const
   {
     assert (this != NULL);
     return p_variables;
   }

SgInitializedNamePtrList &
SgVariableDeclaration::get_variables () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_variables;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgVariableDeclaration::get_variableDeclarationContainsBaseTypeDefiningDeclaration () const
   {
     assert (this != NULL);
     return p_variableDeclarationContainsBaseTypeDefiningDeclaration;
   }

void
SgVariableDeclaration::set_variableDeclarationContainsBaseTypeDefiningDeclaration ( bool variableDeclarationContainsBaseTypeDefiningDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = variableDeclarationContainsBaseTypeDefiningDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement::template_specialization_enum 
SgVariableDeclaration::get_specialization () const
   {
     assert (this != NULL);
     return p_specialization;
   }

void
SgVariableDeclaration::set_specialization ( SgDeclarationStatement::template_specialization_enum specialization )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_specialization = specialization;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgVariableDeclaration::get_requiresGlobalNameQualificationOnType () const
   {
     assert (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgVariableDeclaration::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 8845 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgVariableDeclaration::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
#if DEBUG_FIXUP_COPY
     printf ("Inside of SgVariableDeclaration::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Also call the base class version of the fixupCopycopy() member function
     SgDeclarationStatement::fixupCopy(copy,help);

     SgVariableDeclaration* variableDeclaration_copy = isSgVariableDeclaration(copy);
     ROSE_ASSERT(variableDeclaration_copy != NULL);

  // DQ (10/14/2007): Handle the case of a type defined in the base type of the typedef (similar problem for SgVariableDeclaration).
     if (this->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)
        {
          ROSE_ASSERT(variableDeclaration_copy->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true);
          SgDeclarationStatement* baseTypeDeclaration_original = this->get_baseTypeDefiningDeclaration();
          SgDeclarationStatement* baseTypeDeclaration_copy     = variableDeclaration_copy->get_baseTypeDefiningDeclaration();
          ROSE_ASSERT(baseTypeDeclaration_original != NULL);
          ROSE_ASSERT(baseTypeDeclaration_copy != NULL);

          baseTypeDeclaration_original->fixupCopy(baseTypeDeclaration_copy,help);
        }

     const SgInitializedNamePtrList & variableList_original = this->get_variables();
     SgInitializedNamePtrList & variableList_copy           = variableDeclaration_copy->get_variables();

     SgInitializedNamePtrList::const_iterator i_original = variableList_original.begin();
     SgInitializedNamePtrList::iterator i_copy           = variableList_copy.begin();

  // Iterate over both lists to match up the correct pairs of SgInitializedName objects
     while ( (i_original != variableList_original.end()) && (i_copy != variableList_copy.end()) )
        {
          (*i_original)->fixupCopy(*i_copy,help);

          i_original++;
          i_copy++;
        }
   }
#endif


unsigned int
SgVariableDeclaration::cfgIndexForEnd() const {
  return this->get_variables().size();
}

unsigned int
SgVariableDeclaration::cfgFindChildIndex(SgNode* n) {
    vector<SgNode*> succs = this->get_traversalSuccessorContainer();
    size_t idx = std::find(succs.begin(), succs.end(), n) - succs.begin();
    ROSE_ASSERT (idx != succs.size());
    ROSE_ASSERT (idx != 0);
    return idx - 1;
  }

std::vector<VirtualCFG::CFGEdge> SgVariableDeclaration::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == this->get_variables().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  } else if (idx < this->get_variables().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), this->get_variables()[idx]->cfgForBeginning(), result);
  } else ROSE_ASSERT (!"Bad index for SgVariableDeclaration");
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgVariableDeclaration::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == 0) {
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  } else if (idx <= this->get_variables().size()) {
    makeEdge(this->get_variables()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
  } else ROSE_ASSERT (!"Bad index for SgVariableDeclaration");
  return result;
}

SgVariableDeclaration::SgVariableDeclaration(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   : SgDeclarationStatement(info)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (info,var_name,type,initializer);
   }

SgVariableDeclaration::SgVariableDeclaration( const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (NULL,var_name,type,initializer);
   }

void
SgVariableDeclaration::initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
     ROSE_ASSERT (this != NULL);

  // DQ (7/20/2006): Suggested by Peter to so that the initializer will be used.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName c_item(var_name, type, 0, this);
  // SgInitializedName* c_item = new SgInitializedName(var_name, type, NULL, this);
     SgInitializedName* c_item = new SgInitializedName(var_name, type, initializer, this);
     ROSE_ASSERT (c_item != NULL);

  // DQ (10/10/2007): Added fix for Liao, this is required when using the alternative constructors.
  // DQ (10/10/2007): fixed the segmentation fault occurred in liaOutliner for class ::A this__ptr__ 
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = false;

  // DQ(10/10/2007): Added initialization of another data member.
     p_baseTypeDefiningDeclaration = NULL; // non list case 

  // DQ(10/10/2007): Added initialization of another data member.
     p_specialization = SgDeclarationStatement::e_no_specialization;

  // DQ(10/10/2007): Added initialization of another data member.
     p_requiresGlobalNameQualificationOnType = false;

#if PRINT_DEVELOPER_WARNINGS
     printf ("Inside of SgVariableDeclaration::initializeData for constructor taking all parameters c_item = %p = %s \n",c_item,c_item->get_name().str());
#endif

  // DQ (6/8/2006): Need to set parent and scope of internally built variable
     c_item->set_parent(this);
  // c_item->set_scope();
  // ROSE_ASSERT(c_item->get_scope() != NULL);

#if 1
  // PC (7/14/2006): Set initializer's parent, as expected by inliner
  // DQ (7/20/2006): this would be betterhandled by the code calling this 
  // constructor since this is now a side-effect on "initializer".
     if (initializer != NULL)
        {
          initializer->set_parent(c_item);
        }
#endif

  // DQ (11/10/2006): Added support for null file info pointer so that this could could be used by both constructors.
     if (info != NULL)
        {
       // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
          ROSE_ASSERT (copyOfFileInfo != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          copyOfFileInfo->set_parent(c_item);

       // DQ (1/18/2006): Changed name to be consistant with SgNode::get_file_info()
       // c_item->set_fileInfo(copyOfFileInfo);
       // c_item->set_file_info(copyOfFileInfo);
          c_item->set_startOfConstruct(copyOfFileInfo);

        }

  // DQ (12/15/2006): We are using the initializer in both the SgInitializedName and the 
  // SgVariableDefinition.  We have to pass the initializer to append_variable() because
  // the SgVariableDefinition is built there and we we have removed the code below that 
  // used to reset it.  This implementation is better because we don't reset the initializer
  // and the SgVariableDefinition, however that means we have to set it correctly the first time!
  // So we pass the initializer into the append_variable() member function.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item=&(*(this->append_variable(c_item,0)));
  // SgInitializedName *decl_item = *(this->append_variable(c_item,NULL));
     SgInitializedName *decl_item = *(this->append_variable(c_item,initializer));

  // DQ (6/1/2004): Can we enforce this?
     ROSE_ASSERT (decl_item == c_item);

  // DQ (10/6/2004): Adding documentation - this is to support the unparser and is always set to be true (so it seems).
  // A newer mechanism explicitly marks the variable declaration if it contains a class definition which must be output 
  // when unparsing.
  // Older comment: for class-P var, the definition part of class-P won't get printed
     this->setNameOnly();
   }

void
SgVariableDeclaration::post_construction_initialization()
   {
   }

// given a decl_item
SgVariableDefinition*
SgVariableDeclaration::get_definition(SgInitializedName *ditem)
   {
     SgVariableDefinition *defn_stmt = NULL;
     SgInitializedName    *defn_item = NULL;
#if 0
     printf ("In SgVariableDeclaration::get_definition(): ditem = %p \n",ditem);
#endif
     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() && ditem )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
#if 0
          printf ("In SgVariableDeclaration::get_definition(): loop through variables *p = %p \n",*p);
#endif
          if (ditem == (*p))
             {
            // QY 11/2/04 set defn_item = *p
            //  defn_item = (*p)->get_named_item();
               defn_item = (*p);
               break;
             }
          p++;
        }

     if (ditem == NULL)
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // defn_item=(*p).get_named_item();
          ROSE_ASSERT ((*p) != NULL);
       // QY 11/2/04 set defn_item = *p
       //   defn_item=(*p)->get_named_item();
          defn_item = *p;
        }
       else 
        {
          return NULL;
        }
#if 0
     printf ("In SgVariableDeclaration::get_definition(): defn_item = %p \n",defn_item);
#endif

  // if (defn_item)
     if (defn_item != NULL)
        {
#if 0
          printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %p \n",defn_item->get_definition());
          if (defn_item->get_definition() != NULL)
               printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %s \n",defn_item->get_definition()->class_name().c_str());
#endif
       // DQ (9/9/2007): I think we can assert this for any SgInitializedName found in a SgVariableDeclaration, 
       // else perhaps we should have this function return a SgDeclarationStatement instead of a SgVariableDefinition.
          ROSE_ASSERT(defn_item->get_definition() == NULL || isSgVariableDefinition(defn_item->get_definition()) );

          defn_stmt = isSgVariableDefinition(defn_item->get_definition());
       // assert(defn_stmt);
        }

     return defn_stmt;
   }

SgUnsignedLongVal*
SgVariableDeclaration::get_bitfield()
   {
     assert(get_definition() != 0);
     return get_definition()->get_bitfield();
   }

void
SgVariableDeclaration::set_bitfield (SgUnsignedLongVal *bfield)
   {
     assert(get_definition() != 0);
     get_definition()->set_bitfield(bfield);
   }

void
SgVariableDeclaration::setStatic()
   {
     SgDeclarationStatement::setStatic();
  // if it is a static member data

     printf ("Error: SgVariableDeclaration::setStatic() is deprecated \n");

  // SgStatement* parentPointer = get_parent();
     SgStatement* parentPointer = isSgStatement(get_parent());
  // assert(parentPointer != NULL);
     bool isStaticDeclaration = (isSgClassDefinition(parentPointer) != NULL);
     
     if(isStaticDeclaration == true)
          setDeclarationOnly();
  // if(isSgClassDefinition(get_parent())) setDeclarationOnly();
   }

void
SgVariableDeclaration::setExtern() 
   {
     printf ("Error: SgVariableDeclaration::setExtern() is deprecated \n");

     SgDeclarationStatement::setExtern();
     setDeclarationOnly();
   }

int
SgVariableDeclaration::reset_initializer(SgInitializer *initializer)
   {
/*
     SgVariableDefinition *vdefn = get_definition();
     if ( vdefn != NULL )
        { 
          vdefn->set_initializer(initializer); // reset
          return true;
        }
     return false;
*/
    // QY 11/5/04
     if (get_variables().size()) {
        get_variables().front()->set_initializer(initializer);
        return true;
     } 
     return false;
   }

// setForward in class variable declaration
void
SgVariableDeclaration::setDeclarationOnly()
   {
     SgInitializedName *defn_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
        // QY:11/3/04 removed get_named_item
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
       //   defn_item = (*p)->get_named_item();
          defn_item = (*p);
          if (defn_item->get_definition())
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // (*p).set_named_item(NULL);
            //   (*p)->set_named_item(NULL);
              (*p)->set_definition(NULL);
             }
          p++;
        }
     setForward();
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
SgInitializedNamePtrList::iterator
SgVariableDeclaration::append_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     SgInitializedNamePtrList::iterator new_item = insert_variable(get_variables().end(),what);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
     SgInitializedName *decl_item = *new_item;

  // printf ("Inside of SgVariableDeclaration::append_variable what = %p \n",what);
  // printf ("Inside of SgVariableDeclaration::append_variable decl_item = %p \n",decl_item);

  // DQ (6/1/2004): Can we assert this
     ROSE_ASSERT (decl_item == what);

     assert(this != NULL);
     ROSE_ASSERT (what != NULL);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);  
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);  
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

               defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);  
               assert (defn_stmt != NULL);
               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (3/13/2007): We can't enforce that the endOfConstruct is set (if the interface using the startOfConstruct is used.
            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
            // ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               if (this->get_endOfConstruct() != NULL)
                  {
                    Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
                    defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
                    copyOfEndOfConstruct->set_parent(defn_stmt);
                  }
             }
            else
             {
               defn_stmt = new SgVariableDefinition(decl_item,initializer);
             }
        }

     return new_item;
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
SgInitializedNamePtrList::iterator
SgVariableDeclaration::prepend_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     SgInitializedNamePtrList::iterator new_item = insert_variable(get_variables().begin(),what);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
     SgInitializedName *decl_item = *new_item;

  // DQ (6/1/2004): Can we assert this
     ROSE_ASSERT (decl_item == what);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

               defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);  
               assert (defn_stmt != NULL);
               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
               ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
               copyOfEndOfConstruct->set_parent(defn_stmt);
               defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
             }
            else
             {
               defn_stmt = new SgVariableDefinition(decl_item,initializer);
             }
        }
     return new_item;
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
SgInitializedNamePtrList::iterator
SgVariableDeclaration::insert_variable( const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/27/2004): This function contains a side-effect on its input. For now just output a warning message.

     ROSE_ASSERT (what != NULL);
  // if (what->get_declaration()) // set parent() of definition's declaration 
  //     what->get_declaration()->set_parent(this);
  // QY (11/3/04)
     what->set_parent(this);

     SgInitializedNamePtrList::iterator new_item = get_variables().insert(where,what);

  // DQ (6/1/2004): Can we assert this
     ROSE_ASSERT (*new_item == what);

  // this->setNameOnly();
     return new_item;
   }

//QY 11/5/04 not needed any more since removed named_item in SgInitializedName
#if 0
SgInitializedName*
SgVariableDeclaration::get_defn_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item=&(*p);
               decl_item = (*p);
               break;
             }
          p++;
        }

    // QY : 11/2/04 removed p_named_item
     //if (decl_item && decl_item->get_named_item())
     //     return decl_item->get_named_item();
     if (decl_item && decl_item->get_definition())
          return decl_item;
       else
          return NULL;
   }
#endif
 
SgInitializedName*
SgVariableDeclaration::get_decl_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item = &(*p);
               decl_item = *p;
               break;
             }
          p++;
        }
     return decl_item;
   }

SgStatement*
SgVariableDeclaration::get_next(int & n) const
   {
     if (isNameOnly()) return 0;
     if (n == 0)
        {
          n++;
       // special case if type of variable declaration pt to a tag Reference which
       // maybe a statment of some sort
       // only need to worry about first variable's decl
          SgInitializedNamePtrList::const_iterator p = get_variables().begin();

       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // SgType *tmp_type = (*p).get_type();
          ROSE_ASSERT ((*p) != NULL);
          SgType *tmp_type = (*p)->get_type();

          SgNamedType *ntype = isSgNamedType(tmp_type->findBaseType());
          SgDeclarationStatement* declStmt = 
               (ntype) ? ntype->get_declaration() : (SgDeclarationStatement*)0L;
          if ( declStmt && !declStmt->isForward() && 
               (isSgClassDeclaration(declStmt) || isSgEnumDeclaration(declStmt) ) )
             {
               return declStmt;
             } 
            else 
               return 0;
        }
       else
          return 0; 
   }

#if 0
// DQ (7/19/2005): SgVariableDeclaration should have a structural definition of its scope (based on position in 
// source code) while the variables declared should (and do) have a posible different scope (via name qualification).
// DQ (7/4/2005): implement get_scope to query the initialized names in the initialized name list (SgInitializedNamePtrList)
// without this function we evaluate the scope using a traversal of the parents!
SgScopeStatement*
SgVariableDeclaration::get_scope(void) const
   {
  // This function looks at the first SgInitializedName for file the scope which is stored there explicitly
     const SgInitializedNamePtrList & variableList = get_variables();
     ROSE_ASSERT(variableList.size() > 0);
     const SgInitializedName* firstVariable = *(variableList.begin());
     ROSE_ASSERT(firstVariable != NULL);

  // Note that if this function is called before the SgInitializedName's explicitly stored scope is set the result may be NULL
     SgScopeStatement* scope = firstVariable->get_scope();
  // ROSE_ASSERT(scope != NULL);

     return scope;
   }
#endif

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames;
     SgInitializedNamePtrList::const_iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

#if 0
     printf ("In SgVariableDeclaration::get_mangled_name(void): scope = %p = %s scope->get_qualified_name() = %s \n",
          scope,scope->class_name().c_str(),scope->get_qualified_name().str());
#endif

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_declaration_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_variable_declaration_") + variableNames;

     return returnName;
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. If this variable declaration contains the
// definition of its base type, that defining declaration is returned (computed via the type of the first initialized
// name in the list).
SgDeclarationStatement *
SgVariableDeclaration::compute_baseTypeDefiningDeclaration() const
   {
  // DQ (10/17/2007): It is likely that this function could be relaced with just:
  // return p_baseTypeDefiningDeclaration;
  // in the future.

     if (p_variableDeclarationContainsBaseTypeDefiningDeclaration == true)
        {
#if 0
          ROSE_ASSERT(!p_variables.empty());
          SgInitializedName *var = p_variables.front();
          SgNamedType *baseType = isSgNamedType(var->get_type()->findBaseType());
       // GB (09/25/2007): Can we assert this? The flag above seems to tell us that we can.
          ROSE_ASSERT(baseType != NULL);
          return baseType->get_declaration()->get_definingDeclaration();
#else
       // DQ (10/17/2007): Modified to permit the declaration to be stored and accessed so that the AST COPY mechanism 
       // would not have to lookup the declaration through the type (which is a problem becasue types are shared and 
       // so the declaration in the original AST is returned instead of the declaration form the copy of the AST).
          ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);
          return p_baseTypeDefiningDeclaration;
#endif
        }
       else
        {
          ROSE_ASSERT(p_baseTypeDefiningDeclaration == NULL);
          return NULL;
        }
   }

SgDeclarationStatement *
SgVariableDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined 
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }

void
SgVariableDeclaration::set_baseTypeDefiningDeclaration(SgDeclarationStatement* d)
   {
  // DQ (10/17/2007): This is a non ROSETTA generated function so that the get_baseTypeDefiningDeclaration()
  // version can be written to use the compute_baseTypeDefiningDeclaration() member function.  However, we
  // are changing the compute_baseTypeDefiningDeclaration() member function to return the explicitly stored
  // defining declaration in a SgVariableDeclaration (if such a thing is defined).  An example of where this
  // happens is in: "struct { int x; } y;", here the structure declaration is in the variable declaration for "y".

     ROSE_ASSERT(d != NULL);

     p_baseTypeDefiningDeclaration = d;
     ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);

  // Mark the p_variableDeclarationContainsBaseTypeDefiningDeclaration as true so that the p_baseTypeDefiningDeclaration
  // declaration will be used (by compute_baseTypeDefiningDeclaration()).
     set_variableDeclarationContainsBaseTypeDefiningDeclaration(true);
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 6235 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


bool
SgVariableDeclaration::isSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_specialization);
     return returnValue;
   }

bool
SgVariableDeclaration::isPartialSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_partial_specialization);
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVariableDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVariableDeclaration::variantT() const {
  return V_SgVariableDeclaration;
}

#if 0
int
SgVariableDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VAR_DECL_STMT;
   }
#endif

const char*
SgVariableDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVariableDeclaration";  
   }

std::string
SgVariableDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgVariableDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVariableDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVariableDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VAR_DECL_STMT)
        {
          printf ("Error in SgVariableDeclaration::error(): SgVariableDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVariableDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VAR_DECL_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVariableDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVariableDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return VAR_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVariableDeclaration* isSgVariableDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVariableDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVariableDeclaration* isSgVariableDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVariableDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVariableDeclaration::~SgVariableDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgVariableDeclaration::~SgVariableDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for baseTypeDefiningDeclaration
     p_baseTypeDefiningDeclaration = NULL; // non list case 
  // case: not a listType for variableDeclarationContainsBaseTypeDefiningDeclaration
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = false; // non list case 
  // case: not a listType for specialization
     p_specialization = SgDeclarationStatement::e_no_specialization; // non list case 
  // case: not a listType for requiresGlobalNameQualificationOnType
     p_requiresGlobalNameQualificationOnType = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVariableDeclaration::SgVariableDeclaration ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVariableDeclaration::SgVariableDeclaration (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_baseTypeDefiningDeclaration = NULL;
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = false;
     p_specialization = SgDeclarationStatement::e_no_specialization;
     p_requiresGlobalNameQualificationOnType = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VAR_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgVariableDeclaration() function since it has been problematic
     assert(isSgVariableDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgVariableDefinition::get_vardefn () const
   {
     assert (this != NULL);
     return p_vardefn;
   }

void
SgVariableDefinition::set_vardefn ( SgInitializedName* vardefn )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_vardefn != NULL && vardefn != NULL && p_vardefn != vardefn)
        {
          printf ("Warning: vardefn = %p overwriting valid pointer p_vardefn = %p \n",vardefn,p_vardefn);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_vardefn != NULL && vardefn != NULL && p_vardefn != vardefn) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_vardefn = vardefn;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgUnsignedLongVal* 
SgVariableDefinition::get_bitfield () const
   {
     assert (this != NULL);
     return p_bitfield;
   }

void
SgVariableDefinition::set_bitfield ( SgUnsignedLongVal* bitfield )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_bitfield != NULL && bitfield != NULL && p_bitfield != bitfield)
        {
          printf ("Warning: bitfield = %p overwriting valid pointer p_bitfield = %p \n",bitfield,p_bitfield);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_bitfield != NULL && bitfield != NULL && p_bitfield != bitfield) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_bitfield = bitfield;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 9535 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgVariableDefinition::post_construction_initialization()
   {
   }

SgVariableDeclaration*
SgVariableDefinition::get_declaration()
   {
     assert(get_vardefn() != NULL);

     SgVariableDeclaration *rdecl = isSgVariableDeclaration(get_vardefn()->get_declaration());
     return rdecl;
   }

SgVariableDefinition::
SgVariableDefinition(Sg_File_Info *info, SgInitializedName *decl_item, SgInitializer *initializer)
   : SgDeclarationStatement(info),
  // DQ (11/20/2004): Reordered pre-initialization list to avoid compiler warnings.
  // p_initializer_expr_root(new SgExpressionRoot(initializer == 0?New_File_Info(this) : new Sg_File_Info(*initializer->get_file_info()), initializer)),
  // QY:11/2/04 remove redundant coupled SgInitialized nodes. 
  // p_vardefn ( new SgInitializedName(decl_item->get_name(),NULL,initializer,this,NULL,NULL))
     p_vardefn(decl_item),
     p_bitfield(0)

   {
  // In many places this constructor is called (via the new operator) with the resulting
  // pointer returned by operator::new UNUSED.  The reason why this works is because the
  // call to "set_parent()" at the base of the constructor attaches this object to the
  // program tree (I think this is inelegant (since it is the only class that works this
  // way in SAGE), but I will leave it as is for now).

     ROSE_ASSERT(decl_item != NULL);

#if 0
  // DQ (10/29/2006): This only resets the file info in the SgInitilaizedName object (a memory 
  // leak at least if it were not also an error, since now we set the source position more 
  // precisely and this overwrites the correct value!)

  // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
     Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
     ROSE_ASSERT (copyOfFileInfo != NULL);

  // DQ (1/18/2006): Changed name to be consistant with SgNode::get_file_info()
  // get_vardefn()->set_fileInfo(copyOfFileInfo);
     get_vardefn()->set_file_info(copyOfFileInfo);

  // This should be NULL to to avoid a cycle (set to NULL in call to constructor, above)
  //   ROSE_ASSERT (get_vardefn()->get_itemptr() == NULL);

  // printf ("In SgVariableDefinition constructor: defn_item = %p \n",defn_item);
#endif

  // QY:11/2/04    do not create a new  SgInitialized name. set p_vardefn = decl_item, then set the initializer in decl_item instead
  // This resets the itemptr pointer in the declaration to the SgInitializedName object
  //   decl_item->set_named_item(get_vardefn());
      set_parent(decl_item);
      get_vardefn()->set_initializer(initializer);
      get_vardefn()->set_definition(this);

  // Sage 2 includes this code (the body of post_construction_initialization()
  // instead of calling post_construction_initialization() directly) (?)
     ROSE_ASSERT(decl_item != NULL);
     //ROSE_ASSERT(decl_item->get_declaration() != NULL);
     //ROSE_ASSERT(isSgVariableDeclaration(decl_item->get_declaration()) != NULL);
   }

SgVariableDefinition::
SgVariableDefinition( SgInitializedName *decl_item, SgInitializer *initializer)
   : p_vardefn(decl_item),
     p_bitfield(0)
   {
  // DQ (11/10/2006): This is a version of the constructor that is separated from the source position initalization.
     ROSE_ASSERT(decl_item != NULL);

     set_parent(decl_item);
     get_vardefn()->set_initializer(initializer);
     get_vardefn()->set_definition(this);

     ROSE_ASSERT(decl_item != NULL);
   }

SgType*
SgVariableDefinition::get_type()
   {
     return get_vardefn()->get_type();
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDefinition::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVariableDefinition::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVariableDefinition::variantT() const {
  return V_SgVariableDefinition;
}

#if 0
int
SgVariableDefinition::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VAR_DEFN_STMT;
   }
#endif

const char*
SgVariableDefinition::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVariableDefinition";  
   }

std::string
SgVariableDefinition::class_name() const
   {
     assert(this != NULL);
     return "SgVariableDefinition";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVariableDefinition::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVariableDefinition::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VAR_DEFN_STMT)
        {
          printf ("Error in SgVariableDefinition::error(): SgVariableDefinition object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVariableDefinition::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VAR_DEFN_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVariableDefinition::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVariableDefinition::variant() const \n");
#endif
     assert(this != NULL);
     return VAR_DEFN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVariableDefinition* isSgVariableDefinition ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVariableDefinition*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVariableDefinition* isSgVariableDefinition ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVariableDefinition*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVariableDefinition::~SgVariableDefinition ()
   {
#if 0
  // debugging information!
     printf ("In SgVariableDefinition::~SgVariableDefinition (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for vardefn
     p_vardefn = NULL; // non list case 
  // case: not a listType for bitfield
     p_bitfield = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVariableDefinition::SgVariableDefinition ( Sg_File_Info* startOfConstruct, SgInitializedName* vardefn, SgUnsignedLongVal* bitfield )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVariableDefinition::SgVariableDefinition (Sg_File_Info* startOfConstruct, SgInitializedName* vardefn, SgUnsignedLongVal* bitfield) sage_class_name() = %s \n",sage_class_name());
#endif

     p_vardefn = vardefn;
     p_bitfield = bitfield;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VAR_DEFN_STMT == variant());
     post_construction_initialization();

  // Test the isSgVariableDefinition() function since it has been problematic
     assert(isSgVariableDefinition(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgEnumDeclaration::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgEnumDeclaration::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgEnumDeclaration::get_embedded () const
   {
     assert (this != NULL);
     return p_embedded;
   }

void
SgEnumDeclaration::set_embedded ( bool embedded )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_embedded = embedded;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgEnumType* 
SgEnumDeclaration::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgEnumDeclaration::set_type ( SgEnumType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgEnumDeclaration::get_enumerators () const
   {
     assert (this != NULL);
     return p_enumerators;
   }

SgInitializedNamePtrList &
SgEnumDeclaration::get_enumerators () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_enumerators;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgEnumDeclaration::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgEnumDeclaration::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgEnumDeclaration::get_isUnNamed () const
   {
     assert (this != NULL);
     return p_isUnNamed;
   }

void
SgEnumDeclaration::set_isUnNamed ( bool isUnNamed )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_isUnNamed = isUnNamed;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10469 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgEnumDeclaration::cfgIndexForEnd() const {
  return 0;
}

std::vector<VirtualCFG::CFGEdge> SgEnumDeclaration::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgEnumDeclaration::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}

void
SgEnumDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This should be conditional upon if the SgType was provided 
  // in the constructor argument list (as in SgClassDeclaration).
  // set_type(SgEnumType::createType(this));
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgEnumDeclaration::post_construction_initialization(): setting the SgEnumType type internally (using the declaration) \n");
#endif
#endif
          set_type(SgEnumType::createType(this));
        }
   }

SgInitializedNamePtrList::iterator
// SgEnumDeclaration::append_enumerator(const SgInitializedName & what)
SgEnumDeclaration::append_enumerator( SgInitializedName* what)
   {
     return insert_enumerator(get_enumerators().end(),what);
   }

SgInitializedNamePtrList::iterator
// SgEnumDeclaration::prepend_enumerator(const SgInitializedName & what)
SgEnumDeclaration::prepend_enumerator( SgInitializedName* what)
   {
     return insert_enumerator(get_enumerators().begin(),what);
   }

SgInitializedNamePtrList::iterator
// SgEnumDeclaration::insert_enumerator(const SgInitializedNamePtrList::iterator& where, const SgInitializedName & what) 
SgEnumDeclaration::insert_enumerator(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what) 
   {
  // DQ (9/27/2004): This function appears to have a side-effect on its input, not clear if this is appropriate.
     SgInitializedNamePtrList::iterator new_item = get_enumerators().insert(where,what);
     (*new_item)->set_parent(this);
     return new_item;
   }

SgName
SgEnumDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgEnumDeclaration::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgEnumDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for enum declarations.
SgName
SgEnumDeclaration::get_mangled_name (void) const
   {
#if 0
     SgName mangled_name;
     SgName name = get_name();

#if 1
  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an 
  // printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

  // If this was originally a un-named enum then the astPostProcessing/fixupNames.C updated the name to reflect
  // a compiler generated tag name that could be references (and would be required) when multiple variables
  // might be used and the normalization of the AST (EDG) is done to reflect the separation into indivual 
  // variable declarations.  This was a bug fix in response to a bug report from IBM (Fall 2006).
  // However the compiler generated names are inappropriate for the AST merge since they are not unique 
  // (by design) and so they don't share properly.  So we now detect the ROSE compiler generated name
  // and proceed as though the enum had never need assigneda tag and generate a unique name that will
  // match appropriately to allow sharing (when ODR is not violated).  Basicaly we use the compiler generated
  // name to trigger this mechanism which used to be triggered when no name was available (specifically when
  // case: name.is_null() == true).
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_enum_tag_name_") != std::string::npos);

  // DQ (3/10/2007): If the enum is un-named in a typedef (as the base type) then it should not be given another name by ROSE.
  // This is because the declaration can only be refered to once (handling multiple references is why we sometimes have to
  // provide a generated name (e.g. a variable declaration which has multiple variables).
  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (8/20/2006): This will be a valid name for all C++ programs, but not for C programs (see Cxx_tests/math.C).
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     if (specialCaseNameHandling == true)
        {
       // DQ (8/20/2006): Using the parent can cause endless recursion for the code "typedef enum { enum_field } enum_typedef_type;"
       // so we have to assemble a unique name without resorting to the parent.
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
       // It the enum is unnamed then use the name of the first enum field (since it can't be redefied in the same scope, it is unique)
       // printf ("Using the parent of the enum to generate a name: parent = %p = %s \n",parent,parent->class_name().c_str());
       // This should be true for C but maybe not for C++!
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
          const SgInitializedNamePtrList & fieldList = p_enumerators;
       // printf ("In SgEnumDeclaration::get_mangled_name(): fieldList.size() = %ld \n",fieldList.size());
       // ROSE_ASSERT(fieldList.empty() == false);
          if (fieldList.empty() == true)
             {
               printf ("WARNING in SgEnumDeclaration::get_mangled_name(): fieldList.empty() == true \n");
             }
          SgInitializedNamePtrList::const_iterator i = fieldList.begin();
          name = "__unnamed_enum__";
          while(i != fieldList.end())
             {
               name += (*i)->get_name();
               i++;
               if (i != fieldList.end())
                  {
                    name += "__COMMA__";
                  }
             }
        }

  // DQ (3/10/2007): Modified to let this pass. mangled names for enums would not be
  // used in so critial a situation as class declarations which are more complex.
  // ROSE_ASSERT(name.is_null() == false);
     mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
     if (name.get_length () == 0) // Is an anonymous enum in C
          mangled_name = SgName ("i"); // Treat like an integer
       else // Return a fully qualified mangled type name
          mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#endif

     return mangled_name;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgEnumDeclaration* declaration = const_cast<SgEnumDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgEnumDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
       // DQ (5/11/2007): If this is an enum type in a function definition then the mangled name for the type will
       // atempt to include the mangled name of the function definition (the scope of the function parameter) which
       // will cause infinit recursion in the evaluation of the mangled name of the function declaration which must 
       // include the function parameter, and so on.  However, this only appears to be a problem for C and not C++.
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

          static int counter = 0;
          counter++;
          ROSE_ASSERT(counter < 10);
#endif

          string mangleQualifiersString;
          if (isSgFunctionDefinition(get_scope()) != NULL)
             {
            // printf ("This is a parameter to a function and will cause infinite recursion in its evaluation \n");
               mangleQualifiersString = "_function_parameter_";
             }
            else
             {
               mangleQualifiersString = mangleQualifiers(get_scope());
             }

       // SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());
          SgName mangledName = joinMangledQualifiers (mangleQualifiersString,get_name());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgEnumDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

bool
SgEnumDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgEnumDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
  // DQ (5/30/2007): We might want to look for either the symbol for the defining or the non-defining declaration.
  // SgSymbol* returnSymbol = get_scope()->get_symbol_table()->find(this);
     SgSymbol* returnSymbol = NULL;
     if (returnSymbol == NULL)
        {
       // The symbol appears to be typically associated with the defining declaration (perhaps because forward enums are non-standard).  
       // Though it might be that we should treat enums uniformally with other declarations now that we have recently added forward 
       // enum declarations as a supported non-standard feature (because most frontends do (except for GNU curiously enough)).
          if (this->get_definingDeclaration() != NULL)
             {
               returnSymbol = get_scope()->get_symbol_table()->find(this->get_definingDeclaration());
             }
            else
             {
               if (this->get_firstNondefiningDeclaration() != NULL)
                  {
                    returnSymbol = get_scope()->get_symbol_table()->find(this->get_firstNondefiningDeclaration());
                  }
                 else
                  {
                 // This is an error!
                    ROSE_ASSERT(false);
                  }
             }          
        }

     return returnSymbol;
#else
  // DQ (5/31/2007): This is the version that we want, it is consistant with the implementation elsewhere
  // and the correct fix was to handle the case where this is NULL (in src/frontend/SageIII/astMerge/collectAssocitateNodes.C).
     return get_scope()->get_symbol_table()->find(this);
#endif
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEnumDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEnumDeclaration::variantT() const {
  return V_SgEnumDeclaration;
}

#if 0
int
SgEnumDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ENUM_DECL_STMT;
   }
#endif

const char*
SgEnumDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEnumDeclaration";  
   }

std::string
SgEnumDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgEnumDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEnumDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEnumDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ENUM_DECL_STMT)
        {
          printf ("Error in SgEnumDeclaration::error(): SgEnumDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEnumDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ENUM_DECL_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEnumDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEnumDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return ENUM_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEnumDeclaration* isSgEnumDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEnumDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEnumDeclaration* isSgEnumDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEnumDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEnumDeclaration::~SgEnumDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgEnumDeclaration::~SgEnumDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for embedded
     p_embedded =false; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for isUnNamed
     p_isUnNamed = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEnumDeclaration::SgEnumDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgEnumType* type )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgEnumDeclaration::SgEnumDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgEnumType* type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_embedded =false;
     p_type = type;
     p_scope = NULL;
     p_isUnNamed = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ENUM_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgEnumDeclaration() function since it has been problematic
     assert(isSgEnumDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 11900 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgAsmStmt::post_construction_initialization()
   {}

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgAsmStmt::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // This is a poor way to handle the generation of unique strings (it also 
  // connects the unparser to the fronend handling which is not a great idea).
  // returnName = get_expr_root()->unparseToString();

  // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
     SgExpressionPtrList::const_iterator i = p_operands.begin();
     while (i != p_operands.end())
        {
          returnName += (*i)->get_type()->get_mangled();
          i++;
        }

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgAsmStmt* declaration = const_cast<SgAsmStmt*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgAsmStmt*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // This is a poor way to handle the generation of unique strings (it also 
       // connects the unparser to the fronend handling which is not a great idea).
       // returnName = get_expr_root()->unparseToString();

       // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
          SgExpressionPtrList::const_iterator i = p_operands.begin();
          while (i != p_operands.end())
             {
               mangledName += (*i)->get_type()->get_mangled();
               i++;
             }

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgAsmStmt*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (7/22/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgExpressionPtrList &
SgAsmStmt::get_operands()
   { return p_operands; }

const SgExpressionPtrList &
SgAsmStmt::get_operands() const
   { return p_operands; }

// DQ (7/27/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList()
   { return p_clobberRegisterList; }

const SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList() const
   { return p_clobberRegisterList; }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAsmStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAsmStmt::variantT() const {
  return V_SgAsmStmt;
}

#if 0
int
SgAsmStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ASM_STMT;
   }
#endif

const char*
SgAsmStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAsmStmt";  
   }

std::string
SgAsmStmt::class_name() const
   {
     assert(this != NULL);
     return "SgAsmStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAsmStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAsmStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ASM_STMT)
        {
          printf ("Error in SgAsmStmt::error(): SgAsmStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAsmStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ASM_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAsmStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAsmStmt::variant() const \n");
#endif
     assert(this != NULL);
     return ASM_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAsmStmt* isSgAsmStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAsmStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAsmStmt* isSgAsmStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAsmStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAsmStmt::~SgAsmStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgAsmStmt::~SgAsmStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAsmStmt::SgAsmStmt ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAsmStmt::SgAsmStmt (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ASM_STMT == variant());
     post_construction_initialization();

  // Test the isSgAsmStmt() function since it has been problematic
     assert(isSgAsmStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTypedefDeclaration::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgTypedefDeclaration::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgTypedefDeclaration::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgTypedefDeclaration::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypedefType* 
SgTypedefDeclaration::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgTypedefDeclaration::set_type ( SgTypedefType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgTypedefDeclaration::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgTypedefDeclaration::set_declaration ( SgDeclarationStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgSymbol* 
SgTypedefDeclaration::get_parent_scope () const
   {
     assert (this != NULL);
     return p_parent_scope;
   }

void
SgTypedefDeclaration::set_parent_scope ( SgSymbol* parent_scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_parent_scope != NULL && parent_scope != NULL && p_parent_scope != parent_scope)
        {
          printf ("Warning: parent_scope = %p overwriting valid pointer p_parent_scope = %p \n",parent_scope,p_parent_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_parent_scope != NULL && parent_scope != NULL && p_parent_scope != parent_scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_parent_scope = parent_scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTypedefDeclaration::get_typedefBaseTypeContainsDefiningDeclaration () const
   {
     assert (this != NULL);
     return p_typedefBaseTypeContainsDefiningDeclaration;
   }

void
SgTypedefDeclaration::set_typedefBaseTypeContainsDefiningDeclaration ( bool typedefBaseTypeContainsDefiningDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_typedefBaseTypeContainsDefiningDeclaration = typedefBaseTypeContainsDefiningDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgTypedefDeclaration::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgTypedefDeclaration::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTypedefDeclaration::get_requiresGlobalNameQualificationOnType () const
   {
     assert (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgTypedefDeclaration::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12013 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/14/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgTypedefDeclaration::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgTypedefDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgTypedefDeclaration::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Call the base class fixupCopy member function
     SgDeclarationStatement::fixupCopy(copy,help);

     SgTypedefDeclaration* typedefDeclaration_copy = isSgTypedefDeclaration(copy);
     ROSE_ASSERT(typedefDeclaration_copy != NULL);

  // DQ (10/14/2007): Handle the case of a type defined in the base type of the typedef (similar problem for SgVariableDeclaration).
     if (this->get_typedefBaseTypeContainsDefiningDeclaration() == true)
        {
          ROSE_ASSERT(typedefDeclaration_copy->get_typedefBaseTypeContainsDefiningDeclaration() == true);
          SgDeclarationStatement* baseTypeDeclaration_original = this->get_baseTypeDefiningDeclaration();
          SgDeclarationStatement* baseTypeDeclaration_copy     = typedefDeclaration_copy->get_baseTypeDefiningDeclaration();
          ROSE_ASSERT(baseTypeDeclaration_original != NULL);
          ROSE_ASSERT(baseTypeDeclaration_copy != NULL);

          baseTypeDeclaration_original->fixupCopy(baseTypeDeclaration_copy,help);
        }

  // If this is a defining declaration then there should also be a nondefining declaration.
     if (this == this->get_definingDeclaration())
        {
       // This is the defining class declaration, we want to build a non-defiing declaration to go with this.
       // Let the copying of the defining declaration trigger the construction of a non-defining declaration.

          printf ("This is the defining declaration, so build a copy of the nondefining SgTypedefDeclaration declaration! \n");
#if 0
       // SgClassDeclaration* firstNondefiningDeclaration = this->copy(help);
          SgClassDeclaration* firstNondefiningDeclaration_original = isSgTypedefDeclaration(this->get_firstNondefiningDeclaration());
          ROSE_ASSERT(firstNondefiningDeclaration_original != NULL);
          SgClassDeclaration* firstNondefiningDeclaration_copy     = isSgTypedefDeclaration(firstNondefiningDeclaration_original->copy(help));
#else
          SgTypedefDeclaration* firstNondefiningDeclaration_copy = new SgTypedefDeclaration(this->get_name(),this->get_base_type(),this->get_type(),NULL,NULL);

       // Details that have to be set when building a SgClassDeclaration IR node.

          printf ("***** Setting the scope in the firstNondefiningDeclaration_copy = %p \n",firstNondefiningDeclaration_copy);
          ROSE_ASSERT(typedefDeclaration_copy->get_scope() != NULL);
          firstNondefiningDeclaration_copy->set_scope(typedefDeclaration_copy->get_scope());

          printf ("***** Setting the parent in the firstNondefiningDeclaration_copy = %p \n",firstNondefiningDeclaration_copy);
          ROSE_ASSERT(typedefDeclaration_copy->get_parent() != NULL);
          firstNondefiningDeclaration_copy->set_parent(typedefDeclaration_copy->get_parent());

          firstNondefiningDeclaration_copy->setForward();
          firstNondefiningDeclaration_copy->set_definingDeclaration(typedefDeclaration_copy);

          SgTypedefDeclaration* firstNondefiningDeclaration_original = isSgTypedefDeclaration(this->get_firstNondefiningDeclaration());

          firstNondefiningDeclaration_copy->set_startOfConstruct( new Sg_File_Info( *(firstNondefiningDeclaration_original->get_startOfConstruct()) ) );
          firstNondefiningDeclaration_copy->set_endOfConstruct( new Sg_File_Info( *(firstNondefiningDeclaration_original->get_endOfConstruct()) ) );

       // If the original firstNondefiningDeclaration points to itself as the firstNondefiningDeclaration then set the copy to point to itself as well.
          ROSE_ASSERT(firstNondefiningDeclaration_original != NULL);
          if (firstNondefiningDeclaration_original == firstNondefiningDeclaration_original->get_firstNondefiningDeclaration())
             {
               firstNondefiningDeclaration_copy->set_firstNondefiningDeclaration(firstNondefiningDeclaration_copy);
             }
#endif
          ROSE_ASSERT(firstNondefiningDeclaration_copy != NULL);
          typedefDeclaration_copy->set_firstNondefiningDeclaration(firstNondefiningDeclaration_copy);
        }
   }
#endif

unsigned int
SgTypedefDeclaration::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgTypedefDeclaration::cfgOutEdges(unsigned int idx)
   {
     ROSE_ASSERT (idx == 0);
     std::vector<VirtualCFG::CFGEdge> result;
     makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgTypedefDeclaration::cfgInEdges(unsigned int idx)
   {
     ROSE_ASSERT (idx == 0);
     std::vector<VirtualCFG::CFGEdge> result;
     makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
     return result;
   }

void
SgTypedefDeclaration::post_construction_initialization()
   {
  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in 
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if 0
#if PRINT_DEVELOPER_WARNINGS
     printf ("In SgTypedefDeclaration::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
#endif
     set_type(SgTypedefType::createType(this));

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
   }

// SgStatement *get_next(int&) const;

bool
SgTypedefDeclaration::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_declaration, target, newstmt) == true );
   }

#if 0
SgStatement*
SgTypedefDeclaration::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_declaration();
        }
   }
#endif

SgName
SgTypedefDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgTypedefDeclaration::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgTypedefDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// RV (1/30/2006): Revised to follow typedef chains to their base types.
SgName
SgTypedefDeclaration::get_mangled_name (void) const
   {
#if 0
  // Ask for a mangled name from the base type
     SgType* baseType = get_base_type();
     SgName mangledName;
#if 0
     if (baseType)
        {
          mangledName = baseType->get_mangled();
        }

  // When no name is available, use the qualified typedef name.
  // Example: 'namespace N { typedef struct { int a; } foo_t; }'
  // becomes the mangled form of 'N::foo_t'.
     if (mangledName.is_null() == true)
          mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#else
  // DQ (6/3/2006): I think this is a better implementation of name mangling for a typedef 
  // (need to include the name and the type) but I'm not clear if we want the scope.
     ROSE_ASSERT(baseType != NULL);
     mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name()) + baseType->get_mangled();

  // DQ (1/29/2007): We need to make this more specific to this IR nodes so that a typedef of an unnamed struct does not be mangled to be the same name
     mangledName += "__typedef_declaration";
#endif

  // printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
    
     ROSE_ASSERT (mangledName.get_length () > 0);
     return mangledName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTypedefDeclaration* declaration = const_cast<SgTypedefDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTypedefDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

          SgType* baseType = get_base_type();

       // DQ (6/3/2006): I think this is a better implementation of name mangling for a typedef 
       // (need to include the name and the type) but I'm not clear if we want the scope.
          ROSE_ASSERT(baseType != NULL);
          mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name()) + baseType->get_mangled();

       // DQ (1/29/2007): We need to make this more specific to this IR nodes so that a typedef of an unnamed struct does not be mangled to be the same name
          mangledName += "__typedef_declaration";

       // printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
    
          ROSE_ASSERT (mangledName.get_length () > 0);

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTypedefDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

bool
SgTypedefDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTypedefDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. It returns the p_declaration data member,
// but only if this typedef statement is actually the place where the base type is defined.
SgDeclarationStatement *
SgTypedefDeclaration::compute_baseTypeDefiningDeclaration() const
   {
     if (p_typedefBaseTypeContainsDefiningDeclaration == true)
        {
          return p_declaration;
        }
     else
        {
          return NULL;
        }
   }

SgDeclarationStatement *
SgTypedefDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined 
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypedefDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypedefDeclaration::variantT() const {
  return V_SgTypedefDeclaration;
}

#if 0
int
SgTypedefDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TYPEDEF_STMT;
   }
#endif

const char*
SgTypedefDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypedefDeclaration";  
   }

std::string
SgTypedefDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgTypedefDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypedefDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypedefDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TYPEDEF_STMT)
        {
          printf ("Error in SgTypedefDeclaration::error(): SgTypedefDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypedefDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TYPEDEF_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypedefDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypedefDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return TYPEDEF_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypedefDeclaration* isSgTypedefDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypedefDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypedefDeclaration* isSgTypedefDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypedefDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypedefDeclaration::~SgTypedefDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgTypedefDeclaration::~SgTypedefDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for base_type
     p_base_type = NULL; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for declaration
     p_declaration = NULL; // non list case 
  // case: not a listType for parent_scope
     p_parent_scope = NULL; // non list case 
  // case: not a listType for typedefBaseTypeContainsDefiningDeclaration
     p_typedefBaseTypeContainsDefiningDeclaration = false; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for requiresGlobalNameQualificationOnType
     p_requiresGlobalNameQualificationOnType = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypedefDeclaration::SgTypedefDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgType* base_type, SgTypedefType* type, SgDeclarationStatement* declaration, SgSymbol* parent_scope )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTypedefDeclaration::SgTypedefDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgType* base_type, SgTypedefType* type, SgDeclarationStatement* declaration, SgSymbol* parent_scope) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_base_type = base_type;
     p_type = type;
     p_declaration = declaration;
     p_parent_scope = parent_scope;
     p_typedefBaseTypeContainsDefiningDeclaration = false;
     p_scope = NULL;
     p_requiresGlobalNameQualificationOnType = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TYPEDEF_STMT == variant());
     post_construction_initialization();

  // Test the isSgTypedefDeclaration() function since it has been problematic
     assert(isSgTypedefDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateDeclaration::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgTemplateDeclaration::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateDeclaration::get_string () const
   {
     assert (this != NULL);
     return p_string;
   }

void
SgTemplateDeclaration::set_string ( SgName string )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_string = string;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration::template_type_enum 
SgTemplateDeclaration::get_template_kind () const
   {
     assert (this != NULL);
     return p_template_kind;
   }

void
SgTemplateDeclaration::set_template_kind ( SgTemplateDeclaration::template_type_enum template_kind )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_template_kind = template_kind;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateParameterPtrListPtr 
SgTemplateDeclaration::get_templateParameters () const
   {
     assert (this != NULL);
     return p_templateParameters;
   }

void
SgTemplateDeclaration::set_templateParameters ( SgTemplateParameterPtrListPtr templateParameters )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateParameters = templateParameters;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgTemplateDeclaration::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgTemplateDeclaration::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12299 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgTemplateDeclaration::post_construction_initialization()
   {
   }

// DQ (9/8/2004): added support for qualified names
SgName
SgTemplateDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistant other get_qualified_name functions
  // It previously only returned the name of the scope.
#if 0
  // printf ("In SgTemplateDeclaration::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;
     string returnNameString;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (9/8/2004): Don't use the template name as is stored (which is a mangled name from EDG)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = scope->get_qualified_name();
  // printf ("In SgTemplateDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#else
  // printf ("In SgTemplateDeclaration::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgTemplateDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }

bool
SgTemplateDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateDeclaration::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = get_qualified_name() + SgName("_template_declaration_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_template_declaration_") + get_name();

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateDeclaration* declaration = const_cast<SgTemplateDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = get_scope()->get_mangled_name() + SgName("_template_declaration_") + get_name();

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateDeclaration::variantT() const {
  return V_SgTemplateDeclaration;
}

#if 0
int
SgTemplateDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_DECL_STMT;
   }
#endif

const char*
SgTemplateDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateDeclaration";  
   }

std::string
SgTemplateDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_DECL_STMT)
        {
          printf ("Error in SgTemplateDeclaration::error(): SgTemplateDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_DECL_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateDeclaration* isSgTemplateDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateDeclaration* isSgTemplateDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateDeclaration::~SgTemplateDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateDeclaration::~SgTemplateDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for string
     p_string = ""; // non list case 
  // case: not a listType for template_kind
     p_template_kind = SgTemplateDeclaration::e_template_none; // non list case 
  // case: listType for templateParameters
  // case: listType (typeIsPointerToList == true) for templateParameters
     p_templateParameters = NULL;
  // case: not a listType for scope
     p_scope = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateDeclaration::SgTemplateDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgName string, SgTemplateDeclaration::template_type_enum template_kind, SgTemplateParameterPtrListPtr templateParameters )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTemplateDeclaration::SgTemplateDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgName string, SgTemplateDeclaration::template_type_enum template_kind, SgTemplateParameterPtrListPtr templateParameters) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_string = string;
     p_template_kind = template_kind;
     p_templateParameters = templateParameters;
     p_scope = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateDeclaration() function since it has been problematic
     assert(isSgTemplateDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgTemplateInstantiationDirectiveStatement::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgTemplateInstantiationDirectiveStatement::set_declaration ( SgDeclarationStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12768 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/15/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgTemplateInstantiationDirectiveStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgVariableDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgTemplateInstantiationDirectiveStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

     SgTemplateInstantiationDirectiveStatement* templateInstantiationDirectiveStatement_copy = isSgTemplateInstantiationDirectiveStatement(copy);

  // Call the base class fixupCopy member function
     SgDeclarationStatement::fixupCopy(copy,help);

     ROSE_ASSERT(this->get_declaration() != NULL);

  // DQ (10/15/2007): This is a simpler approach using the map stored in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(this->get_declaration());
     if (i != help.get_copiedNodeMap().end())
        {
       // Use the associated value from the map as the scope.
          SgNode* node_copy = i->second;
          ROSE_ASSERT(node_copy != NULL);
          SgDeclarationStatement* declarationStatement_copy = isSgDeclarationStatement(node_copy);
          templateInstantiationDirectiveStatement_copy->set_declaration(declarationStatement_copy);
        }
       else
        {
       // Else set the scope in the copyDeclarationStatement to be the same as this->get_scope()
       // printf ("In SgTemplateInstantiationDirectiveStatement::fixupCopy() this = %p = %s this->get_parent() = %p = %s \n",
       //      this,this->class_name().c_str(),this->get_declaration(),this->get_declaration()->class_name().c_str());
          templateInstantiationDirectiveStatement_copy->set_declaration(this->get_declaration());
        }
   }
#endif

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateInstantiationDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgTemplateInstantiationDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateInstantiationDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateInstantiationDirectiveStatement::variantT() const {
  return V_SgTemplateInstantiationDirectiveStatement;
}

#if 0
int
SgTemplateInstantiationDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_INST_DIRECTIVE_STMT;
   }
#endif

const char*
SgTemplateInstantiationDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDirectiveStatement";  
   }

std::string
SgTemplateInstantiationDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateInstantiationDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateInstantiationDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_INST_DIRECTIVE_STMT)
        {
          printf ("Error in SgTemplateInstantiationDirectiveStatement::error(): SgTemplateInstantiationDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateInstantiationDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_INST_DIRECTIVE_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateInstantiationDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_INST_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateInstantiationDirectiveStatement* isSgTemplateInstantiationDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateInstantiationDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateInstantiationDirectiveStatement* isSgTemplateInstantiationDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateInstantiationDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateInstantiationDirectiveStatement::~SgTemplateInstantiationDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateInstantiationDirectiveStatement::~SgTemplateInstantiationDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateInstantiationDirectiveStatement::SgTemplateInstantiationDirectiveStatement ( Sg_File_Info* startOfConstruct, SgDeclarationStatement* declaration )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDirectiveStatement::SgTemplateInstantiationDirectiveStatement (Sg_File_Info* startOfConstruct, SgDeclarationStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_INST_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationDirectiveStatement() function since it has been problematic
     assert(isSgTemplateInstantiationDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgNamespaceDeclarationStatement::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgNamespaceDeclarationStatement::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDefinitionStatement* 
SgNamespaceDeclarationStatement::get_definition () const
   {
     assert (this != NULL);
     return p_definition;
   }

void
SgNamespaceDeclarationStatement::set_definition ( SgNamespaceDefinitionStatement* definition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_definition != NULL && definition != NULL && p_definition != definition)
        {
          printf ("Warning: definition = %p overwriting valid pointer p_definition = %p \n",definition,p_definition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_definition != NULL && definition != NULL && p_definition != definition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_definition = definition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgNamespaceDeclarationStatement::get_isUnnamedNamespace () const
   {
     assert (this != NULL);
     return p_isUnnamedNamespace;
   }

void
SgNamespaceDeclarationStatement::set_isUnnamedNamespace ( bool isUnnamedNamespace )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_isUnnamedNamespace = isUnnamedNamespace;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12460 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/13/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgNamespaceDeclarationStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgVariableDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgNamespaceDeclarationStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Call the base class fixupCopy member function
     SgDeclarationStatement::fixupCopy(copy,help);

     SgNamespaceDeclarationStatement* namespaceDeclaration_copy = isSgNamespaceDeclarationStatement(copy);
     ROSE_ASSERT(namespaceDeclaration_copy != NULL);

     SgNamespaceDefinitionStatement* namespaceDefinition_original = this->get_definition();
     SgNamespaceDefinitionStatement* namespaceDefinition_copy     = namespaceDeclaration_copy->get_definition();

     ROSE_ASSERT(namespaceDefinition_original != NULL);
     ROSE_ASSERT(namespaceDefinition_copy != NULL);

     namespaceDefinition_original->fixupCopy(namespaceDefinition_copy,help);
   }
#endif

bool
SgNamespaceDeclarationStatement::isSameNamespace( const SgNamespaceDeclarationStatement* n ) const
   {
  // DQ (6/5/2007): Since namespaces are re-entrant we define a simple function to test if two namespaces 
  // are the same (not the same SgNamespaceDeclarationStatement, but the same namespace).
     ROSE_ASSERT(get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(n->get_firstNondefiningDeclaration() != NULL);

     return ( get_firstNondefiningDeclaration() == n->get_firstNondefiningDeclaration() );
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDeclarationStatement::get_qualified_name() const
   {
     SgName returnName;

  // printf ("In SgNamespaceDeclarationStatement::get_qualified_name() name = %s \n",get_name().str());

     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope!= NULL);

  // DQ (8/24/2006): Need to test for unnamed namespaces since we have to ignore the extra "::" that would be generated in this case!
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
  // returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     if (get_name().is_null() == true)
        {
       // DQ (10/12/2006): Return and empty name instead of the qualified name 
       // of the current scope (see test2004_33.C using un-named namespaces).

       // Ignore the namespace name if it is a unnamed namespace
       // returnName = scope->get_qualified_name();

       // DQ (10/14/2006): Correction for un-named namespaces in nested scopes!
          if (isSgGlobal(scope) != NULL)
             {
            // If this is an un-named namespace in global scope then we are finished and the qualifier is empty.
               returnName = "";
             }
            else
             {
            // If we are not yet in global scope then go further!
               returnName = scope->get_qualified_name();
             }
        }
       else
        {
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }

  // printf ("In SgNamespaceDeclarationStatement::get_qualified_name() : get_name().is_null == %s for name '%s'\n",get_name().is_null() ? "true" : "false", get_name().str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for namespace declarations.
SgName
SgNamespaceDeclarationStatement::get_mangled_name (void) const
   {
#if 0
     return joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgNamespaceDeclarationStatement* declaration = const_cast<SgNamespaceDeclarationStatement*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgNamespaceDeclarationStatement*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgNamespaceDeclarationStatement*>(this),mangledName);
          return mangledName;
        }
#endif
   }

#if 0
// DQ (2/19/2006): Added to handle case destribed in the header file.
bool
SgNamespaceDeclarationStatement::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }
#endif

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgNamespaceDeclarationStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgNamespaceDeclarationStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNamespaceDeclarationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNamespaceDeclarationStatement::variantT() const {
  return V_SgNamespaceDeclarationStatement;
}

#if 0
int
SgNamespaceDeclarationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NAMESPACE_DECLARATION_STMT;
   }
#endif

const char*
SgNamespaceDeclarationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceDeclarationStatement";  
   }

std::string
SgNamespaceDeclarationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceDeclarationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNamespaceDeclarationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNamespaceDeclarationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NAMESPACE_DECLARATION_STMT)
        {
          printf ("Error in SgNamespaceDeclarationStatement::error(): SgNamespaceDeclarationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNamespaceDeclarationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NAMESPACE_DECLARATION_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNamespaceDeclarationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNamespaceDeclarationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return NAMESPACE_DECLARATION_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNamespaceDeclarationStatement* isSgNamespaceDeclarationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNamespaceDeclarationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNamespaceDeclarationStatement* isSgNamespaceDeclarationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNamespaceDeclarationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNamespaceDeclarationStatement::~SgNamespaceDeclarationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgNamespaceDeclarationStatement::~SgNamespaceDeclarationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for definition
     p_definition = NULL; // non list case 
  // case: not a listType for isUnnamedNamespace
     p_isUnnamedNamespace = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNamespaceDeclarationStatement::SgNamespaceDeclarationStatement ( Sg_File_Info* startOfConstruct, SgName name, SgNamespaceDefinitionStatement* definition, bool isUnnamedNamespace )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNamespaceDeclarationStatement::SgNamespaceDeclarationStatement (Sg_File_Info* startOfConstruct, SgName name, SgNamespaceDefinitionStatement* definition, bool isUnnamedNamespace) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_definition = definition;
     p_isUnnamedNamespace = isUnnamedNamespace;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NAMESPACE_DECLARATION_STMT == variant());
     post_construction_initialization();

  // Test the isSgNamespaceDeclarationStatement() function since it has been problematic
     assert(isSgNamespaceDeclarationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgNamespaceAliasDeclarationStatement::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgNamespaceAliasDeclarationStatement::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDeclarationStatement* 
SgNamespaceAliasDeclarationStatement::get_namespaceDeclaration () const
   {
     assert (this != NULL);
     return p_namespaceDeclaration;
   }

void
SgNamespaceAliasDeclarationStatement::set_namespaceDeclaration ( SgNamespaceDeclarationStatement* namespaceDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration)
        {
          printf ("Warning: namespaceDeclaration = %p overwriting valid pointer p_namespaceDeclaration = %p \n",namespaceDeclaration,p_namespaceDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_namespaceDeclaration = namespaceDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12604 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgNamespaceAliasDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_namespace_alias_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_namespace_alias_") + get_name();

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgNamespaceAliasDeclarationStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNamespaceAliasDeclarationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNamespaceAliasDeclarationStatement::variantT() const {
  return V_SgNamespaceAliasDeclarationStatement;
}

#if 0
int
SgNamespaceAliasDeclarationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NAMESPACE_ALIAS_DECLARATION_STMT;
   }
#endif

const char*
SgNamespaceAliasDeclarationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceAliasDeclarationStatement";  
   }

std::string
SgNamespaceAliasDeclarationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceAliasDeclarationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNamespaceAliasDeclarationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNamespaceAliasDeclarationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NAMESPACE_ALIAS_DECLARATION_STMT)
        {
          printf ("Error in SgNamespaceAliasDeclarationStatement::error(): SgNamespaceAliasDeclarationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNamespaceAliasDeclarationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NAMESPACE_ALIAS_DECLARATION_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNamespaceAliasDeclarationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNamespaceAliasDeclarationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return NAMESPACE_ALIAS_DECLARATION_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNamespaceAliasDeclarationStatement* isSgNamespaceAliasDeclarationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNamespaceAliasDeclarationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNamespaceAliasDeclarationStatement* isSgNamespaceAliasDeclarationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNamespaceAliasDeclarationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNamespaceAliasDeclarationStatement::~SgNamespaceAliasDeclarationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgNamespaceAliasDeclarationStatement::~SgNamespaceAliasDeclarationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for namespaceDeclaration
     p_namespaceDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNamespaceAliasDeclarationStatement::SgNamespaceAliasDeclarationStatement ( Sg_File_Info* startOfConstruct, SgName name, SgNamespaceDeclarationStatement* namespaceDeclaration )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNamespaceAliasDeclarationStatement::SgNamespaceAliasDeclarationStatement (Sg_File_Info* startOfConstruct, SgName name, SgNamespaceDeclarationStatement* namespaceDeclaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_namespaceDeclaration = namespaceDeclaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NAMESPACE_ALIAS_DECLARATION_STMT == variant());
     post_construction_initialization();

  // Test the isSgNamespaceAliasDeclarationStatement() function since it has been problematic
     assert(isSgNamespaceAliasDeclarationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDeclarationStatement* 
SgUsingDirectiveStatement::get_namespaceDeclaration () const
   {
     assert (this != NULL);
     return p_namespaceDeclaration;
   }

void
SgUsingDirectiveStatement::set_namespaceDeclaration ( SgNamespaceDeclarationStatement* namespaceDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration)
        {
          printf ("Warning: namespaceDeclaration = %p overwriting valid pointer p_namespaceDeclaration = %p \n",namespaceDeclaration,p_namespaceDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_namespaceDeclaration = namespaceDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12696 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgUsingDirectiveStatement::cfgIndexForEnd() const {
  return 0;
}

std::vector<VirtualCFG::CFGEdge> SgUsingDirectiveStatement::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgUsingDirectiveStatement::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgUsingDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUsingDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUsingDirectiveStatement::variantT() const {
  return V_SgUsingDirectiveStatement;
}

#if 0
int
SgUsingDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return USING_DIRECTIVE_STMT;
   }
#endif

const char*
SgUsingDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUsingDirectiveStatement";  
   }

std::string
SgUsingDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgUsingDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUsingDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUsingDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != USING_DIRECTIVE_STMT)
        {
          printf ("Error in SgUsingDirectiveStatement::error(): SgUsingDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUsingDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == USING_DIRECTIVE_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUsingDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUsingDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return USING_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUsingDirectiveStatement* isSgUsingDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUsingDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUsingDirectiveStatement* isSgUsingDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUsingDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUsingDirectiveStatement::~SgUsingDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgUsingDirectiveStatement::~SgUsingDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for namespaceDeclaration
     p_namespaceDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUsingDirectiveStatement::SgUsingDirectiveStatement ( Sg_File_Info* startOfConstruct, SgNamespaceDeclarationStatement* namespaceDeclaration )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUsingDirectiveStatement::SgUsingDirectiveStatement (Sg_File_Info* startOfConstruct, SgNamespaceDeclarationStatement* namespaceDeclaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_namespaceDeclaration = namespaceDeclaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(USING_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgUsingDirectiveStatement() function since it has been problematic
     assert(isSgUsingDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgUsingDeclarationStatement::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgUsingDeclarationStatement::set_declaration ( SgDeclarationStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgUsingDeclarationStatement::get_initializedName () const
   {
     assert (this != NULL);
     return p_initializedName;
   }

void
SgUsingDeclarationStatement::set_initializedName ( SgInitializedName* initializedName )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_initializedName != NULL && initializedName != NULL && p_initializedName != initializedName)
        {
          printf ("Warning: initializedName = %p overwriting valid pointer p_initializedName = %p \n",initializedName,p_initializedName);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_initializedName != NULL && initializedName != NULL && p_initializedName != initializedName) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_initializedName = initializedName;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12737 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName name;
     if (get_declaration() != NULL)
          name = get_declaration()->get_mangled_name();
       else
        {
          ROSE_ASSERT(get_initializedName() != NULL);
          name = get_initializedName()->get_mangled_name();
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_declaration_") + name;
     returnName = scope->get_mangled_name() + SgName("_using_declaration_") + name;

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgUsingDeclarationStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUsingDeclarationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUsingDeclarationStatement::variantT() const {
  return V_SgUsingDeclarationStatement;
}

#if 0
int
SgUsingDeclarationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return USING_DECLARATION_STMT;
   }
#endif

const char*
SgUsingDeclarationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUsingDeclarationStatement";  
   }

std::string
SgUsingDeclarationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgUsingDeclarationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUsingDeclarationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUsingDeclarationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != USING_DECLARATION_STMT)
        {
          printf ("Error in SgUsingDeclarationStatement::error(): SgUsingDeclarationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUsingDeclarationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == USING_DECLARATION_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUsingDeclarationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUsingDeclarationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return USING_DECLARATION_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUsingDeclarationStatement* isSgUsingDeclarationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUsingDeclarationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUsingDeclarationStatement* isSgUsingDeclarationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUsingDeclarationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUsingDeclarationStatement::~SgUsingDeclarationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgUsingDeclarationStatement::~SgUsingDeclarationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 
  // case: not a listType for initializedName
     p_initializedName = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUsingDeclarationStatement::SgUsingDeclarationStatement ( Sg_File_Info* startOfConstruct, SgDeclarationStatement* declaration, SgInitializedName* initializedName )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUsingDeclarationStatement::SgUsingDeclarationStatement (Sg_File_Info* startOfConstruct, SgDeclarationStatement* declaration, SgInitializedName* initializedName) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;
     p_initializedName = initializedName;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(USING_DECLARATION_STMT == variant());
     post_construction_initialization();

  // Test the isSgUsingDeclarationStatement() function since it has been problematic
     assert(isSgUsingDeclarationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgFunctionParameterList::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

SgInitializedNamePtrList &
SgFunctionParameterList::get_args () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7803 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
void
SgFunctionParameterList::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
#if DEBUG_FIXUP_COPY
     printf ("Inside of SgFunctionParameterList::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

     SgFunctionParameterList* copyFunctionParameterList = isSgFunctionParameterList(copy);
     ROSE_ASSERT(copyFunctionParameterList != NULL);

     const SgInitializedNamePtrList & parameterList_original = this->get_args();
     SgInitializedNamePtrList & parameterList_copy           = copyFunctionParameterList->get_args();

     SgInitializedNamePtrList::const_iterator i_original = parameterList_original.begin();
     SgInitializedNamePtrList::iterator i_copy           = parameterList_copy.begin();

  // Iterate over both lists to match up the correct pairs of SgInitializedName objects
     while ( (i_original != parameterList_original.end()) && (i_copy != parameterList_copy.end()) )
        {
          (*i_original)->fixupCopy(*i_copy,help);

          i_original++;
          i_copy++;
        }

  // Also call the base class version of the fixupCopycopy() member function
     SgDeclarationStatement::fixupCopy(copy,help);
   }
#endif

unsigned int
SgFunctionParameterList::cfgIndexForEnd() const
   {
     return this->get_args().size();
   }

std::vector<VirtualCFG::CFGEdge>
SgFunctionParameterList::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     if (idx == this->get_args().size())
        {
          makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
        }
       else
        {
          if (idx < this->get_args().size())
             {
               makeEdge(VirtualCFG::CFGNode(this, idx), this->get_args()[idx]->cfgForBeginning(), result);
             }
            else
             {
               ROSE_ASSERT (!"Bad index for SgFunctionParameterList");
             }
        }

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgFunctionParameterList::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     if (idx == 0)
        {
          makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
        }
       else
        {
          if (idx <= this->get_args().size())
             {
               makeEdge(this->get_args()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
             }
            else
             {
               ROSE_ASSERT (!"Bad index for SgFunctionParameterList");
             }
        }

     return result;
   }

void
SgFunctionParameterList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Fixup parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }
   }

SgInitializedNamePtrList::iterator 
SgFunctionParameterList::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/24/2004): this should be true but verify it!
     ROSE_ASSERT(what != NULL);

     SgInitializedNamePtrList::iterator new_item = get_args().insert(where, what);

  // DQ (9/24/2004): This code requires that parent pointers be set in the AST 
  // (which we would like to defer to post-processing AST Fixup).  See if we can 
  // eliminate this code.  The declaration in the InitializedName should have 
  // already been set anyway, so I don't think it should be reset!  Though it 
  // could be that it is not set to the function declaration!
#ifndef REMOVE_SET_PARENT_FUNCTION
     SgFunctionDeclaration* declStmt	= dynamic_cast<SgFunctionDeclaration*>(get_parent());
     ROSE_ASSERT(declStmt!=0);
     (*new_item)->set_declaration(declStmt); // MS: 'get_parent' instead of 'this'
#else
  // Verify that the declaration of all function parameters have been set to the function declaration!
    // ROSE_ASSERT((*new_item)->get_declaration() != NULL);
   //  ROSE_ASSERT ( isSgFunctionDeclaration( (*new_item)->get_declaration() ) != NULL );

//   if ( (*new_item)->get_declaration()->variantT() != V_SgFunctionDeclaration &&
//        (*new_item)->get_declaration()->variantT() != V_SgMemberFunctionDeclaration )
//      {
//        printf ("Error: function parameter declaration (not SgFunctionDeclaration or SgMemberFunctionDeclaration) set to %s \n",(*new_item)->get_declaration()->sage_class_name());
//      }
//   ROSE_ASSERT ( (*new_item)->get_declaration()->variantT() == V_SgFunctionDeclaration ||
//                 (*new_item)->get_declaration()->variantT() == V_SgMemberFunctionDeclaration );
#endif
     return new_item;
   }

SgInitializedNamePtrList::iterator
SgFunctionParameterList::append_arg( SgInitializedName* what)
   {
     SgInitializedNamePtrList::iterator new_item = insert_arg(get_args().end(), what);
     return new_item;
   }

SgInitializedNamePtrList::iterator
SgFunctionParameterList::prepend_arg( SgInitializedName* what)
   {
     SgInitializedNamePtrList::iterator new_item = insert_arg(get_args().begin(), what);
     return new_item;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgFunctionParameterList::get_mangled_name(void) const
   {
#if 0
  // printf ("In SgFunctionParameterList::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames = "_args_";
     SgInitializedNamePtrList::const_iterator p = get_args().begin();
     while ( p != get_args().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_function_parameter_list_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
#else
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionParameterList* declaration = const_cast<SgFunctionParameterList*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionParameterList*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName variableNames = "_args_";
          SgInitializedNamePtrList::const_iterator p = get_args().begin();
          while ( p != get_args().end() )
             {
            // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
               variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

               p++;
             }

       // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
       // This is a poor way to handle the generation of a mangled name (will be improved)
          SgName mangledName = get_scope()->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionParameterList*>(this),mangledName);
          return mangledName;
        }
#endif
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionParameterList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionParameterList::variantT() const {
  return V_SgFunctionParameterList;
}

#if 0
int
SgFunctionParameterList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNCTION_PARAMETER_LIST;
   }
#endif

const char*
SgFunctionParameterList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionParameterList";  
   }

std::string
SgFunctionParameterList::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionParameterList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionParameterList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionParameterList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNCTION_PARAMETER_LIST)
        {
          printf ("Error in SgFunctionParameterList::error(): SgFunctionParameterList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionParameterList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNCTION_PARAMETER_LIST);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionParameterList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionParameterList::variant() const \n");
#endif
     assert(this != NULL);
     return FUNCTION_PARAMETER_LIST;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionParameterList* isSgFunctionParameterList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionParameterList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionParameterList* isSgFunctionParameterList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionParameterList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionParameterList::~SgFunctionParameterList ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionParameterList::~SgFunctionParameterList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionParameterList::SgFunctionParameterList ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFunctionParameterList::SgFunctionParameterList (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(FUNCTION_PARAMETER_LIST == variant());
     post_construction_initialization();

  // Test the isSgFunctionParameterList() function since it has been problematic
     assert(isSgFunctionParameterList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgCtorInitializerList::get_ctors () const
   {
     assert (this != NULL);
     return p_ctors;
   }

SgInitializedNamePtrList &
SgCtorInitializerList::get_ctors () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_ctors;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 8779 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgCtorInitializerList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }
   }

/* SgInitializedName tuple: (SgName, type, Initializer) */
void
SgCtorInitializerList::append_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().end(), iName);
   }

void
SgCtorInitializerList::prepend_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().begin(), iName);
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgCtorInitializerList::get_mangled_name(void) const
   {
  // printf ("In SgCtorInitializerList::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName memberNames;
     SgInitializedNamePtrList::const_iterator p = get_ctors().begin();
     while ( p != get_ctors().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // memberNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          memberNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_constructor_initialization_list_") + memberNames;
     returnName = scope->get_mangled_name() + SgName("_constructor_initialization_list_") + memberNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCtorInitializerList::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCtorInitializerList::variantT() const {
  return V_SgCtorInitializerList;
}

#if 0
int
SgCtorInitializerList::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CTOR_INITIALIZER_LIST;
   }
#endif

const char*
SgCtorInitializerList::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCtorInitializerList";  
   }

std::string
SgCtorInitializerList::class_name() const
   {
     assert(this != NULL);
     return "SgCtorInitializerList";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCtorInitializerList::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCtorInitializerList::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CTOR_INITIALIZER_LIST)
        {
          printf ("Error in SgCtorInitializerList::error(): SgCtorInitializerList object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCtorInitializerList::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CTOR_INITIALIZER_LIST);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCtorInitializerList::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCtorInitializerList::variant() const \n");
#endif
     assert(this != NULL);
     return CTOR_INITIALIZER_LIST;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCtorInitializerList* isSgCtorInitializerList ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCtorInitializerList*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCtorInitializerList* isSgCtorInitializerList ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCtorInitializerList*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCtorInitializerList::~SgCtorInitializerList ()
   {
#if 0
  // debugging information!
     printf ("In SgCtorInitializerList::~SgCtorInitializerList (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCtorInitializerList::SgCtorInitializerList ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCtorInitializerList::SgCtorInitializerList (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(CTOR_INITIALIZER_LIST == variant());
     post_construction_initialization();

  // Test the isSgCtorInitializerList() function since it has been problematic
     assert(isSgCtorInitializerList(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgPragma* 
SgPragmaDeclaration::get_pragma () const
   {
     assert (this != NULL);
     return p_pragma;
   }

void
SgPragmaDeclaration::set_pragma ( SgPragma* pragma )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_pragma != NULL && pragma != NULL && p_pragma != pragma)
        {
          printf ("Warning: pragma = %p overwriting valid pointer p_pragma = %p \n",pragma,p_pragma);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_pragma != NULL && pragma != NULL && p_pragma != pragma) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_pragma = pragma;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12407 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgPragmaDeclaration::cfgIndexForEnd() const {
  return 0;
}

std::vector<VirtualCFG::CFGEdge> SgPragmaDeclaration::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgPragmaDeclaration::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}

void
SgPragmaDeclaration::post_construction_initialization()
   {
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgPragmaDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
  // SgScopeStatement* scope = get_scope();
  // ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
     returnName = "pragma_statement";

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPragmaDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPragmaDeclaration::variantT() const {
  return V_SgPragmaDeclaration;
}

#if 0
int
SgPragmaDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PRAGMA_DECL;
   }
#endif

const char*
SgPragmaDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPragmaDeclaration";  
   }

std::string
SgPragmaDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgPragmaDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPragmaDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPragmaDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PRAGMA_DECL)
        {
          printf ("Error in SgPragmaDeclaration::error(): SgPragmaDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPragmaDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PRAGMA_DECL);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPragmaDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPragmaDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return PRAGMA_DECL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPragmaDeclaration* isSgPragmaDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPragmaDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPragmaDeclaration* isSgPragmaDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPragmaDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPragmaDeclaration::~SgPragmaDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgPragmaDeclaration::~SgPragmaDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for pragma
     p_pragma = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPragmaDeclaration::SgPragmaDeclaration ( Sg_File_Info* startOfConstruct, SgPragma* pragma )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgPragmaDeclaration::SgPragmaDeclaration (Sg_File_Info* startOfConstruct, SgPragma* pragma) sage_class_name() = %s \n",sage_class_name());
#endif

     p_pragma = pragma;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(PRAGMA_DECL == variant());
     post_construction_initialization();

  // Test the isSgPragmaDeclaration() function since it has been problematic
     assert(isSgPragmaDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 13518 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgParameterStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgParameterStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgParameterStatement::variantT() const {
  return V_SgParameterStatement;
}

#if 0
int
SgParameterStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PARAMETER_STATEMENT;
   }
#endif

const char*
SgParameterStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgParameterStatement";  
   }

std::string
SgParameterStatement::class_name() const
   {
     assert(this != NULL);
     return "SgParameterStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgParameterStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgParameterStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PARAMETER_STATEMENT)
        {
          printf ("Error in SgParameterStatement::error(): SgParameterStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgParameterStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PARAMETER_STATEMENT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgParameterStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgParameterStatement::variant() const \n");
#endif
     assert(this != NULL);
     return PARAMETER_STATEMENT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgParameterStatement* isSgParameterStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgParameterStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgParameterStatement* isSgParameterStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgParameterStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgParameterStatement::~SgParameterStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgParameterStatement::~SgParameterStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgParameterStatement::SgParameterStatement ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgParameterStatement::SgParameterStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(PARAMETER_STATEMENT == variant());
     post_construction_initialization();

  // Test the isSgParameterStatement() function since it has been problematic
     assert(isSgParameterStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgCommonBlock::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgCommonBlock::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgCommonBlock::get_variables () const
   {
     assert (this != NULL);
     return p_variables;
   }

SgInitializedNamePtrList &
SgCommonBlock::get_variables () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_variables;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13389 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgCommonBlock::post_construction_initialization()
   {
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCommonBlock::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCommonBlock::variantT() const {
  return V_SgCommonBlock;
}

#if 0
int
SgCommonBlock::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return COMMON_BLOCK;
   }
#endif

const char*
SgCommonBlock::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCommonBlock";  
   }

std::string
SgCommonBlock::class_name() const
   {
     assert(this != NULL);
     return "SgCommonBlock";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCommonBlock::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCommonBlock::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != COMMON_BLOCK)
        {
          printf ("Error in SgCommonBlock::error(): SgCommonBlock object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCommonBlock::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == COMMON_BLOCK);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCommonBlock::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCommonBlock::variant() const \n");
#endif
     assert(this != NULL);
     return COMMON_BLOCK;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCommonBlock* isSgCommonBlock ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCommonBlock*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCommonBlock* isSgCommonBlock ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCommonBlock*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCommonBlock::SgCommonBlock ( Sg_File_Info* startOfConstruct, SgName name )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCommonBlock::SgCommonBlock (Sg_File_Info* startOfConstruct, SgName name) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(COMMON_BLOCK == variant());
     post_construction_initialization();

  // Test the isSgCommonBlock() function since it has been problematic
     assert(isSgCommonBlock(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgImplicitStatement::get_implicit_none () const
   {
     assert (this != NULL);
     return p_implicit_none;
   }

void
SgImplicitStatement::set_implicit_none ( bool implicit_none )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_implicit_none = implicit_none;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgInitializedNamePtrList &
SgImplicitStatement::get_variables () const
   {
     assert (this != NULL);
     return p_variables;
   }

SgInitializedNamePtrList &
SgImplicitStatement::get_variables () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_variables;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13534 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgImplicitStatement::post_construction_initialization()
   {}

SgName
SgImplicitStatement::get_mangled_name() const
   {
     printf ("Sorry, SgImplicitStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgImplicitStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgImplicitStatement::variantT() const {
  return V_SgImplicitStatement;
}

#if 0
int
SgImplicitStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Implicit_Statement;
   }
#endif

const char*
SgImplicitStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgImplicitStatement";  
   }

std::string
SgImplicitStatement::class_name() const
   {
     assert(this != NULL);
     return "SgImplicitStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgImplicitStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgImplicitStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Implicit_Statement)
        {
          printf ("Error in SgImplicitStatement::error(): SgImplicitStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgImplicitStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Implicit_Statement);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgImplicitStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgImplicitStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Implicit_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgImplicitStatement* isSgImplicitStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgImplicitStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgImplicitStatement* isSgImplicitStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgImplicitStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgImplicitStatement::~SgImplicitStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgImplicitStatement::~SgImplicitStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for implicit_none
     p_implicit_none = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgImplicitStatement::SgImplicitStatement ( Sg_File_Info* startOfConstruct, bool implicit_none )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgImplicitStatement::SgImplicitStatement (Sg_File_Info* startOfConstruct, bool implicit_none) sage_class_name() = %s \n",sage_class_name());
#endif

     p_implicit_none = implicit_none;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Implicit_Statement == variant());
     post_construction_initialization();

  // Test the isSgImplicitStatement() function since it has been problematic
     assert(isSgImplicitStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionDeclaration* 
SgStatementFunctionStatement::get_function () const
   {
     assert (this != NULL);
     return p_function;
   }

void
SgStatementFunctionStatement::set_function ( SgFunctionDeclaration* function )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_function != NULL && function != NULL && p_function != function)
        {
          printf ("Warning: function = %p overwriting valid pointer p_function = %p \n",function,p_function);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_function != NULL && function != NULL && p_function != function) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_function = function;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgStatementFunctionStatement::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgStatementFunctionStatement::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13548 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgStatementFunctionStatement::post_construction_initialization()
   {}

SgName
SgStatementFunctionStatement::get_mangled_name() const
   {
     printf ("Sorry, SgStatementFunctionStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStatementFunctionStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStatementFunctionStatement::variantT() const {
  return V_SgStatementFunctionStatement;
}

#if 0
int
SgStatementFunctionStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Statement_Function_Statement;
   }
#endif

const char*
SgStatementFunctionStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStatementFunctionStatement";  
   }

std::string
SgStatementFunctionStatement::class_name() const
   {
     assert(this != NULL);
     return "SgStatementFunctionStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStatementFunctionStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStatementFunctionStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Statement_Function_Statement)
        {
          printf ("Error in SgStatementFunctionStatement::error(): SgStatementFunctionStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStatementFunctionStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Statement_Function_Statement);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStatementFunctionStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStatementFunctionStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Statement_Function_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStatementFunctionStatement* isSgStatementFunctionStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStatementFunctionStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStatementFunctionStatement* isSgStatementFunctionStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStatementFunctionStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStatementFunctionStatement::~SgStatementFunctionStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgStatementFunctionStatement::~SgStatementFunctionStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for function
     p_function = NULL; // non list case 
  // case: not a listType for expression
     p_expression = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStatementFunctionStatement::SgStatementFunctionStatement ( Sg_File_Info* startOfConstruct, SgFunctionDeclaration* function, SgExpression* expression )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgStatementFunctionStatement::SgStatementFunctionStatement (Sg_File_Info* startOfConstruct, SgFunctionDeclaration* function, SgExpression* expression) sage_class_name() = %s \n",sage_class_name());
#endif

     p_function = function;
     p_expression = expression;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Statement_Function_Statement == variant());
     post_construction_initialization();

  // Test the isSgStatementFunctionStatement() function since it has been problematic
     assert(isSgStatementFunctionStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgEquivalenceStatement::get_count () const
   {
     assert (this != NULL);
     return p_count;
   }

void
SgEquivalenceStatement::set_count ( int count )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_count = count;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13583 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgEquivalenceStatement::post_construction_initialization()
   {}

SgName
SgEquivalenceStatement::get_mangled_name() const
   {
     printf ("Sorry, SgEquivalenceStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEquivalenceStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEquivalenceStatement::variantT() const {
  return V_SgEquivalenceStatement;
}

#if 0
int
SgEquivalenceStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Equivalence_Statement;
   }
#endif

const char*
SgEquivalenceStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEquivalenceStatement";  
   }

std::string
SgEquivalenceStatement::class_name() const
   {
     assert(this != NULL);
     return "SgEquivalenceStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEquivalenceStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEquivalenceStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Equivalence_Statement)
        {
          printf ("Error in SgEquivalenceStatement::error(): SgEquivalenceStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEquivalenceStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Equivalence_Statement);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEquivalenceStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEquivalenceStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Equivalence_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEquivalenceStatement* isSgEquivalenceStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEquivalenceStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEquivalenceStatement* isSgEquivalenceStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEquivalenceStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEquivalenceStatement::~SgEquivalenceStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgEquivalenceStatement::~SgEquivalenceStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for count
     p_count = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEquivalenceStatement::SgEquivalenceStatement ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgEquivalenceStatement::SgEquivalenceStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_count = 0;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Equivalence_Statement == variant());
     post_construction_initialization();

  // Test the isSgEquivalenceStatement() function since it has been problematic
     assert(isSgEquivalenceStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgC_PreprocessorDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgC_PreprocessorDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgC_PreprocessorDirectiveStatement::variantT() const {
  return V_SgC_PreprocessorDirectiveStatement;
}

#if 0
int
SgC_PreprocessorDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CPP_DIRECTIVE_STMT;
   }
#endif

const char*
SgC_PreprocessorDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgC_PreprocessorDirectiveStatement";  
   }

std::string
SgC_PreprocessorDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgC_PreprocessorDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgC_PreprocessorDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgC_PreprocessorDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CPP_DIRECTIVE_STMT)
        {
          printf ("Error in SgC_PreprocessorDirectiveStatement::error(): SgC_PreprocessorDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgC_PreprocessorDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CPP_DIRECTIVE_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgC_PreprocessorDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgC_PreprocessorDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return CPP_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgC_PreprocessorDirectiveStatement* isSgC_PreprocessorDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgC_PreprocessorDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgC_PreprocessorDirectiveStatement* isSgC_PreprocessorDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgC_PreprocessorDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgC_PreprocessorDirectiveStatement::~SgC_PreprocessorDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgC_PreprocessorDirectiveStatement::~SgC_PreprocessorDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for directiveString
     p_directiveString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgC_PreprocessorDirectiveStatement::SgC_PreprocessorDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgC_PreprocessorDirectiveStatement::SgC_PreprocessorDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_directiveString = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CPP_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgC_PreprocessorDirectiveStatement() function since it has been problematic
     assert(isSgC_PreprocessorDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgIncludeDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIncludeDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIncludeDirectiveStatement::variantT() const {
  return V_SgIncludeDirectiveStatement;
}

#if 0
int
SgIncludeDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INCLUDE_DIRECTIVE_STMT;
   }
#endif

const char*
SgIncludeDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIncludeDirectiveStatement";  
   }

std::string
SgIncludeDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIncludeDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIncludeDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIncludeDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INCLUDE_DIRECTIVE_STMT)
        {
          printf ("Error in SgIncludeDirectiveStatement::error(): SgIncludeDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIncludeDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INCLUDE_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIncludeDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIncludeDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return INCLUDE_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIncludeDirectiveStatement* isSgIncludeDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIncludeDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIncludeDirectiveStatement* isSgIncludeDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIncludeDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIncludeDirectiveStatement::~SgIncludeDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIncludeDirectiveStatement::~SgIncludeDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString3
     p_dummyString3 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIncludeDirectiveStatement::SgIncludeDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIncludeDirectiveStatement::SgIncludeDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString3 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INCLUDE_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgIncludeDirectiveStatement() function since it has been problematic
     assert(isSgIncludeDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgDefineDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDefineDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDefineDirectiveStatement::variantT() const {
  return V_SgDefineDirectiveStatement;
}

#if 0
int
SgDefineDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DEFINE_DIRECTIVE_STMT;
   }
#endif

const char*
SgDefineDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDefineDirectiveStatement";  
   }

std::string
SgDefineDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgDefineDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDefineDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDefineDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DEFINE_DIRECTIVE_STMT)
        {
          printf ("Error in SgDefineDirectiveStatement::error(): SgDefineDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDefineDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DEFINE_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDefineDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDefineDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return DEFINE_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDefineDirectiveStatement* isSgDefineDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDefineDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDefineDirectiveStatement* isSgDefineDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDefineDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDefineDirectiveStatement::~SgDefineDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgDefineDirectiveStatement::~SgDefineDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString4
     p_dummyString4 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDefineDirectiveStatement::SgDefineDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDefineDirectiveStatement::SgDefineDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString4 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DEFINE_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgDefineDirectiveStatement() function since it has been problematic
     assert(isSgDefineDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgUndefDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUndefDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUndefDirectiveStatement::variantT() const {
  return V_SgUndefDirectiveStatement;
}

#if 0
int
SgUndefDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNDEF_DIRECTIVE_STMT;
   }
#endif

const char*
SgUndefDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUndefDirectiveStatement";  
   }

std::string
SgUndefDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgUndefDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUndefDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUndefDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNDEF_DIRECTIVE_STMT)
        {
          printf ("Error in SgUndefDirectiveStatement::error(): SgUndefDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUndefDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNDEF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUndefDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUndefDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return UNDEF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUndefDirectiveStatement* isSgUndefDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUndefDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUndefDirectiveStatement* isSgUndefDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUndefDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUndefDirectiveStatement::~SgUndefDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgUndefDirectiveStatement::~SgUndefDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString5
     p_dummyString5 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUndefDirectiveStatement::SgUndefDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUndefDirectiveStatement::SgUndefDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString5 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNDEF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgUndefDirectiveStatement() function since it has been problematic
     assert(isSgUndefDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgIfdefDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIfdefDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIfdefDirectiveStatement::variantT() const {
  return V_SgIfdefDirectiveStatement;
}

#if 0
int
SgIfdefDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IFDEF_DIRECTIVE_STMT;
   }
#endif

const char*
SgIfdefDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIfdefDirectiveStatement";  
   }

std::string
SgIfdefDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIfdefDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIfdefDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIfdefDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IFDEF_DIRECTIVE_STMT)
        {
          printf ("Error in SgIfdefDirectiveStatement::error(): SgIfdefDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIfdefDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IFDEF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIfdefDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIfdefDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return IFDEF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIfdefDirectiveStatement* isSgIfdefDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIfdefDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIfdefDirectiveStatement* isSgIfdefDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIfdefDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIfdefDirectiveStatement::~SgIfdefDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIfdefDirectiveStatement::~SgIfdefDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString6
     p_dummyString6 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIfdefDirectiveStatement::SgIfdefDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIfdefDirectiveStatement::SgIfdefDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString6 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IFDEF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgIfdefDirectiveStatement() function since it has been problematic
     assert(isSgIfdefDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgIfndefDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIfndefDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIfndefDirectiveStatement::variantT() const {
  return V_SgIfndefDirectiveStatement;
}

#if 0
int
SgIfndefDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IFNDEF_DIRECTIVE_STMT;
   }
#endif

const char*
SgIfndefDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIfndefDirectiveStatement";  
   }

std::string
SgIfndefDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIfndefDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIfndefDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIfndefDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IFNDEF_DIRECTIVE_STMT)
        {
          printf ("Error in SgIfndefDirectiveStatement::error(): SgIfndefDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIfndefDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IFNDEF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIfndefDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIfndefDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return IFNDEF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIfndefDirectiveStatement* isSgIfndefDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIfndefDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIfndefDirectiveStatement* isSgIfndefDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIfndefDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIfndefDirectiveStatement::~SgIfndefDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIfndefDirectiveStatement::~SgIfndefDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString7
     p_dummyString7 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIfndefDirectiveStatement::SgIfndefDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIfndefDirectiveStatement::SgIfndefDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString7 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IFNDEF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgIfndefDirectiveStatement() function since it has been problematic
     assert(isSgIfndefDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgIfDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIfDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIfDirectiveStatement::variantT() const {
  return V_SgIfDirectiveStatement;
}

#if 0
int
SgIfDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IF_DIRECTIVE_STMT;
   }
#endif

const char*
SgIfDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIfDirectiveStatement";  
   }

std::string
SgIfDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgIfDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIfDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIfDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IF_DIRECTIVE_STMT)
        {
          printf ("Error in SgIfDirectiveStatement::error(): SgIfDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIfDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIfDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIfDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return IF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIfDirectiveStatement* isSgIfDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIfDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIfDirectiveStatement* isSgIfDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIfDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIfDirectiveStatement::~SgIfDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgIfDirectiveStatement::~SgIfDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString8
     p_dummyString8 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIfDirectiveStatement::SgIfDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIfDirectiveStatement::SgIfDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString8 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgIfDirectiveStatement() function since it has been problematic
     assert(isSgIfDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgDeadIfDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDeadIfDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDeadIfDirectiveStatement::variantT() const {
  return V_SgDeadIfDirectiveStatement;
}

#if 0
int
SgDeadIfDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DEAD_IF_DIRECTIVE_STMT;
   }
#endif

const char*
SgDeadIfDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDeadIfDirectiveStatement";  
   }

std::string
SgDeadIfDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgDeadIfDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDeadIfDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDeadIfDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DEAD_IF_DIRECTIVE_STMT)
        {
          printf ("Error in SgDeadIfDirectiveStatement::error(): SgDeadIfDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDeadIfDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DEAD_IF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDeadIfDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDeadIfDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return DEAD_IF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDeadIfDirectiveStatement* isSgDeadIfDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDeadIfDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDeadIfDirectiveStatement* isSgDeadIfDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDeadIfDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDeadIfDirectiveStatement::~SgDeadIfDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgDeadIfDirectiveStatement::~SgDeadIfDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString8
     p_dummyString8 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDeadIfDirectiveStatement::SgDeadIfDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDeadIfDirectiveStatement::SgDeadIfDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString8 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DEAD_IF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgDeadIfDirectiveStatement() function since it has been problematic
     assert(isSgDeadIfDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgElseDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgElseDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgElseDirectiveStatement::variantT() const {
  return V_SgElseDirectiveStatement;
}

#if 0
int
SgElseDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ELSE_DIRECTIVE_STMT;
   }
#endif

const char*
SgElseDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgElseDirectiveStatement";  
   }

std::string
SgElseDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgElseDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgElseDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgElseDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ELSE_DIRECTIVE_STMT)
        {
          printf ("Error in SgElseDirectiveStatement::error(): SgElseDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgElseDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ELSE_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgElseDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgElseDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return ELSE_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgElseDirectiveStatement* isSgElseDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgElseDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgElseDirectiveStatement* isSgElseDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgElseDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgElseDirectiveStatement::~SgElseDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgElseDirectiveStatement::~SgElseDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString9
     p_dummyString9 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgElseDirectiveStatement::SgElseDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgElseDirectiveStatement::SgElseDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString9 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ELSE_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgElseDirectiveStatement() function since it has been problematic
     assert(isSgElseDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgElseifDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgElseifDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgElseifDirectiveStatement::variantT() const {
  return V_SgElseifDirectiveStatement;
}

#if 0
int
SgElseifDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ELSEIF_DIRECTIVE_STMT;
   }
#endif

const char*
SgElseifDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgElseifDirectiveStatement";  
   }

std::string
SgElseifDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgElseifDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgElseifDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgElseifDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ELSEIF_DIRECTIVE_STMT)
        {
          printf ("Error in SgElseifDirectiveStatement::error(): SgElseifDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgElseifDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ELSEIF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgElseifDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgElseifDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return ELSEIF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgElseifDirectiveStatement* isSgElseifDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgElseifDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgElseifDirectiveStatement* isSgElseifDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgElseifDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgElseifDirectiveStatement::~SgElseifDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgElseifDirectiveStatement::~SgElseifDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString10
     p_dummyString10 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgElseifDirectiveStatement::SgElseifDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgElseifDirectiveStatement::SgElseifDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString10 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ELSEIF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgElseifDirectiveStatement() function since it has been problematic
     assert(isSgElseifDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgEndifDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEndifDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEndifDirectiveStatement::variantT() const {
  return V_SgEndifDirectiveStatement;
}

#if 0
int
SgEndifDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ENDIF_DIRECTIVE_STMT;
   }
#endif

const char*
SgEndifDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEndifDirectiveStatement";  
   }

std::string
SgEndifDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgEndifDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEndifDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEndifDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ENDIF_DIRECTIVE_STMT)
        {
          printf ("Error in SgEndifDirectiveStatement::error(): SgEndifDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEndifDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ENDIF_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEndifDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEndifDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return ENDIF_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEndifDirectiveStatement* isSgEndifDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEndifDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEndifDirectiveStatement* isSgEndifDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEndifDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEndifDirectiveStatement::~SgEndifDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgEndifDirectiveStatement::~SgEndifDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString11
     p_dummyString11 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEndifDirectiveStatement::SgEndifDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgEndifDirectiveStatement::SgEndifDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString11 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ENDIF_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgEndifDirectiveStatement() function since it has been problematic
     assert(isSgEndifDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgLineDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLineDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLineDirectiveStatement::variantT() const {
  return V_SgLineDirectiveStatement;
}

#if 0
int
SgLineDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LINE_DIRECTIVE_STMT;
   }
#endif

const char*
SgLineDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLineDirectiveStatement";  
   }

std::string
SgLineDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgLineDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLineDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLineDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LINE_DIRECTIVE_STMT)
        {
          printf ("Error in SgLineDirectiveStatement::error(): SgLineDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLineDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LINE_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLineDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLineDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return LINE_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLineDirectiveStatement* isSgLineDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLineDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLineDirectiveStatement* isSgLineDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLineDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLineDirectiveStatement::~SgLineDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgLineDirectiveStatement::~SgLineDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString12
     p_dummyString12 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLineDirectiveStatement::SgLineDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgLineDirectiveStatement::SgLineDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString12 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LINE_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgLineDirectiveStatement() function since it has been problematic
     assert(isSgLineDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgWarningDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgWarningDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgWarningDirectiveStatement::variantT() const {
  return V_SgWarningDirectiveStatement;
}

#if 0
int
SgWarningDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return WARNING_DIRECTIVE_STMT;
   }
#endif

const char*
SgWarningDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgWarningDirectiveStatement";  
   }

std::string
SgWarningDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgWarningDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgWarningDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgWarningDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != WARNING_DIRECTIVE_STMT)
        {
          printf ("Error in SgWarningDirectiveStatement::error(): SgWarningDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgWarningDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == WARNING_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgWarningDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgWarningDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return WARNING_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgWarningDirectiveStatement* isSgWarningDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgWarningDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgWarningDirectiveStatement* isSgWarningDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgWarningDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgWarningDirectiveStatement::~SgWarningDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgWarningDirectiveStatement::~SgWarningDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString13
     p_dummyString13 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgWarningDirectiveStatement::SgWarningDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgWarningDirectiveStatement::SgWarningDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString13 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(WARNING_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgWarningDirectiveStatement() function since it has been problematic
     assert(isSgWarningDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgErrorDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgErrorDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgErrorDirectiveStatement::variantT() const {
  return V_SgErrorDirectiveStatement;
}

#if 0
int
SgErrorDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ERROR_DIRECTIVE_STMT;
   }
#endif

const char*
SgErrorDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgErrorDirectiveStatement";  
   }

std::string
SgErrorDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgErrorDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgErrorDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgErrorDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ERROR_DIRECTIVE_STMT)
        {
          printf ("Error in SgErrorDirectiveStatement::error(): SgErrorDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgErrorDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ERROR_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgErrorDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgErrorDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return ERROR_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgErrorDirectiveStatement* isSgErrorDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgErrorDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgErrorDirectiveStatement* isSgErrorDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgErrorDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgErrorDirectiveStatement::~SgErrorDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgErrorDirectiveStatement::~SgErrorDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString14
     p_dummyString14 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgErrorDirectiveStatement::SgErrorDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgErrorDirectiveStatement::SgErrorDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString14 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ERROR_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgErrorDirectiveStatement() function since it has been problematic
     assert(isSgErrorDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgEmptyDirectiveStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEmptyDirectiveStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEmptyDirectiveStatement::variantT() const {
  return V_SgEmptyDirectiveStatement;
}

#if 0
int
SgEmptyDirectiveStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EMPTY_DIRECTIVE_STMT;
   }
#endif

const char*
SgEmptyDirectiveStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEmptyDirectiveStatement";  
   }

std::string
SgEmptyDirectiveStatement::class_name() const
   {
     assert(this != NULL);
     return "SgEmptyDirectiveStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEmptyDirectiveStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEmptyDirectiveStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EMPTY_DIRECTIVE_STMT)
        {
          printf ("Error in SgEmptyDirectiveStatement::error(): SgEmptyDirectiveStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEmptyDirectiveStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EMPTY_DIRECTIVE_STMT);
     return SgC_PreprocessorDirectiveStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEmptyDirectiveStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEmptyDirectiveStatement::variant() const \n");
#endif
     assert(this != NULL);
     return EMPTY_DIRECTIVE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEmptyDirectiveStatement* isSgEmptyDirectiveStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEmptyDirectiveStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEmptyDirectiveStatement* isSgEmptyDirectiveStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEmptyDirectiveStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEmptyDirectiveStatement::~SgEmptyDirectiveStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgEmptyDirectiveStatement::~SgEmptyDirectiveStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString15
     p_dummyString15 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEmptyDirectiveStatement::SgEmptyDirectiveStatement ( Sg_File_Info* startOfConstruct )
   : SgC_PreprocessorDirectiveStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgEmptyDirectiveStatement::SgEmptyDirectiveStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString15 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(EMPTY_DIRECTIVE_STMT == variant());
     post_construction_initialization();

  // Test the isSgEmptyDirectiveStatement() function since it has been problematic
     assert(isSgEmptyDirectiveStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgClinkageDeclarationStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClinkageDeclarationStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClinkageDeclarationStatement::variantT() const {
  return V_SgClinkageDeclarationStatement;
}

#if 0
int
SgClinkageDeclarationStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return C_LINKAGE_DECLARATION_STMT;
   }
#endif

const char*
SgClinkageDeclarationStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClinkageDeclarationStatement";  
   }

std::string
SgClinkageDeclarationStatement::class_name() const
   {
     assert(this != NULL);
     return "SgClinkageDeclarationStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClinkageDeclarationStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClinkageDeclarationStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != C_LINKAGE_DECLARATION_STMT)
        {
          printf ("Error in SgClinkageDeclarationStatement::error(): SgClinkageDeclarationStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClinkageDeclarationStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == C_LINKAGE_DECLARATION_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClinkageDeclarationStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClinkageDeclarationStatement::variant() const \n");
#endif
     assert(this != NULL);
     return C_LINKAGE_DECLARATION_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClinkageDeclarationStatement* isSgClinkageDeclarationStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClinkageDeclarationStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClinkageDeclarationStatement* isSgClinkageDeclarationStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClinkageDeclarationStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClinkageDeclarationStatement::~SgClinkageDeclarationStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgClinkageDeclarationStatement::~SgClinkageDeclarationStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for languageSpecifier
     p_languageSpecifier = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClinkageDeclarationStatement::SgClinkageDeclarationStatement ( Sg_File_Info* startOfConstruct )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClinkageDeclarationStatement::SgClinkageDeclarationStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_languageSpecifier = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(C_LINKAGE_DECLARATION_STMT == variant());
     post_construction_initialization();

  // Test the isSgClinkageDeclarationStatement() function since it has been problematic
     assert(isSgClinkageDeclarationStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgClinkageStartStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClinkageStartStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClinkageStartStatement::variantT() const {
  return V_SgClinkageStartStatement;
}

#if 0
int
SgClinkageStartStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return C_LINKAGE_START_STMT;
   }
#endif

const char*
SgClinkageStartStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClinkageStartStatement";  
   }

std::string
SgClinkageStartStatement::class_name() const
   {
     assert(this != NULL);
     return "SgClinkageStartStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClinkageStartStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClinkageStartStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != C_LINKAGE_START_STMT)
        {
          printf ("Error in SgClinkageStartStatement::error(): SgClinkageStartStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClinkageStartStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == C_LINKAGE_START_STMT);
     return SgClinkageDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClinkageStartStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClinkageStartStatement::variant() const \n");
#endif
     assert(this != NULL);
     return C_LINKAGE_START_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClinkageStartStatement* isSgClinkageStartStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClinkageStartStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClinkageStartStatement* isSgClinkageStartStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClinkageStartStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClinkageStartStatement::~SgClinkageStartStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgClinkageStartStatement::~SgClinkageStartStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString16
     p_dummyString16 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClinkageStartStatement::SgClinkageStartStatement ( Sg_File_Info* startOfConstruct )
   : SgClinkageDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClinkageStartStatement::SgClinkageStartStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString16 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(C_LINKAGE_START_STMT == variant());
     post_construction_initialization();

  // Test the isSgClinkageStartStatement() function since it has been problematic
     assert(isSgClinkageStartStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgClinkageEndStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClinkageEndStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClinkageEndStatement::variantT() const {
  return V_SgClinkageEndStatement;
}

#if 0
int
SgClinkageEndStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return C_LINKAGE_END_STMT;
   }
#endif

const char*
SgClinkageEndStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClinkageEndStatement";  
   }

std::string
SgClinkageEndStatement::class_name() const
   {
     assert(this != NULL);
     return "SgClinkageEndStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClinkageEndStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClinkageEndStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != C_LINKAGE_END_STMT)
        {
          printf ("Error in SgClinkageEndStatement::error(): SgClinkageEndStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClinkageEndStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == C_LINKAGE_END_STMT);
     return SgClinkageDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClinkageEndStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClinkageEndStatement::variant() const \n");
#endif
     assert(this != NULL);
     return C_LINKAGE_END_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClinkageEndStatement* isSgClinkageEndStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClinkageEndStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClinkageEndStatement* isSgClinkageEndStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClinkageEndStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClinkageEndStatement::~SgClinkageEndStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgClinkageEndStatement::~SgClinkageEndStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for dummyString17
     p_dummyString17 = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClinkageEndStatement::SgClinkageEndStatement ( Sg_File_Info* startOfConstruct )
   : SgClinkageDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClinkageEndStatement::SgClinkageEndStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_dummyString17 = "";

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(C_LINKAGE_END_STMT == variant());
     post_construction_initialization();

  // Test the isSgClinkageEndStatement() function since it has been problematic
     assert(isSgClinkageEndStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgClassDeclaration::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgClassDeclaration::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDeclaration::class_types 
SgClassDeclaration::get_class_type () const
   {
     assert (this != NULL);
     return p_class_type;
   }

void
SgClassDeclaration::set_class_type ( SgClassDeclaration::class_types class_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_class_type = class_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassType* 
SgClassDeclaration::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgClassDeclaration::set_type ( SgClassType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDefinition* 
SgClassDeclaration::get_definition () const
   {
     assert (this != NULL);
     return p_definition;
   }

void
SgClassDeclaration::set_definition ( SgClassDefinition* definition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_definition != NULL && definition != NULL && p_definition != definition)
        {
          printf ("Warning: definition = %p overwriting valid pointer p_definition = %p \n",definition,p_definition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_definition != NULL && definition != NULL && p_definition != definition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_definition = definition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgClassDeclaration::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgClassDeclaration::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement::template_specialization_enum 
SgClassDeclaration::get_specialization () const
   {
     assert (this != NULL);
     return p_specialization;
   }

void
SgClassDeclaration::set_specialization ( SgDeclarationStatement::template_specialization_enum specialization )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_specialization = specialization;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgClassDeclaration::get_from_template () const
   {
     assert (this != NULL);
     return p_from_template;
   }

void
SgClassDeclaration::set_from_template ( bool from_template )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_from_template = from_template;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgClassDeclaration::get_fixupScope () const
   {
     assert (this != NULL);
     return p_fixupScope;
   }

void
SgClassDeclaration::set_fixupScope ( bool fixupScope )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_fixupScope = fixupScope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgClassDeclaration::get_isUnNamed () const
   {
     assert (this != NULL);
     return p_isUnNamed;
   }

void
SgClassDeclaration::set_isUnNamed ( bool isUnNamed )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_isUnNamed = isUnNamed;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 9644 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/13/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgClassDeclaration::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgVariableDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgClassDeclaration::fixupCopy() for %p = %s copy = %p (defining = %p firstNondefining = %p) \n",
          this,this->class_name().c_str(),copy,this->get_definingDeclaration(),this->get_firstNondefiningDeclaration());
#endif

  // Call the base class fixupCopy member function
     SgDeclarationStatement::fixupCopy(copy,help);

     SgClassDeclaration* classDeclaration_copy = isSgClassDeclaration(copy);
     ROSE_ASSERT(classDeclaration_copy != NULL);

     SgClassDefinition* classDefinition_original = this->get_definition();
     SgClassDefinition* classDefinition_copy     = classDeclaration_copy->get_definition();

     if (isForward() == false)
        {
          classDefinition_original->fixupCopy(classDefinition_copy,help);
        }

     if (this == this->get_definingDeclaration())
        {
       // This is the defining class declaration, we want to build a non-defiing declaration to go with this.
       // Let the copying of the defining declaration trigger the construction of a non-defining declaration.

          printf ("This is the defining declaration, so build a copy of the nondefining declaration! \n");
#if 0
       // SgClassDeclaration* firstNondefiningDeclaration = this->copy(help);
          SgClassDeclaration* firstNondefiningDeclaration_original = isSgClassDeclaration(this->get_firstNondefiningDeclaration());
          ROSE_ASSERT(firstNondefiningDeclaration_original != NULL);
          SgClassDeclaration* firstNondefiningDeclaration_copy     = isSgClassDeclaration(firstNondefiningDeclaration_original->copy(help));
#else
          SgClassDeclaration* firstNondefiningDeclaration_copy = new SgClassDeclaration(this->get_name(),this->get_class_type(),this->get_type(),classDefinition_copy);

       // Details that have to be set when building a SgClassDeclaration IR node.

          printf ("***** Setting the scope in the firstNondefiningDeclaration_copy = %p \n",firstNondefiningDeclaration_copy);
          ROSE_ASSERT(classDeclaration_copy->get_scope() != NULL);
          firstNondefiningDeclaration_copy->set_scope(classDeclaration_copy->get_scope());

          printf ("***** Setting the parent in the firstNondefiningDeclaration_copy = %p \n",firstNondefiningDeclaration_copy);
          ROSE_ASSERT(classDeclaration_copy->get_parent() != NULL);
          firstNondefiningDeclaration_copy->set_parent(classDeclaration_copy->get_parent());

          firstNondefiningDeclaration_copy->setForward();
          firstNondefiningDeclaration_copy->set_definingDeclaration(classDeclaration_copy);

          SgClassDeclaration* firstNondefiningDeclaration_original = isSgClassDeclaration(this->get_firstNondefiningDeclaration());

          firstNondefiningDeclaration_copy->set_startOfConstruct( new Sg_File_Info( *(firstNondefiningDeclaration_original->get_startOfConstruct()) ) );
          firstNondefiningDeclaration_copy->set_endOfConstruct( new Sg_File_Info( *(firstNondefiningDeclaration_original->get_endOfConstruct()) ) );

       // If the original firstNondefiningDeclaration points to itself as the firstNondefiningDeclaration then set the copy to point to itself as well.
          ROSE_ASSERT(firstNondefiningDeclaration_original != NULL);
          if (firstNondefiningDeclaration_original == firstNondefiningDeclaration_original->get_firstNondefiningDeclaration())
             {
               firstNondefiningDeclaration_copy->set_firstNondefiningDeclaration(firstNondefiningDeclaration_copy);
             }
#endif
          ROSE_ASSERT(firstNondefiningDeclaration_copy != NULL);
          classDeclaration_copy->set_firstNondefiningDeclaration(firstNondefiningDeclaration_copy);
        }
   }
#endif

unsigned int
SgClassDeclaration::cfgIndexForEnd() const {
  return 0;
}

std::vector<VirtualCFG::CFGEdge> SgClassDeclaration::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgClassDeclaration::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}

void
SgClassDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which 
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.
#if 0
     if (get_type())
          get_type()->set_declaration(this);
       else	
          set_type(SgClassType::createType(this)); 
#else
  // Only build a type if one does not exist
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgClassDeclaration::post_construction_initialization(): generating the SgClassType internally (from the declaration) \n");
#endif
#endif
          set_type(SgClassType::createType(this));
        }
     
#endif
   }

// SgStatement *get_first() const;

bool
SgClassDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
{
  return false;
}

SgName
SgClassDeclaration::get_qualified_name() const
   {
  //! \todo Find out why qualified name generation requires a special case for unions.

  // DQ (9/27/2004): This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgClassDeclaration::get_qualified_name() name = %s isUnion = %s \n",get_name().str(),(isUnion == true) ? "true" : "false") ;

     SgName returnName;

#if 1
  // DQ (6/3/2006): I think we should handle unions uniformally with structs and classes.
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);
     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
#else
  // Ignore case of a union (why?)
     bool isUnion = (get_class_type() == SgClassDeclaration::e_union);

     if (isUnion == true)
        {
       // DQ (8/28/2005): I'm not clear on why this is handles as a special case!
          printf ("In SgClassDeclaration::get_qualified_name(): Special case of union, does not include scope information! \n");
          returnName = get_name();
        }
       else
        {
       // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
          SgScopeStatement* scope = get_scope();
          ROSE_ASSERT(scope != NULL);

       // ROSE_ASSERT(get_name().is_null() == false);

       // returnName = scope->get_qualified_name() << "::" << get_name().str();
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }
#endif

  // printf ("In SgClassDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

  // ROSE_ASSERT(returnName.is_null() == false);

     return returnName;
   }

// RV (1/31/2006): Added mangler for class declarations.
SgName
SgClassDeclaration::get_mangled_name (void) const
   {
#if 0
  // return joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());

     SgName name = get_name();

  // DQ (2/8/2007): See the note in the SgEnumDeclaration::get_mangled_name() function.
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_structure_tag_name_") != std::string::npos);

  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an 
  // printf ("In SgClassDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     return joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgClassDeclaration* classDeclaration = const_cast<SgClassDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(classDeclaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgClassDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());;

       // p_globalMangledNameMap[classDeclaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgClassDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

SgName
SgClassDeclaration::get_mangled_qualified_name ( int & cnt )
   {
  // This function is called durring the construction of the SAGE AST.  As a result 
  // it currently represents a dependence of the parent pointer.

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
  // ROSE_ASSERT (get_parent() != NULL);
  // ROSE_ASSERT (get_parent() == NULL);

     SgName nm;

  // if(isSgClassDefinition(get_parent()))
     SgNode* parentNode = get_parent();
     SgClassDefinition* parentDefinition = isSgClassDefinition(parentNode);
     if (parentDefinition != NULL)
        {
       // nm = (isSgClassDefinition(get_parent())->get_mangled_qualified_name(cnt));
          nm = (parentDefinition->get_mangled_qualified_name(cnt));
       // printf ("In SgClassDeclaration::get_mangled_qualified_name(): nm = %s \n",nm.str());
        }
     cnt++;

  // DQ (4/28/2005): 
  // nm << strlen(get_name().str());
  // nm << get_name().str();

     const SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(this);
     if (templateClassDeclaration != NULL)
        {
       // Need to remove " < " and " > " from template name so that can support name mangling
       // SgName className = "_"; // Avoid leading character being a number
          SgName className;
          className << get_name().getString().size();
          className += get_name();
          nm << fixupTemplateNameForMangledNameSupport(className).str();
        }
       else
        {
          nm << get_name().getString().size();
          nm << get_name().str();
        }

#if 0
     if (parentDefinition != NULL)
        {
//        printf ("In SgClassDeclaration::get_mangled_qualified_name(cnt = %d) nm = %s \n",cnt-1,nm.str());
//        get_file_info()->display("Called from SgClassDeclaration::get_mangled_qualified_name()");
        }
#endif

     return nm;
   }

bool
SgClassDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgClassDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

// GB (09/26/2007): Added this function as part of the move to index-based traversals: We only want the definition to be
// a traversal successor if isForward is false. This used to be handled in the AstSuccessorsSelectors code, but now it
// is isolated in this function (which is used by the traversal code generated by ROSETTA).
SgClassDefinition *
SgClassDeclaration::compute_classDefinition() const
   {
     if (isForward())
        {
          return NULL;
        }
     else
        {
          return p_definition;
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 6235 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


bool
SgClassDeclaration::isSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_specialization);
     return returnValue;
   }

bool
SgClassDeclaration::isPartialSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_partial_specialization);
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassDeclaration::variantT() const {
  return V_SgClassDeclaration;
}

#if 0
int
SgClassDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CLASS_DECL_STMT;
   }
#endif

const char*
SgClassDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassDeclaration";  
   }

std::string
SgClassDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgClassDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CLASS_DECL_STMT)
        {
          printf ("Error in SgClassDeclaration::error(): SgClassDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CLASS_DECL_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return CLASS_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassDeclaration* isSgClassDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassDeclaration* isSgClassDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassDeclaration::~SgClassDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgClassDeclaration::~SgClassDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for class_type
     p_class_type = SgClassDeclaration::e_class; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for definition
     p_definition = NULL; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for specialization
     p_specialization = SgDeclarationStatement::e_no_specialization; // non list case 
  // case: not a listType for from_template
     p_from_template = false; // non list case 
  // case: not a listType for fixupScope
     p_fixupScope = false; // non list case 
  // case: not a listType for isUnNamed
     p_isUnNamed = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClassDeclaration::SgClassDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClassDeclaration::SgClassDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_class_type = class_type;
     p_type = type;
     p_definition = definition;
     p_scope = NULL;
     p_specialization = SgDeclarationStatement::e_no_specialization;
     p_from_template = false;
     p_fixupScope = false;
     p_isUnNamed = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CLASS_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgClassDeclaration() function since it has been problematic
     assert(isSgClassDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateInstantiationDecl::get_templateName () const
   {
     assert (this != NULL);
     return p_templateName;
   }

void
SgTemplateInstantiationDecl::set_templateName ( SgName templateName )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateName = templateName;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateInstantiationDecl::get_templateHeader () const
   {
     assert (this != NULL);
     return p_templateHeader;
   }

void
SgTemplateInstantiationDecl::set_templateHeader ( SgName templateHeader )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateHeader = templateHeader;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateInstantiationDecl::get_templateDeclaration () const
   {
     assert (this != NULL);
     return p_templateDeclaration;
   }

void
SgTemplateInstantiationDecl::set_templateDeclaration ( SgTemplateDeclaration* templateDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration)
        {
          printf ("Warning: templateDeclaration = %p overwriting valid pointer p_templateDeclaration = %p \n",templateDeclaration,p_templateDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_templateDeclaration = templateDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateArgumentPtrListPtr 
SgTemplateInstantiationDecl::get_templateArguments () const
   {
     assert (this != NULL);
     return p_templateArguments;
   }

void
SgTemplateInstantiationDecl::set_templateArguments ( SgTemplateArgumentPtrListPtr templateArguments )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateArguments = templateArguments;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTemplateInstantiationDecl::get_nameResetFromMangledForm () const
   {
     assert (this != NULL);
     return p_nameResetFromMangledForm;
   }

void
SgTemplateInstantiationDecl::set_nameResetFromMangledForm ( bool nameResetFromMangledForm )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nameResetFromMangledForm = nameResetFromMangledForm;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 9964 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgTemplateInstantiationDecl::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which 
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.
#if 0
     if (get_type()) 
          get_type()->set_declaration(this);
       else	
          set_type(SgClassType::createType(this)); 
#else
  // Only build a type if one does not exist
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgTemplateInstantiationDecl::post_construction_initialization(): generating the SgClassType internally (from the declaration) \n");
#endif
#endif
          set_type(SgClassType::createType(this));
        }
#endif

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
     if (p_templateArguments != NULL)
        {
          SgTemplateArgumentPtrList::iterator i = p_templateArguments->begin();
          while (i != p_templateArguments->end())
             {
               (*i)->set_parent(this);
               i++;
             }
        }
       else
        {
       // DQ (2/22/2007): This is OK sometimes, though a better implementation could likely be done to make this an error (more strict).
       // printf ("Warning (post_construction_initialization): p_templateArguments == NULL in SgTemplateInstantiationDecl = %p \n",this);
        }
   }

SgName
SgTemplateInstantiationDecl::get_qualified_name() const
   {
  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Some error checking!
     ROSE_ASSERT (get_parent() != NULL);

  // DQ (11/23/2004): This name should have been reset already (before it is used here)
     if (get_nameResetFromMangledForm() == false)
        {
       // DQ (6/26/2005): It is OK for the EDG/Sage III translation to reference the qualified names 
       // even before the names are properly set! As long as we consistantly return EDG uniquely generated 
       // names.  This will allow the symbols to be built and shared, but afterward the symbols will have 
       // be in the wrong position in the hash table since the names used to place them will have changed.

       // printf ("Warning: In SgTemplateInstantiationDecl::get_qualified_name() (at %p) get_qualified_name() (get_nameResetFromMangledForm() == false) name = %s (skipping call to reset) \n",this,get_name().str());
        }
  // ROSE_ASSERT(get_nameResetFromMangledForm() == true);

  // DQ (8/28/2005): This function previously used the template declaration as a basis for 
  // its qualified name generation.  I think this is a mistake and that the templates scope 
  // should be used instead (same as for where qualified names are generated elsewhere).

#if 0
  // printf ("In SgTemplateInstantiationDecl::get_qualified_name() name = %s \n",get_name().str());

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
     if (get_parent() == NULL)
        {
          printf ("In SgTemplateInstantiationDecl::get_qualified_name() this = %p at: \n",this);
          get_file_info()->display("Error at this location in source code!");
        }
     ROSE_ASSERT (get_parent() != NULL);

     SgName returnName;

     SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
     ROSE_ASSERT(templateDeclaration != NULL);

     returnName = SgName::assembleQualifiedName(templateDeclaration->get_qualified_name(),get_name());

     return returnName;
#else
  // printf ("In SgTemplateInstantiationDecl::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgTemplateInstantiationDecl::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }

// RV (2/1/2006): Added mangler for template instantiations.
SgName
SgTemplateInstantiationDecl::get_mangled_name (void) const
   {
#if 0
     return mangleTemplate (get_templateName (),
                            get_templateArguments (),
                            get_scope ());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationDecl* declaration = const_cast<SgTemplateInstantiationDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplate (get_templateName(),get_templateArguments(),get_scope());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationDecl*>(this),mangledName);
          return mangledName;
        }
#endif
   }

void
SgTemplateInstantiationDecl::set_definition( SgTemplateInstantiationDefn* definition )
   {
  // DQ (9/23/2004): Implement this function to hide the base class one so that the interface
  // to set_definition takes a SgTemplateInstantiationDefn instead of a SgClassDefinition.
  // Implement using explicit call to the base class set_definition function.
     SgClassDeclaration::set_definition(definition);
   }

void
SgTemplateInstantiationDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateInstantiationDecl::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateInstantiationDecl::variantT() const {
  return V_SgTemplateInstantiationDecl;
}

#if 0
int
SgTemplateInstantiationDecl::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_INST_DECL_STMT;
   }
#endif

const char*
SgTemplateInstantiationDecl::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDecl";  
   }

std::string
SgTemplateInstantiationDecl::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDecl";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateInstantiationDecl::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateInstantiationDecl::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_INST_DECL_STMT)
        {
          printf ("Error in SgTemplateInstantiationDecl::error(): SgTemplateInstantiationDecl object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateInstantiationDecl::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_INST_DECL_STMT);
     return SgClassDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateInstantiationDecl::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDecl::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_INST_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateInstantiationDecl* isSgTemplateInstantiationDecl ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateInstantiationDecl*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateInstantiationDecl* isSgTemplateInstantiationDecl ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateInstantiationDecl*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateInstantiationDecl::~SgTemplateInstantiationDecl ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateInstantiationDecl::~SgTemplateInstantiationDecl (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for templateName
     p_templateName = ""; // non list case 
  // case: not a listType for templateHeader
     p_templateHeader = ""; // non list case 
  // case: not a listType for templateDeclaration
     p_templateDeclaration = NULL; // non list case 
  // case: listType for templateArguments
  // case: listType (typeIsPointerToList == true) for templateArguments
     p_templateArguments = NULL;
  // case: not a listType for nameResetFromMangledForm
     p_nameResetFromMangledForm = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateInstantiationDecl::SgTemplateInstantiationDecl ( Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments )
   : SgClassDeclaration(startOfConstruct, name, class_type, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDecl::SgTemplateInstantiationDecl (Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments) sage_class_name() = %s \n",sage_class_name());
#endif

     p_templateName = "";
     p_templateHeader = "";
     p_templateDeclaration = templateDeclaration;
     p_templateArguments = templateArguments;
     p_nameResetFromMangledForm = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_INST_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationDecl() function since it has been problematic
     assert(isSgTemplateInstantiationDecl(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgDerivedTypeStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgDerivedTypeStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13597 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgDerivedTypeStatement::post_construction_initialization()
   {}

SgName
SgDerivedTypeStatement::get_mangled_name() const
   {
     return SgClassDeclaration::get_mangled_name();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDerivedTypeStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDerivedTypeStatement::variantT() const {
  return V_SgDerivedTypeStatement;
}

#if 0
int
SgDerivedTypeStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Derived_Type_Statement;
   }
#endif

const char*
SgDerivedTypeStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDerivedTypeStatement";  
   }

std::string
SgDerivedTypeStatement::class_name() const
   {
     assert(this != NULL);
     return "SgDerivedTypeStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDerivedTypeStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDerivedTypeStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Derived_Type_Statement)
        {
          printf ("Error in SgDerivedTypeStatement::error(): SgDerivedTypeStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDerivedTypeStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Derived_Type_Statement);
     return SgClassDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDerivedTypeStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDerivedTypeStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Derived_Type_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDerivedTypeStatement* isSgDerivedTypeStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDerivedTypeStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDerivedTypeStatement* isSgDerivedTypeStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDerivedTypeStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDerivedTypeStatement::~SgDerivedTypeStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgDerivedTypeStatement::~SgDerivedTypeStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDerivedTypeStatement::SgDerivedTypeStatement ( Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition )
   : SgClassDeclaration(startOfConstruct, name, class_type, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgDerivedTypeStatement::SgDerivedTypeStatement (Sg_File_Info* startOfConstruct, SgName name, SgClassDeclaration::class_types class_type, SgClassType* type, SgClassDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Derived_Type_Statement == variant());
     post_construction_initialization();

  // Test the isSgDerivedTypeStatement() function since it has been problematic
     assert(isSgDerivedTypeStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgFunctionDeclaration::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgFunctionDeclaration::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionParameterList* 
SgFunctionDeclaration::get_parameterList () const
   {
     assert (this != NULL);
     return p_parameterList;
   }

void
SgFunctionDeclaration::set_parameterList ( SgFunctionParameterList* parameterList )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_parameterList != NULL && parameterList != NULL && p_parameterList != parameterList)
        {
          printf ("Warning: parameterList = %p overwriting valid pointer p_parameterList = %p \n",parameterList,p_parameterList);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_parameterList != NULL && parameterList != NULL && p_parameterList != parameterList) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_parameterList = parameterList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgFunctionModifier &
SgFunctionDeclaration::get_functionModifier () const
   {
     assert (this != NULL);
     return p_functionModifier;
   }

SgFunctionModifier &
SgFunctionDeclaration::get_functionModifier () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_functionModifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgSpecialFunctionModifier &
SgFunctionDeclaration::get_specialFunctionModifier () const
   {
     assert (this != NULL);
     return p_specialFunctionModifier;
   }

SgSpecialFunctionModifier &
SgFunctionDeclaration::get_specialFunctionModifier () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_specialFunctionModifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypePtrListPtr 
SgFunctionDeclaration::get_exceptionSpecification () const
   {
     assert (this != NULL);
     return p_exceptionSpecification;
   }

void
SgFunctionDeclaration::set_exceptionSpecification ( SgTypePtrListPtr exceptionSpecification )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_exceptionSpecification = exceptionSpecification;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFunctionDeclaration::get_named_in_end_statement () const
   {
     assert (this != NULL);
     return p_named_in_end_statement;
   }

void
SgFunctionDeclaration::set_named_in_end_statement ( bool named_in_end_statement )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_named_in_end_statement = named_in_end_statement;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionType* 
SgFunctionDeclaration::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgFunctionDeclaration::set_type ( SgFunctionType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionDefinition* 
SgFunctionDeclaration::get_definition () const
   {
     assert (this != NULL);
     return p_definition;
   }

void
SgFunctionDeclaration::set_definition ( SgFunctionDefinition* definition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_definition != NULL && definition != NULL && p_definition != definition)
        {
          printf ("Warning: definition = %p overwriting valid pointer p_definition = %p \n",definition,p_definition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_definition != NULL && definition != NULL && p_definition != definition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_definition = definition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFunctionDeclaration::get_oldStyleDefinition () const
   {
     assert (this != NULL);
     return p_oldStyleDefinition;
   }

void
SgFunctionDeclaration::set_oldStyleDefinition ( bool oldStyleDefinition )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_oldStyleDefinition = oldStyleDefinition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgScopeStatement* 
SgFunctionDeclaration::get_scope () const
   {
     assert (this != NULL);
     return p_scope;
   }

void
SgFunctionDeclaration::set_scope ( SgScopeStatement* scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_scope != NULL && scope != NULL && p_scope != scope)
        {
          printf ("Warning: scope = %p overwriting valid pointer p_scope = %p \n",scope,p_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_scope != NULL && scope != NULL && p_scope != scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_scope = scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement::template_specialization_enum 
SgFunctionDeclaration::get_specialization () const
   {
     assert (this != NULL);
     return p_specialization;
   }

void
SgFunctionDeclaration::set_specialization ( SgDeclarationStatement::template_specialization_enum specialization )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_specialization = specialization;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFunctionDeclaration::get_requiresNameQualificationOnReturnType () const
   {
     assert (this != NULL);
     return p_requiresNameQualificationOnReturnType;
   }

void
SgFunctionDeclaration::set_requiresNameQualificationOnReturnType ( bool requiresNameQualificationOnReturnType )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_requiresNameQualificationOnReturnType = requiresNameQualificationOnReturnType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 7100 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
void
SgFunctionDeclaration::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
     SgFunctionDeclaration* functionDeclaration_copy = isSgFunctionDeclaration(copy);
     ROSE_ASSERT(functionDeclaration_copy != NULL);

#if DEBUG_FIXUP_COPY
     printf ("In SgFunctionDeclaration::fixupCopy(): for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Call the base class fixupCopy member function
     SgDeclarationStatement::fixupCopy(copy,help);

  // Setup the scopes of the SgInitializedName objects in the paraleter list
     ROSE_ASSERT(get_parameterList() != NULL);
     get_parameterList()->fixupCopy(functionDeclaration_copy->get_parameterList(),help);

  // Setup the details in the SgFunctionDefinition (this may have to rebuild the sysmbol table)
     if (get_definition() != NULL)
        {
          ROSE_ASSERT(isForward() == false);
          get_definition()->fixupCopy(functionDeclaration_copy->get_definition(),help);

       // If this is a declaration with a definition then it is a defining declaration
       // functionDeclaration_copy->set_definingDeclaration(functionDeclaration_copy);
        }

#if 0
     if (get_scope() == functionDeclaration_copy->get_scope())
        {
       // This is certainly not correct...
#if 0
          printf ("The scope of the AST copy and the original AST are the same. \n");
#endif
          if (get_scope() == get_parent())
             {
            // If the scope is the same as the parent in the original AST, then set the scope of the copy of the AST to it's parent, if it is set.
#if 0
               printf ("The scope of the original AST is the same as it's parent \n");
#endif
               SgNode* parent_copy = functionDeclaration_copy->get_parent();
               SgScopeStatement* scope_copy = isSgScopeStatement(parent_copy);
               if (scope_copy != NULL)
                  {
                    functionDeclaration_copy->set_scope(scope_copy);
                  }
             }
            else
             {
            // This could be a difficult scope to set, not sure what to do. This is unfinished.
               printf ("##### Error: In SgFunctionDeclaration::fixupCopy(): scope not set to parent (unfinished) ##### \n");
            // ROSE_ASSERT(false);
             }
        }
#endif
   }
#endif

unsigned int
SgFunctionDeclaration::cfgIndexForEnd() const {
  return 0;
}

// FIXME: these both assume that a function declaration is outside any
// function, which may not actually be the case.

std::vector<VirtualCFG::CFGEdge> SgFunctionDeclaration::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  // makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgFunctionDeclaration::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  // makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}

void
SgFunctionDeclaration::post_construction_initialization()
   {
  // Sg_File_Info* thisFileInfo = get_file_info();
  // ROSE_ASSERT (thisFileInfo != NULL);

  // DQ (10/25/2004): Force generation of new file info object (all such objects should be unique)
  // initialize the FunctionParameterList as an object that is refered to from FunctionDeclaration
  // Sg_File_Info* fileInfo = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (fileInfo != NULL);

  // DQ (11/12/2006): Modified to permit being called by constructor without Sg_File_Info objects.
  // DQ (7/19/2005): set parameter list on a single location (and independently of existance of function parameters)
  // p_args = new SgFunctionParameterList(fileInfo);
     SgFunctionParameterList* args = NULL;
     if (get_startOfConstruct() != NULL)
        {
          args = new SgFunctionParameterList(New_File_Info(this));
          args->get_startOfConstruct()->set_parent(args);
        }
       else
        {
       // DQ (11/12/2006): Use the new constructor.
          args = new SgFunctionParameterList();
        }
     ROSE_ASSERT (args != NULL);
     set_parameterList(args);

  // DQ (7/19/2005): set the parent explicitly
     get_parameterList()->set_parent(this);

  // DQ (3/6/2007): Set the firstNondefiningDeclaration of args to itself (this is now required 
  // for the AST consistancy tests after the AST merge).  Likely because one where a member fucntion 
  // is referenced before being declared in a class the member function was not previously visited by 
  // the AST traversal and so one of its defining or non-defining declarations was not set and after 
  // the merge this declaration is used (shared) and thus accessed where before it had been hidden.
  // DQ (3/15/2006): Let this be NULL so that it will be fixed by the fixupDeclarations function 
  // within the post processing phase.
  // DQ (9/6/2005): Since a SgFunctionParameterList is a SgDeclarationStatement we should set
  // either its defining or non-defining declaration (I choose the non-defining declaration).
  // args->set_definingDeclaration(args);
  // args->set_firstNondefiningDeclaration(args);
     args->set_firstNondefiningDeclaration(args);

  // DQ (10/25/2004): Add a ending file info object for completeness (though this is not yet 
  // initialized to the correct possition, yet).  Initially let's get them in place then we can
  // work on the accuracy afterward!
  // Sg_File_Info* endingPosition = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (endingPosition != NULL);
  // p_args->set_endOfConstruct(endingPosition);

  // DQ (7/31/2006): Explicit initialization of this data member is required!
     p_exceptionSpecification = NULL;
   }

SgType*
SgFunctionDeclaration::get_orig_return_type() const
   {
     return get_type()->get_orig_return_type();
   }

void
SgFunctionDeclaration::hasEllipses()
   {
  // Record as true!
     get_type()->set_has_ellipses(1);
   }

/* InitalizedName tuple : (SgName, DeclStmt, type, Initializer) */
SgInitializedNamePtrList::iterator 
SgFunctionDeclaration::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->insert_arg(where,what);
   }

SgInitializedNamePtrList::iterator
SgFunctionDeclaration::append_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->append_arg(what);
   }

SgInitializedNamePtrList::iterator
SgFunctionDeclaration::prepend_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->prepend_arg(what);
   }

SgInitializedNamePtrList & 
SgFunctionDeclaration::get_args() 
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->get_args();
   }

const SgInitializedNamePtrList & 
SgFunctionDeclaration::get_args() const 
   {
  // QY:11/2/04 should make sure get_parameterList() != 0
     assert(get_parameterList() != NULL);
     return get_parameterList()->get_args();
   }

// QY:11/2/04: Removed p_mangled_name member because it is always obtained from p_type anyway
// void SgFunctionDeclaration::set_mangled_name()
//   {
//     SgUnparse_Info info;
//     info.set_decl_stmt((SgDeclarationStatement *)this);
//     info.set_name(p_name);
//     info.set_PrintName();
//     if(p_type)
//          p_mangled_name=p_type->get_mangled(info);
//   }

bool
SgFunctionDeclaration::isTemplateFunction() const
   {
  // DQ (4/28/2005): This function tests for a template function. It is non-trivial because
  // we combine both non-template member functions in templated classes (or nested classes 
  // of templated classes) with member functions that are templated.

     bool returnValue = false;

     const SgTemplateInstantiationFunctionDecl *templateFunction = isSgTemplateInstantiationFunctionDecl(this);
     if (templateFunction != NULL)
        {
          returnValue = true;

       // Error checking 
          ROSE_ASSERT(templateFunction->get_templateDeclaration() != NULL);
          ROSE_ASSERT(templateFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
        }
       else
        {
          const SgTemplateInstantiationMemberFunctionDecl *templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateMemberFunction != NULL)
             {
            // This is a template member function but we need to know if it is a member 
            // function of a template class or a template function in a non template class.
               SgTemplateDeclaration *templateDeclaration = templateMemberFunction->get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);

            // printf ("type of template declaration = %d \n",templateDeclaration->get_template_kind());
#if 0
               SgTemplateParameterPtrList *templateParameterList = templateDeclaration->get_templateParameters();
               if (templateParameterList == NULL)
                  {
                    printf ("Null pointer to SgTemplateParameterPtrList in template declaration \n");
                  }
                 else
                  {
                    int numberOfTemplateParameters = templateParameterList->size();
                    printf ("Number of template parameters = %d \n",numberOfTemplateParameters);
                  }
            // ROSE_ASSERT(templateParameterList != NULL);
#endif
               ROSE_ASSERT(templateMemberFunction->get_templateArguments() != NULL);
               int numberOfTemplateArguments  = templateMemberFunction->get_templateArguments()->size();

            // printf ("Number of template arguments  = %d \n",numberOfTemplateArguments);

               if (numberOfTemplateArguments == 0)
                  {
                 // This is the case of a non-template member function in a templated class or nested class of a templated class!
                 // printf ("This is the case of a non-template member function in a templated class or nested class of a templated class \n");
                    returnValue = false;

                 // Error checking
                    ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);

                 // DQ (8/12/2005): This can also be a template declaration for a class (at least where the template declaration is stringified presently)
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_class /* 2 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_m_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }

                 // DQ (12/14/2005): Added acceptable case of e_template_m_class.
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_class /* 2 */);
                  }
                 else
                  {
                 // printf ("This is a valid templated member function! numberOfTemplateArguments = %d \n",numberOfTemplateArguments);
                    returnValue = true;

                 // Error checking
                    ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */);
                  }

            // printf ("type of template declaration = %d returnValue = %s \n",templateDeclaration->get_template_kind(),returnValue ? "true" : "false");
             }
        }

     return returnValue;
   }


// DQ (2/7/2006): New version added by Rich Vuduc
SgName
SgFunctionDeclaration::get_mangled_name() const
   {
  // RV (1/31/2006): Changed this routine to include the name
  // qualification in the mangled name, to guarantee the returned
  // string identifies a function uniquely. Moreover, the
  // SgMemberFunctionDeclaration child class then automatically
  // inherits the correct behavior.
  //! \todo Update ROSE manual to document the revised mangling scheme.

  // DQ (4/27/2005): I have considered making this the qualified
  // name, but decided against it. See notes in the ROSE manual
  // appendix about mangled names and qualified names.

     ROSE_ASSERT(this != NULL);

#if 0
#if SKIP_MANGLED_NAME_CACHING
  // Compute a mangled name from this function's type
     SgName type_name;
     SgName ret_type_name;
     const SgFunctionType* func_type = get_type();
     if (func_type != NULL)
        {
          type_name = func_type->get_mangled();
          const SgType* ret_type = func_type->get_return_type();
          if (ret_type)
               ret_type_name = ret_type->get_mangled();
        }
       else
          type_name = "defaultFunctionTypeName";
 
  // This function's name, transformed.
     SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
  // Compute the name qualification, if any.
     const SgScopeStatement* par_scope = get_scope();
     SgName scope_name = mangleQualifiers(par_scope);
 
  // Compute the final mangled name.
     return joinMangledQualifiers (scope_name, func_name + "__" + type_name);
#else
  // DQ (10/6/2006): Added support for mangled name caching!
  // SgGlobal* globalScope = TransformationSupport::getGlobalScope(this);
  // std::map<SgNode*,std::string> & mangledNameCache = globalScope->get_mangledNameCache();
  // Build an iterator
  // std::map<SgNode*,std::string>::iterator i = mangledNameCache.find(this);

     SgName mangledName;

     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // get the precomputed mangled name!
          mangledName = mangledNameString.c_str();
       // printf ("Mangled name found \n");
        }
       else
        {
       // Compute a mangled name from this function's type
          SgName type_name;
          SgName ret_type_name;
          const SgFunctionType* func_type = get_type();
          if (func_type != NULL)
             {
               type_name = func_type->get_mangled();
               const SgType* ret_type = func_type->get_return_type();
               if (ret_type)
                    ret_type_name = ret_type->get_mangled();
             }
            else
             {
               type_name = "defaultFunctionTypeName";
             }
 
       // This function's name, transformed.
          SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
       // Compute the name qualification, if any.
          const SgScopeStatement* par_scope = get_scope();
          SgName scope_name = mangleQualifiers(par_scope);
 
       // Compute the final mangled name.
          mangledName = joinMangledQualifiers (scope_name, func_name + "__" + type_name);

       // Add this mangled name to the cache of mangled names
       // mangledNameCache[this] = string(mangledName.str());
       // mangledNameCache.insert ( pair<SgNode*,std::string>( this , string(mangledName.str()) ) );
       // printf ("Mangled name will be added to the cache! \n");

          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionDeclaration*>(this),mangledName);
        }

     return mangledName;
#endif

#else
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionDeclaration* function = const_cast<SgFunctionDeclaration*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(function);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // Compute a mangled name from this function's type
          SgName type_name;
          SgName ret_type_name;
          const SgFunctionType* func_type = get_type();
          if (func_type != NULL)
             {
               type_name = func_type->get_mangled();
               const SgType* ret_type = func_type->get_return_type();
               if (ret_type)
                    ret_type_name = ret_type->get_mangled();
             }
            else
             {
               type_name = "defaultFunctionTypeName";
             }
 
       // This function's name, transformed.
          SgName func_name = mangleFunctionName (get_name(), ret_type_name);
 
       // Compute the name qualification, if any.
          const SgScopeStatement* par_scope = get_scope();
          SgName scope_name = mangleQualifiers(par_scope);

       // Compute the final mangled name.
          mangledName = joinMangledQualifiers (scope_name, func_name + "__" + type_name);

       // p_globalMangledNameMap[function] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

#if 0
// Old code
SgName
SgFunctionDeclaration::get_mangled_name() const
   {
  // DQ (10/24/2003): fix for mangle names. Default value specified 
  //                  caused set_mangled_name() to not be called properly.
  // if(p_mangled_name.is_null())
  //   if (p_mangled_name == "defaultName")
  //        set_mangled_name();
  //   return p_mangled_name;

     SgName returnName;

  // QY: 11/2/04 go through p_type;  if p_type == 0, return "defaultname"? (as in the old version)
     if (get_type() != NULL)
        {
          SgUnparse_Info info;
          info.set_decl_stmt( const_cast<SgFunctionDeclaration*>(this));

       // DQ (4/28/2005): Need to filter out the use of template names and convert them to something 
       // that can appear in a mangled name!
       // DQ (4/27/2005): I have considered making this the qualified name, but decided against it.
       // see notes in the ROSE manual appendix about mangled names and qualified names.
       // info.set_name(get_name());

          const SgTemplateInstantiationFunctionDecl       *templateFunction       = isSgTemplateInstantiationFunctionDecl(this);
          const SgTemplateInstantiationMemberFunctionDecl *templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);

       // SgName functionName = "_";  // Avoid numbers in leading character of names
       // functionName += get_name();
          SgName functionName = get_name().str();
#if 0
          if (templateMemberFunction == NULL && templateFunction == NULL)
             {
               printf ("This is not a template function = %s \n",functionName.str());
             }
#endif
          if (templateMemberFunction != NULL)
             {
            // This is a template member function but we need to know if it is a member 
            // function of a template class or a template function in a non template class.
            // printf ("Found a templated member function name = %s \n",functionName.str());
               if (templateMemberFunction->isTemplateFunction() == true)
                  {
                 // functionName = "memberfunction" + functionName;
                    functionName = fixupTemplateNameForMangledNameSupport(functionName);
                  }
                 else
                  {
                    string f = functionName.str();
                    if (f.find("<") != string::npos)
                       {
                      // printf ("Found template syntax in a non template member function! \n");
                         functionName = fixupTemplateNameForMangledNameSupport(functionName);
                       }
#if 0
                    f = functionName.str();
                    ROSE_ASSERT (f.find("<") == string::npos);
                    ROSE_ASSERT (f.find(">") == string::npos);
#endif
                  }
#if 0
               string f = functionName.str();
               ROSE_ASSERT (f.find("<") == string::npos);
               ROSE_ASSERT (f.find(">") == string::npos);
#endif
            }

          if (templateFunction != NULL)
             {
            // This is a template and it has a name in template form (e.g. templateName < templateArgument >)
            // what we need is a form which is more appropriate to name mangling.
            // printf ("Found a templated function name = %s \n",functionName.str());
            // functionName = "function" + functionName;
               functionName = fixupTemplateNameForMangledNameSupport(functionName);

            // string f = functionName.str();
            // ROSE_ASSERT (f.find("<") == string::npos);
            // ROSE_ASSERT (f.find(">") == string::npos);
             }

       // string f = functionName.str();
       // ROSE_ASSERT (f.find("<") == string::npos);
       // ROSE_ASSERT (f.find(">") == string::npos);

       // functionName = "_" + functionName;

          info.set_name(functionName);

          info.set_PrintName();

       // printf ("In SgFunctionDeclaration::get_mangled_name()get_type() = %s \n",get_type()->sage_class_name());

          returnName = get_type()->get_mangled(info);
        }
       else
        {
          returnName = "defaultFunctionTypeName";
        }

     string mangledName = returnName.str();

  // printf ("In SgFunctionDeclaration::get_mangled_name() mangledName = %s \n",mangledName.c_str());

     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

     return returnName;
   }
#endif

// SgStatement* get_next(int&) const;

bool
SgFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_definition, target, newstmt) == true )
          return true;
     else
          return ( StatementReplace(this, p_parameterList, target, newstmt) == true );
   }

#if 0
// DQ (8/18/2004): Removing older attribute mechanism

/******  SgFunctionDeclaration ******/
/* suppress the printing of atomic keyword */
int
get_suppress_atomic (SgFunctionDeclaration *node)
   {
     SgFuncDecl_attr *attr= 
         (SgFuncDecl_attr *) Sgget_user_attribute 
              (node->get_uattributes(),"SgFuncDecl_attr");
     if(attr)
        return attr->get_suppress_atomic();

     return 0;
   }
#endif

// DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
// for example: "template <typename T> class X { X(); }; X<int>::X() {}"

// DQ (10/20/2004): This function should be different from those that are automatically generated 
// via ROSETTA.  In the case of a constructor or destructor the class name should be used.  This 
// is particularly important in the case of constructors and destructors of templated classes since 
// the mangled form or the templae class should not be used since it will not allow the generated 
// code to compile.  Instead of names of the form "ABC____L8" we want names of the form "ABC<int>".
// These functions are now implemented explicitly instead of being automatically generated via ROSETTA.
// SgName get_name() const
//    {
//      SgName returnName = p_name;
//      if ( get_specialFunctionModifier().isConstructor() || 
//           get_specialFunctionModifier().isDestructor()  ||
//           get_specialFunctionModifier().isConversion() )
//         {
//            printf ("In SgFunctionDeclaration::get_name: case of a constructor, destructor or conversion operator \n");
//            returnName = "Use the class Name";
//         }
//      
//      return returnName;
//    }

// SgName SgFunctionDeclaration::get_qualified_name(); 
SgName
SgFunctionDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     return returnName;
   }


bool
SgFunctionDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgFunctionDeclaration::get_symbol_from_symbol_table() const
   {
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
     printf ("In SgFunctionDeclaration::get_symbol_from_symbol_table(): this = %p = %s = %s scope = %p = %s scope->get_symbol_table() = %p \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),scope,scope->class_name().c_str(),scope->get_symbol_table());
#endif
     return scope->get_symbol_table()->find(this);

  // ROSE_ASSERT(get_scope() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 6235 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


bool
SgFunctionDeclaration::isSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_specialization);
     return returnValue;
   }

bool
SgFunctionDeclaration::isPartialSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_partial_specialization);
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionDeclaration::variantT() const {
  return V_SgFunctionDeclaration;
}

#if 0
int
SgFunctionDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNC_DECL_STMT;
   }
#endif

const char*
SgFunctionDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionDeclaration";  
   }

std::string
SgFunctionDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNC_DECL_STMT)
        {
          printf ("Error in SgFunctionDeclaration::error(): SgFunctionDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNC_DECL_STMT);
     return SgDeclarationStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return FUNC_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionDeclaration* isSgFunctionDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionDeclaration* isSgFunctionDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionDeclaration::~SgFunctionDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionDeclaration::~SgFunctionDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for parameterList
     p_parameterList = NULL; // non list case 
  // case: not a listType for named_in_end_statement
     p_named_in_end_statement = false; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 
  // case: not a listType for definition
     p_definition = NULL; // non list case 
  // case: not a listType for oldStyleDefinition
     p_oldStyleDefinition = false; // non list case 
  // case: not a listType for scope
     p_scope = NULL; // non list case 
  // case: not a listType for specialization
     p_specialization = SgDeclarationStatement::e_no_specialization; // non list case 
  // case: not a listType for requiresNameQualificationOnReturnType
     p_requiresNameQualificationOnReturnType = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionDeclaration::SgFunctionDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
   : SgDeclarationStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFunctionDeclaration::SgFunctionDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_parameterList = NULL;
     p_named_in_end_statement = false;
     p_type = type;
     p_definition = definition;
     p_oldStyleDefinition = false;
     p_scope = NULL;
     p_specialization = SgDeclarationStatement::e_no_specialization;
     p_requiresNameQualificationOnReturnType = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNC_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgFunctionDeclaration() function since it has been problematic
     assert(isSgFunctionDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateInstantiationFunctionDecl::get_templateName () const
   {
     assert (this != NULL);
     return p_templateName;
   }

void
SgTemplateInstantiationFunctionDecl::set_templateName ( SgName templateName )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateName = templateName;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateInstantiationFunctionDecl::get_templateDeclaration () const
   {
     assert (this != NULL);
     return p_templateDeclaration;
   }

void
SgTemplateInstantiationFunctionDecl::set_templateDeclaration ( SgTemplateDeclaration* templateDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration)
        {
          printf ("Warning: templateDeclaration = %p overwriting valid pointer p_templateDeclaration = %p \n",templateDeclaration,p_templateDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_templateDeclaration = templateDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateArgumentPtrListPtr 
SgTemplateInstantiationFunctionDecl::get_templateArguments () const
   {
     assert (this != NULL);
     return p_templateArguments;
   }

void
SgTemplateInstantiationFunctionDecl::set_templateArguments ( SgTemplateArgumentPtrListPtr templateArguments )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateArguments = templateArguments;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTemplateInstantiationFunctionDecl::get_nameResetFromMangledForm () const
   {
     assert (this != NULL);
     return p_nameResetFromMangledForm;
   }

void
SgTemplateInstantiationFunctionDecl::set_nameResetFromMangledForm ( bool nameResetFromMangledForm )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nameResetFromMangledForm = nameResetFromMangledForm;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10131 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgTemplateInstantiationFunctionDecl::post_construction_initialization()
   {
  // DQ (4/19/2005): Removed since it is redundant with the define of the template support in ROSE
  // set_from_template(true);

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
     if (p_templateArguments != NULL)
        {
          SgTemplateArgumentPtrList::iterator i = p_templateArguments->begin();
          while (i != p_templateArguments->end())
             {
               (*i)->set_parent(this);
               i++;
             }
        }
       else
        {
          printf ("Warning (post_construction_initialization): p_templateArguments == NULL in SgTemplateInstantiationFunctionDecl = %p \n",this);
        }
   }

void
SgTemplateInstantiationFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template function instantiations.
SgName
SgTemplateInstantiationFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationFunctionDecl* declaration = const_cast<SgTemplateInstantiationFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this),mangledName);
          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateInstantiationFunctionDecl::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateInstantiationFunctionDecl::variantT() const {
  return V_SgTemplateInstantiationFunctionDecl;
}

#if 0
int
SgTemplateInstantiationFunctionDecl::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_INST_FUNCTION_DECL_STMT;
   }
#endif

const char*
SgTemplateInstantiationFunctionDecl::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationFunctionDecl";  
   }

std::string
SgTemplateInstantiationFunctionDecl::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationFunctionDecl";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateInstantiationFunctionDecl::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateInstantiationFunctionDecl::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_INST_FUNCTION_DECL_STMT)
        {
          printf ("Error in SgTemplateInstantiationFunctionDecl::error(): SgTemplateInstantiationFunctionDecl object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateInstantiationFunctionDecl::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_INST_FUNCTION_DECL_STMT);
     return SgFunctionDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateInstantiationFunctionDecl::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationFunctionDecl::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_INST_FUNCTION_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateInstantiationFunctionDecl* isSgTemplateInstantiationFunctionDecl ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateInstantiationFunctionDecl*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateInstantiationFunctionDecl* isSgTemplateInstantiationFunctionDecl ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateInstantiationFunctionDecl*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateInstantiationFunctionDecl::~SgTemplateInstantiationFunctionDecl ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateInstantiationFunctionDecl::~SgTemplateInstantiationFunctionDecl (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for templateName
     p_templateName = ""; // non list case 
  // case: not a listType for templateDeclaration
     p_templateDeclaration = NULL; // non list case 
  // case: listType for templateArguments
  // case: listType (typeIsPointerToList == true) for templateArguments
     p_templateArguments = NULL;
  // case: not a listType for nameResetFromMangledForm
     p_nameResetFromMangledForm = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateInstantiationFunctionDecl::SgTemplateInstantiationFunctionDecl ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments )
   : SgFunctionDeclaration(startOfConstruct, name, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationFunctionDecl::SgTemplateInstantiationFunctionDecl (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments) sage_class_name() = %s \n",sage_class_name());
#endif

     p_templateName = "";
     p_templateDeclaration = templateDeclaration;
     p_templateArguments = templateArguments;
     p_nameResetFromMangledForm = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_INST_FUNCTION_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationFunctionDecl() function since it has been problematic
     assert(isSgTemplateInstantiationFunctionDecl(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgProgramHeaderStatement::get_program_statement_explicit () const
   {
     assert (this != NULL);
     return p_program_statement_explicit;
   }

void
SgProgramHeaderStatement::set_program_statement_explicit ( bool program_statement_explicit )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_program_statement_explicit = program_statement_explicit;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgProgramHeaderStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgProgramHeaderStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12835 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgProgramHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProgramHeaderStatement::get_mangled_name() const
   {
  // DQ (8/17/2007): This Fortran specific IR node can be as simple a mangled name as we like, I think.

  // printf ("SgProgramHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
  // return get_name();
     return SgFunctionDeclaration::get_mangled_name();
   }

#if 0
// DQ (3/20/2007): This should be removed, it is not required.
SgName 
SgProgramHeaderStatement::get_name () const
   {
     return p_name;
   }

void
SgProgramHeaderStatement::set_name ( SgName name )
   {
     set_isModified(true);
     p_name = name;
   }

SgFunctionType* 
SgProgramHeaderStatement::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgProgramHeaderStatement::set_type ( SgFunctionType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     p_type = type;
     /* 
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (type != NULL)
          type->set_parent(this);
#endif */
   }

SgType* SgProgramHeaderStatement::get_orig_return_type() const
{
  return get_type()->get_orig_return_type();
}

void
SgProgramHeaderStatement::hasEllipses()
   {
  // Record as true!
     get_type()->set_has_ellipses(1);
   }

/* IniitalizedName tuple : (SgName, DeclStmt, type, Initializer) */
SgInitializedNamePtrList::iterator 
SgProgramHeaderStatement::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->insert_arg(where,what);
   }

SgInitializedNamePtrList::iterator
SgProgramHeaderStatement::append_arg( SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->append_arg(what);
   }

SgInitializedNamePtrList::iterator
SgProgramHeaderStatement::prepend_arg( SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->prepend_arg(what);
   }
#endif

bool
SgProgramHeaderStatement::replace_child(SgStatement *target, SgStatement *newstmt, bool extractBasicBlock)
   {
     if(StatementReplace(this, p_definition, target, newstmt))
          return true;
     else
          return (StatementReplace(this, p_parameterList, target, newstmt));
   }

#if 0
// DQ (8/18/2004): Removing older attribute mechanism

/******  SgFunctionDeclaration ******/
/* suppress the printing of atomic keyword */
int
get_suppress_atomic (SgProgramHeaderStatement *node)
   {
     SgFuncDecl_attr *attr= 
         (SgFuncDecl_attr *) Sgget_user_attribute 
              (node->get_uattributes(),"SgFuncDecl_attr");
     if(attr)
        return attr->get_suppress_atomic();

     return 0;
   }
#endif

#if 0
SgInitializedNamePtrList & 
SgProgramHeaderStatement::get_args() 
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->get_args();
   }

const SgInitializedNamePtrList & 
SgProgramHeaderStatement::get_args() const 
   {
  // QY:11/2/04 should make sure get_parameterList() != 0
     assert(get_parameterList() != NULL);
     return get_parameterList()->get_args();
   }

void
SgProgramHeaderStatement::set_parameterList ( SgFunctionParameterList* parameterList )
   {
     assert (this != NULL);
     set_isModified(true);
     p_parameterList = parameterList;
     /* 
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (parameterList != NULL)
          parameterList->set_parent(this);
#endif */
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgProgramHeaderStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgProgramHeaderStatement::variantT() const {
  return V_SgProgramHeaderStatement;
}

#if 0
int
SgProgramHeaderStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PROGRAM_HEADER_STMT;
   }
#endif

const char*
SgProgramHeaderStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgProgramHeaderStatement";  
   }

std::string
SgProgramHeaderStatement::class_name() const
   {
     assert(this != NULL);
     return "SgProgramHeaderStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgProgramHeaderStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgProgramHeaderStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PROGRAM_HEADER_STMT)
        {
          printf ("Error in SgProgramHeaderStatement::error(): SgProgramHeaderStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgProgramHeaderStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PROGRAM_HEADER_STMT);
     return SgFunctionDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgProgramHeaderStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgProgramHeaderStatement::variant() const \n");
#endif
     assert(this != NULL);
     return PROGRAM_HEADER_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgProgramHeaderStatement* isSgProgramHeaderStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgProgramHeaderStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgProgramHeaderStatement* isSgProgramHeaderStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgProgramHeaderStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgProgramHeaderStatement::~SgProgramHeaderStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgProgramHeaderStatement::~SgProgramHeaderStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for program_statement_explicit
     p_program_statement_explicit = false; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgProgramHeaderStatement::SgProgramHeaderStatement ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
   : SgFunctionDeclaration(startOfConstruct, name, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgProgramHeaderStatement::SgProgramHeaderStatement (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_program_statement_explicit = false;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(PROGRAM_HEADER_STMT == variant());
     post_construction_initialization();

  // Test the isSgProgramHeaderStatement() function since it has been problematic
     assert(isSgProgramHeaderStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgProcedureHeaderStatement::subprogram_kind_enum 
SgProcedureHeaderStatement::get_subprogram_kind () const
   {
     assert (this != NULL);
     return p_subprogram_kind;
   }

void
SgProcedureHeaderStatement::set_subprogram_kind ( SgProcedureHeaderStatement::subprogram_kind_enum subprogram_kind )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_subprogram_kind = subprogram_kind;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgProcedureHeaderStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgProcedureHeaderStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12992 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgProcedureHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProcedureHeaderStatement::get_mangled_name() const
   {
  // DQ (8/23/2007): Use the get_mangled_name() member function from the base class.
  // printf ("SgProcedureHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
     return SgFunctionDeclaration::get_mangled_name();
   }

bool
SgProcedureHeaderStatement::isFunction() const
   {
     bool result = false;
     if (p_subprogram_kind == e_function_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isSubroutine() const
   {
     bool result = false;
     if (p_subprogram_kind == e_subroutine_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isBlockData() const
   {
     bool result = false;
     if (p_subprogram_kind == e_block_data_subprogram_kind)
        result = true;

     return result;
   }

#if 0
// DQ (3/20/2007): These are automatically generated so they need not be defined exxplicitly
SgName 
SgProcedureHeaderStatement::get_name () const
   {
     return p_name;
   }

void
SgProcedureHeaderStatement::set_name ( SgName name )
   {
     set_isModified(true);
     p_name = name;
   }

SgFunctionType* 
SgProcedureHeaderStatement::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgProcedureHeaderStatement::set_type ( SgFunctionType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     p_type = type;
     /* 
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (type != NULL)
          type->set_parent(this);
#endif */
   }

SgType* SgProcedureHeaderStatement::get_orig_return_type() const
{
  return get_type()->get_orig_return_type();
}

void
SgProcedureHeaderStatement::hasEllipses()
   {
  // Record as true!
     get_type()->set_has_ellipses(1);
   }
#endif


#if 0
// DQ (3/20/2007): This should use the one in SgFunctionDefinition (base class)
/* IniitalizedName tuple : (SgName, DeclStmt, type, Initializer) */
SgInitializedNamePtrList::iterator 
SgProcedureHeaderStatement::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->insert_arg(where,what);
   }

SgInitializedNamePtrList::iterator
SgProcedureHeaderStatement::append_arg( SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->append_arg(what);
   }

SgInitializedNamePtrList::iterator
SgProcedureHeaderStatement::prepend_arg( SgInitializedName* what)
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->prepend_arg(what);
   }
#endif

#if 0
// DQ (3/20/2007): This should use the one in SgFunctionDefinition (base class)
// This references the definition which does not exist.
bool
SgProcedureHeaderStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if(StatementReplace(this, p_definition, target, newstmt))
          return true;
       else
          return (StatementReplace(this, p_parameterList, target, newstmt));
   }
#endif

#if 0
// DQ (8/18/2004): Removing older attribute mechanism

/******  SgFunctionDeclaration ******/
/* suppress the printing of atomic keyword */
int
get_suppress_atomic (SgProcedureHeaderStatement *node)
   {
     SgFuncDecl_attr *attr= 
         (SgFuncDecl_attr *) Sgget_user_attribute 
              (node->get_uattributes(),"SgFuncDecl_attr");
     if(attr)
        return attr->get_suppress_atomic();

     return 0;
   }
#endif

#if 0
SgInitializedNamePtrList & 
SgProcedureHeaderStatement::get_args() 
   {
     if (get_parameterList() == NULL) {
       set_parameterList(new SgFunctionParameterList(New_File_Info(this)));
       get_parameterList()->set_parent(this);
     }
     return get_parameterList()->get_args();
   }

const SgInitializedNamePtrList & 
SgProcedureHeaderStatement::get_args() const 
   {
  // QY:11/2/04 should make sure get_parameterList() != 0
     assert(get_parameterList() != 0);
     return get_parameterList()->get_args();
   }
#endif

#if 0
// This should be automatically generated
void
SgProcedureHeaderStatement::set_parameterList ( SgFunctionParameterList* parameterList )
   {
     assert (this != NULL);
     set_isModified(true);
     p_parameterList = parameterList;
     /* 
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (parameterList != NULL)
          parameterList->set_parent(this);
#endif */
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgProcedureHeaderStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgProcedureHeaderStatement::variantT() const {
  return V_SgProcedureHeaderStatement;
}

#if 0
int
SgProcedureHeaderStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PROCEDURE_HEADER_STMT;
   }
#endif

const char*
SgProcedureHeaderStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgProcedureHeaderStatement";  
   }

std::string
SgProcedureHeaderStatement::class_name() const
   {
     assert(this != NULL);
     return "SgProcedureHeaderStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgProcedureHeaderStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgProcedureHeaderStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PROCEDURE_HEADER_STMT)
        {
          printf ("Error in SgProcedureHeaderStatement::error(): SgProcedureHeaderStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgProcedureHeaderStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PROCEDURE_HEADER_STMT);
     return SgFunctionDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgProcedureHeaderStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgProcedureHeaderStatement::variant() const \n");
#endif
     assert(this != NULL);
     return PROCEDURE_HEADER_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgProcedureHeaderStatement* isSgProcedureHeaderStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgProcedureHeaderStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgProcedureHeaderStatement* isSgProcedureHeaderStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgProcedureHeaderStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgProcedureHeaderStatement::~SgProcedureHeaderStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgProcedureHeaderStatement::~SgProcedureHeaderStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for subprogram_kind
     p_subprogram_kind = SgProcedureHeaderStatement::e_unknown_kind; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgProcedureHeaderStatement::SgProcedureHeaderStatement ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
   : SgFunctionDeclaration(startOfConstruct, name, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgProcedureHeaderStatement::SgProcedureHeaderStatement (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_subprogram_kind = SgProcedureHeaderStatement::e_unknown_kind;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(PROCEDURE_HEADER_STMT == variant());
     post_construction_initialization();

  // Test the isSgProcedureHeaderStatement() function since it has been problematic
     assert(isSgProcedureHeaderStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgCtorInitializerList* 
SgMemberFunctionDeclaration::get_CtorInitializerList () const
   {
     assert (this != NULL);
     return p_CtorInitializerList;
   }

void
SgMemberFunctionDeclaration::set_CtorInitializerList ( SgCtorInitializerList* CtorInitializerList )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_CtorInitializerList != NULL && CtorInitializerList != NULL && p_CtorInitializerList != CtorInitializerList)
        {
          printf ("Warning: CtorInitializerList = %p overwriting valid pointer p_CtorInitializerList = %p \n",CtorInitializerList,p_CtorInitializerList);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_CtorInitializerList != NULL && CtorInitializerList != NULL && p_CtorInitializerList != CtorInitializerList) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_CtorInitializerList = CtorInitializerList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 8457 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


bool
SgMemberFunctionDeclaration::isDefinedInClass() const
   {
     bool returnValue = false;

  // If the scopes are the same then the class is structurally defined in the class scope
     bool isDefiningDeclaration  = (get_definition() != NULL);
     bool isDeclaredInClassScope = (get_parent() == get_scope());
     if ( (isDefiningDeclaration == true) && (isDeclaredInClassScope == true) )
          returnValue = true;

     return returnValue;
   }


void
SgMemberFunctionDeclaration::post_construction_initialization()
   {
  // DQ (9/15/2005): Remove side-effect from get_ctors() member function.
  // This was a problem for the AST tests where the post processing saw a 
  // NULL pointer and then the unparers was called in the rewrite mechanism 
  // and then the AST tests failed because the pointer was non-NULL (and 
  // also the SgCtorInitializerList had not been properly setup).
  // p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
     if (get_startOfConstruct() != NULL)
        {
          p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
        }
       else
        {
          p_CtorInitializerList = new SgCtorInitializerList();
        }
     ROSE_ASSERT(p_CtorInitializerList != NULL);

  // Like the "enum" declaration (SgEnumDeclaration) this can only be defined 
  // once, so it is its defining declaration.  Well, not exactly.  The uniform
  // handling of the defining and non-defining declarations requires that this
  // be set as the firstNondefining declaration.  This might be an error and 
  // should be reviewed.

  // DQ (9/20/2005): Need to set the nondefining declaration instead of the defining declaration!
  // p_CtorInitializerList->set_definingDeclaration(p_CtorInitializerList);
     p_CtorInitializerList->set_firstNondefiningDeclaration(p_CtorInitializerList);

  // DQ (9/21/2005): Added warning since this is an issue worth review! 
  // printf ("Warning: Set p_CtorInitializerList = %p firstNondefiingDeclaration to self, unclear if this is correct \n",p_CtorInitializerList);

  // DQ (9/21/2005): set the parent so that the scope will be computed correctly
  // (scope is not stored explicitly on the SgCtorInitializerList IR node).
     p_CtorInitializerList->set_parent(this);
   }

void
SgMemberFunctionDeclaration::append_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->append_ctor_initializer(iName);
   }

void
SgMemberFunctionDeclaration::prepend_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->prepend_ctor_initializer(iName);
   }

SgInitializedNamePtrList & 
SgMemberFunctionDeclaration::get_ctors()
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL) 
  //    set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     return get_CtorInitializerList()->get_ctors();
   }

const SgInitializedNamePtrList &
SgMemberFunctionDeclaration::get_ctors() const
   {
     ROSE_ASSERT(get_CtorInitializerList() != NULL);
     return get_CtorInitializerList()->get_ctors();
   }

// SgName SgMemberFunctionDeclaration::get_qualified_name(); 
SgName
SgMemberFunctionDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistant other get_qualified_name functions
  // It previously only returned the name of the class to which is was a member function!
  // printf ("In SgMemberFunctionDeclaration::get_qualified_name() name = %s \n",get_name().str());

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName (scope->get_qualified_name(), get_name ());

  // printf ("In SgMemberFunctionDeclaration::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

void
SgMemberFunctionDeclaration::set_orig_return_type(SgType *t)
   {
   // QY: removed p_orig_return_type. reset p_type by making another member function type (the original p_type might be shared?)
  // DQ (10/6/2004): Not sure why this works this way!
     ROSE_ASSERT(t != NULL);

     SgMemberFunctionType *ntype = isSgMemberFunctionType(get_type())->mkAnotherType(t);
     ROSE_ASSERT (ntype != NULL);
     set_type(ntype); // reset function type if necessary
   }

bool
SgMemberFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( SgFunctionDeclaration::replace_child(target, newstmt,extractBasicBlock) == true )
        {
          return true;
        }
       else
        {
       // Handle other possible replacements
          if ( StatementReplace(this, p_scope, target, newstmt) == true )
             {
               return true;
             }
            else
             {
               return ( StatementReplace(this, p_CtorInitializerList, target, newstmt) == true );
             }
        }
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration 
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
SgClassDeclaration* 
SgMemberFunctionDeclaration::get_associatedClassDeclaration () const
   {
     assert (this != NULL);
  // return p_associatedClassDeclaration;

     SgClassDeclaration* returnValue = NULL;

  // The p_associatedClassDeclaration is only set when the class definition is unavailable (not defined in the current 
  // translation unit) and yet there is a class declared for there to be a member function declared.  This is always 
  // the case of a pointer to a member function, since only in this case can the pointer to a member function be declared 
  // without a member function having been declared.
     if (p_associatedClassDeclaration != NULL)
        {
       // If this is a valid pointer then it is only because the class definition has not been seen (and this backup 
       // mechanism has been used to relate the member function to the class declaration).
          returnValue = p_associatedClassDeclaration;
        }
       else
        {
       // When p_associatedClassDeclaration == NULL, it is because the class definition exists (and the backup mechanism 
       // of relating the member function to the class declaration was not required) and so the class declaration can be 
       // obtained directly from the class definition.
          SgClassDefinition* scope = get_class_scope();

       // Testing ...
       // ROSE_ASSERT(scope != NULL);
          if (scope == NULL)
             {
               printf ("ERROR: retuning NULL from SgMemberFunctionDeclaration::get_associatedClassDeclaration \n");
               return NULL;
             }
            else
             {
               returnValue = scope->get_declaration();
             }
        }

     return returnValue;
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration 
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
// This SgMemberFunctionDeclaration::set_associatedClassDeclaration() member function is public so that it can be set in 
// construction of the AST.
void
SgMemberFunctionDeclaration::set_associatedClassDeclaration ( SgClassDeclaration* associatedClassDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration)
        {
          printf ("Warning: associatedClassDeclaration = %p overwriting valid pointer p_associatedClassDeclaration = %p \n",associatedClassDeclaration,p_associatedClassDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_associatedClassDeclaration = associatedClassDeclaration;
   }

SgClassDefinition* 
SgMemberFunctionDeclaration::get_class_scope(void) const
   {
  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!

  // DQ (12/5/2004): The scope is explicit and should be a vailid pointer (if not it is an error!)
  // ROSE_ASSERT(p_scope != NULL);

  // DQ (11/17/2004): Note that get_scope returns a SgScopeStatement, but member functions are always part 
  // of a SgClassDefinition and we want to reflect this and be as consistatn as possible with the former 
  // get_scope() function which was only defined on the SgMemberFunctionDeclaration but is now defined on 
  // many different IR nodes (as a result of a major bug fix specific to scopes vs. parents handling).
  // SgClassDefinition *parentScope = isSgClassDefinition(get_scope());
     SgClassDefinition* parentScope = NULL;

  // DQ (10/12/2007): Modified to access the p_associatedClassDeclaration data member directly because
  // the get_associatedClassDeclaration() member function is more than an access function (no longer built be ROSETTA).
  // DQ (7/26/2007): Member function pointers don't require a SgClassDefinition so we have no scope 
  // for such cases, to make up for this, we explicitly store the class declaration.
  // SgClassDeclaration* classDeclaration = this->get_associatedClassDeclaration();
     SgClassDeclaration* classDeclaration = this->p_associatedClassDeclaration;
     if (classDeclaration != NULL)
        {
          parentScope = NULL;
          SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(classDeclaration->get_definingDeclaration());
          if (definingClassDeclaration != NULL)
               parentScope = definingClassDeclaration->get_definition();

          if (parentScope != NULL)
             {
               printf ("SgMemberFunctionDeclaration::get_class_scope(): memberFunction = %p = %s = %s classDeclaration = %p = %s = %s \n",
                    this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),
                    classDeclaration,classDeclaration->class_name().c_str(),SageInterface::get_name(classDeclaration).c_str());
             }
       // ROSE_ASSERT(parentScope != NULL);
        }
       else
        {
       // DQ (7/26/2007): Moved from top of function
          ROSE_ASSERT(p_scope != NULL);

       // DQ (10/15/2007): Added assertion.
          ROSE_ASSERT(this->get_parent() != NULL);

       // SgClassDefinition *parentScope = isSgClassDefinition(get_scope());
          parentScope = isSgClassDefinition(get_scope());

       // The scope associated with a member function had better be a SgClassDefinition!
       // if (this->get_associatedClassDeclaration() != NULL || parentScope == NULL)
          if (parentScope == NULL)
             {
            // DQ (12/5/2004): Note that new member function declarations added from the rewrite system 
            // allow there scope to be derived from the parent node.  This results in incorrect information 
            // which is later discoved in the unparser!  Need to do a better job of setting the scoep of
            // all statements when introduced from the rewrite mechanism.

               ROSE_ASSERT(get_name().is_null() == false);
               printf ("Error in SgMemberFunctionDeclaration::get_class_scope() member function name = %s (can be incorrect due to rewrite system) \n",get_name().str());
               printf ("     get_parent() = %p = %s \n",get_parent(),(get_parent() != NULL) ? get_parent()->sage_class_name() : "NULL");
               printf ("     p_scope      = %p = %s \n",p_scope,p_scope->sage_class_name());
             }
       // ROSE_ASSERT(parentScope != NULL);
        }

  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!
  // ROSE_ASSERT(parentScope != NULL);
     return parentScope;
   }


// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgMemberFunctionDeclaration::get_symbol_from_symbol_table() const
   {
     SgSymbol* symbol = NULL;
     if (get_scope() == NULL)
        {
          printf ("In SgMemberFunctionDeclaration::get_symbol_from_symbol_table(): get_scope() == NULL for %p = %s \n",this,this->class_name().c_str());
          symbol = NULL;
        }
       else
        {
          ROSE_ASSERT(get_scope() != NULL);
          ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
          symbol = get_scope()->get_symbol_table()->find(this);
        }

     return symbol;
   }

unsigned int
SgMemberFunctionDeclaration::cfgIndexForEnd() const {
  return 0;
}

// FIXME: these both assume that a function declaration is outside any
// function, which may not actually be the case.

std::vector<VirtualCFG::CFGEdge> SgMemberFunctionDeclaration::cfgOutEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  // makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgMemberFunctionDeclaration::cfgInEdges(unsigned int idx) {
  ROSE_ASSERT (idx == 0);
  std::vector<VirtualCFG::CFGEdge> result;
  // makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  return result;
}



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMemberFunctionDeclaration::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMemberFunctionDeclaration::variantT() const {
  return V_SgMemberFunctionDeclaration;
}

#if 0
int
SgMemberFunctionDeclaration::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MFUNC_DECL_STMT;
   }
#endif

const char*
SgMemberFunctionDeclaration::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionDeclaration";  
   }

std::string
SgMemberFunctionDeclaration::class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionDeclaration";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMemberFunctionDeclaration::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMemberFunctionDeclaration::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MFUNC_DECL_STMT)
        {
          printf ("Error in SgMemberFunctionDeclaration::error(): SgMemberFunctionDeclaration object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMemberFunctionDeclaration::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MFUNC_DECL_STMT);
     return SgFunctionDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMemberFunctionDeclaration::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMemberFunctionDeclaration::variant() const \n");
#endif
     assert(this != NULL);
     return MFUNC_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMemberFunctionDeclaration* isSgMemberFunctionDeclaration ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMemberFunctionDeclaration*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMemberFunctionDeclaration* isSgMemberFunctionDeclaration ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMemberFunctionDeclaration*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMemberFunctionDeclaration::~SgMemberFunctionDeclaration ()
   {
#if 0
  // debugging information!
     printf ("In SgMemberFunctionDeclaration::~SgMemberFunctionDeclaration (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for CtorInitializerList
     p_CtorInitializerList = NULL; // non list case 
  // case: not a listType for associatedClassDeclaration
     p_associatedClassDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMemberFunctionDeclaration::SgMemberFunctionDeclaration ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
   : SgFunctionDeclaration(startOfConstruct, name, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgMemberFunctionDeclaration::SgMemberFunctionDeclaration (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_CtorInitializerList = NULL;
     p_associatedClassDeclaration = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(MFUNC_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgMemberFunctionDeclaration() function since it has been problematic
     assert(isSgMemberFunctionDeclaration(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgTemplateInstantiationMemberFunctionDecl::get_templateName () const
   {
     assert (this != NULL);
     return p_templateName;
   }

void
SgTemplateInstantiationMemberFunctionDecl::set_templateName ( SgName templateName )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateName = templateName;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateInstantiationMemberFunctionDecl::get_templateDeclaration () const
   {
     assert (this != NULL);
     return p_templateDeclaration;
   }

void
SgTemplateInstantiationMemberFunctionDecl::set_templateDeclaration ( SgTemplateDeclaration* templateDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration)
        {
          printf ("Warning: templateDeclaration = %p overwriting valid pointer p_templateDeclaration = %p \n",templateDeclaration,p_templateDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_templateDeclaration != NULL && templateDeclaration != NULL && p_templateDeclaration != templateDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_templateDeclaration = templateDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateArgumentPtrListPtr 
SgTemplateInstantiationMemberFunctionDecl::get_templateArguments () const
   {
     assert (this != NULL);
     return p_templateArguments;
   }

void
SgTemplateInstantiationMemberFunctionDecl::set_templateArguments ( SgTemplateArgumentPtrListPtr templateArguments )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_templateArguments = templateArguments;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgTemplateInstantiationMemberFunctionDecl::get_nameResetFromMangledForm () const
   {
     assert (this != NULL);
     return p_nameResetFromMangledForm;
   }

void
SgTemplateInstantiationMemberFunctionDecl::set_nameResetFromMangledForm ( bool nameResetFromMangledForm )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_nameResetFromMangledForm = nameResetFromMangledForm;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10205 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgTemplateInstantiationMemberFunctionDecl::post_construction_initialization()
   {
  // DQ (4/19/2005): Removed since it is redundant with the define of the template support in ROSE
  // set_from_template(true);

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
     if (p_templateArguments != NULL)
        {
          SgTemplateArgumentPtrList::iterator i = p_templateArguments->begin();
          while (i != p_templateArguments->end())
             {
               (*i)->set_parent(this);
               i++;
             }
        }
       else
        {
          printf ("Warning (post_construction_initialization): p_templateArguments == NULL in SgTemplateInstantiationMemberFunctionDecl = %p \n",this);
        }
   }

void
SgTemplateInstantiationMemberFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template member function instantiations.
SgName
SgTemplateInstantiationMemberFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationMemberFunctionDecl* declaration = const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this),mangledName);
          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationMemberFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateInstantiationMemberFunctionDecl::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateInstantiationMemberFunctionDecl::variantT() const {
  return V_SgTemplateInstantiationMemberFunctionDecl;
}

#if 0
int
SgTemplateInstantiationMemberFunctionDecl::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT;
   }
#endif

const char*
SgTemplateInstantiationMemberFunctionDecl::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationMemberFunctionDecl";  
   }

std::string
SgTemplateInstantiationMemberFunctionDecl::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationMemberFunctionDecl";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateInstantiationMemberFunctionDecl::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateInstantiationMemberFunctionDecl::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT)
        {
          printf ("Error in SgTemplateInstantiationMemberFunctionDecl::error(): SgTemplateInstantiationMemberFunctionDecl object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateInstantiationMemberFunctionDecl::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT);
     return SgMemberFunctionDeclaration::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateInstantiationMemberFunctionDecl::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationMemberFunctionDecl::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateInstantiationMemberFunctionDecl* isSgTemplateInstantiationMemberFunctionDecl ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateInstantiationMemberFunctionDecl*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateInstantiationMemberFunctionDecl* isSgTemplateInstantiationMemberFunctionDecl ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateInstantiationMemberFunctionDecl*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateInstantiationMemberFunctionDecl::~SgTemplateInstantiationMemberFunctionDecl ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateInstantiationMemberFunctionDecl::~SgTemplateInstantiationMemberFunctionDecl (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for templateName
     p_templateName = ""; // non list case 
  // case: not a listType for templateDeclaration
     p_templateDeclaration = NULL; // non list case 
  // case: listType for templateArguments
  // case: listType (typeIsPointerToList == true) for templateArguments
     p_templateArguments = NULL;
  // case: not a listType for nameResetFromMangledForm
     p_nameResetFromMangledForm = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateInstantiationMemberFunctionDecl::SgTemplateInstantiationMemberFunctionDecl ( Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments )
   : SgMemberFunctionDeclaration(startOfConstruct, name, type, definition)
   {
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationMemberFunctionDecl::SgTemplateInstantiationMemberFunctionDecl (Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition, SgTemplateDeclaration* templateDeclaration, SgTemplateArgumentPtrListPtr templateArguments) sage_class_name() = %s \n",sage_class_name());
#endif

     p_templateName = "";
     p_templateDeclaration = templateDeclaration;
     p_templateArguments = templateArguments;
     p_nameResetFromMangledForm = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationMemberFunctionDecl() function since it has been problematic
     assert(isSgTemplateInstantiationMemberFunctionDecl(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgSymbolTable* 
SgScopeStatement::get_symbol_table () const
   {
     assert (this != NULL);
     return p_symbol_table;
   }

void
SgScopeStatement::set_symbol_table ( SgSymbolTable* symbol_table )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_symbol_table != NULL && symbol_table != NULL && p_symbol_table != symbol_table)
        {
          printf ("Warning: symbol_table = %p overwriting valid pointer p_symbol_table = %p \n",symbol_table,p_symbol_table);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_symbol_table != NULL && symbol_table != NULL && p_symbol_table != symbol_table) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_symbol_table = symbol_table;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2759 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgScopeStatement::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // We need to call the fixupCopy function from the parent of a SgVariableDeclaration because the 
  // copy function in the parent of the variable declaration sets the parent of the SgVariableDeclaration
  // and we need this parent in the fixupCopy function in the SgInitializedName.

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgScopeStatement::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

     SgScopeStatement* copyScopeStatement = isSgScopeStatement(copy);
     ROSE_ASSERT(copyScopeStatement != NULL);

     const SgStatementPtrList & statementList_original = this->generateStatementList();
     const SgStatementPtrList & statementList_copy     = copyScopeStatement->generateStatementList();

     SgStatementPtrList::const_iterator i_original = statementList_original.begin();
     SgStatementPtrList::const_iterator i_copy     = statementList_copy.begin();

  // Iterate over both lists to match up the correct pairs of SgStatement objects
     while ( (i_original != statementList_original.end()) && (i_copy != statementList_copy.end()) )
        {
          (*i_original)->fixupCopy(*i_copy,help);

          i_original++;
          i_copy++;
        }

  // Do we need to reset up the symbol table???

  // Call the base class fixupCopy member function
     SgStatement::fixupCopy(copy,help);
   }
#endif

// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::prepend_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().begin(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().begin(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::append_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().end(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().end(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_type_elaboration_list ()
   {
     assert (this != NULL);
     return p_type_elaboration_list;
   }

void
SgScopeStatement::set_type_elaboration_list ( const std::set<SgSymbol*> & type_elaboration_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_type_elaboration_list = type_elaboration_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_type_list ()
   {
     assert (this != NULL);
     return p_hidden_type_list;
   }

void
SgScopeStatement::set_hidden_type_list ( const std::set<SgSymbol*> & hidden_type_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_hidden_type_list = hidden_type_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_declaration_list ()
   {
     assert (this != NULL);
     return p_hidden_declaration_list;
   }

void
SgScopeStatement::set_hidden_declaration_list ( const std::set<SgSymbol*> & hidden_declaration_list )
   {
     assert (this != NULL);
     set_isModified(true);
     p_hidden_declaration_list = hidden_declaration_list;
   }


std::ostream & operator<< ( std::ostream & os, const std::set<SgSymbol*> & l )
   {
     os << "output operator for std::set<SgSymbol*> not implemented";
     return os;
   }

SgScopeStatement::SgScopeStatement ( Sg_File_Info* file_info )
   : SgStatement(file_info)
   {
  // Make the global scope hash multimap larger since it typically supports more synbols.
  // Use a prime number (better!)
     if (variantT() == V_SgGlobal || variantT() == V_SgNamespaceDefinitionStatement)
        {
          p_symbol_table = new SgSymbolTable(101);
        }
       else
        {
          if (variantT() == V_SgClassDefinition || variantT() == V_SgTemplateInstantiationDefn)
             {
               p_symbol_table = new SgSymbolTable(51);
             }
            else
             {
            // Use the default size of hash_multimap
               p_symbol_table = new SgSymbolTable();
             }
        }

     ROSE_ASSERT(p_symbol_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_symbol_table->set_parent(this);
   }

void
SgScopeStatement::post_construction_initialization()
   {
   }

// DQ (9/8/2004): Added to support qualified name generation
// RV (1/31/2006): Modified to return a fully qualified name by recursion.
SgName
SgScopeStatement::get_qualified_name() const
   {
  // Compute name of this scope -- by default, an unnamed (or empty) string.
     SgName local_qual_name;

  // Compute parent scope's qualified name
     SgName par_qual_name;
     const SgScopeStatement* parent_scope = get_scope ();
     if (parent_scope)
       par_qual_name = parent_scope->get_qualified_name ();

     return SgName::assembleQualifiedName (par_qual_name, local_qual_name);
   }

SgName
SgScopeStatement::get_mangled_name(void) const
   {
     printf ("Error: this is a virtual function call on a base class implementation! scope = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return SgName ("__error__");
   }

size_t
SgScopeStatement::count_symbol(const SgName& n)
   {
  // DQ (2/10/2007): Added function to count entries in symbol table with same name!
  // This can be more than 1, e.g. "typedef struct X{} X;"
     assert (p_symbol_table != NULL);
     return p_symbol_table->count(n);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm , SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm,sp);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(sp);
   }


void
SgScopeStatement::insert_symbol ( const SgName& n, SgSymbol* s )
   {
     assert (p_symbol_table != NULL);

  // Make sure that this specific symbol and name combination don't already exist in the AST.
     bool symbolAlreadyPresentLookupName = p_symbol_table->exists(n,s);
     if (symbolAlreadyPresentLookupName == true)
        {
          printf ("Error in insert_symbol(n=%s,s=%p): (exists(n,s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               n.str(),s,s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
          printf ("     s->get_symbol_basis() = %p = %s \n",s->get_symbol_basis(),s->get_symbol_basis()->class_name().c_str());
          s->get_symbol_basis()->get_file_info()->display("Error in insert_symbol(n,s)");
        }
     ROSE_ASSERT(symbolAlreadyPresentLookupName == false);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Also test the symbol directly (this is an expensive test, linear in complexity)
  // We don't want to do this except for testing!
     bool symbolAlreadyPresent = p_symbol_table->exists(s);
     if (symbolAlreadyPresent == true)
        {
          printf ("Error: (exists(s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
        }
     ROSE_ASSERT(symbolAlreadyPresent == false);
#endif

     p_symbol_table->insert(n,s);
   }

void
SgScopeStatement::remove_symbol ( SgSymbol* s )
   {
     assert (p_symbol_table != NULL);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Make sure that the symbol exists before we try to remove it
     ROSE_ASSERT(p_symbol_table->exists(s) == true);
#endif

     p_symbol_table->remove(s);
   }

  // see if this is in symbol table already
int
SgScopeStatement::lookup_symbol(const SgName& n, SgSymbol *s) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find(n,s);
   }

  // first symbol with n
SgSymbol*
SgScopeStatement::lookup_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_any(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgTypedefSymbol*
SgScopeStatement::lookup_typedef_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_typedef(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgEnumSymbol*
SgScopeStatement::lookup_enum_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_enum(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgEnumFieldSymbol*
SgScopeStatement::lookup_enum_field_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_enum_field(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::lookup_var_symbol(const SgName& n) const
   {
  // DQ (2/4/2007): This function is part of an older interface which is depricated.
     return lookup_variable_symbol(n);
   }
SgVariableSymbol*
SgScopeStatement::lookup_variable_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_variable(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::lookup_class_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_class(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgLabelSymbol*
SgScopeStatement::lookup_label_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_label(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n, const SgType* t) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function(n,t);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function(n);
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgNamespaceSymbol*
SgScopeStatement::lookup_namespace_symbol ( const SgName & n ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_namespace(n);
   }


SgTemplateSymbol*
SgScopeStatement::lookup_template_symbol(const SgName& n) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_template(n);
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::first_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::first_variable_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::first_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_class();
   }
// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::first_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistant.
SgTypedefSymbol*
SgScopeStatement::first_typedef_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_typedef();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistant.
SgEnumSymbol*
SgScopeStatement::first_enum_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistant.
SgEnumFieldSymbol*
SgScopeStatement::first_enum_field_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum_field();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistant.
SgLabelSymbol*
SgScopeStatement::first_label_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_label();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistant.
SgNamespaceSymbol*
SgScopeStatement::first_namespace_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_namespace();
   }

// DQ (2/4/2007): Added to ROSE to make the interface consistant.
SgTemplateSymbol*
SgScopeStatement::first_template_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_template();
   }
















// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::next_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::next_variable_symbol() const
   {
  // use this function after lookup_XXX_symbol(const SgName&) or after first_XXX_symbol()
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::next_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_class();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I 
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::next_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_function();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgTypedefSymbol*
SgScopeStatement::next_typedef_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_typedef();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumSymbol*
SgScopeStatement::next_enum_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumFieldSymbol*
SgScopeStatement::next_enum_field_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum_field();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgLabelSymbol*
SgScopeStatement::next_label_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_label();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgNamespaceSymbol*
SgScopeStatement::next_namespace_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_namespace();
   }

// DQ (2/4/2007): Added new member function to ROSE.
SgTemplateSymbol*
SgScopeStatement::next_template_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_template();
   }




void
SgScopeStatement::print_symboltable( const std::string& str, ostream& os ) 
   {
     os << endl << "...SymTbl(" << str << ")... " << endl;
  // printf ("ERROR: not supported in SAGE 3 \n");
  // abort();
  // p_symbol_table->print(os);
     ROSE_ASSERT (p_symbol_table != NULL);
     p_symbol_table->print("Called from SgScopeStatement::print_symboltable");
   }

#if 0
// Not implemented in SAGE3 yet!

/* additional symbol table insertion utitily routines */

SgVariableSymbol *insert_symbol(const SgInitializedNamePtrList::iterator&);
SgVariableSymbol *insert_symbol(SgVariableDeclaration *);
SgFunctionSymbol *insert_symbol(SgFunctionDeclaration *);
SgMemberFunctionSymbol *insert_symbol(SgMemberFunctionDeclaration *);
SgClassSymbol *insert_symbol(SgClassDeclaration *cdecl);
SgEnumSymbol *insert_symbol(SgEnumDeclaration *cdecl);
SgTypedefSymbol *insert_symbol(SgTypedefDeclaration *);
SgLabelSymbol *insert_symbol(SgLabelStatement *);
SgEnumFieldSymbol *insert_enum_symbol(const SgInitializedNamePtrList::iterator&);
#endif

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
bool
SgScopeStatement::containsOnlyDeclarations() const
   {
  // All but two of the derived classes contain one or more list of SgStatements while two of them
  // contain a list of SgDeclarationStmt which complicates the design of a simple implmentation of
  // functions that operate on scopes generally.
     bool returnValue = false;
     switch ( variantT() )
        {
          case V_SgBasicBlock:
          case V_SgCatchOptionStmt:
          case V_SgDoWhileStmt:
          case V_SgForStatement:
          case V_SgFunctionDefinition:
          case V_SgIfStmt:
          case V_SgSwitchStatement:
          case V_SgWhileStmt:
               returnValue = false;
               break;

          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
          case V_SgGlobal:
               returnValue = true;
               break;

          default:
               printf ("ERROR: default reached in switch (SgScopeStatement::containsOnlyDeclarations() is called from a %s) \n",sage_class_name());
               ROSE_ASSERT(false);
               break;
        }

     return returnValue;
   }


bool
SgScopeStatement::supportsDefiningFunctionDeclaration()
   {
  // DQ (10/18/2006): Not all scopes permit function declarations. Any function prototype in a 
  // scope appropriate for a function definition triggers requirements for name qualifiaction.
  // This function returns true if the scope is appropriate for the definition of a function
  // or member function (i.e. is a SgGlobal, SgClassDefinition, or SgNamespaceDefinitionStatement).

  // This is equivalent to the test for if the scope only permits declarations.
     return containsOnlyDeclarations();
   }


// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
void
SgScopeStatement::insertStatementInScope ( SgStatement* newTransformationStatement, bool atTop )
   {
  // Put the new statement at the front (without regard to any dependencies on declared types)

  // We have only debugged this case so far
  // ROSE_ASSERT (atTop == true);

     bool inFront = (atTop == true);
     SgScopeStatement* currentScope = this;
     if (atTop == true)
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::iterator declaration = declarationList.begin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newDeclarationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);
               
#if 0
               printf ("Exiting after call to insert_statement in SgScopeStatement::insertStatementInScope() \n");
               ROSE_ABORT();
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::iterator statement = statementList.begin();

            // if (statementList.size() == 0)
               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *statement != NULL );
                    insert_statement (*statement,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
        }
       else
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::reverse_iterator declaration = declarationList.rbegin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);

            // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
               ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
#if 0
               printf ("Exiting after call to insert_statement in SgScopeStatement::insertStatementInScope() \n");
               ROSE_ABORT();
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::reverse_iterator statement = statementList.rbegin();

            // if (statementList.size() == 0)
               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *statement != NULL );
                    insert_statement (*statement,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
   }

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList ()
// SgScopeStatement::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgClassDefinition:
             {
               SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
               currentStatementList = &(classDefinitionScope->get_members());
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
               currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               break;
             }

          case V_SgGlobal:
             {
               SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
               currentStatementList = &(globalScope->get_declarations());
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
               currentStatementList = &(namespaceScope->get_declarations());
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getDeclarationList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     return *currentStatementList;
   }

const SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList () const
// SgScopeStatement::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

  // SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgClassDefinition:
             {
               const SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
            // currentStatementList = &(classDefinitionScope->get_members());
               return classDefinitionScope->get_members();
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               const SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
            // currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               return templateInstantiationDefinitionScope->get_members();
               break;
             }

          case V_SgGlobal:
             {
               const SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
            // currentStatementList = &(globalScope->get_declarations());
               return globalScope->get_declarations();
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               const SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
            // currentStatementList = &(namespaceScope->get_declarations());
               return namespaceScope->get_declarations();
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getDeclarationList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
     static SgDeclarationStatementPtrList defaultList;
     return defaultList;
   }

#if 0
// DQ (1/30/2007): Added this cases that previously caused the default case to be used
// so that better error handling could be used.
SgStatementPtrList
SgScopeStatement::generateStatementList()
   {
  // This function permits access to the statements or declarations as a list of statements
  // since declaations are derivved from statements.  This function gnerates a copy of the
  // list in both cases (symetricly for both types).

#if 0
     printf ("In SgScopeStatement::generateStatementList() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::iterator i = declarationList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
               returnList.push_back(*i);

          ROSE_ASSERT (returnList.size() == declarationList.size());

#if 0
       // error checking
          SgStatementPtrList::iterator j = returnList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
             {
               ROSE_ASSERT ( (*i) == (*j) );
               printf ("     declaration = %s \n",(*i)->unparseToString().c_str());
               j++;
             }
#endif
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list
          SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               returnList = ifStatement->get_true_body()->getStatementList();
	       if (ifStatement->get_false_body()) {
		 SgStatementPtrList falseList = ifStatement->get_false_body()->getStatementList();
		 for (SgStatementPtrList::iterator i = falseList.begin(); i != falseList.end(); i++)
		    {
		      returnList.push_back(*i);
		    }
	       }
             }
            else
             {
               returnList = getStatementList();
             }
        }

  // printf ("In generateStatementList(): returnList.size() = %zu \n",returnList.size());

     return returnList;
   }
#endif

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgStatementPtrList &
SgScopeStatement::getStatementList ()
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
               currentStatementList = &(basicBlock->get_statements());
               break;
             }

          case V_SgCatchOptionStmt:
             {
               SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
               currentStatementList = &(catchOptionScope->get_body()->getStatementList());
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
               currentStatementList = &(doWhileScope->get_body()->getStatementList());
               break;
             }

          case V_SgForStatement:
             { 
               SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
               currentStatementList = &(forScope->get_loop_body()->getStatementList());
               break;
             }

          case V_SgFunctionDefinition:
             {
               SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
               currentStatementList = &(functionScope->get_body()->getStatementList());
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               
               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not 
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() return value not defined for SgIfStatement containing true and false bodies (use generateStatementList() to form copy of merges lists) \n");
               ROSE_ABORT();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
               currentStatementList = &(switchStatement->get_body()->getStatementList());
               break;
             }

          case V_SgWhileStmt:
             {
               SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
               currentStatementList = &(whileStatement->get_body()->getStatementList());
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getStatementList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ABORT();
               break;
        }

     return *currentStatementList;
   }


// DQ (10/6/2007): Added const version of this function to support const version of generateStatementList() 
const SgStatementPtrList &
SgScopeStatement::getStatementList () const
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

  // SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               const SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
            // currentStatementList = &(basicBlock->get_statements());
               return basicBlock->get_statements();
               break;
             }

          case V_SgCatchOptionStmt:
             {
               const SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
            // currentStatementList = &(catchOptionScope->get_body()->getStatementList());
               return catchOptionScope->get_body()->getStatementList();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               const SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
            // currentStatementList = &(doWhileScope->get_body()->getStatementList());
               return doWhileScope->get_body()->getStatementList();
               break;
             }

          case V_SgForStatement:
             { 
               const SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return forScope->get_loop_body()->getStatementList();
               break;
             }

          case V_SgFunctionDefinition:
             {
               const SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
            // currentStatementList = &(functionScope->get_body()->getStatementList());
               return functionScope->get_body()->getStatementList();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               
               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               const SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not 
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() const return value not defined for SgIfStatement containing true and false bodies (use generateStatementList() const to form copy of merges lists) \n");
               ROSE_ABORT();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               const SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
            // currentStatementList = &(switchStatement->get_body()->getStatementList());
               return switchStatement->get_body()->getStatementList();
               break;
             }

          case V_SgWhileStmt:
             {
               const SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
            // currentStatementList = &(whileStatement->get_body()->getStatementList());
               return whileStatement->get_body()->getStatementList();
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getStatementList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ABORT();
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
  // return SgStatementPtrList();
     static SgStatementPtrList defaultList;
     return defaultList;
   }


const SgStatementPtrList
SgScopeStatement::generateStatementList() const
   {
  // This function permits access to the statements or declarations as a list of statements
  // since declaations are derivved from statements.  This function gnerates a copy of the
  // list in both cases (symetricly for both types).

#if 0
     printf ("In SgScopeStatement::generateStatementList() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
               returnList.push_back(*i);

          ROSE_ASSERT (returnList.size() == declarationList.size());

#if 0
       // error checking
          const SgStatementPtrList::const_iterator j = returnList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
             {
               ROSE_ASSERT ( (*i) == (*j) );
               printf ("     declaration = %s \n",(*i)->unparseToString().c_str());
               j++;
             }
#endif
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list
          const SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               returnList = ifStatement->get_true_body()->getStatementList();
               const SgStatementPtrList falseList = ifStatement->get_false_body()->getStatementList();
               for (SgStatementPtrList::const_iterator i = falseList.begin(); i != falseList.end(); i++)
                  {
                    returnList.push_back(*i);
                  }
             }
            else
             {
               returnList = getStatementList();
             }
        }

  // printf ("In generateStatementList(): returnList.size() = %zu \n",returnList.size());

     return returnList;
   }

unsigned int
SgScopeStatement::generateUniqueStatementNumberForScope( SgStatement* statement )
   {
  // DQ (2/20/2007): This function supports the AST merge mechansim, but is general 
  // and may be useful for the mangled name generation in the future.

  // This function generates a unique number for each statement in the scope by returning
  // its position value countered from the top of the list of statements of declarations.
  // It is used in the AST merge within the mechanism to generate unique names for both 
  // un-named enums and class declarations and template declarations of overloaded 
  // functions in a templated class (since at the point of instantiation of the outer class
  // the names of any overloaded functions are all the same).  The value of returned 
  // by this function should only be relyied upon to be unique for the given scope (nothing more).
  // This function may be useful for naming un-named scopes such as though in loop constructs.

#if 1
     printf ("In SgScopeStatement::generateUniqueStatementNumberForScope() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     unsigned int counter = 0;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatement* declaration = isSgDeclarationStatement(statement);
          ROSE_ASSERT(declaration != NULL);

          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          while ( (i != declarationList.end()) && ( (*i)->get_definingDeclaration() != declaration->get_definingDeclaration()) )
             {
               printf ("counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
               counter++;
               i++;
             }

          if (i == declarationList.end())
             {
               printf ("statement = %p = %s not found in scope (declaration list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
               ROSE_ASSERT(counter == declarationList.size());
             }
            else
             {
               printf ("END: counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
             }

        }
       else
        {
       // Handle special case of two lists in a single statement (just add the 2nd list to the 1st result)
          SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
            // If we didn't have a SgBasicBlock as a body then the nested if's could generate some strange numbers.
            // Since this might change in the future we will make it explicit with assertions!
               ROSE_ASSERT(isSgBasicBlock(ifStatement->get_true_body())  != NULL);
               ROSE_ASSERT(isSgBasicBlock(ifStatement->get_false_body()) != NULL);

               unsigned int true_block_size  = ifStatement->get_true_body()->get_statements().size();
               unsigned int true_part  = ifStatement->get_true_body()->generateUniqueStatementNumberForScope(statement);
               if (true_part != true_block_size)
                  {
                    counter = true_part;
                  }
                 else
                  {
                    printf ("statement = %p = %s not found in SgIfStmt scope = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
                    unsigned int false_part = ifStatement->get_false_body()->generateUniqueStatementNumberForScope(statement);
                    counter = true_part + false_part;
                  }
             }
            else
             {
               const SgStatementPtrList & statementList = getStatementList();
               SgStatementPtrList::const_iterator i = statementList.begin();
               while ( (i != statementList.end()) && (*i != statement) )
                  {
                    counter++;
                    i++;
                  }

               if (i == statementList.end())
                  {
                    printf ("statement = %p = %s not found in scope (statement list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
                    ROSE_ASSERT(counter == statementList.size());
                  }
             }
        }

     printf ("In generateUniqueStatementNumberForScope(): counter = %d \n",counter);

     return counter;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgScopeStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgScopeStatement::variantT() const {
  return V_SgScopeStatement;
}

#if 0
int
SgScopeStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SCOPE_STMT;
   }
#endif

const char*
SgScopeStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgScopeStatement";  
   }

std::string
SgScopeStatement::class_name() const
   {
     assert(this != NULL);
     return "SgScopeStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgScopeStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgScopeStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SCOPE_STMT)
        {
          printf ("Error in SgScopeStatement::error(): SgScopeStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgScopeStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SCOPE_STMT);
     return SgStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgScopeStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgScopeStatement::variant() const \n");
#endif
     assert(this != NULL);
     return SCOPE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgScopeStatement* isSgScopeStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgScopeStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgScopeStatement* isSgScopeStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgScopeStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgScopeStatement::~SgScopeStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgScopeStatement::~SgScopeStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_symbol_table;

  // case: not a listType for symbol_table
     p_symbol_table = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgDeclarationStatementPtrList &
SgGlobal::get_declarations () const
   {
     assert (this != NULL);
     return p_declarations;
   }

SgDeclarationStatementPtrList &
SgGlobal::get_declarations () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_declarations;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4385 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgGlobal::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgGlobal::fixupCopy() for %p copy = %p \n",this,copy);
#endif

  // Need to fixup the function type table!

  // Call the base class fixupCopy member function
     SgScopeStatement::fixupCopy(copy,help);
   }
#endif

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgGlobal::get_qualified_name() const
   {
  // DQ (8/25/2005): This is the case where we previously names the global scope as "::"
  // within name qualification.  This was done to handle test2005_144.C but it broke
  // test2004_80.C So we have moved to an explicit marking of IR nodes using global scope
  // qualification (since it clearly seems to be required).
  // DQ (8/22/2005): Added global scope qualifier (see test2005_144.C) it is sometimes 
  // required to prevent base class types from being used instead of globally defined types.
  // Note that this will still evaluate so that "returnName.is_null()" will be true

  // DQ (10/11/2006): Under the new name qualification, we must traverse all the way
  // to global scope, and include global scope to get test2006_157.C correct.
  // return SgName ("");
     return SgName ("::");
   }

SgName
SgGlobal::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
  // DQ (3/12/2007): This is likely faster than using the mangled name map
     return SgName ("__global__");
   }

void
SgGlobal::post_construction_initialization()
   {
   }

void
SgGlobal::append_declaration(SgDeclarationStatement * what) 
   {
  // DQ (3/10/2007): Make sure that the statement does not already exist in the scope
  // It may be OK if is is marked explicitly as shared. Note that this is a linear time test.
#if 0
  // printf ("In SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
     if (find(get_declarations().begin(),get_declarations().end(),what) != get_declarations().end() && what->get_file_info()->isShared() == false)
        {
          printf ("Error: SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
          what->get_startOfConstruct()->display("statement does not already exists: debug");
        }

  // Since we have later error checking we don't require this here as it introduces a performance problem.
     ROSE_ASSERT(find(get_declarations().begin(),get_declarations().end(),what) == get_declarations().end() || what->get_file_info()->isShared() == true);
#endif

     insert_declaration(get_declarations().end(),what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgGlobal::prepend_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().begin(),what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgGlobal::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
#error "DEAD CODE"
     what->set_parent(this);
#endif
     what->set_parent(this);

     get_declarations().insert(where,what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

bool
SgGlobal::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 
SgGlobal:: replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }

#if 0
std::map<SgNode*,std::string> &
SgGlobal:: get_mangledNameCache()
   {
     return p_mangledNameCache;
   }

std::map<std::string, int> &
SgGlobal:: get_shortMangledNameCache()
   {
     return p_shortMangledNameCache;
   }
#endif

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,std::string> not implemented";
     return os;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGlobal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGlobal::variantT() const {
  return V_SgGlobal;
}

#if 0
int
SgGlobal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GLOBAL_STMT;
   }
#endif

const char*
SgGlobal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGlobal";  
   }

std::string
SgGlobal::class_name() const
   {
     assert(this != NULL);
     return "SgGlobal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGlobal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGlobal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GLOBAL_STMT)
        {
          printf ("Error in SgGlobal::error(): SgGlobal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGlobal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GLOBAL_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGlobal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGlobal::variant() const \n");
#endif
     assert(this != NULL);
     return GLOBAL_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGlobal* isSgGlobal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGlobal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGlobal* isSgGlobal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGlobal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGlobal::~SgGlobal ()
   {
#if 0
  // debugging information!
     printf ("In SgGlobal::~SgGlobal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGlobal::SgGlobal ( Sg_File_Info* startOfConstruct )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgGlobal::SgGlobal (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(GLOBAL_STMT == variant());
     post_construction_initialization();

  // Test the isSgGlobal() function since it has been problematic
     assert(isSgGlobal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgStatementPtrList &
SgBasicBlock::get_statements () const
   {
     assert (this != NULL);
     return p_statements;
   }

SgStatementPtrList &
SgBasicBlock::get_statements () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_statements;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 6256 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


#if 0
// DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
void
SgBasicBlock::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
     SgBasicBlock* block_copy = isSgBasicBlock(copy);
     ROSE_ASSERT(block_copy != NULL);

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgBasicBlock::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Do we need to re set up the symbol table???

  // Call the base class fixupCopy member function
     SgScopeStatement::fixupCopy(copy,help);
   }
#endif

unsigned int
SgBasicBlock::cfgIndexForEnd() const {
  return this->get_statements().size();
}

bool SgBasicBlock::cfgIsIndexInteresting(unsigned int idx) const {
  return false;
}

std::vector<VirtualCFG::CFGEdge> SgBasicBlock::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == this->get_statements().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
  } else if (idx < this->get_statements().size()) {
    makeEdge(VirtualCFG::CFGNode(this, idx), this->get_statements()[idx]->cfgForBeginning(), result);
  } else ROSE_ASSERT (!"Bad index for SgBasicBlock");
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgBasicBlock::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  if (idx == 0) {
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
  } else if (idx <= this->get_statements().size()) {
    makeEdge(this->get_statements()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
  } else ROSE_ASSERT (!"Bad index for SgBasicBlock");
  return result;
}

SgBasicBlock::SgBasicBlock(Sg_File_Info* info, SgStatement* stmt)
:SgScopeStatement(info)
   {
  /* now a call to the user defined intialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

SgBasicBlock::SgBasicBlock( SgStatement* stmt )
:SgScopeStatement()
   {
  /* now a call to the user defined intialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgBasicBlock::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgBasicBlock::get_mangled_name(void) const
   {
     return SgName ("");
   }

void
SgBasicBlock::post_construction_initialization()
   {
   // Call the base class post_construction_initialization() member function
   // SgScopeStatement::post_construction_initialization();
   }

void
SgBasicBlock::append_statement(SgStatement * what) 
   {
//   printf ("In SgBasicBlock::append_statement(): Call to insert_statement() commented out \n");
//   ROSE_ABORT();

     insert_statement(get_statements().end(),what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgBasicBlock::prepend_statement(SgStatement *what)
   {
     insert_statement(get_statements().begin(), what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 1
void
SgBasicBlock::append_statement(const SgStatementPtrList::iterator& where, SgStatement * what) 
   {
  // Alternative that allows for appending after any statement in the list
  // insert_statement(where,what);

     SgStatementPtrList::iterator tempIterator = where;
     tempIterator++;
  // Handle the case of appending at the end of the list
     if ( tempIterator == get_statements().end() )
        {
          append_statement (what);
        }
       else
        {
          insert_statement (tempIterator,what);
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 1
void
SgBasicBlock::prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what)
   {
  // Alternative that allows for prepending before any statement in the list
     insert_statement(where, what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 1
void
SgBasicBlock::insert_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

#if PRINT_SIDE_EFFECT_WARNINGS
     printf ("Warning Side-Effect: Calling set_parent on %p = %s (set to %p = %s) \n",what,what->sage_class_name(),this,sage_class_name());
#endif
     what->set_parent(this);

     get_statements().insert(where,what);
   }
#endif

bool
SgBasicBlock::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, true, extractBasicBlock, true);
   }

bool
SgBasicBlock::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBasicBlock::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBasicBlock::variantT() const {
  return V_SgBasicBlock;
}

#if 0
int
SgBasicBlock::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BASIC_BLOCK_STMT;
   }
#endif

const char*
SgBasicBlock::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBasicBlock";  
   }

std::string
SgBasicBlock::class_name() const
   {
     assert(this != NULL);
     return "SgBasicBlock";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBasicBlock::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBasicBlock::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BASIC_BLOCK_STMT)
        {
          printf ("Error in SgBasicBlock::error(): SgBasicBlock object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBasicBlock::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BASIC_BLOCK_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBasicBlock::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBasicBlock::variant() const \n");
#endif
     assert(this != NULL);
     return BASIC_BLOCK_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBasicBlock* isSgBasicBlock ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBasicBlock*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBasicBlock* isSgBasicBlock ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBasicBlock*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBasicBlock::~SgBasicBlock ()
   {
#if 0
  // debugging information!
     printf ("In SgBasicBlock::~SgBasicBlock (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgIfStmt::get_conditional () const
   {
     assert (this != NULL);
     return p_conditional;
   }

void
SgIfStmt::set_conditional ( SgStatement* conditional )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_conditional != NULL && conditional != NULL && p_conditional != conditional)
        {
          printf ("Warning: conditional = %p overwriting valid pointer p_conditional = %p \n",conditional,p_conditional);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_conditional != NULL && conditional != NULL && p_conditional != conditional) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_conditional = conditional;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgIfStmt::get_true_body () const
   {
     assert (this != NULL);
     return p_true_body;
   }

void
SgIfStmt::set_true_body ( SgBasicBlock* true_body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_true_body != NULL && true_body != NULL && p_true_body != true_body)
        {
          printf ("Warning: true_body = %p overwriting valid pointer p_true_body = %p \n",true_body,p_true_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_true_body != NULL && true_body != NULL && p_true_body != true_body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_true_body = true_body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgIfStmt::get_false_body () const
   {
     assert (this != NULL);
     return p_false_body;
   }

void
SgIfStmt::set_false_body ( SgBasicBlock* false_body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_false_body != NULL && false_body != NULL && p_false_body != false_body)
        {
          printf ("Warning: false_body = %p overwriting valid pointer p_false_body = %p \n",false_body,p_false_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_false_body != NULL && false_body != NULL && p_false_body != false_body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_false_body = false_body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgIfStmt::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgIfStmt::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 6451 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgIfStmt::cfgIndexForEnd() const
   {
     return 2;
   }

bool
SgIfStmt::cfgIsIndexInteresting(unsigned int idx) const
   {
     return idx == 1;
   }

unsigned int
SgIfStmt::cfgFindChildIndex(SgNode* n)
   {
  // DQ (8/24/2006): Could be rewritten as:
  // Make sure that this is either the conditional, true body, or the fals body
  // ROSE_ASSERT (n == this->get_conditional() || n == this->get_true_body() || n == this->get_false_body() );
  // return (n == this->get_conditional()) ? 0 : 1;

     if (n == this->get_conditional())
        {
          return 0;
        }
       else
          if (n == this->get_true_body() || n == this->get_false_body())
             {
               return 1;
             } 
            else
               ROSE_ASSERT (!"Bad child in if statement");

  // DQ (8/24/2006): Added return to avoid compiler warning.
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgIfStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_conditional()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_true_body()->cfgForBeginning(), result);
	    if (this->get_false_body()) {
	      makeEdge(VirtualCFG::CFGNode(this, idx), this->get_false_body()->cfgForBeginning(), result);
	    } else {
	      makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 2), result);
	    }
	    break;
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgIfStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge>
SgIfStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_conditional()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: makeEdge(this->get_true_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	    if (this->get_false_body()) {
	      makeEdge(this->get_false_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	    } else {
	      makeEdge(VirtualCFG::CFGNode(this, 1), VirtualCFG::CFGNode(this, idx), result);
	    }
	    break;
    default: ROSE_ASSERT (!"Bad index for SgIfStmt");
  }
  return result;
}

void
SgIfStmt::post_construction_initialization()
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

  // printf ("Note: modified SgIfStmt::post_construction_initialization() to set parents of conditional, true_body, and false_body \n");

// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_conditional() != NULL) get_conditional()->set_parent(this);
     if (get_true_body()   != NULL) get_true_body  ()->set_parent(this);
     if (get_false_body()  != NULL) get_false_body ()->set_parent(this);
// #endif
   }

bool
SgIfStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     if (StatementReplace(this, p_conditional, target, newstmt) == true)
        {
          return true; 
        }
       else
        {
          if (StatementReplace(this, p_true_body, target, newstmt) == true)
             {
               return true;
             }
            else
             {
               if (StatementReplace(this, p_false_body, target, newstmt) == true)
                  {
                    return true;
                  }
                 else
                  {
                    return false;
                  }
             }
        }
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgIfStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIfStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIfStmt::variantT() const {
  return V_SgIfStmt;
}

#if 0
int
SgIfStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IF_STMT;
   }
#endif

const char*
SgIfStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIfStmt";  
   }

std::string
SgIfStmt::class_name() const
   {
     assert(this != NULL);
     return "SgIfStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIfStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIfStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IF_STMT)
        {
          printf ("Error in SgIfStmt::error(): SgIfStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIfStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IF_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIfStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIfStmt::variant() const \n");
#endif
     assert(this != NULL);
     return IF_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIfStmt* isSgIfStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIfStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIfStmt* isSgIfStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIfStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIfStmt::~SgIfStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgIfStmt::~SgIfStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for conditional
     p_conditional = NULL; // non list case 
  // case: not a listType for true_body
     p_true_body = NULL; // non list case 
  // case: not a listType for false_body
     p_false_body = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIfStmt::SgIfStmt ( Sg_File_Info* startOfConstruct, SgStatement* conditional, SgBasicBlock* true_body, SgBasicBlock* false_body )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIfStmt::SgIfStmt (Sg_File_Info* startOfConstruct, SgStatement* conditional, SgBasicBlock* true_body, SgBasicBlock* false_body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_conditional = conditional;
     p_true_body = true_body;
     p_false_body = false_body;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IF_STMT == variant());
     post_construction_initialization();

  // Test the isSgIfStmt() function since it has been problematic
     assert(isSgIfStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgForInitStatement* 
SgForStatement::get_for_init_stmt () const
   {
     assert (this != NULL);
     return p_for_init_stmt;
   }

void
SgForStatement::set_for_init_stmt ( SgForInitStatement* for_init_stmt )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_for_init_stmt != NULL && for_init_stmt != NULL && p_for_init_stmt != for_init_stmt)
        {
          printf ("Warning: for_init_stmt = %p overwriting valid pointer p_for_init_stmt = %p \n",for_init_stmt,p_for_init_stmt);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_for_init_stmt != NULL && for_init_stmt != NULL && p_for_init_stmt != for_init_stmt) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_for_init_stmt = for_init_stmt;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgForStatement::get_test () const
   {
     assert (this != NULL);
     return p_test;
   }

void
SgForStatement::set_test ( SgStatement* test )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_test != NULL && test != NULL && p_test != test)
        {
          printf ("Warning: test = %p overwriting valid pointer p_test = %p \n",test,p_test);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_test != NULL && test != NULL && p_test != test) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_test = test;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgForStatement::get_increment () const
   {
     assert (this != NULL);
     return p_increment;
   }

void
SgForStatement::set_increment ( SgExpression* increment )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_increment != NULL && increment != NULL && p_increment != increment)
        {
          printf ("Warning: increment = %p overwriting valid pointer p_increment = %p \n",increment,p_increment);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_increment != NULL && increment != NULL && p_increment != increment) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_increment = increment;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgForStatement::get_loop_body () const
   {
     assert (this != NULL);
     return p_loop_body;
   }

void
SgForStatement::set_loop_body ( SgBasicBlock* loop_body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_loop_body != NULL && loop_body != NULL && p_loop_body != loop_body)
        {
          printf ("Warning: loop_body = %p overwriting valid pointer p_loop_body = %p \n",loop_body,p_loop_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_loop_body != NULL && loop_body != NULL && p_loop_body != loop_body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_loop_body = loop_body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 6649 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgForStatement::cfgIndexForEnd() const {
  return 4;
}

bool SgForStatement::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 2;
}

unsigned int SgForStatement::cfgFindChildIndex(SgNode* n)
   {
  // DQ (8/24/2006): Could be rewritten as:
  // Make sure that this is either the conditional, true body, or the false body
  // ROSE_ASSERT (n == this->get_for_init_stmt() || n == this->get_test() || n == this->get_loop_body() || n == this->get_increment_expr_root() );
  // return (n == this->get_conditional()) ? 0 : ((n == this->get_test()) ? 1 : ((n == this->get_loop_body()) ? 2 : 3) );

     if (n == this->get_for_init_stmt())
        {
          return 0;
        }
       else
        {
          if (n == this->get_test())
             {
               return 1;
             }
            else
             {
               if (n == this->get_loop_body())
                  {
                    return 2;
                  }
                 else
                  {
                 // if (n == this->get_increment_expr_root())
                    if (n == this->get_increment())
                       {
                         return 3;
                       }
                      else
                       {
                         ROSE_ASSERT (!"Bad child in for statement");
                       }
                  }
             }
        }

  // DQ (8/24/2006): Added to avoid compiler warning
     return 0;
   }

unsigned int SgForStatement::cfgFindNextChildIndex(SgNode* n)
   {
     unsigned int parentIndex = this->cfgFindChildIndex(n);

  // DQ (8/24/2006): Modified function to avoid compiler warning about no return value
     unsigned int returnValue;
  // if (parentIndex == 3) return 1; else return parentIndex + 1;
     if (parentIndex == 3) 
          returnValue = 1;
       else
          returnValue = parentIndex + 1;

     return returnValue;
   }

std::vector<VirtualCFG::CFGEdge> SgForStatement::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_for_init_stmt()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_test()->cfgForBeginning(), result); break;
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_loop_body()->cfgForBeginning(), result);
	    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 4), result); break;
 // case 3: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_increment_expr_root()->cfgForBeginning(), result); break;
    case 3: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_increment()->cfgForBeginning(), result); break;
    case 4: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgForStatement");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgForStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_for_init_stmt()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
    // makeEdge(this->get_increment_expr_root()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
       makeEdge(this->get_increment()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	    break;
    case 2: makeEdge(this->get_test()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 3: {
      makeEdge(this->get_loop_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      vector<SgContinueStmt*> continueStmts = findContinueStmts(this->get_loop_body());
      for (unsigned int i = 0; i < continueStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(continueStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    case 4: {
      makeEdge(VirtualCFG::CFGNode(this, 2), VirtualCFG::CFGNode(this, idx), result);
      vector<SgBreakStmt*> breakStmts = SageInterface::findBreakStmts(this->get_loop_body());
      for (unsigned int i = 0; i < breakStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(breakStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgForStatement");
  }
  return result;
}

void
SgForStatement::post_construction_initialization()
   {
  // DQ (6/24/2006): Refactored this code to build the SgForInitStatement 
  // for all SgForStatement as part of constructor.
     ROSE_ASSERT(p_for_init_stmt == NULL);
  // SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
     SgForInitStatement* forInitStatement = NULL;
     if (get_startOfConstruct() != NULL)
        {
          forInitStatement = new SgForInitStatement(New_File_Info(this));

       // DQ (10/27/2006): This will have to be updated after construction, 
       // since we don't know the ending position at this point!
          forInitStatement->set_endOfConstruct(New_File_Info(this));

       // DQ (12/17/2006): Fixup the parents of Sg_File_Info objects
          forInitStatement->get_startOfConstruct()->set_parent(forInitStatement);
          forInitStatement->get_endOfConstruct()->set_parent(forInitStatement);
        }
       else
        {
          forInitStatement = new SgForInitStatement();
        }

     ROSE_ASSERT(forInitStatement != NULL);

  // All SgForStatement IR nodes should have a valid SgForInitStatement (even if it is an empty list!).
     set_for_init_stmt(forInitStatement);

     forInitStatement->set_parent(this);

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_test != NULL)
        {
          p_test->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_increment != NULL)
        {
          p_increment->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }
   }

// MS: moved StatementPtrList to ForInitStatement. Therefore the call is simply forwarded and the same interface
SgStatementPtrList &
SgForStatement::get_init_stmt()
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
#if 0
     if (get_for_init_stmt() == NULL)
        {
       // DQ (6/6/2005): fixup parent of SgForInitStatement
       // set_for_init_stmt(new SgForInitStatement(New_File_Info(this)));
          SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
          ROSE_ASSERT(forInitStatement != NULL);
          set_for_init_stmt(forInitStatement);
          forInitStatement->set_parent(this);
        }
#endif
     return get_for_init_stmt()->get_init_stmt(); 
   }

const SgStatementPtrList &
SgForStatement::get_init_stmt() const
   {
  // DQ (6/24/2006): When we later simplify the append, prepend, inster functions this will be important.
     ROSE_ASSERT(p_for_init_stmt != NULL);

     return get_for_init_stmt()->get_init_stmt();
   }

void
SgForStatement::append_init_stmt(SgStatement * what)
   { 
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
#if 0
     if (get_for_init_stmt() == NULL)
        {
       // DQ (6/6/2005): fixup parent of SgForInitStatement
       // set_for_init_stmt(new SgForInitStatement(New_File_Info(this)));
          SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
          ROSE_ASSERT(forInitStatement != NULL);
          set_for_init_stmt(forInitStatement);
          forInitStatement->set_parent(this);
        }
#endif
     get_for_init_stmt()->append_init_stmt(what);
   }

void
SgForStatement::prepend_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
#if 0
     if (get_for_init_stmt() == NULL)
        {
       // DQ (6/6/2005): fixup parent of SgForInitStatement
       // set_for_init_stmt(new SgForInitStatement(New_File_Info(this)));
          SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
          ROSE_ASSERT(forInitStatement != NULL);
          set_for_init_stmt(forInitStatement);
          forInitStatement->set_parent(this);
        }
#endif
     get_for_init_stmt()->prepend_init_stmt(what); 
   }

void
SgForStatement::insert_init_stmt(const SgStatementPtrList::iterator& where, SgStatement * what) 
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
#if 0
     if (get_for_init_stmt() == NULL)
        {
       // DQ (6/6/2005): fixup parent of SgForInitStatement
       // set_for_init_stmt(new SgForInitStatement(New_File_Info(this)));
          SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
          ROSE_ASSERT(forInitStatement != NULL);
          set_for_init_stmt(forInitStatement);
          forInitStatement->set_parent(this);
        }
#endif
     get_for_init_stmt()->insert_init_stmt(where,what);
   }

bool
SgForStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
          return true;
       else
          if ( StatementReplace(this, p_for_init_stmt, target, newstmt) == true )
               return true;
            else 
               return false;
   }

// DQ (11/25/2005): preserve the previous interface so that
// the most common case of where a test is an expression can
// be handled as before.  We can depricate this function later.
// Currently the test has been modified to allow it to be a SgStatement
// and in the case of an expression, it is just a SgExprStatement.
// This is required for C and C++ which allows declarations to be
// placed where the test is evaluated in a for loop (note that this
// is part of uniform changes to the IR to fixup such details).
SgExpression* 
SgForStatement::get_test_expr () const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpression*    testExpression = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
       // testExpression = exprStatement->get_the_expr();
          testExpression = exprStatement->get_expression();
          ROSE_ASSERT(testExpression != NULL);
        }
       else
        {
          printf ("test in SgForStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpression != NULL);
     return testExpression;
   }

void
SgForStatement::set_test_expr (SgExpression* expr )
   {
  // DQ (11/25/2005): preserve the previous interface. This function 
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (expr != NULL);

#if 0
  // Make this a new Sg_File_Info object so that they will not be shared
  // Sg_File_Info* fileInfo1 = Sg_File_Info::generateDefaultFileInfoForTransformationNode();
  // Sg_File_Info* fileInfo2 = Sg_File_Info::generateDefaultFileInfoForTransformationNode();
     Sg_File_Info* fileInfo1 = New_File_Info(expr);
     Sg_File_Info* fileInfo2 = New_File_Info(expr);

     printf ("Calling SgForStatement::set_test_expr() which builds a SgExpressionRoot (should no longer be used) \n");
     ROSE_ASSERT(false);

     SgExpressionRoot* expressionRoot     = new SgExpressionRoot(fileInfo1,expr,NULL);
     ROSE_ASSERT(expressionRoot != NULL);

  // DQ (10/27/2006): This might have to be reset later,
  // since at this point we might not know the exact size.
     expressionRoot->set_endOfConstruct(New_File_Info(expr));

  // DQ (4/7/2006): Set the parents
     expr->set_parent(expressionRoot);

     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo2,expressionRoot);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (4/7/2006): Set the parents
     expressionRoot->set_parent(expressionStatement);
#else
     Sg_File_Info* fileInfo = New_File_Info(expr);
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expr);
     ROSE_ASSERT(expressionStatement != NULL);
#endif

  // DQ (10/27/2006): This might have to be reset later, 
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(New_File_Info(expr));

     expressionStatement->get_startOfConstruct()->set_parent(expressionStatement);
     expressionStatement->get_endOfConstruct()->set_parent(expressionStatement);

     if (get_test() != NULL)
        {
          printf ("Warning SgForStatement::set_test_expr is clobbering the existing test statement \n");
        }
     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }

#if 0
// DQ (11/7/2006): This function is now generated by ROSETTA.

SgExpressionRoot*
SgForStatement::get_test_expr_root () const
   {
  // DQ (11/25/2005): preserve the previous interface.
  // This function returns the expression root (one IR node higher than 
  // the test expression if it is a SgExpression and not a SgStatement).
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpressionRoot*    testExpressionRoot = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
          testExpressionRoot = exprStatement->get_expression_root();
          ROSE_ASSERT(testExpressionRoot != NULL);
        }
       else
        {
          printf ("test in SgForStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpressionRoot != NULL);
     return testExpressionRoot;
   }
#endif

#if 0
// DQ (11/7/2006): This function is now generated by ROSETTA.

void
SgForStatement::set_test_expr_root (SgExpressionRoot* expressionRoot )
   {
  // DQ (11/25/2005): preserve the previous interface. This function 
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(expressionRoot != NULL);

     Sg_File_Info* fileInfo = Sg_File_Info::generateDefaultFileInfoForTransformationNode();
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expressionRoot);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (10/27/2006): This might have to be reset later,
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());

  // DQ (4/7/2006): Set the parents
     expressionRoot->set_parent(expressionStatement);

     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }
#endif

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformally on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgForStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_increment);

     set_increment(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgForStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgForStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgForStatement::variantT() const {
  return V_SgForStatement;
}

#if 0
int
SgForStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FOR_STMT;
   }
#endif

const char*
SgForStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgForStatement";  
   }

std::string
SgForStatement::class_name() const
   {
     assert(this != NULL);
     return "SgForStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgForStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgForStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FOR_STMT)
        {
          printf ("Error in SgForStatement::error(): SgForStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgForStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FOR_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgForStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgForStatement::variant() const \n");
#endif
     assert(this != NULL);
     return FOR_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgForStatement* isSgForStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgForStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgForStatement* isSgForStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgForStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgForStatement::~SgForStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgForStatement::~SgForStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for for_init_stmt
     p_for_init_stmt = NULL; // non list case 
  // case: not a listType for test
     p_test = NULL; // non list case 
  // case: not a listType for increment
     p_increment = NULL; // non list case 
  // case: not a listType for loop_body
     p_loop_body = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgForStatement::SgForStatement ( Sg_File_Info* startOfConstruct, SgStatement* test, SgExpression* increment, SgBasicBlock* loop_body )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgForStatement::SgForStatement (Sg_File_Info* startOfConstruct, SgStatement* test, SgExpression* increment, SgBasicBlock* loop_body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_for_init_stmt = NULL;
     p_test = test;
     p_increment = increment;
     p_loop_body = loop_body;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FOR_STMT == variant());
     post_construction_initialization();

  // Test the isSgForStatement() function since it has been problematic
     assert(isSgForStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgFunctionDefinition::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgFunctionDefinition::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 8099 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


// DQ (10/4/2006): Support for static map of SgBasicBlock IR nodes to integers.
// std::map<SgBasicBlockPtr, int> SgFunctionDefinition::p_block_number_map;

#if 0
// DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
void
SgFunctionDefinition::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
     SgFunctionDefinition* functionDefinition_copy = isSgFunctionDefinition(copy);
     ROSE_ASSERT(functionDefinition_copy != NULL);

#if DEBUG_FIXUP_COPY
     printf ("Inside of SgFunctionDefinition::fixupCopy() for %p = %s copy = %p \n",this,this->class_name().c_str(),copy);
#endif

  // Setup the scopes of the SgInitializedName objects in the paraleter list
     ROSE_ASSERT(get_body() != NULL);
     get_body()->fixupCopy(functionDefinition_copy->get_body(),help);

  // Do we need to re-setup the symbol table???

  // DQ (10/8/2007): We don't have to re-setup the symbol table, but we do have to add the function declaration's parameters to it.
     SgFunctionDeclaration* functionDeclaration = functionDefinition_copy->get_declaration();
  // printf ("In SgFunctionDefinition::fixupCopy(): functionDefinition = %p functionDeclaration = %p \n",this,functionDeclaration);
     if (functionDeclaration != NULL)
        {
          SgSymbolTable* symbolTable = functionDefinition_copy->get_symbol_table();

          SgInitializedNamePtrList & argumentList = functionDeclaration->get_args();
          SgInitializedNamePtrList::iterator i = argumentList.begin();
          while (i != argumentList.end())
             {
               SgInitializedName* variable = *i;
               ROSE_ASSERT(variable != NULL);
               SgName name = variable->get_name();

            // If the symbol exists, as a variable, then don't add it.
               if (symbolTable->find_variable(name) == NULL)
                  {
                    SgSymbol* symbol = new SgVariableSymbol(variable);
                    ROSE_ASSERT(symbol != NULL);
                    symbolTable->insert(name,symbol);
                  }

               i++;
             }
        }

  // Call the base class fixupCopy member function
     SgScopeStatement::fixupCopy(copy,help);
   }
#endif

unsigned int
SgFunctionDefinition::cfgIndexForEnd() const {
  return 2;
}

bool
SgFunctionDefinition::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 0 || idx == 2;
}

unsigned int 
SgFunctionDefinition::cfgFindChildIndex(SgNode* n)
   {
  // DQ (8/24/2006): Could be rewritten as:
  // Make sure that this is either the conditional, true body, or the fals body
  // ROSE_ASSERT (n == this->get_declaration()->get_parameterList() || n == this->get_body() );
  // return (n == this->get_declaration()->get_parameterList()) ? 0 : 1;

     if (n == this->get_declaration()->get_parameterList())
        {
          return 0;
        }
       else 
          if (n == this->get_body())
             {
               return 1;
             }
            else
               ROSE_ASSERT (!"Bad child in function definition");

  // DQ (8/24/2006): Added return to avoid compiler warning.
     return 0;
   }

std::vector<VirtualCFG::CFGEdge> 
SgFunctionDefinition::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_declaration()->get_parameterList()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 2: /* No out edges */ break;
    default: ROSE_ASSERT (!"Bad index for SgFunctionDefinition");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgFunctionDefinition::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: /* No in edges */ break;
    case 1: makeEdge(this->get_declaration()->get_parameterList()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: {
      makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      std::vector<SgReturnStmt*> returnStmts = findReturnStmts(this);
      for (unsigned int i = 0; i < returnStmts.size(); ++i) {
	makeEdge(returnStmts[i]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgFunctionDefinition");
  }
  return result;
}

void
SgFunctionDefinition::post_construction_initialization()
   { }

SgFunctionDefinition::SgFunctionDefinition(Sg_File_Info* f, SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(f), p_body(body)
   {
     set_declaration(d); 
     d->set_definition(this);
   }

SgFunctionDefinition::SgFunctionDefinition( SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(), p_body(body)
   {
     set_declaration(d); 
     d->set_definition(this);
   }

SgFunctionDeclaration*
SgFunctionDefinition::get_declaration() const
   {
     SgNode* res = get_parent();
     SgFunctionDeclaration* res1 = isSgFunctionDeclaration(res); 
     assert( res == 0 || res1 != 0);
     return res1;
   }

void
SgFunctionDefinition::set_declaration(SgFunctionDeclaration* new_val)
   {
     set_parent(new_val);
   }

bool
SgFunctionDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

void
SgFunctionDefinition::append_statement(SgStatement * what)
   {
     assert(this != NULL);
     if (!get_body())
        {
          set_body(new SgBasicBlock(New_File_Info(this)));
        }
     get_body()->append_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgFunctionDefinition::prepend_statement(SgStatement *what)
   {
     assert(this != NULL);
     if(!get_body()) {
          set_body(new SgBasicBlock(New_File_Info(this)));
     }
     get_body()->prepend_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// RV (2/5/2006): Added name mangling for function definitions
SgName
SgFunctionDefinition::get_mangled_name (void) const
   {
     const SgFunctionDeclaration* decl = get_declaration ();
     ROSE_ASSERT (decl);
     return decl->get_mangled_name ();
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
std::map<SgNode*,int> &
SgFunctionDefinition::get_scope_number_list()
   {
     return p_scope_number_list;
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
int
SgFunctionDefinition::get_scope_number ( const SgNode* scope ) const
   {
     if (p_scope_number_list.empty() == true)
        {
       // Build a local reference that can be modified (cast cost from this cost function to get access).
          const_cast<SgFunctionDefinition*>(this)->resetScopeNumbers();
        }

     ROSE_ASSERT (p_scope_number_list.empty() == false);

  // int uniqueScopeNumber = p_scope_number_list[scope];

  // Make sure that the required entry is in the map!
     if (const_cast<SgFunctionDefinition*>(this)->p_scope_number_list.find(const_cast<SgNode*>(scope)) == const_cast<SgFunctionDefinition*>(this)->p_scope_number_list.end())
        {
          printf ("In Function = %p = %s = %s \n",get_declaration(),get_declaration()->class_name().c_str(),SageInterface::get_name(get_declaration()).c_str());
          printf ("Looking for scope = %p = %s \n",scope,scope->class_name().c_str());
          scope->get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: input scope debug");
          get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: debug");
          for (std::map<SgNode*,int>::const_iterator i = p_scope_number_list.begin(); i != p_scope_number_list.end(); i++)
             {
               printf ("i->first = %p = %s i->second = %d \n",i->first,i->first->class_name().c_str(),i->second);
             }
        }
     ROSE_ASSERT(const_cast<SgFunctionDefinition*>(this)->p_scope_number_list.find(const_cast<SgNode*>(scope)) != const_cast<SgFunctionDefinition*>(this)->p_scope_number_list.end());

     int uniqueScopeNumber = const_cast<SgFunctionDefinition*>(this)->p_scope_number_list[const_cast<SgNode*>(scope)];

#if 0
     printf ("uniqueScopeNumber = %d for scope = %p = %s of function = %s \n",
          uniqueScopeNumber,scope,scope->class_name().c_str(),get_declaration()->get_name().str());
#endif

     ROSE_ASSERT(uniqueScopeNumber > 0);

     return uniqueScopeNumber;
   }

void
SgFunctionDefinition::clearScopeNumbers()
   {
  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::clearScopeNumbers(this);
   }

void
SgFunctionDefinition::resetScopeNumbers()
   {
  // This function will be called automatically when get_scope_number() is call if the p_scope_number_list is empty.

  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::resetScopeNumbers(this);
   }

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,int> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,int> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,int> not implemented";
     return os;
   }

// DQ (1/8/2007): Added to support qualified name generation (this forces 
// function parameters to have the correct qualified name, same as local
// variables declared in the scope of the function more directly (which
// is handled by having a special implementation of "SgBasicblock::get_qualified_name() const"
SgName
SgFunctionDefinition::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionDefinition::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionDefinition::variantT() const {
  return V_SgFunctionDefinition;
}

#if 0
int
SgFunctionDefinition::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNC_DEFN_STMT;
   }
#endif

const char*
SgFunctionDefinition::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionDefinition";  
   }

std::string
SgFunctionDefinition::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionDefinition";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionDefinition::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionDefinition::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNC_DEFN_STMT)
        {
          printf ("Error in SgFunctionDefinition::error(): SgFunctionDefinition object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionDefinition::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNC_DEFN_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionDefinition::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionDefinition::variant() const \n");
#endif
     assert(this != NULL);
     return FUNC_DEFN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionDefinition* isSgFunctionDefinition ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionDefinition*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionDefinition* isSgFunctionDefinition ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionDefinition*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionDefinition::~SgFunctionDefinition ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionDefinition::~SgFunctionDefinition (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for body
     p_body = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionDefinition::SgFunctionDefinition ( Sg_File_Info* startOfConstruct, SgBasicBlock* body )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFunctionDefinition::SgFunctionDefinition (Sg_File_Info* startOfConstruct, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_body = body;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNC_DEFN_STMT == variant());
     post_construction_initialization();

  // Test the isSgFunctionDefinition() function since it has been problematic
     assert(isSgFunctionDefinition(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgWhileStmt::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgWhileStmt::set_condition ( SgStatement* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgWhileStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgWhileStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgWhileStmt::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgWhileStmt::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10899 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

bool SgWhileStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 1;
}

unsigned int
SgWhileStmt::cfgIndexForEnd() const {
  return 2;
}

unsigned int SgWhileStmt::cfgFindNextChildIndex(SgNode* n)
   {
     unsigned int parentIndex = this->cfgFindChildIndex(n);
  // DQ (8/24/2006): Modified function to avoid compiler warning about no return value
     unsigned int returnValue;
  // if (parentIndex == 1) return 0; else return parentIndex + 1;
     if (parentIndex == 1)
          returnValue = 0;
       else
          returnValue = parentIndex + 1;

     return returnValue;
   }

std::vector<VirtualCFG::CFGEdge> SgWhileStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_condition()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result);
	    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 2), result); break;
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgWhileStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgWhileStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: {
      makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
      makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      std::vector<SgContinueStmt*> continueStmts = findContinueStmts(this->get_body());
      for (unsigned int i = 0; i < continueStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(continueStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    case 1: makeEdge(this->get_condition()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: {
      makeEdge(VirtualCFG::CFGNode(this, 1), VirtualCFG::CFGNode(this, idx), result);
      std::vector<SgBreakStmt*> breakStmts = SageInterface::findBreakStmts(this->get_body());
      for (unsigned int i = 0; i < breakStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(breakStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgWhileStmt");
  }
  return result;
}

void
SgWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgWhileStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_condition();
        }
       else
          if(n==1)
             {
               n++;
               return get_body();
             }
     return 0; 
   }
#endif

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgWhileStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgWhileStmt::variantT() const {
  return V_SgWhileStmt;
}

#if 0
int
SgWhileStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return WHILE_STMT;
   }
#endif

const char*
SgWhileStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgWhileStmt";  
   }

std::string
SgWhileStmt::class_name() const
   {
     assert(this != NULL);
     return "SgWhileStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgWhileStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgWhileStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != WHILE_STMT)
        {
          printf ("Error in SgWhileStmt::error(): SgWhileStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgWhileStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == WHILE_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgWhileStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgWhileStmt::variant() const \n");
#endif
     assert(this != NULL);
     return WHILE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgWhileStmt* isSgWhileStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgWhileStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgWhileStmt* isSgWhileStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgWhileStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgWhileStmt::~SgWhileStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgWhileStmt::~SgWhileStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for condition
     p_condition = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgWhileStmt::SgWhileStmt ( Sg_File_Info* startOfConstruct, SgStatement* condition, SgBasicBlock* body )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgWhileStmt::SgWhileStmt (Sg_File_Info* startOfConstruct, SgStatement* condition, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_condition = condition;
     p_body = body;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(WHILE_STMT == variant());
     post_construction_initialization();

  // Test the isSgWhileStmt() function since it has been problematic
     assert(isSgWhileStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgDoWhileStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgDoWhileStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgDoWhileStmt::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgDoWhileStmt::set_condition ( SgStatement* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11008 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgDoWhileStmt::cfgIndexForEnd() const {
  return 3;
}

bool SgDoWhileStmt::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 2;
}

std::vector<VirtualCFG::CFGEdge> SgDoWhileStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_condition()->cfgForBeginning(), result); break;
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 0), result);
	    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 3), result); break;
    case 3: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgDoWhileStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgDoWhileStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
	    makeEdge(VirtualCFG::CFGNode(this, 2), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: {
      makeEdge(this->get_condition()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      vector<SgContinueStmt*> continueStmts = findContinueStmts(this->get_body());
      for (unsigned int i = 0; i < continueStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(continueStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    case 3: {
      makeEdge(VirtualCFG::CFGNode(this, 2), VirtualCFG::CFGNode(this, idx), result);
      vector<SgBreakStmt*> breakStmts = SageInterface::findBreakStmts(this->get_body());
      for (unsigned int i = 0; i < breakStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(breakStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgDoWhileStmt");
  }
  return result;
}

void
SgDoWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgDoWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
}

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgDoWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDoWhileStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDoWhileStmt::variantT() const {
  return V_SgDoWhileStmt;
}

#if 0
int
SgDoWhileStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DO_WHILE_STMT;
   }
#endif

const char*
SgDoWhileStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDoWhileStmt";  
   }

std::string
SgDoWhileStmt::class_name() const
   {
     assert(this != NULL);
     return "SgDoWhileStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDoWhileStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDoWhileStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DO_WHILE_STMT)
        {
          printf ("Error in SgDoWhileStmt::error(): SgDoWhileStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDoWhileStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DO_WHILE_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDoWhileStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDoWhileStmt::variant() const \n");
#endif
     assert(this != NULL);
     return DO_WHILE_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDoWhileStmt* isSgDoWhileStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDoWhileStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDoWhileStmt* isSgDoWhileStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDoWhileStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDoWhileStmt::~SgDoWhileStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgDoWhileStmt::~SgDoWhileStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for condition
     p_condition = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDoWhileStmt::SgDoWhileStmt ( Sg_File_Info* startOfConstruct, SgBasicBlock* body, SgStatement* condition )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDoWhileStmt::SgDoWhileStmt (Sg_File_Info* startOfConstruct, SgBasicBlock* body, SgStatement* condition) sage_class_name() = %s \n",sage_class_name());
#endif

     p_body = body;
     p_condition = condition;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DO_WHILE_STMT == variant());
     post_construction_initialization();

  // Test the isSgDoWhileStmt() function since it has been problematic
     assert(isSgDoWhileStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgSwitchStatement::get_item_selector () const
   {
     assert (this != NULL);
     return p_item_selector;
   }

void
SgSwitchStatement::set_item_selector ( SgStatement* item_selector )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_item_selector != NULL && item_selector != NULL && p_item_selector != item_selector)
        {
          printf ("Warning: item_selector = %p overwriting valid pointer p_item_selector = %p \n",item_selector,p_item_selector);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_item_selector != NULL && item_selector != NULL && p_item_selector != item_selector) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_item_selector = item_selector;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgSwitchStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgSwitchStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgSwitchStatement::get_end_numeric_label () const
   {
     assert (this != NULL);
     return p_end_numeric_label;
   }

void
SgSwitchStatement::set_end_numeric_label ( int end_numeric_label )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_end_numeric_label = end_numeric_label;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11086 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

unsigned int
SgSwitchStatement::cfgIndexForEnd() const {
  return 2;
}

bool SgSwitchStatement::cfgIsIndexInteresting(unsigned int idx) const {
  return idx == 1;
}

std::vector<VirtualCFG::CFGEdge> SgSwitchStatement::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_item_selector()->cfgForBeginning(), result); break;
    case 1: {
      vector<SgStatement*> cases = getSwitchCases(this); // Also includes default statements
      for (unsigned int i = 0; i < cases.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(this, idx), cases[i]->cfgForBeginning(), result);
      }
      break;
    }
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgSwitchStatement");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgSwitchStatement::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_item_selector()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: {
      makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
      vector<SgBreakStmt*> breakStmts = SageInterface::findBreakStmts(this->get_body());
      for (unsigned int i = 0; i < breakStmts.size(); ++i) {
	makeEdge(VirtualCFG::CFGNode(breakStmts[i], 0), VirtualCFG::CFGNode(this, idx), result);
      }
      break;
    }
    default: ROSE_ASSERT (!"Bad index for SgSwitchStatement");
  }
  return result;
}

void
SgSwitchStatement::post_construction_initialization()
   {
 // if (get_item_selector_root() != 0)
 //      get_item_selector_root()->set_parent(this);
    if (get_item_selector() != NULL)
       get_item_selector()->set_parent(this);
   }

bool
SgSwitchStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

void
SgSwitchStatement::append_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }

     get_body()->append_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::prepend_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }
     get_body()->prepend_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::append_default(SgDefaultOptionStmt *& what)
   {
  // if(!get_body()) set_body(new SgBasicBlock(this->get_file_info()));
     assert(this != NULL);
     if(!get_body())
        {
       // set_body(new SgBasicBlock(this->get_file_info()));
          SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
          assert(newBlock != NULL);
          set_body(newBlock);
        }
     get_body()->append_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgSwitchStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSwitchStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSwitchStatement::variantT() const {
  return V_SgSwitchStatement;
}

#if 0
int
SgSwitchStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SWITCH_STMT;
   }
#endif

const char*
SgSwitchStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSwitchStatement";  
   }

std::string
SgSwitchStatement::class_name() const
   {
     assert(this != NULL);
     return "SgSwitchStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSwitchStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSwitchStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SWITCH_STMT)
        {
          printf ("Error in SgSwitchStatement::error(): SgSwitchStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSwitchStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SWITCH_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSwitchStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSwitchStatement::variant() const \n");
#endif
     assert(this != NULL);
     return SWITCH_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSwitchStatement* isSgSwitchStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSwitchStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSwitchStatement* isSgSwitchStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSwitchStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSwitchStatement::~SgSwitchStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgSwitchStatement::~SgSwitchStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for item_selector
     p_item_selector = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for end_numeric_label
     p_end_numeric_label = -1; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSwitchStatement::SgSwitchStatement ( Sg_File_Info* startOfConstruct, SgStatement* item_selector, SgBasicBlock* body )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSwitchStatement::SgSwitchStatement (Sg_File_Info* startOfConstruct, SgStatement* item_selector, SgBasicBlock* body) sage_class_name() = %s \n",sage_class_name());
#endif

     p_item_selector = item_selector;
     p_body = body;
     p_end_numeric_label = -1;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SWITCH_STMT == variant());
     post_construction_initialization();

  // Test the isSgSwitchStatement() function since it has been problematic
     assert(isSgSwitchStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgVariableDeclaration* 
SgCatchOptionStmt::get_condition () const
   {
     assert (this != NULL);
     return p_condition;
   }

void
SgCatchOptionStmt::set_condition ( SgVariableDeclaration* condition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_condition != NULL && condition != NULL && p_condition != condition)
        {
          printf ("Warning: condition = %p overwriting valid pointer p_condition = %p \n",condition,p_condition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_condition != NULL && condition != NULL && p_condition != condition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_condition = condition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgCatchOptionStmt::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgCatchOptionStmt::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTryStmt* 
SgCatchOptionStmt::get_trystmt () const
   {
     assert (this != NULL);
     return p_trystmt;
   }

void
SgCatchOptionStmt::set_trystmt ( SgTryStmt* trystmt )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_trystmt != NULL && trystmt != NULL && p_trystmt != trystmt)
        {
          printf ("Warning: trystmt = %p overwriting valid pointer p_trystmt = %p \n",trystmt,p_trystmt);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_trystmt != NULL && trystmt != NULL && p_trystmt != trystmt) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_trystmt = trystmt;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 11470 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


unsigned int
SgCatchOptionStmt::cfgIndexForEnd() const {
  return 2;
}

std::vector<VirtualCFG::CFGEdge> SgCatchOptionStmt::cfgOutEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_condition()->cfgForBeginning(), result); break;
    case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_body()->cfgForBeginning(), result); break;
    case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
    default: ROSE_ASSERT (!"Bad index for SgCatchOptionStmt");
  }
  return result;
}

std::vector<VirtualCFG::CFGEdge> SgCatchOptionStmt::cfgInEdges(unsigned int idx) {
  std::vector<VirtualCFG::CFGEdge> result;
  switch (idx) {
    case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
    case 1: makeEdge(this->get_condition()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    case 2: makeEdge(this->get_body()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
    default: ROSE_ASSERT (!"Bad index for SgCatchOptionStmt");
  }
  return result;
}

void
SgCatchOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgCatchOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
         return true;
     else if ( StatementReplace(this, p_body, target, newstmt) == true )
         return true;
     else
         return false;
   }

#if 0
SgStatement*
SgCatchOptionStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          if(get_condition())
               return get_condition();
            else
             {
               n++;
               return get_body();
             }
        }
       else
          if(n==1)
             {
               n++;
               get_body();
             }
     return 0;
   }
#endif

SgName
SgCatchOptionStmt::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
     return SgName("");
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCatchOptionStmt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCatchOptionStmt::variantT() const {
  return V_SgCatchOptionStmt;
}

#if 0
int
SgCatchOptionStmt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CATCH_STMT;
   }
#endif

const char*
SgCatchOptionStmt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCatchOptionStmt";  
   }

std::string
SgCatchOptionStmt::class_name() const
   {
     assert(this != NULL);
     return "SgCatchOptionStmt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCatchOptionStmt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCatchOptionStmt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CATCH_STMT)
        {
          printf ("Error in SgCatchOptionStmt::error(): SgCatchOptionStmt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCatchOptionStmt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CATCH_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCatchOptionStmt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCatchOptionStmt::variant() const \n");
#endif
     assert(this != NULL);
     return CATCH_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCatchOptionStmt* isSgCatchOptionStmt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCatchOptionStmt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCatchOptionStmt* isSgCatchOptionStmt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCatchOptionStmt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCatchOptionStmt::~SgCatchOptionStmt ()
   {
#if 0
  // debugging information!
     printf ("In SgCatchOptionStmt::~SgCatchOptionStmt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for condition
     p_condition = NULL; // non list case 
  // case: not a listType for body
     p_body = NULL; // non list case 
  // case: not a listType for trystmt
     p_trystmt = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCatchOptionStmt::SgCatchOptionStmt ( Sg_File_Info* startOfConstruct, SgVariableDeclaration* condition, SgBasicBlock* body, SgTryStmt* trystmt )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCatchOptionStmt::SgCatchOptionStmt (Sg_File_Info* startOfConstruct, SgVariableDeclaration* condition, SgBasicBlock* body, SgTryStmt* trystmt) sage_class_name() = %s \n",sage_class_name());
#endif

     p_condition = condition;
     p_body = body;
     p_trystmt = trystmt;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CATCH_STMT == variant());
     post_construction_initialization();

  // Test the isSgCatchOptionStmt() function since it has been problematic
     assert(isSgCatchOptionStmt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgDeclarationStatementPtrList &
SgNamespaceDefinitionStatement::get_declarations () const
   {
     assert (this != NULL);
     return p_declarations;
   }

SgDeclarationStatementPtrList &
SgNamespaceDefinitionStatement::get_declarations () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_declarations;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDeclarationStatement* 
SgNamespaceDefinitionStatement::get_namespaceDeclaration () const
   {
     assert (this != NULL);
     return p_namespaceDeclaration;
   }

void
SgNamespaceDefinitionStatement::set_namespaceDeclaration ( SgNamespaceDeclarationStatement* namespaceDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration)
        {
          printf ("Warning: namespaceDeclaration = %p overwriting valid pointer p_namespaceDeclaration = %p \n",namespaceDeclaration,p_namespaceDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_namespaceDeclaration != NULL && namespaceDeclaration != NULL && p_namespaceDeclaration != namespaceDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_namespaceDeclaration = namespaceDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 12626 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


bool
SgNamespaceDefinitionStatement::isSameNamespace(const SgNamespaceDefinitionStatement* n ) const
   {
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(this->get_namespaceDeclaration() != NULL);
     ROSE_ASSERT(n->get_namespaceDeclaration() != NULL);

     return this->get_namespaceDeclaration()->isSameNamespace(n->get_namespaceDeclaration());
   }

void
SgNamespaceDefinitionStatement::append_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().end(),what);
   }

void
SgNamespaceDefinitionStatement::prepend_declaration(SgDeclarationStatement * what) 
   {
     insert_declaration(get_declarations().begin(),what);
   }

void
SgNamespaceDefinitionStatement::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where, 
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }

// DQ (8/27/2004): Turn this back on!
#if 1
bool
SgNamespaceDefinitionStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool 
SgNamespaceDefinitionStatement::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
{
  return  StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
}
#endif

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDefinitionStatement::get_qualified_name() const
   {
  // printf ("In SgNamespaceDefinitionStatement::get_qualified_name() \n");

     ROSE_ASSERT(get_namespaceDeclaration() != NULL);
     return get_namespaceDeclaration()->get_qualified_name();
   }

// RV (2/1/2006): Added mangler for namespace definitions.
SgName
SgNamespaceDefinitionStatement::get_mangled_name (void) const
  {
    ROSE_ASSERT (get_namespaceDeclaration());
    return get_namespaceDeclaration()->get_mangled_name ();
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 12450 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgNamespaceDefinitionStatement::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNamespaceDefinitionStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNamespaceDefinitionStatement::variantT() const {
  return V_SgNamespaceDefinitionStatement;
}

#if 0
int
SgNamespaceDefinitionStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NAMESPACE_DEFINITION_STMT;
   }
#endif

const char*
SgNamespaceDefinitionStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceDefinitionStatement";  
   }

std::string
SgNamespaceDefinitionStatement::class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceDefinitionStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNamespaceDefinitionStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNamespaceDefinitionStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NAMESPACE_DEFINITION_STMT)
        {
          printf ("Error in SgNamespaceDefinitionStatement::error(): SgNamespaceDefinitionStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNamespaceDefinitionStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NAMESPACE_DEFINITION_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNamespaceDefinitionStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNamespaceDefinitionStatement::variant() const \n");
#endif
     assert(this != NULL);
     return NAMESPACE_DEFINITION_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNamespaceDefinitionStatement* isSgNamespaceDefinitionStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNamespaceDefinitionStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNamespaceDefinitionStatement* isSgNamespaceDefinitionStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNamespaceDefinitionStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNamespaceDefinitionStatement::~SgNamespaceDefinitionStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgNamespaceDefinitionStatement::~SgNamespaceDefinitionStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for namespaceDeclaration
     p_namespaceDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNamespaceDefinitionStatement::SgNamespaceDefinitionStatement ( Sg_File_Info* startOfConstruct, SgNamespaceDeclarationStatement* namespaceDeclaration )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNamespaceDefinitionStatement::SgNamespaceDefinitionStatement (Sg_File_Info* startOfConstruct, SgNamespaceDeclarationStatement* namespaceDeclaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_namespaceDeclaration = namespaceDeclaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NAMESPACE_DEFINITION_STMT == variant());
     post_construction_initialization();

  // Test the isSgNamespaceDefinitionStatement() function since it has been problematic
     assert(isSgNamespaceDefinitionStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgBasicBlock* 
SgBlockDataStatement::get_body () const
   {
     assert (this != NULL);
     return p_body;
   }

void
SgBlockDataStatement::set_body ( SgBasicBlock* body )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_body != NULL && body != NULL && p_body != body)
        {
          printf ("Warning: body = %p overwriting valid pointer p_body = %p \n",body,p_body);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_body != NULL && body != NULL && p_body != body) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_body = body;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 13527 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"

void
SgBlockDataStatement::post_construction_initialization()
   {}


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBlockDataStatement::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBlockDataStatement::variantT() const {
  return V_SgBlockDataStatement;
}

#if 0
int
SgBlockDataStatement::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMP_Block_Data_Statement;
   }
#endif

const char*
SgBlockDataStatement::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBlockDataStatement";  
   }

std::string
SgBlockDataStatement::class_name() const
   {
     assert(this != NULL);
     return "SgBlockDataStatement";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBlockDataStatement::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBlockDataStatement::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMP_Block_Data_Statement)
        {
          printf ("Error in SgBlockDataStatement::error(): SgBlockDataStatement object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBlockDataStatement::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMP_Block_Data_Statement);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBlockDataStatement::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBlockDataStatement::variant() const \n");
#endif
     assert(this != NULL);
     return TEMP_Block_Data_Statement;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBlockDataStatement* isSgBlockDataStatement ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBlockDataStatement*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBlockDataStatement* isSgBlockDataStatement ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBlockDataStatement*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBlockDataStatement::~SgBlockDataStatement ()
   {
#if 0
  // debugging information!
     printf ("In SgBlockDataStatement::~SgBlockDataStatement (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for body
     p_body = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBlockDataStatement::SgBlockDataStatement ( Sg_File_Info* startOfConstruct )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgBlockDataStatement::SgBlockDataStatement (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_body = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMP_Block_Data_Statement == variant());
     post_construction_initialization();

  // Test the isSgBlockDataStatement() function since it has been problematic
     assert(isSgBlockDataStatement(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgDeclarationStatementPtrList &
SgClassDefinition::get_members () const
   {
     assert (this != NULL);
     return p_members;
   }

SgDeclarationStatementPtrList &
SgClassDefinition::get_members () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_members;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/listMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

const SgBaseClassPtrList &
SgClassDefinition::get_inheritances () const
   {
     assert (this != NULL);
     return p_inheritances;
   }

SgBaseClassPtrList &
SgClassDefinition::get_inheritances () 
   {
     assert (this != NULL);
     set_isModified(true);
     return p_inheritances;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned int 
SgClassDefinition::get_packingAlignment () const
   {
     assert (this != NULL);
     return p_packingAlignment;
   }

void
SgClassDefinition::set_packingAlignment ( unsigned int packingAlignment )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_packingAlignment = packingAlignment;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 10326 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgClassDefinition::post_construction_initialization()
   {
  // DQ (9/5/2006): I don't think that this is called, but if it is then packingAlignment initialization is required.
     p_packingAlignment = 0;
   }

void
SgClassDefinition::set_declaration(SgClassDeclaration* new_val)
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     set_parent(new_val);
   }

SgClassDeclaration*
SgClassDefinition::get_declaration() const
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     SgClassDeclaration *decl= isSgClassDeclaration(get_parent());
     assert( get_parent() == NULL || decl != NULL ); 
     return decl;
   }

SgClassDefinition::SgClassDefinition( Sg_File_Info *f, SgClassDeclaration *decl)
   : SgScopeStatement(f)
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

SgClassDefinition::SgClassDefinition( SgClassDeclaration *decl)
   : SgScopeStatement()
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

void
SgClassDefinition::insert_member(const SgDeclarationStatementPtrList::iterator& where, SgDeclarationStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_members().insert(where,what);
   }

void
SgClassDefinition::append_member(SgDeclarationStatement * what) 
   {
     insert_member(get_members().end(),what);
   }

void
SgClassDefinition::prepend_member(SgDeclarationStatement * what) 
   {
     insert_member(get_members().begin(),what);
   }

void
// SgClassDefinition::append_inheritance(const SgBaseClass & what)
SgClassDefinition::append_inheritance(SgBaseClass* what)
   {
     insert_inheritance(get_inheritances().end(),what);
   }

void
// SgClassDefinition::prepend_inheritance(const SgBaseClass & what)
SgClassDefinition::prepend_inheritance(SgBaseClass* what)
   {
     insert_inheritance(get_inheritances().begin(),what);
   }

void
// SgClassDefinition::insert_inheritance(const SgBaseClassList::iterator & where, const SgBaseClass & what)
SgClassDefinition::insert_inheritance(const SgBaseClassPtrList::iterator & where, SgBaseClass* what)
   { 
     get_inheritances().insert(where,what);
   }

SgName
SgClassDefinition::get_qualified_name() const
   {
  // printf ("In SgClassDefinition::get_qualified_name() \n");
     return get_declaration()->get_qualified_name();
   }

// DQ (2/7/2006): code added by Rich Vuduc
SgName
SgClassDefinition::get_mangled_name (void) const
   {
     return get_declaration()->get_mangled_name ();
   }

SgName
SgClassDefinition::get_mangled_qualified_name (int& i) 
   {
  // printf ("In SgClassDefinition::get_mangled_qualified_name(%d): Calling get_declaration()->get_mangled_qualified_name(%d) \n",i,i);
     return get_declaration()->get_mangled_qualified_name(i);
   }

bool
SgClassDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return StatementListInsertChild(this, get_members(), target, newstmt, true, extractBasicBlock, true);
   }

bool
SgClassDefinition::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront,
                                 bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, get_members(), target, newstmt, inFront, extractBasicBlock, false);
   }

#if 0
// DQ (8/18/2004): removing this older pragma mechanism
/******  SgClassDeclaration ******/
int
get_suppress_global(SgClassDeclaration *node)
   {
     SgClassDecl_attr *attr= (SgClassDecl_attr *) Sgget_user_attribute(node->get_uattributes(),"SgClassDecl_attr");
     if(attr)
          return attr->get_suppress_global();

     return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassDefinition::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassDefinition::variantT() const {
  return V_SgClassDefinition;
}

#if 0
int
SgClassDefinition::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CLASS_DEFN_STMT;
   }
#endif

const char*
SgClassDefinition::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassDefinition";  
   }

std::string
SgClassDefinition::class_name() const
   {
     assert(this != NULL);
     return "SgClassDefinition";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassDefinition::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassDefinition::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CLASS_DEFN_STMT)
        {
          printf ("Error in SgClassDefinition::error(): SgClassDefinition object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassDefinition::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CLASS_DEFN_STMT);
     return SgScopeStatement::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassDefinition::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassDefinition::variant() const \n");
#endif
     assert(this != NULL);
     return CLASS_DEFN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassDefinition* isSgClassDefinition ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassDefinition*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassDefinition* isSgClassDefinition ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassDefinition*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassDefinition::~SgClassDefinition ()
   {
#if 0
  // debugging information!
     printf ("In SgClassDefinition::~SgClassDefinition (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for packingAlignment
     p_packingAlignment = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClassDefinition::SgClassDefinition ( Sg_File_Info* startOfConstruct )
   : SgScopeStatement(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClassDefinition::SgClassDefinition (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_packingAlignment = 0;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CLASS_DEFN_STMT == variant());
     post_construction_initialization();

  // Test the isSgClassDefinition() function since it has been problematic
     assert(isSgClassDefinition(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 10279 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Statement.code"


void
SgTemplateInstantiationDefn::post_construction_initialization()
   {
   }


// DQ (9/8/2004): overrides base class implementation
SgName
SgTemplateInstantiationDefn::get_qualified_name() const
   {
  // printf ("In SgTemplateInstantiationDefn::get_qualified_name() \n");

  // It is a little less trivial to obtain the SgTemplateInstatiationDecl from the SgTemplateInstatiationDefn
  // since get_declaration() returns a SgClassDeclaration pointer and not a SgTemplateInstantiationDecl pointer.
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
     ROSE_ASSERT(templateInstantiationDeclaration != NULL);

  // DQ (10/16/2004): Not sure why this is not set!
  // ROSE_ASSERT (get_parent() != NULL);
     if (templateInstantiationDeclaration->get_parent() == NULL)
        {
          printf ("templateInstantiationDeclaration->get_parent() == NULL SgTemplateInstantiationDecl = %p SgClassDefinition = %p \n",
               templateInstantiationDeclaration,this);
          get_file_info()->display("SgTemplateInstantiationDefn");
          templateInstantiationDeclaration->get_file_info()->display("templateInstantiationDeclaration");
        }
     ROSE_ASSERT (templateInstantiationDeclaration->get_parent() != NULL);

     return templateInstantiationDeclaration->get_qualified_name();
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( Sg_File_Info *f, SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(f,decl)
   {
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(decl)
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateInstantiationDefn::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateInstantiationDefn::variantT() const {
  return V_SgTemplateInstantiationDefn;
}

#if 0
int
SgTemplateInstantiationDefn::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_INST_DEFN_STMT;
   }
#endif

const char*
SgTemplateInstantiationDefn::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDefn";  
   }

std::string
SgTemplateInstantiationDefn::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateInstantiationDefn";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateInstantiationDefn::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateInstantiationDefn::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_INST_DEFN_STMT)
        {
          printf ("Error in SgTemplateInstantiationDefn::error(): SgTemplateInstantiationDefn object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateInstantiationDefn::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_INST_DEFN_STMT);
     return SgClassDefinition::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateInstantiationDefn::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDefn::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_INST_DEFN_STMT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateInstantiationDefn* isSgTemplateInstantiationDefn ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateInstantiationDefn*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateInstantiationDefn* isSgTemplateInstantiationDefn ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateInstantiationDefn*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateInstantiationDefn::~SgTemplateInstantiationDefn ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateInstantiationDefn::~SgTemplateInstantiationDefn (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateInstantiationDefn::SgTemplateInstantiationDefn ( Sg_File_Info* startOfConstruct )
   : SgClassDefinition(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTemplateInstantiationDefn::SgTemplateInstantiationDefn (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(TEMPLATE_INST_DEFN_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationDefn() function since it has been problematic
     assert(isSgTemplateInstantiationDefn(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgExpression::get_need_paren () const
   {
     assert (this != NULL);
     return p_need_paren;
   }

void
SgExpression::set_need_paren ( bool need_paren )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_paren = need_paren;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgExpression::get_lvalue () const
   {
     assert (this != NULL);
     return p_lvalue;
   }

void
SgExpression::set_lvalue ( bool lvalue )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_lvalue = lvalue;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgExpression::get_global_qualified_name () const
   {
     assert (this != NULL);
     return p_global_qualified_name;
   }

void
SgExpression::set_global_qualified_name ( bool global_qualified_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_global_qualified_name = global_qualified_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

Sg_File_Info* 
SgExpression::get_operatorPosition () const
   {
     assert (this != NULL);
     return p_operatorPosition;
   }

void
SgExpression::set_operatorPosition ( Sg_File_Info* operatorPosition )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operatorPosition != NULL && operatorPosition != NULL && p_operatorPosition != operatorPosition)
        {
          printf ("Warning: operatorPosition = %p overwriting valid pointer p_operatorPosition = %p \n",operatorPosition,p_operatorPosition);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operatorPosition != NULL && operatorPosition != NULL && p_operatorPosition != operatorPosition) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operatorPosition = operatorPosition;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 873 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


Sg_File_Info*
SgExpression::get_file_info() const
   {
  // DQ (11/8/2006): Note that the EDG/SageIII translation only 
  // uses set_startOfConstruct() and set_endOfConstruct().

  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_operatorPosition()" instead of the get_startOfConstruct()"
  // Most if not all operator positions will associated with syntax for the operator.
  // return get_operatorPosition();
     Sg_File_Info* returnFileInfo = get_operatorPosition();
     if (returnFileInfo == NULL)
          returnFileInfo = get_startOfConstruct();
     return returnFileInfo;
   }

void
SgExpression::set_file_info(Sg_File_Info* fileInfo)
   {
  // DQ (11/8/2006): Note that the EDG/SageIII translation only 
  // uses set_startOfConstruct() and set_endOfConstruct().

  // This redefines get_file_info() as it is implemented for a SgLocatedNode
  // to use the "get_operatorPosition()" instead of the get_startOfConstruct()"
  // Most if not all operator positions will associated with syntax for the operator.
     return set_operatorPosition(fileInfo);
   }

unsigned int 
SgExpression::cfgIndexForEnd() const 
   {
     std::cerr << "Bad expression case " << this->class_name() << " in cfgIndexForEnd()" << std::endl;
     ROSE_ASSERT (false);
   }

bool
SgExpression::cfgIsIndexInteresting(unsigned int idx) const {
    // Default -- overridden in short-circuiting operators
    return idx == this->cfgIndexForEnd();
  }

unsigned int
SgExpression::cfgFindChildIndex(SgNode* n) {
    // Default -- overridden in some cases
    // FIXME -- should override with something faster than this code, even when
    // it works
    vector<SgNode*> succs = this->get_traversalSuccessorContainer();
    size_t idx = std::find(succs.begin(), succs.end(), n) - succs.begin();
    ROSE_ASSERT ((size_t)idx != succs.size());
    return idx;
  }

unsigned int
SgExpression::cfgFindNextChildIndex(SgNode* n) {
    return this->cfgFindChildIndex(n) + 1;
  }

  std::vector<VirtualCFG::CFGEdge> SgExpression::cfgOutEdges(unsigned int) {
    std::cerr << "Bad expression case " << this->class_name() << " in cfgOutEdges()" << std::endl;
    ROSE_ASSERT (false);
  }

  std::vector<VirtualCFG::CFGEdge> SgExpression::cfgInEdges(unsigned int) {
    std::cerr << "Bad expression case " << this->class_name() << " in cfgInEdges()" << std::endl;
    ROSE_ASSERT (false);
  }

void
SgExpression::post_construction_initialization()
   {
   }

int
SgExpression::replace_expression(SgExpression *,SgExpression *)
   {
     printf ("Error: base class  SgExpression::replace_expression called, likely a mistake! \n");
     ROSE_ASSERT(false);
     return 0;
   }

#if 0
// DQ (1/14/2006): set_type is removed
void
SgExpression::set_type()
   {
    /* 
     * this is a quick hack to allow me to rely on being to create a non
     * abstract object.  For some expression classes this had not been 
     * overridden
     */
     
     cerr << "Call to undefined set_type(): aborting" << endl;
     exit(1);
   }
#endif

SgType*
SgExpression::get_type() const
   {
  // DQ: With this function defined we can be sure that we don't call it by accident.
  // This catches any IR nodes where the fucntion should have been overwritten and was not.

     cerr << "Call to undefined SgExpression::get_type(): aborting" << endl;
     ROSE_ASSERT(false);

     return 0;
   }

#if 0
// DQ (8/18/2004): removing this older pragma mechanism
void
SgExpression::output_pragma(ostream& os)
   {
     ::print_pragma( p_uattributes, os);
   }
#endif

int
SgExpression::precedence() const
   {
     return 0;
   }

#if 0
int
SgExpression::length() const
   {
     return 0;
   }
#endif

#if 0
bool
SgExpression::empty() const
   {
     return 1;
   }
#endif

#if 0
SgExpression*
SgExpression::get_first() const
   {
     int p = 0;
     return get_next(p);
   }
#endif

#if 0
SgExpression*
SgExpression::get_next(int&) const
   {
     printf ("Error: baseClass called! \n");
     abort();

     return NULL;
   }
#endif

#if 0
SgExpression*
SgExpression::get_end() const
   {
     printf ("Error: baseClass called! \n");
     abort();

     return NULL;
   }
#endif

#if 0
void
SgExpression::insert_next(int,SgExpression *)
   {
   }
#endif

#if 0
SgExpressionPtrList::iterator
SgExpression::begin()
   { return get_first(); }

SgExpressionPtrList::iterator
SgExpression::end()
   { return get_end(); }
#endif

#if 0
// DQ (8/18/2004): Removed since it is not used!
void
SgExpression::set_lvalue()
   {
#if 0
     printf ("ERROR: not yet implemented in SAGE3! \n");
     abort();
#else
     set_system_bitflag(p_uattributes,e_lvalue);
#endif
   }

int
SgExpression::get_is_lvalue() const 
   { return is_system_bitflag(p_uattributes,e_lvalue); }
#endif

 
#if 0
void
SgExpression::unset_lvalue() 
   { unset_system_bitflag(p_uattributes,e_lvalue); }

void
SgExpression::add_pragma(int cnt, SgPragma** plist)
   {
     for(int i=0; i<cnt; i++)
        {
          ::add_pragma(p_uattributes, plist[i]);
          plist[i]=0; 
        }
   }

SgPragma*
SgExpression::add_pragma(char *nm) 
   { return ::add_pragma(p_uattributes, nm); }

SgPragma*
SgExpression::get_pragma(char *nm) const
   { return ::get_pragma(p_uattributes, nm); }

int
SgExpression::remove_pragma(char *nm) 
   { return ::remove_pragma(p_uattributes,nm); }

// get attribute,
SgAttribute*
SgExpression::get_user_attribute(char *nm) const
   { return ::Sgget_user_attribute(p_uattributes,nm); }

SgAttribute*
SgExpression::add_user_attribute(char *nm, SgAttribute* attr)
   { return ::Sgadd_user_attribute(p_uattributes,nm,attr); }

int
SgExpression::remove_user_attribute(char *nm)
   { return ::remove_user_attribute(p_uattributes,nm); }
#endif

#if 0
// DQ (8/18/2004): Removed since it uses the old attribute mechanism
// Some global functions that are used by expressions
SgAttribute*
get_system_bitflag(const SgAttributePtrList & pattr)
   {
     SgAttributePtrList::const_iterator p = pattr.begin();
     if(p == pattr.end())
          return NULL;
       else
        {
          assert((*p) != NULL);
          return (SgAttribute *)(*p); // first one
        }
   }

/* always the first SgAttributePtr in the list */
void
set_system_bitflag(SgAttributePtrList & pattr, unsigned long int bit)
   {
     SgAttributePtrList::iterator p = pattr.begin();
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          p = pattr.insert(p, newAttribute);
      //  p = pattr.insert(p,(SgAttribute *) new SgBitAttribute("SYS_BITFLAG"));
        }

     SgBitAttribute *bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     bp->setAttribute(bit);
   }

void
unset_system_bitflag(SgAttributePtrList& pattr, unsigned long int bit)
   {
     SgAttributePtrList::iterator p=pattr.begin();  
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          p=pattr.insert(p,(SgAttribute *) newAttribute);
       // p=pattr.insert(p,(SgAttribute *) new SgBitAttribute("SYS_BITFLAG"));
        }

     SgBitAttribute* bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     bp->unsetAttribute(bit);
   }

int
is_system_bitflag(const SgAttributePtrList& pattr, unsigned long int bit)
   {
     SgAttributePtrList::const_iterator p=pattr.begin();  
     if(p==pattr.end())
          return 0;

     SgBitAttribute *bp = (SgBitAttribute *)(*p);
     assert(bp != NULL);
     return bp->isAttributeSet(bit);
   }

SgAttribute*
Sgadd_user_attribute(SgAttributePtrList& pattr, char *attr_name, SgAttribute* attr)
   {
     SgAttributePtrList::iterator p=pattr.begin();
     if(p==pattr.end())
        {
          SgBitAttribute* newAttribute = new SgBitAttribute("SYS_BITFLAG");
          assert(newAttribute != NULL);
          pattr.insert(p,newAttribute);
       // pattr.insert(p,(SgAttribute *)new SgBitAttribute("SYS_BITFLAG"));
        }
     p++;

  // I think it would not make much sense to insert a NULL pointer
     assert(attr != NULL);
     pattr.insert(pattr.end(), attr);
     p++;

  // DQ: Not sure we can assert that the return value is a valid pointer
     assert((*p) != NULL);
     return (SgAttribute *)(*p);
   }

// get user attribute,
SgAttribute*
Sgget_user_attribute(const SgAttributePtrList& pattr, char *attr_name)
   {
     assert(attr_name != NULL);
     SgAttributePtrList::const_iterator p = pattr.begin();
     if(p == pattr.end())
          return 0;
       else
          p++; // skip the system attribute

     while( p != pattr.end())
        {
          assert((*p) != NULL);
          if( !(*p)->isPragma() && (*p)->isSame(attr_name) ) 
             {
               assert((*p) != NULL);
               return (SgAttribute *)(*p);
             }
          p++;
        }

     return NULL;
   }

int
remove_user_attribute(SgAttributePtrList& pattr, char *attr_name)
   {
     assert(attr_name != NULL);
     SgAttributePtrList::iterator p = pattr.begin();
     if(p==pattr.end())
          return 0;
       else
          p++; // skip the system one

     while( p!=pattr.end())
        {
          assert((*p) != NULL);
          if( !(*p)->isPragma() && (*p)->isSame(attr_name) )
             {
               pattr.remove((*p));
               return 1;
             }
          p++;
        }

     return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgExpression::variantT() const {
  return V_SgExpression;
}

#if 0
int
SgExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ExpressionTag;
   }
#endif

const char*
SgExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgExpression";  
   }

std::string
SgExpression::class_name() const
   {
     assert(this != NULL);
     return "SgExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ExpressionTag)
        {
          printf ("Error in SgExpression::error(): SgExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ExpressionTag);
     return SgLocatedNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgExpression::variant() const \n");
#endif
     assert(this != NULL);
     return ExpressionTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgExpression* isSgExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgExpression* isSgExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgExpression::~SgExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgExpression::~SgExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_operatorPosition;

  // case: not a listType for need_paren
     p_need_paren = false; // non list case 
  // case: not a listType for lvalue
     p_lvalue = false; // non list case 
  // case: not a listType for global_qualified_name
     p_global_qualified_name = false; // non list case 
  // case: not a listType for operatorPosition
     p_operatorPosition = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgExpression::SgExpression ( Sg_File_Info* startOfConstruct )
   : SgLocatedNode(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgExpression::SgExpression (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_need_paren = false;
     p_lvalue = false;
     p_global_qualified_name = false;
     p_operatorPosition = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ExpressionTag == variant());
     post_construction_initialization();

  // Test the isSgExpression() function since it has been problematic
     assert(isSgExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgExprListExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1670 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int
SgExprListExp::cfgIndexForEnd() const
   {
     return this->get_expressions().size();
   }

std::vector<VirtualCFG::CFGEdge>
SgExprListExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     if (idx == this->get_expressions().size())
        {
          makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
        }
       else
          if (idx < this->get_expressions().size())
             {
               makeEdge(VirtualCFG::CFGNode(this, idx), this->get_expressions()[idx]->cfgForBeginning(), result);
             }
            else
               ROSE_ASSERT (!"Bad index for SgExprListExp");

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgExprListExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     if (idx == 0)
        {
          makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
        }
       else
          if (idx <= this->get_expressions().size())
             {
               makeEdge(this->get_expressions()[idx - 1]->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
             }
            else
               ROSE_ASSERT (!"Bad index for SgExprListExp");

     return result;
   }

bool
SgExprListExp::empty() const
   {
     if (p_expressions.empty())
          return 1;
       else
          return 0;
   }

SgExpressionPtrList&
SgExprListExp::get_expressions()
   { return p_expressions; }

const SgExpressionPtrList&
SgExprListExp::get_expressions() const
   { return p_expressions; }

void
SgExprListExp::append_expression(SgExpression *what)
   { insert_expression(p_expressions.end(),what); }

void
SgExprListExp::prepend_expression(SgExpression *what)
   { insert_expression(p_expressions.begin(),what); }

void
SgExprListExp::insert_expression(const SgExpressionPtrList::iterator &where, SgExpression *what)
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
// #endif
     p_expressions.insert(where,what);
   }

#if 0
SgExpression*
SgExprListExp::get_first() const
   {
     if(get_expressions().empty())
          return 0;
     SgExpressionPtrList::const_iterator p=get_expressions().begin();
#if USE_SAGE3
     ROSE_ASSERT( (*p) != NULL );
     return (*p);
#else
     return (*p).irep();
#endif
   }
#endif

#if 0
SgExpression*
SgExprListExp::get_end() const
   {
     return NULL;
   }
#endif

#if 0
int
SgExprListExp::get_index(SgExpression *e) const
   {
     if(get_expressions().empty()) return -1;
     SgExpressionPtrList::const_iterator p=get_expressions().begin();
     int i=0;
     while(p!=p_expressions.end())
        {
#if 0
          if( (*p).irep()== e )
             return i;
#else
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
#endif
          i++;
          p++;
        }
     return -1;
   }
#endif

#if 1
int
SgExprListExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (10/5/2007): This is a new version of this function (from Jeremiah) which observes STL vector iterator semantics.

  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     for (SgExpressionPtrList::iterator i=p_expressions.begin();
          i != p_expressions.end(); ++i)
        {
          if( (*i) == o)
             {
               *i = n;
               return 1;
             }
        }
     return 0;
   }
#else
int
SgExprListExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     SgExpressionPtrList::iterator i=p_expressions.begin();
     while (i != p_expressions.end())
        {
          if( (*i) == o)
             {
               insert_expression(i, n);
               p_expressions.erase(i);
               return 1;
             }
/*
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
*/
          i++;
        }
     return 0;
   }
#endif

#if 0
void
SgExprListExp::insert_expression(SgExpression *o, SgExpression *n, int inFront)
   {
     SgExpressionPtrList::iterator i=p_expressions.begin();
     while(i!=p_expressions.end())
        {
#if 0
          if((*i).irep() == o)
             {
               if(!inFront) i++;
#ifndef REMOVE_SET_PARENT_FUNCTION
               n->set_parent(this);
#endif
               insert_expression(i,n);
             }
#else
          printf ("ERROR: not yet implemented in SAGE3 \n");
          abort();
#endif
        }
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 4650 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*

SgExprListExp::get_type() const
   { 
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgExprListExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgExprListExp::variantT() const {
  return V_SgExprListExp;
}

#if 0
int
SgExprListExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPR_LIST;
   }
#endif

const char*
SgExprListExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgExprListExp";  
   }

std::string
SgExprListExp::class_name() const
   {
     assert(this != NULL);
     return "SgExprListExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgExprListExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgExprListExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPR_LIST)
        {
          printf ("Error in SgExprListExp::error(): SgExprListExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgExprListExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPR_LIST);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgExprListExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgExprListExp::variant() const \n");
#endif
     assert(this != NULL);
     return EXPR_LIST;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgExprListExp* isSgExprListExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgExprListExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgExprListExp* isSgExprListExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgExprListExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgExprListExp::~SgExprListExp ()
   {
#if 0
  // debugging information!
     printf ("In SgExprListExp::~SgExprListExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgExprListExp::SgExprListExp ( Sg_File_Info* startOfConstruct )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgExprListExp::SgExprListExp (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(EXPR_LIST == variant());
     post_construction_initialization();

  // Test the isSgExprListExp() function since it has been problematic
     assert(isSgExprListExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarRefExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgVariableSymbol* 
SgVarRefExp::get_symbol () const
   {
     assert (this != NULL);
     return p_symbol;
   }

void
SgVarRefExp::set_symbol ( SgVariableSymbol* symbol )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_symbol != NULL && symbol != NULL && p_symbol != symbol)
        {
          printf ("Warning: symbol = %p overwriting valid pointer p_symbol = %p \n",symbol,p_symbol);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_symbol != NULL && symbol != NULL && p_symbol != symbol) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_symbol = symbol;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1875 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int
SgVarRefExp::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgVarRefExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgVarRefExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
     return result;
   }

void
SgVarRefExp::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
     printf ("Inside of SgVarRefExp::fixupCopy() \n");

     SgVarRefExp* variableRefExpression_copy = isSgVarRefExp(copy);

  // We could first check if the declarations are the same, but that would not imply that they had to be reset!

     ROSE_ASSERT(variableRefExpression_copy->get_symbol() != NULL);
     SgNode* declaration_key = variableRefExpression_copy->get_symbol()->get_declaration();
     ROSE_ASSERT(declaration_key != NULL);

  // If this is a reference to a declaration that was copied, then we have a new symbol that should be referencec by the reference.
  // The declaration is saved into a map held as state in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(declaration_key);
     if (i != help.get_copiedNodeMap().end())
        {
       // Found the key (a declaration SgDeclarationStatement or a SgInitializedName) so get the symbol and reset the symbol in the referencec to the value's associated symbol!
          SgNode* declaration_value = i->second;
          SgInitializedName* initializedName_copy = isSgInitializedName(declaration_value);
          ROSE_ASSERT(initializedName_copy != NULL);
          SgSymbol* symbol_copy = initializedName_copy->get_symbol_from_symbol_table();

       // DQ (10/8/2007): It might be too early to expect this to work!
       // ROSE_ASSERT(symbol_copy != NULL);
          printf ("Inside of SgVarRefExp::fixupCopy(): symbol_copy = %p \n",symbol_copy);
          if (symbol_copy != NULL)
             {
               SgVariableSymbol* variableSymbol_copy = isSgVariableSymbol(symbol_copy);
               ROSE_ASSERT(variableSymbol_copy != NULL);
               variableRefExpression_copy->set_symbol(variableSymbol_copy);
             }
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4661 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgVarRefExp::get_type() const
   {
     ROSE_ASSERT(get_symbol() != NULL);
  // DQ (9/27/2006): Added assertion
     ROSE_ASSERT(get_symbol()->get_type() != NULL);
     return get_symbol()->get_type();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarRefExp::variantT() const {
  return V_SgVarRefExp;
}

#if 0
int
SgVarRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VAR_REF;
   }
#endif

const char*
SgVarRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarRefExp";  
   }

std::string
SgVarRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgVarRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VAR_REF)
        {
          printf ("Error in SgVarRefExp::error(): SgVarRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VAR_REF);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return VAR_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarRefExp* isSgVarRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarRefExp* isSgVarRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarRefExp::~SgVarRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarRefExp::~SgVarRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for symbol
     p_symbol = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarRefExp::SgVarRefExp ( Sg_File_Info* startOfConstruct, SgVariableSymbol* symbol )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarRefExp::SgVarRefExp (Sg_File_Info* startOfConstruct, SgVariableSymbol* symbol) sage_class_name() = %s \n",sage_class_name());
#endif

     p_symbol = symbol;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VAR_REF == variant());
     post_construction_initialization();

  // Test the isSgVarRefExp() function since it has been problematic
     assert(isSgVarRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgClassNameRefExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassSymbol* 
SgClassNameRefExp::get_symbol () const
   {
     assert (this != NULL);
     return p_symbol;
   }

void
SgClassNameRefExp::set_symbol ( SgClassSymbol* symbol )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_symbol != NULL && symbol != NULL && p_symbol != symbol)
        {
          printf ("Warning: symbol = %p overwriting valid pointer p_symbol = %p \n",symbol,p_symbol);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_symbol != NULL && symbol != NULL && p_symbol != symbol) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_symbol = symbol;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1940 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassNameRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassNameRefExp::variantT() const {
  return V_SgClassNameRefExp;
}

#if 0
int
SgClassNameRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CLASSNAME_REF;
   }
#endif

const char*
SgClassNameRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassNameRefExp";  
   }

std::string
SgClassNameRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgClassNameRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassNameRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassNameRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CLASSNAME_REF)
        {
          printf ("Error in SgClassNameRefExp::error(): SgClassNameRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassNameRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CLASSNAME_REF);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassNameRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassNameRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return CLASSNAME_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassNameRefExp* isSgClassNameRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassNameRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassNameRefExp* isSgClassNameRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassNameRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassNameRefExp::~SgClassNameRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgClassNameRefExp::~SgClassNameRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for symbol
     p_symbol = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClassNameRefExp::SgClassNameRefExp ( Sg_File_Info* startOfConstruct, SgClassSymbol* symbol )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgClassNameRefExp::SgClassNameRefExp (Sg_File_Info* startOfConstruct, SgClassSymbol* symbol) sage_class_name() = %s \n",sage_class_name());
#endif

     p_symbol = symbol;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CLASSNAME_REF == variant());
     post_construction_initialization();

  // Test the isSgClassNameRefExp() function since it has been problematic
     assert(isSgClassNameRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionSymbol* 
SgFunctionRefExp::get_symbol_i () const
   {
     assert (this != NULL);
     return p_symbol_i;
   }

void
SgFunctionRefExp::set_symbol_i ( SgFunctionSymbol* symbol_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_symbol_i != NULL && symbol_i != NULL && p_symbol_i != symbol_i)
        {
          printf ("Warning: symbol_i = %p overwriting valid pointer p_symbol_i = %p \n",symbol_i,p_symbol_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_symbol_i != NULL && symbol_i != NULL && p_symbol_i != symbol_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_symbol_i = symbol_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1944 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgFunctionRefExp::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
     printf ("Inside of SgFunctionRefExp::fixupCopy() \n");

     SgFunctionRefExp* functionRefExpression_copy = isSgFunctionRefExp(copy);

  // We could first check if the declarations are the same, but that would not imply that they had to be reset!

     ROSE_ASSERT(functionRefExpression_copy->get_symbol() != NULL);
     SgNode* declaration_key = functionRefExpression_copy->get_symbol()->get_declaration();
     ROSE_ASSERT(declaration_key != NULL);

  // If this is a reference to a declaration that was copied, then we have a new symbol that should be referencec by the reference.
  // The declaration is saved into a map held as state in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(declaration_key);
     if (i != help.get_copiedNodeMap().end())
        {
       // Found the key (a declaration SgDeclarationStatement or a SgInitializedName) so get the symbol and reset the symbol in the referencec to the value's associated symbol!
          SgNode* declaration_value = i->second;
          SgFunctionDeclaration* functionDeclaration_copy = isSgFunctionDeclaration(declaration_value);
          ROSE_ASSERT(functionDeclaration_copy != NULL);
          SgSymbol* symbol_copy = functionDeclaration_copy->get_symbol_from_symbol_table();
       // ROSE_ASSERT(symbol_copy != NULL);
          if (symbol_copy != NULL)
             {
               SgFunctionSymbol* functionSymbol_copy = isSgFunctionSymbol(symbol_copy);
               ROSE_ASSERT(functionSymbol_copy != NULL);
               functionRefExpression_copy->set_symbol(functionSymbol_copy);
             }
        }
   }

unsigned int
SgFunctionRefExp::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgFunctionRefExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgFunctionRefExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
     return result;
   }

void
SgFunctionRefExp::post_construction_initialization()
   {
  // DQ (1/14/2006): set_type is removed
  // if (! get_function_type())
  //      set_type(); 
   }

SgFunctionSymbol*
SgFunctionRefExp::get_symbol() const
   { return get_symbol_i(); }

void
SgFunctionRefExp::set_symbol(SgFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

#if 0
// DQ (1/14/2006): set_type is removed
void
SgFunctionRefExp::set_type()
   {
  // The p_function_type member data's existence forces the use of a set_symbol() 
  // function that can not only set the symbol but also call the function to fixup the type.
  // As a result we need to manually maintain the get_symbol() function and have ROSETTA
  // automatically generate another access function for the symbol_i.  The
  // solution is to get rid of the p_function_type data member so that we 
  // don't have to set it explicitly.  Then we could just write a get_type() 
  // member function which got the type directly from the symbol rather than 
  // storing it locally.

  // This function does not set the is_modified flag so if this is called the AST 
  // is not correctly marked as updated (modified).

  // The debugging technique is to search for set_<function name> functions, since 
  // all of these should be automatically generated by ROSETTA and so should not be 
  // explicitly represented here.

     SgFunctionSymbol *fsym = get_symbol();
     ROSE_ASSERT(fsym != NULL);
     p_function_type = (SgFunctionType *)(fsym->get_type());
     if ( p_function_type == NULL )
        {
          cout << "bad" << fsym->get_name().str() << endl;
          ROSE_ASSERT(false);
        }
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 4661 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgFunctionRefExp::get_type() const
   {
     ROSE_ASSERT(get_symbol() != NULL);
  // DQ (9/27/2006): Added assertion
     ROSE_ASSERT(get_symbol()->get_type() != NULL);
     return get_symbol()->get_type();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionRefExp::variantT() const {
  return V_SgFunctionRefExp;
}

#if 0
int
SgFunctionRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNCTION_REF;
   }
#endif

const char*
SgFunctionRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionRefExp";  
   }

std::string
SgFunctionRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNCTION_REF)
        {
          printf ("Error in SgFunctionRefExp::error(): SgFunctionRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNCTION_REF);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return FUNCTION_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionRefExp* isSgFunctionRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionRefExp* isSgFunctionRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionRefExp::~SgFunctionRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionRefExp::~SgFunctionRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for symbol_i
     p_symbol_i = NULL; // non list case 
  // case: not a listType for function_type
     p_function_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionRefExp::SgFunctionRefExp ( Sg_File_Info* startOfConstruct, SgFunctionSymbol* symbol_i, SgFunctionType* function_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFunctionRefExp::SgFunctionRefExp (Sg_File_Info* startOfConstruct, SgFunctionSymbol* symbol_i, SgFunctionType* function_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_symbol_i = symbol_i;
     p_function_type = function_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNCTION_REF == variant());
     post_construction_initialization();

  // Test the isSgFunctionRefExp() function since it has been problematic
     assert(isSgFunctionRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgMemberFunctionSymbol* 
SgMemberFunctionRefExp::get_symbol_i () const
   {
     assert (this != NULL);
     return p_symbol_i;
   }

void
SgMemberFunctionRefExp::set_symbol_i ( SgMemberFunctionSymbol* symbol_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_symbol_i != NULL && symbol_i != NULL && p_symbol_i != symbol_i)
        {
          printf ("Warning: symbol_i = %p overwriting valid pointer p_symbol_i = %p \n",symbol_i,p_symbol_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_symbol_i != NULL && symbol_i != NULL && p_symbol_i != symbol_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_symbol_i = symbol_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgMemberFunctionRefExp::get_virtual_call () const
   {
     assert (this != NULL);
     return p_virtual_call;
   }

void
SgMemberFunctionRefExp::set_virtual_call ( int virtual_call )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_virtual_call = virtual_call;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgMemberFunctionRefExp::get_need_qualifier () const
   {
     assert (this != NULL);
     return p_need_qualifier;
   }

void
SgMemberFunctionRefExp::set_need_qualifier ( int need_qualifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_qualifier = need_qualifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2060 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgMemberFunctionRefExp::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
     printf ("Inside of SgMemberFunctionRefExp::fixupCopy() \n");

     SgFunctionRefExp* functionRefExpression_copy = isSgFunctionRefExp(copy);

  // We could first check if the declarations are the same, but that would not imply that they had to be reset!

     ROSE_ASSERT(functionRefExpression_copy->get_symbol() != NULL);
     SgNode* declaration_key = functionRefExpression_copy->get_symbol()->get_declaration();
     ROSE_ASSERT(declaration_key != NULL);

  // If this is a reference to a declaration that was copied, then we have a new symbol that should be referencec by the reference.
  // The declaration is saved into a map held as state in the SgCopyHelp object.
     SgCopyHelp::copiedNodeMapTypeIterator i = help.get_copiedNodeMap().find(declaration_key);
     if (i != help.get_copiedNodeMap().end())
        {
       // Found the key (a declaration SgDeclarationStatement or a SgInitializedName) so get the symbol and reset the symbol in the referencec to the value's associated symbol!
          SgNode* declaration_value = i->second;
          SgMemberFunctionDeclaration* functionDeclaration_copy = isSgMemberFunctionDeclaration(declaration_value);
          ROSE_ASSERT(functionDeclaration_copy != NULL);
          SgSymbol* symbol_copy = functionDeclaration_copy->get_symbol_from_symbol_table();
       // ROSE_ASSERT(symbol_copy != NULL);
          if (symbol_copy != NULL)
             {
               SgMemberFunctionSymbol* functionSymbol_copy = isSgMemberFunctionSymbol(symbol_copy);
               ROSE_ASSERT(functionSymbol_copy != NULL);
               functionRefExpression_copy->set_symbol(functionSymbol_copy);
             }
        }
   }


unsigned int
SgMemberFunctionRefExp::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgMemberFunctionRefExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgMemberFunctionRefExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
     return result;
   }

void
SgMemberFunctionRefExp::post_construction_initialization() 
   {
  // DQ (1/14/2006): set_type is removed
  // if (!p_function_type)
  //      set_type();

  // DQ (4/13/2004): Qing reports this as a bug, since it is set by the constructor parameter already!
  // p_need_qualifier = 1; // default is always true
   }

SgMemberFunctionSymbol*
SgMemberFunctionRefExp::get_symbol() const
   { return get_symbol_i(); }

void
SgMemberFunctionRefExp::set_symbol(SgMemberFunctionSymbol * symbol)
   {
     set_symbol_i(symbol);

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

#if 0
void
SgMemberFunctionRefExp::set_type()
   {
     SgMemberFunctionSymbol *mfsym = get_symbol();
     ROSE_ASSERT(mfsym != NULL);
     p_function_type = (SgFunctionType *)(mfsym->get_type());
     if ( p_function_type == NULL )
        {
          cout << "bad" << mfsym->get_name().str() << endl;

       // DQ (9/12/2004): Made this an error (I think it should be and it is in the case of a function pointer)
          ROSE_ASSERT(false);
        }
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 4661 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgMemberFunctionRefExp::get_type() const
   {
     ROSE_ASSERT(get_symbol() != NULL);
  // DQ (9/27/2006): Added assertion
     ROSE_ASSERT(get_symbol()->get_type() != NULL);
     return get_symbol()->get_type();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMemberFunctionRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMemberFunctionRefExp::variantT() const {
  return V_SgMemberFunctionRefExp;
}

#if 0
int
SgMemberFunctionRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MEMBER_FUNCTION_REF;
   }
#endif

const char*
SgMemberFunctionRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionRefExp";  
   }

std::string
SgMemberFunctionRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMemberFunctionRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMemberFunctionRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MEMBER_FUNCTION_REF)
        {
          printf ("Error in SgMemberFunctionRefExp::error(): SgMemberFunctionRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMemberFunctionRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MEMBER_FUNCTION_REF);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMemberFunctionRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMemberFunctionRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return MEMBER_FUNCTION_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMemberFunctionRefExp* isSgMemberFunctionRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMemberFunctionRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMemberFunctionRefExp* isSgMemberFunctionRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMemberFunctionRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMemberFunctionRefExp::~SgMemberFunctionRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgMemberFunctionRefExp::~SgMemberFunctionRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for symbol_i
     p_symbol_i = NULL; // non list case 
  // case: not a listType for virtual_call
     p_virtual_call = 0; // non list case 
  // case: not a listType for function_type
     p_function_type = NULL; // non list case 
  // case: not a listType for need_qualifier
     p_need_qualifier = true; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMemberFunctionRefExp::SgMemberFunctionRefExp ( Sg_File_Info* startOfConstruct, SgMemberFunctionSymbol* symbol_i, int virtual_call, SgFunctionType* function_type, int need_qualifier )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgMemberFunctionRefExp::SgMemberFunctionRefExp (Sg_File_Info* startOfConstruct, SgMemberFunctionSymbol* symbol_i, int virtual_call, SgFunctionType* function_type, int need_qualifier) sage_class_name() = %s \n",sage_class_name());
#endif

     p_symbol_i = symbol_i;
     p_virtual_call = virtual_call;
     p_function_type = function_type;
     p_need_qualifier = need_qualifier;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(MEMBER_FUNCTION_REF == variant());
     post_construction_initialization();

  // Test the isSgMemberFunctionRefExp() function since it has been problematic
     assert(isSgMemberFunctionRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgFunctionCallExp::get_function () const
   {
     assert (this != NULL);
     return p_function;
   }

void
SgFunctionCallExp::set_function ( SgExpression* function )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_function != NULL && function != NULL && p_function != function)
        {
          printf ("Warning: function = %p overwriting valid pointer p_function = %p \n",function,p_function);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_function != NULL && function != NULL && p_function != function) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_function = function;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgFunctionCallExp::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

void
SgFunctionCallExp::set_args ( SgExprListExp* args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_args != NULL && args != NULL && p_args != args)
        {
          printf ("Warning: args = %p overwriting valid pointer p_args = %p \n",args,p_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_args != NULL && args != NULL && p_args != args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_args = args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2315 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

  unsigned int SgFunctionCallExp::cfgIndexForEnd() const {
    return 3;
  }

  std::vector<VirtualCFG::CFGEdge> SgFunctionCallExp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_function()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_args()->cfgForBeginning(), result); break;
      case 2: {
	SgFunctionDeclaration* decl =
	  interproceduralControlFlowGraph ?
	  VirtualCFG::getDeclaration(this->get_function()) : NULL;
	if (decl)
	  makeEdge(VirtualCFG::CFGNode(this, idx), decl->cfgForBeginning(),
		   result);
	else
	  makeEdge(VirtualCFG::CFGNode(this, idx),
		   VirtualCFG::CFGNode(this, 3), result);
	break;
      }
      case 3: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgFunctionCallExp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgFunctionCallExp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_function()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      case 2: makeEdge(this->get_args()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      case 3: {
	SgFunctionDeclaration* decl =
	  interproceduralControlFlowGraph ?
	  VirtualCFG::getDeclaration(this->get_function()) : NULL;
	if (decl)
	  makeEdge(decl->cfgForEnd(), VirtualCFG::CFGNode(this, idx),
		   result);
	else
	  makeEdge(VirtualCFG::CFGNode(this, 2),
		   VirtualCFG::CFGNode(this, idx), result);
	break;
      }
      default: ROSE_ASSERT (!"Bad index for SgFunctionCallExp");
    }
    return result;
  }

void
SgFunctionCallExp::post_construction_initialization() 
   {
     if (p_function != NULL)
          p_function->set_parent(this);
   }

#if 1
// DQ: trying to remove the nested iterator class
void
SgFunctionCallExp::append_arg(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_args != NULL);
     if (p_args == NULL)
        {
       // set_args(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_args(newArgs);
        }

    // insert_arg(p_args->end(),what);
       p_args->append_expression(what);
   }
#endif

#if 0
// DQ: trying to remove the nested iterator class
// SgFunctionCallExp::insert_arg(const SgExpression::iterator& where, SgExpression* what)
void
SgFunctionCallExp::insert_arg(const SgExpressionPtrList::iterator& where, SgExpression* what)
   {
     p_args->insert_expression(where,what); 
   }
#endif

SgExpression*
SgFunctionCallExp::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_function();
        } 
       else 
          if(p_args && n==1)
             {
               n++;
               return get_args();
             }

     return 0;
   }

int
SgFunctionCallExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_function() == o)
        {
          set_function(n);
          printf ("SgFunctionCallExp::replace_expression(): This should set the parent of the new expression. \n");
          n->set_parent(this);

          return 1;
        }
       else
        {
          if (p_args == o)
             {
            // DQ (12/17/2006): Make this code safer (avoid passing NULL pointers to functions that we call!
            // set_args(isSgExprListExp(n));
               SgExprListExp* expressionList = isSgExprListExp(n);
               ROSE_ASSERT(expressionList != NULL);
               set_args(expressionList);
               n->set_parent(this);
               return 1;
             }
        }

     return 0;
   }

SgType*
SgFunctionCallExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgFunctionCallExp::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // DQ (7/20/2006): Peter's patch now allows this function to be simplified to the following (suggested by Jeremiah).
     SgType* returnType = NULL;

     ROSE_ASSERT(p_function != NULL);
  // printf ("In SgFunctionCallExp::get_type(): calling get_type() on p_function = %p = %s \n",p_function,p_function->class_name().c_str());
     SgType* likelyFunctionType = p_function->get_type();
     ROSE_ASSERT(likelyFunctionType != NULL);
     SgFunctionType* functionType = isSgFunctionType(likelyFunctionType);
     if (functionType == NULL)
        {
       // printf ("Error: unexpected type found for likelyFunctionType = %p = %s \n",likelyFunctionType,likelyFunctionType->class_name().c_str());
       // get_file_info()->display("Location of call to SgFunctionCallExp::get_type(): debug");

       // DQ (7/15/2007): Handle case of typedef of function type
          likelyFunctionType = likelyFunctionType->stripType(SgType::STRIP_TYPEDEF_TYPE);

          functionType = isSgFunctionType(likelyFunctionType);
          ROSE_ASSERT(functionType != NULL);
        }
     
     ROSE_ASSERT(functionType != NULL);
     returnType = functionType->get_return_type();
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionCallExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionCallExp::variantT() const {
  return V_SgFunctionCallExp;
}

#if 0
int
SgFunctionCallExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNC_CALL;
   }
#endif

const char*
SgFunctionCallExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionCallExp";  
   }

std::string
SgFunctionCallExp::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionCallExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionCallExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionCallExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNC_CALL)
        {
          printf ("Error in SgFunctionCallExp::error(): SgFunctionCallExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionCallExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNC_CALL);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionCallExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionCallExp::variant() const \n");
#endif
     assert(this != NULL);
     return FUNC_CALL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionCallExp* isSgFunctionCallExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionCallExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionCallExp* isSgFunctionCallExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionCallExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionCallExp::~SgFunctionCallExp ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionCallExp::~SgFunctionCallExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for function
     p_function = NULL; // non list case 
  // case: not a listType for args
     p_args = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionCallExp::SgFunctionCallExp ( Sg_File_Info* startOfConstruct, SgExpression* function, SgExprListExp* args, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFunctionCallExp::SgFunctionCallExp (Sg_File_Info* startOfConstruct, SgExpression* function, SgExprListExp* args, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_function = function;
     p_args = args;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNC_CALL == variant());
     post_construction_initialization();

  // Test the isSgFunctionCallExp() function since it has been problematic
     assert(isSgFunctionCallExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgSizeOfOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSizeOfOp::get_operand_expr () const
   {
     assert (this != NULL);
     return p_operand_expr;
   }

void
SgSizeOfOp::set_operand_expr ( SgExpression* operand_expr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr)
        {
          printf ("Warning: operand_expr = %p overwriting valid pointer p_operand_expr = %p \n",operand_expr,p_operand_expr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_expr = operand_expr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgSizeOfOp::get_operand_type () const
   {
     assert (this != NULL);
     return p_operand_type;
   }

void
SgSizeOfOp::set_operand_type ( SgType* operand_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_type != NULL && operand_type != NULL && p_operand_type != operand_type)
        {
          printf ("Warning: operand_type = %p overwriting valid pointer p_operand_type = %p \n",operand_type,p_operand_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_type != NULL && operand_type != NULL && p_operand_type != operand_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_type = operand_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2933 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgSizeOfOp::get_type() const
   {
  // This function returns an unsigned integer representing the size of type 
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_operand_expr != NULL || p_operand_type != NULL);
     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSizeOfOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSizeOfOp::variantT() const {
  return V_SgSizeOfOp;
}

#if 0
int
SgSizeOfOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SIZEOF_OP;
   }
#endif

const char*
SgSizeOfOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSizeOfOp";  
   }

std::string
SgSizeOfOp::class_name() const
   {
     assert(this != NULL);
     return "SgSizeOfOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSizeOfOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSizeOfOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SIZEOF_OP)
        {
          printf ("Error in SgSizeOfOp::error(): SgSizeOfOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSizeOfOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SIZEOF_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSizeOfOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSizeOfOp::variant() const \n");
#endif
     assert(this != NULL);
     return SIZEOF_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSizeOfOp* isSgSizeOfOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSizeOfOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSizeOfOp* isSgSizeOfOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSizeOfOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSizeOfOp::~SgSizeOfOp ()
   {
#if 0
  // debugging information!
     printf ("In SgSizeOfOp::~SgSizeOfOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_expr
     p_operand_expr = NULL; // non list case 
  // case: not a listType for operand_type
     p_operand_type = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSizeOfOp::SgSizeOfOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* operand_type, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSizeOfOp::SgSizeOfOp (Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* operand_type, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_expr = operand_expr;
     p_operand_type = operand_type;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SIZEOF_OP == variant());
     post_construction_initialization();

  // Test the isSgSizeOfOp() function since it has been problematic
     assert(isSgSizeOfOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgTypeIdOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgTypeIdOp::get_operand_expr () const
   {
     assert (this != NULL);
     return p_operand_expr;
   }

void
SgTypeIdOp::set_operand_expr ( SgExpression* operand_expr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr)
        {
          printf ("Warning: operand_expr = %p overwriting valid pointer p_operand_expr = %p \n",operand_expr,p_operand_expr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_expr = operand_expr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgTypeIdOp::get_operand_type () const
   {
     assert (this != NULL);
     return p_operand_type;
   }

void
SgTypeIdOp::set_operand_type ( SgType* operand_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_type != NULL && operand_type != NULL && p_operand_type != operand_type)
        {
          printf ("Warning: operand_type = %p overwriting valid pointer p_operand_type = %p \n",operand_type,p_operand_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_type != NULL && operand_type != NULL && p_operand_type != operand_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_type = operand_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2950 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgTypeIdOp::get_type() const
   {
  // DQ (7/20/2006): The typeid operator returns an lvalue of type const std::type_info that represents the 
  // type of expression expr. You must include the standard template library header <typeinfo> to use the 
  // typeid operator (obtained from IBM C++ web page).  So it seems that the correct return type is a 
  // SgClassType with reference to the class declaration that should have been seen or we can perhaps assume to be
  // simply: "std::type_info"

  // DQ (8/8/2006): The C++ standard requires that this return a "std::type_info" classType
     SgType* returnType = p_expression_type;
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeIdOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeIdOp::variantT() const {
  return V_SgTypeIdOp;
}

#if 0
int
SgTypeIdOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TYPEID_OP;
   }
#endif

const char*
SgTypeIdOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeIdOp";  
   }

std::string
SgTypeIdOp::class_name() const
   {
     assert(this != NULL);
     return "SgTypeIdOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeIdOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeIdOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TYPEID_OP)
        {
          printf ("Error in SgTypeIdOp::error(): SgTypeIdOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeIdOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TYPEID_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeIdOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeIdOp::variant() const \n");
#endif
     assert(this != NULL);
     return TYPEID_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeIdOp* isSgTypeIdOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeIdOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeIdOp* isSgTypeIdOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeIdOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeIdOp::~SgTypeIdOp ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeIdOp::~SgTypeIdOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_expr
     p_operand_expr = NULL; // non list case 
  // case: not a listType for operand_type
     p_operand_type = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeIdOp::SgTypeIdOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* operand_type, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgTypeIdOp::SgTypeIdOp (Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* operand_type, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_expr = operand_expr;
     p_operand_type = operand_type;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TYPEID_OP == variant());
     post_construction_initialization();

  // Test the isSgTypeIdOp() function since it has been problematic
     assert(isSgTypeIdOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgConditionalExp::get_conditional_exp () const
   {
     assert (this != NULL);
     return p_conditional_exp;
   }

void
SgConditionalExp::set_conditional_exp ( SgExpression* conditional_exp )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_conditional_exp != NULL && conditional_exp != NULL && p_conditional_exp != conditional_exp)
        {
          printf ("Warning: conditional_exp = %p overwriting valid pointer p_conditional_exp = %p \n",conditional_exp,p_conditional_exp);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_conditional_exp != NULL && conditional_exp != NULL && p_conditional_exp != conditional_exp) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_conditional_exp = conditional_exp;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgConditionalExp::get_true_exp () const
   {
     assert (this != NULL);
     return p_true_exp;
   }

void
SgConditionalExp::set_true_exp ( SgExpression* true_exp )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_true_exp != NULL && true_exp != NULL && p_true_exp != true_exp)
        {
          printf ("Warning: true_exp = %p overwriting valid pointer p_true_exp = %p \n",true_exp,p_true_exp);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_true_exp != NULL && true_exp != NULL && p_true_exp != true_exp) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_true_exp = true_exp;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgConditionalExp::get_false_exp () const
   {
     assert (this != NULL);
     return p_false_exp;
   }

void
SgConditionalExp::set_false_exp ( SgExpression* false_exp )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_false_exp != NULL && false_exp != NULL && p_false_exp != false_exp)
        {
          printf ("Warning: false_exp = %p overwriting valid pointer p_false_exp = %p \n",false_exp,p_false_exp);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_false_exp != NULL && false_exp != NULL && p_false_exp != false_exp) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_false_exp = false_exp;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 3291 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int
SgConditionalExp::cfgIndexForEnd() const 
  {
    return 2;
  }

  bool SgConditionalExp::cfgIsIndexInteresting(unsigned int idx) const {
    return idx == 1 || idx == 2;
  }

unsigned int
SgConditionalExp::cfgFindChildIndex(SgNode* n)
   {
  // DQ (8/24/2006): Could be rewritten as:
  // Make sure that this is either the conditional, true body, or the fals body
  // ROSE_ASSERT (n == this->get_conditional_exp() || n == this->get_true_exp() || n == this->get_false_exp() );
  // return (n == this->get_conditional_exp()) ? 0 : 1;

     if (n == this->get_conditional_exp())
        {
          return 0;
        }
       else
          if (n == this->get_true_exp() || n == this->get_false_exp())
             {
               return 1;
             }
            else
               ROSE_ASSERT (!"Bad child in conditional expression");

  // DQ (8/24/2006): Added return to avoid compiler warning.
     return 0;
   }

  std::vector<VirtualCFG::CFGEdge> SgConditionalExp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_conditional_exp()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_true_exp()->cfgForBeginning(), result);
	      makeEdge(VirtualCFG::CFGNode(this, idx), this->get_false_exp()->cfgForBeginning(), result); break;
      case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index in SgConditionalExp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgConditionalExp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_conditional_exp()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      case 2: makeEdge(this->get_true_exp()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	      makeEdge(this->get_false_exp()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index in SgConditionalExp");
    }
    return result;
  }

void
SgConditionalExp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (p_conditional_exp != NULL)
          p_conditional_exp->set_parent(this);
     if (p_true_exp != NULL)
          p_true_exp->set_parent(this);
     if (p_false_exp != NULL)
          p_false_exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
SgConditionalExp::get_type() const
   {
  // In this function we want to return the type of the true of false option but it only makes sense for them to be the same type.

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // printf ("SgConditionalExp::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // Jeremiah (7/20/2006): Despite the comments, SOURCE_CONDITIONAL_EXPRESSION refers to a p_expression_type member, 
  // but then ignores it.  I think you may want to store the type explicitly for this operator, as computing it is 
  // difficult (requires handling user-defined conversions and such).  The return type can be either the true or false 
  // types, and they can be different.

     ROSE_ASSERT(p_true_exp  != NULL);
     ROSE_ASSERT(p_false_exp != NULL);

     SgType* trueType   = p_true_exp->get_type();
     ROSE_ASSERT(trueType != NULL);

     SgType* falseType  = p_false_exp->get_type();
     ROSE_ASSERT(falseType != NULL);

#if PRINT_DEVELOPER_WARNINGS
     string expression_type_name = "NULL";
     if (p_expression_type != NULL)
          expression_type_name = p_expression_type->class_name();

  // ROSE_ASSERT(trueType == falseType);
     if (trueType != falseType)
        {
          printf ("Warning: In SgConditionalExp::get_type(): trueType = %s != falseType = %s  (p_expression_type = %s) \n",
               trueType->class_name().c_str(),falseType->class_name().c_str(),expression_type_name.c_str());
       // get_file_info()->display("Warning: In SgConditionalExp::get_type(): trueType != falseType");
        }
#endif

  // This was the previous choice for how p_expression_type was set, 
  // so to be consistant we will select the same branch.
     SgType* returnType = trueType;

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SgExpression*
SgConditionalExp::get_next(int& n) const
   {
     SgExpression *tmp = NULL;
     switch (n)
        {
          case 0: tmp = get_conditional_exp(); n++; break;
          case 1: tmp = get_true_exp(); n++; break;
          case 2: tmp = get_false_exp(); n++; break;
        }

     return tmp;
   }

int
SgConditionalExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_conditional_exp() == o)
        {
          set_conditional_exp(n);
          n->set_parent(this);
          return 1;
        } 
       else
        {
          if (get_true_exp() == o)
             {
               set_true_exp(n);
               n->set_parent(this);
               return 1; 
             }
            else
             {
               if (get_false_exp() == o)
                  {
                    set_false_exp(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgConditionalExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgConditionalExp::variantT() const {
  return V_SgConditionalExp;
}

#if 0
int
SgConditionalExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPR_CONDITIONAL;
   }
#endif

const char*
SgConditionalExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgConditionalExp";  
   }

std::string
SgConditionalExp::class_name() const
   {
     assert(this != NULL);
     return "SgConditionalExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgConditionalExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgConditionalExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPR_CONDITIONAL)
        {
          printf ("Error in SgConditionalExp::error(): SgConditionalExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgConditionalExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPR_CONDITIONAL);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgConditionalExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgConditionalExp::variant() const \n");
#endif
     assert(this != NULL);
     return EXPR_CONDITIONAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgConditionalExp* isSgConditionalExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgConditionalExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgConditionalExp* isSgConditionalExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgConditionalExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgConditionalExp::~SgConditionalExp ()
   {
#if 0
  // debugging information!
     printf ("In SgConditionalExp::~SgConditionalExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for conditional_exp
     p_conditional_exp = NULL; // non list case 
  // case: not a listType for true_exp
     p_true_exp = NULL; // non list case 
  // case: not a listType for false_exp
     p_false_exp = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgConditionalExp::SgConditionalExp ( Sg_File_Info* startOfConstruct, SgExpression* conditional_exp, SgExpression* true_exp, SgExpression* false_exp, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgConditionalExp::SgConditionalExp (Sg_File_Info* startOfConstruct, SgExpression* conditional_exp, SgExpression* true_exp, SgExpression* false_exp, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_conditional_exp = conditional_exp;
     p_true_exp = true_exp;
     p_false_exp = false_exp;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(EXPR_CONDITIONAL == variant());
     post_construction_initialization();

  // Test the isSgConditionalExp() function since it has been problematic
     assert(isSgConditionalExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgNewExp::get_specified_type () const
   {
     assert (this != NULL);
     return p_specified_type;
   }

void
SgNewExp::set_specified_type ( SgType* specified_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_specified_type != NULL && specified_type != NULL && p_specified_type != specified_type)
        {
          printf ("Warning: specified_type = %p overwriting valid pointer p_specified_type = %p \n",specified_type,p_specified_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_specified_type != NULL && specified_type != NULL && p_specified_type != specified_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_specified_type = specified_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgNewExp::get_placement_args () const
   {
     assert (this != NULL);
     return p_placement_args;
   }

void
SgNewExp::set_placement_args ( SgExprListExp* placement_args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_placement_args != NULL && placement_args != NULL && p_placement_args != placement_args)
        {
          printf ("Warning: placement_args = %p overwriting valid pointer p_placement_args = %p \n",placement_args,p_placement_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_placement_args != NULL && placement_args != NULL && p_placement_args != placement_args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_placement_args = placement_args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgConstructorInitializer* 
SgNewExp::get_constructor_args () const
   {
     assert (this != NULL);
     return p_constructor_args;
   }

void
SgNewExp::set_constructor_args ( SgConstructorInitializer* constructor_args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_constructor_args != NULL && constructor_args != NULL && p_constructor_args != constructor_args)
        {
          printf ("Warning: constructor_args = %p overwriting valid pointer p_constructor_args = %p \n",constructor_args,p_constructor_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_constructor_args != NULL && constructor_args != NULL && p_constructor_args != constructor_args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_constructor_args = constructor_args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgNewExp::get_builtin_args () const
   {
     assert (this != NULL);
     return p_builtin_args;
   }

void
SgNewExp::set_builtin_args ( SgExpression* builtin_args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_builtin_args != NULL && builtin_args != NULL && p_builtin_args != builtin_args)
        {
          printf ("Warning: builtin_args = %p overwriting valid pointer p_builtin_args = %p \n",builtin_args,p_builtin_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_builtin_args != NULL && builtin_args != NULL && p_builtin_args != builtin_args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_builtin_args = builtin_args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

short 
SgNewExp::get_need_global_specifier () const
   {
     assert (this != NULL);
     return p_need_global_specifier;
   }

void
SgNewExp::set_need_global_specifier ( short need_global_specifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_global_specifier = need_global_specifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionDeclaration* 
SgNewExp::get_newOperatorDeclaration () const
   {
     assert (this != NULL);
     return p_newOperatorDeclaration;
   }

void
SgNewExp::set_newOperatorDeclaration ( SgFunctionDeclaration* newOperatorDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_newOperatorDeclaration != NULL && newOperatorDeclaration != NULL && p_newOperatorDeclaration != newOperatorDeclaration)
        {
          printf ("Warning: newOperatorDeclaration = %p overwriting valid pointer p_newOperatorDeclaration = %p \n",newOperatorDeclaration,p_newOperatorDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_newOperatorDeclaration != NULL && newOperatorDeclaration != NULL && p_newOperatorDeclaration != newOperatorDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_newOperatorDeclaration = newOperatorDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3607 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


unsigned int
SgNewExp::cfgIndexForEnd() const
  {
    return 2; // At most one of constructor args or array size are present
  }

unsigned int
SgNewExp::cfgFindChildIndex(SgNode* n)
   {
  // DQ (8/24/2006): Could be rewritten as:
  // Make sure that this is either the conditional, true body, or the fals body
  // ROSE_ASSERT (n == this->get_placement_args() || n == this->get_constructor_args() || n == this->get_builtin_args() );
  // return (n == this->get_placement_args()) ? 0 : 1;

     if (n == this->get_placement_args())
        {
          return 0;
        }
       else
          if (n == this->get_constructor_args() || n == this->get_builtin_args())
             {
               return 1;
             }
            else
               ROSE_ASSERT (!"Bad child in new expression");

  // DQ (8/24/2006): Added return to avoid compiler warning.
     return 0;
   }

  std::vector<VirtualCFG::CFGEdge> SgNewExp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: {
	if (this->get_placement_args()) {
	  makeEdge(VirtualCFG::CFGNode(this, idx), this->get_placement_args()->cfgForBeginning(), result);
	} else {
	  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 1), result);
	}
	break;
      }
      case 1: {
	if (this->get_constructor_args()) {
	  makeEdge(VirtualCFG::CFGNode(this, idx), this->get_constructor_args()->cfgForBeginning(), result);
	} else if (this->get_builtin_args()) {
	  makeEdge(VirtualCFG::CFGNode(this, idx), this->get_builtin_args()->cfgForBeginning(), result);
	} else {
	  makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 2), result);
	}
	break;
      }
      case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgNewExp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgNewExp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: {
	if (this->get_placement_args()) {
	  makeEdge(this->get_placement_args()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	} else {
	  makeEdge(VirtualCFG::CFGNode(this, 0), VirtualCFG::CFGNode(this, idx), result);
	}
	break;
      }
      case 2: {
	if (this->get_constructor_args()) {
	  makeEdge(this->get_constructor_args()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	} else if (this->get_builtin_args()) {
	  makeEdge(this->get_builtin_args()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	} else {
	  makeEdge(VirtualCFG::CFGNode(this, 1), VirtualCFG::CFGNode(this, idx), result);
	}
	break;
      }
      default: ROSE_ASSERT (!"Bad index for SgNewExp");
    }
    return result;
  }

void
SgNewExp::post_construction_initialization()
   {
     if(p_constructor_args)
        {
// #ifndef REMOVE_SET_PARENT_FUNCTION
          p_constructor_args->set_parent(this);
// #endif
          p_constructor_args->set_need_paren(true);
        }

// #ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_builtin_args)
        {
          p_builtin_args->set_parent(this);
        }

     if(p_placement_args)
          p_placement_args->set_parent(this);
// #endif
   }


SgExpression*
SgNewExp::get_next(int& n) const
   {
  // SgExpression *tmp = NULL;
     if(n==0)
        {
          n++;
          if(get_placement_args()) return get_placement_args();
            else
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }
        }
       else 
          if(n==1)
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }

     return NULL;
   }

int
SgNewExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_placement_args()==o)
        {
          set_placement_args(isSgExprListExp(n));
          n->set_parent(this);
          return 1; 
        }
       else
        {
          if(get_constructor_args()==o)
             {
               set_constructor_args(isSgConstructorInitializer(n));
               n->set_parent(this);
               return 1;
             }
            else
             {
               if(get_builtin_args()==o)
                  {
                    set_builtin_args(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }

SgType*
SgNewExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgNewExp::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // The p_constructor_args really just identifies the constructor being called, 
  // from which we can get the type to be returned from the new operator!
  // If there is no constructor then this might be a primative type or perhaps 
  // a class or struct without an explicit constructor.
     ROSE_ASSERT(p_constructor_args != NULL);

  // Since where the p_constructor_args->get_declaration() == NULL (often for primative types) 
  // we need the explicitly stored p_expression_type pointer anyway so we can just make it the 
  // return type for all cases.
  // SgType* returnType = p_expression_type;
  // SgType* returnType = SgPointerType::createType(p_expression_type);
     ROSE_ASSERT(p_specified_type != NULL);
     SgType* returnType = SgPointerType::createType(p_specified_type);

     ROSE_ASSERT(returnType != NULL);
  // printf ("SgNewExp::get_type(): We might have to return a pointer to this type! returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNewExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNewExp::variantT() const {
  return V_SgNewExp;
}

#if 0
int
SgNewExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NEW_OP;
   }
#endif

const char*
SgNewExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNewExp";  
   }

std::string
SgNewExp::class_name() const
   {
     assert(this != NULL);
     return "SgNewExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNewExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNewExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NEW_OP)
        {
          printf ("Error in SgNewExp::error(): SgNewExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNewExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NEW_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNewExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNewExp::variant() const \n");
#endif
     assert(this != NULL);
     return NEW_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNewExp* isSgNewExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNewExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNewExp* isSgNewExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNewExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNewExp::~SgNewExp ()
   {
#if 0
  // debugging information!
     printf ("In SgNewExp::~SgNewExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for specified_type
     p_specified_type = NULL; // non list case 
  // case: not a listType for placement_args
     p_placement_args = NULL; // non list case 
  // case: not a listType for constructor_args
     p_constructor_args = NULL; // non list case 
  // case: not a listType for builtin_args
     p_builtin_args = NULL; // non list case 
  // case: not a listType for need_global_specifier
     p_need_global_specifier = 0; // non list case 
  // case: not a listType for newOperatorDeclaration
     p_newOperatorDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNewExp::SgNewExp ( Sg_File_Info* startOfConstruct, SgType* specified_type, SgExprListExp* placement_args, SgConstructorInitializer* constructor_args, SgExpression* builtin_args, short need_global_specifier, SgFunctionDeclaration* newOperatorDeclaration )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNewExp::SgNewExp (Sg_File_Info* startOfConstruct, SgType* specified_type, SgExprListExp* placement_args, SgConstructorInitializer* constructor_args, SgExpression* builtin_args, short need_global_specifier, SgFunctionDeclaration* newOperatorDeclaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_specified_type = specified_type;
     p_placement_args = placement_args;
     p_constructor_args = constructor_args;
     p_builtin_args = builtin_args;
     p_need_global_specifier = need_global_specifier;
     p_newOperatorDeclaration = newOperatorDeclaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NEW_OP == variant());
     post_construction_initialization();

  // Test the isSgNewExp() function since it has been problematic
     assert(isSgNewExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgDeleteExp::get_variable () const
   {
     assert (this != NULL);
     return p_variable;
   }

void
SgDeleteExp::set_variable ( SgExpression* variable )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_variable != NULL && variable != NULL && p_variable != variable)
        {
          printf ("Warning: variable = %p overwriting valid pointer p_variable = %p \n",variable,p_variable);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_variable != NULL && variable != NULL && p_variable != variable) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_variable = variable;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

short 
SgDeleteExp::get_is_array () const
   {
     assert (this != NULL);
     return p_is_array;
   }

void
SgDeleteExp::set_is_array ( short is_array )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_is_array = is_array;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

short 
SgDeleteExp::get_need_global_specifier () const
   {
     assert (this != NULL);
     return p_need_global_specifier;
   }

void
SgDeleteExp::set_need_global_specifier ( short need_global_specifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_global_specifier = need_global_specifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionDeclaration* 
SgDeleteExp::get_deleteOperatorDeclaration () const
   {
     assert (this != NULL);
     return p_deleteOperatorDeclaration;
   }

void
SgDeleteExp::set_deleteOperatorDeclaration ( SgFunctionDeclaration* deleteOperatorDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_deleteOperatorDeclaration != NULL && deleteOperatorDeclaration != NULL && p_deleteOperatorDeclaration != deleteOperatorDeclaration)
        {
          printf ("Warning: deleteOperatorDeclaration = %p overwriting valid pointer p_deleteOperatorDeclaration = %p \n",deleteOperatorDeclaration,p_deleteOperatorDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_deleteOperatorDeclaration != NULL && deleteOperatorDeclaration != NULL && p_deleteOperatorDeclaration != deleteOperatorDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_deleteOperatorDeclaration = deleteOperatorDeclaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3814 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


unsigned int
SgDeleteExp::cfgIndexForEnd() const
   {
     return 1;
   }

std::vector<VirtualCFG::CFGEdge>
SgDeleteExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_variable()->cfgForBeginning(), result); break;
          case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
          default: ROSE_ASSERT (!"Bad index for SgDeleteExp");
        }

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgDeleteExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
          case 1: makeEdge(this->get_variable()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
          default: ROSE_ASSERT (!"Bad index for SgDeleteExp");
        }

     return result;
   }

#if 0
// This should be generated automatically
SgDeleteExp::SgDeleteExp(Sg_File_Info* info , SgExpression* variable, short is_array, short need_global_specifier)
   : SgExpression(info)
   {
     p_variable = variable;
     p_is_array = is_array;
     p_need_global_specifier = need_global_specifier;
  /* now a call to the user defined intialization function */
     post_construction_initialization();
   }
#endif

void
SgDeleteExp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_variable)
          p_variable->set_parent(this);
// #endif
   }

SgType*
SgDeleteExp::get_type() const
   {
  // The delete operator always returns "void" as a type.  This used to return SgDefaultType (but that didn't seem quite right)

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgDeleteExp::get_type(): p_expression_type has been removed, we now return SgTypeVoid \n");

     SgType* returnType = SgTypeVoid::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SgExpression*
SgDeleteExp::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_variable();
        }
       else
        {
          return 0;
        }
   }

int
SgDeleteExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_variable() == o)
        {
          set_variable(n);
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDeleteExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDeleteExp::variantT() const {
  return V_SgDeleteExp;
}

#if 0
int
SgDeleteExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DELETE_OP;
   }
#endif

const char*
SgDeleteExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDeleteExp";  
   }

std::string
SgDeleteExp::class_name() const
   {
     assert(this != NULL);
     return "SgDeleteExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDeleteExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDeleteExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DELETE_OP)
        {
          printf ("Error in SgDeleteExp::error(): SgDeleteExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDeleteExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DELETE_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDeleteExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDeleteExp::variant() const \n");
#endif
     assert(this != NULL);
     return DELETE_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDeleteExp* isSgDeleteExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDeleteExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDeleteExp* isSgDeleteExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDeleteExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDeleteExp::~SgDeleteExp ()
   {
#if 0
  // debugging information!
     printf ("In SgDeleteExp::~SgDeleteExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for variable
     p_variable = NULL; // non list case 
  // case: not a listType for is_array
     p_is_array = 0; // non list case 
  // case: not a listType for need_global_specifier
     p_need_global_specifier = 0; // non list case 
  // case: not a listType for deleteOperatorDeclaration
     p_deleteOperatorDeclaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDeleteExp::SgDeleteExp ( Sg_File_Info* startOfConstruct, SgExpression* variable, short is_array, short need_global_specifier, SgFunctionDeclaration* deleteOperatorDeclaration )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDeleteExp::SgDeleteExp (Sg_File_Info* startOfConstruct, SgExpression* variable, short is_array, short need_global_specifier, SgFunctionDeclaration* deleteOperatorDeclaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_variable = variable;
     p_is_array = is_array;
     p_need_global_specifier = need_global_specifier;
     p_deleteOperatorDeclaration = deleteOperatorDeclaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DELETE_OP == variant());
     post_construction_initialization();

  // Test the isSgDeleteExp() function since it has been problematic
     assert(isSgDeleteExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgThisExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassSymbol* 
SgThisExp::get_class_symbol () const
   {
     assert (this != NULL);
     return p_class_symbol;
   }

void
SgThisExp::set_class_symbol ( SgClassSymbol* class_symbol )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_class_symbol != NULL && class_symbol != NULL && p_class_symbol != class_symbol)
        {
          printf ("Warning: class_symbol = %p overwriting valid pointer p_class_symbol = %p \n",class_symbol,p_class_symbol);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_class_symbol != NULL && class_symbol != NULL && p_class_symbol != class_symbol) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_class_symbol = class_symbol;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgThisExp::get_pobj_this () const
   {
     assert (this != NULL);
     return p_pobj_this;
   }

void
SgThisExp::set_pobj_this ( int pobj_this )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_pobj_this = pobj_this;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3925 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int
SgThisExp::cfgIndexForEnd() const
   {
     return 0;
   }

std::vector<VirtualCFG::CFGEdge>
SgThisExp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
     return result;
  }

std::vector<VirtualCFG::CFGEdge>
SgThisExp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     ROSE_ASSERT (idx == 0);
     makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
     return result;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4824 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgThisExp::get_type() const 
   {
  // DQ (1/14/2006): The p_pobj_this data member was CC++ specific and no longer used (deprecated in Sage III), p_pobj_this is now removed
     ROSE_ASSERT(get_class_symbol() != NULL);
     ROSE_ASSERT(get_class_symbol()->get_type() != NULL);
     return SgPointerType::createType(get_class_symbol()->get_type());
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgThisExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgThisExp::variantT() const {
  return V_SgThisExp;
}

#if 0
int
SgThisExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return THIS_NODE;
   }
#endif

const char*
SgThisExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgThisExp";  
   }

std::string
SgThisExp::class_name() const
   {
     assert(this != NULL);
     return "SgThisExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgThisExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgThisExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != THIS_NODE)
        {
          printf ("Error in SgThisExp::error(): SgThisExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgThisExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == THIS_NODE);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgThisExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgThisExp::variant() const \n");
#endif
     assert(this != NULL);
     return THIS_NODE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgThisExp* isSgThisExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgThisExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgThisExp* isSgThisExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgThisExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgThisExp::~SgThisExp ()
   {
#if 0
  // debugging information!
     printf ("In SgThisExp::~SgThisExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for class_symbol
     p_class_symbol = NULL; // non list case 
  // case: not a listType for pobj_this
     p_pobj_this = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgThisExp::SgThisExp ( Sg_File_Info* startOfConstruct, SgClassSymbol* class_symbol, int pobj_this )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgThisExp::SgThisExp (Sg_File_Info* startOfConstruct, SgClassSymbol* class_symbol, int pobj_this) sage_class_name() = %s \n",sage_class_name());
#endif

     p_class_symbol = class_symbol;
     p_pobj_this = pobj_this;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(THIS_NODE == variant());
     post_construction_initialization();

  // Test the isSgThisExp() function since it has been problematic
     assert(isSgThisExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgRefExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgRefExp::get_type_name () const
   {
     assert (this != NULL);
     return p_type_name;
   }

void
SgRefExp::set_type_name ( SgType* type_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type_name != NULL && type_name != NULL && p_type_name != type_name)
        {
          printf ("Warning: type_name = %p overwriting valid pointer p_type_name = %p \n",type_name,p_type_name);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type_name != NULL && type_name != NULL && p_type_name != type_name) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type_name = type_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4001 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgRefExp::variantT() const {
  return V_SgRefExp;
}

#if 0
int
SgRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TYPE_REF;
   }
#endif

const char*
SgRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgRefExp";  
   }

std::string
SgRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TYPE_REF)
        {
          printf ("Error in SgRefExp::error(): SgRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TYPE_REF);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return TYPE_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgRefExp* isSgRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgRefExp* isSgRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgRefExp::~SgRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgRefExp::~SgRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for type_name
     p_type_name = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgRefExp::SgRefExp ( Sg_File_Info* startOfConstruct, SgType* type_name )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgRefExp::SgRefExp (Sg_File_Info* startOfConstruct, SgType* type_name) sage_class_name() = %s \n",sage_class_name());
#endif

     p_type_name = type_name;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TYPE_REF == variant());
     post_construction_initialization();

  // Test the isSgRefExp() function since it has been problematic
     assert(isSgRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarArgStartOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgStartOp::get_lhs_operand () const
   {
     assert (this != NULL);
     return p_lhs_operand;
   }

void
SgVarArgStartOp::set_lhs_operand ( SgExpression* lhs_operand )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lhs_operand != NULL && lhs_operand != NULL && p_lhs_operand != lhs_operand)
        {
          printf ("Warning: lhs_operand = %p overwriting valid pointer p_lhs_operand = %p \n",lhs_operand,p_lhs_operand);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lhs_operand != NULL && lhs_operand != NULL && p_lhs_operand != lhs_operand) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lhs_operand = lhs_operand;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgStartOp::get_rhs_operand () const
   {
     assert (this != NULL);
     return p_rhs_operand;
   }

void
SgVarArgStartOp::set_rhs_operand ( SgExpression* rhs_operand )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_rhs_operand != NULL && rhs_operand != NULL && p_rhs_operand != rhs_operand)
        {
          printf ("Warning: rhs_operand = %p overwriting valid pointer p_rhs_operand = %p \n",rhs_operand,p_rhs_operand);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_rhs_operand != NULL && rhs_operand != NULL && p_rhs_operand != rhs_operand) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_rhs_operand = rhs_operand;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgVarArgStartOp::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgVarArgStartOp::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2971 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

  unsigned int SgVarArgStartOp::cfgIndexForEnd() const {
    return 2;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgStartOp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_lhs_operand()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_rhs_operand()->cfgForBeginning(), result); break;
      case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgStartOp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgStartOp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_lhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      case 2: makeEdge(this->get_rhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgStartOp");
    }
    return result;
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 4650 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*

SgVarArgStartOp::get_type() const
   { 
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarArgStartOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarArgStartOp::variantT() const {
  return V_SgVarArgStartOp;
}

#if 0
int
SgVarArgStartOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VA_START_OP;
   }
#endif

const char*
SgVarArgStartOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarArgStartOp";  
   }

std::string
SgVarArgStartOp::class_name() const
   {
     assert(this != NULL);
     return "SgVarArgStartOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarArgStartOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarArgStartOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VA_START_OP)
        {
          printf ("Error in SgVarArgStartOp::error(): SgVarArgStartOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarArgStartOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VA_START_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarArgStartOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarArgStartOp::variant() const \n");
#endif
     assert(this != NULL);
     return VA_START_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarArgStartOp* isSgVarArgStartOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarArgStartOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarArgStartOp* isSgVarArgStartOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarArgStartOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarArgStartOp::~SgVarArgStartOp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarArgStartOp::~SgVarArgStartOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lhs_operand
     p_lhs_operand = NULL; // non list case 
  // case: not a listType for rhs_operand
     p_rhs_operand = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarArgStartOp::SgVarArgStartOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand, SgExpression* rhs_operand, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarArgStartOp::SgVarArgStartOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand, SgExpression* rhs_operand, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lhs_operand = lhs_operand;
     p_rhs_operand = rhs_operand;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VA_START_OP == variant());
     post_construction_initialization();

  // Test the isSgVarArgStartOp() function since it has been problematic
     assert(isSgVarArgStartOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarArgOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgOp::get_operand_expr () const
   {
     assert (this != NULL);
     return p_operand_expr;
   }

void
SgVarArgOp::set_operand_expr ( SgExpression* operand_expr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr)
        {
          printf ("Warning: operand_expr = %p overwriting valid pointer p_operand_expr = %p \n",operand_expr,p_operand_expr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_expr = operand_expr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgVarArgOp::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgVarArgOp::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3001 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgVarArgOp::get_type() const
   {
  // This function returns an explicitly stored type

     SgType* returnType = p_expression_type;

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

  unsigned int SgVarArgOp::cfgIndexForEnd() const {
    return 1;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgOp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_operand_expr()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgOp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgOp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_operand_expr()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgOp");
    }
    return result;
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarArgOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarArgOp::variantT() const {
  return V_SgVarArgOp;
}

#if 0
int
SgVarArgOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VA_OP;
   }
#endif

const char*
SgVarArgOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarArgOp";  
   }

std::string
SgVarArgOp::class_name() const
   {
     assert(this != NULL);
     return "SgVarArgOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarArgOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarArgOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VA_OP)
        {
          printf ("Error in SgVarArgOp::error(): SgVarArgOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarArgOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VA_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarArgOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarArgOp::variant() const \n");
#endif
     assert(this != NULL);
     return VA_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarArgOp* isSgVarArgOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarArgOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarArgOp* isSgVarArgOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarArgOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarArgOp::~SgVarArgOp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarArgOp::~SgVarArgOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_expr
     p_operand_expr = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarArgOp::SgVarArgOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarArgOp::SgVarArgOp (Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_expr = operand_expr;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VA_OP == variant());
     post_construction_initialization();

  // Test the isSgVarArgOp() function since it has been problematic
     assert(isSgVarArgOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarArgEndOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgEndOp::get_operand_expr () const
   {
     assert (this != NULL);
     return p_operand_expr;
   }

void
SgVarArgEndOp::set_operand_expr ( SgExpression* operand_expr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr)
        {
          printf ("Warning: operand_expr = %p overwriting valid pointer p_operand_expr = %p \n",operand_expr,p_operand_expr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_expr = operand_expr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgVarArgEndOp::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgVarArgEndOp::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3041 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


  unsigned int SgVarArgEndOp::cfgIndexForEnd() const {
    return 1;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgEndOp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_operand_expr()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgEndOp");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgVarArgEndOp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_operand_expr()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index for SgVarArgEndOp");
    }
    return result;
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 4650 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*

SgVarArgEndOp::get_type() const
   { 
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarArgEndOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarArgEndOp::variantT() const {
  return V_SgVarArgEndOp;
}

#if 0
int
SgVarArgEndOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VA_END_OP;
   }
#endif

const char*
SgVarArgEndOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarArgEndOp";  
   }

std::string
SgVarArgEndOp::class_name() const
   {
     assert(this != NULL);
     return "SgVarArgEndOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarArgEndOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarArgEndOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VA_END_OP)
        {
          printf ("Error in SgVarArgEndOp::error(): SgVarArgEndOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarArgEndOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VA_END_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarArgEndOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarArgEndOp::variant() const \n");
#endif
     assert(this != NULL);
     return VA_END_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarArgEndOp* isSgVarArgEndOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarArgEndOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarArgEndOp* isSgVarArgEndOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarArgEndOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarArgEndOp::~SgVarArgEndOp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarArgEndOp::~SgVarArgEndOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_expr
     p_operand_expr = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarArgEndOp::SgVarArgEndOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarArgEndOp::SgVarArgEndOp (Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_expr = operand_expr;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VA_END_OP == variant());
     post_construction_initialization();

  // Test the isSgVarArgEndOp() function since it has been problematic
     assert(isSgVarArgEndOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarArgCopyOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgCopyOp::get_lhs_operand () const
   {
     assert (this != NULL);
     return p_lhs_operand;
   }

void
SgVarArgCopyOp::set_lhs_operand ( SgExpression* lhs_operand )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lhs_operand != NULL && lhs_operand != NULL && p_lhs_operand != lhs_operand)
        {
          printf ("Warning: lhs_operand = %p overwriting valid pointer p_lhs_operand = %p \n",lhs_operand,p_lhs_operand);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lhs_operand != NULL && lhs_operand != NULL && p_lhs_operand != lhs_operand) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lhs_operand = lhs_operand;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgCopyOp::get_rhs_operand () const
   {
     assert (this != NULL);
     return p_rhs_operand;
   }

void
SgVarArgCopyOp::set_rhs_operand ( SgExpression* rhs_operand )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_rhs_operand != NULL && rhs_operand != NULL && p_rhs_operand != rhs_operand)
        {
          printf ("Warning: rhs_operand = %p overwriting valid pointer p_rhs_operand = %p \n",rhs_operand,p_rhs_operand);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_rhs_operand != NULL && rhs_operand != NULL && p_rhs_operand != rhs_operand) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_rhs_operand = rhs_operand;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgVarArgCopyOp::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgVarArgCopyOp::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4650 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*

SgVarArgCopyOp::get_type() const
   { 
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarArgCopyOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarArgCopyOp::variantT() const {
  return V_SgVarArgCopyOp;
}

#if 0
int
SgVarArgCopyOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VA_COPY_OP;
   }
#endif

const char*
SgVarArgCopyOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarArgCopyOp";  
   }

std::string
SgVarArgCopyOp::class_name() const
   {
     assert(this != NULL);
     return "SgVarArgCopyOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarArgCopyOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarArgCopyOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VA_COPY_OP)
        {
          printf ("Error in SgVarArgCopyOp::error(): SgVarArgCopyOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarArgCopyOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VA_COPY_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarArgCopyOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarArgCopyOp::variant() const \n");
#endif
     assert(this != NULL);
     return VA_COPY_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarArgCopyOp* isSgVarArgCopyOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarArgCopyOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarArgCopyOp* isSgVarArgCopyOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarArgCopyOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarArgCopyOp::~SgVarArgCopyOp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarArgCopyOp::~SgVarArgCopyOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lhs_operand
     p_lhs_operand = NULL; // non list case 
  // case: not a listType for rhs_operand
     p_rhs_operand = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarArgCopyOp::SgVarArgCopyOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand, SgExpression* rhs_operand, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarArgCopyOp::SgVarArgCopyOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand, SgExpression* rhs_operand, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lhs_operand = lhs_operand;
     p_rhs_operand = rhs_operand;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VA_COPY_OP == variant());
     post_construction_initialization();

  // Test the isSgVarArgCopyOp() function since it has been problematic
     assert(isSgVarArgCopyOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVarArgStartOneOperandOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgVarArgStartOneOperandOp::get_operand_expr () const
   {
     assert (this != NULL);
     return p_operand_expr;
   }

void
SgVarArgStartOneOperandOp::set_operand_expr ( SgExpression* operand_expr )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr)
        {
          printf ("Warning: operand_expr = %p overwriting valid pointer p_operand_expr = %p \n",operand_expr,p_operand_expr);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_expr != NULL && operand_expr != NULL && p_operand_expr != operand_expr) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_expr = operand_expr;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgVarArgStartOneOperandOp::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgVarArgStartOneOperandOp::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4650 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*

SgVarArgStartOneOperandOp::get_type() const
   { 
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVarArgStartOneOperandOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVarArgStartOneOperandOp::variantT() const {
  return V_SgVarArgStartOneOperandOp;
}

#if 0
int
SgVarArgStartOneOperandOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VA_START_ONE_OPERAND_OP;
   }
#endif

const char*
SgVarArgStartOneOperandOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVarArgStartOneOperandOp";  
   }

std::string
SgVarArgStartOneOperandOp::class_name() const
   {
     assert(this != NULL);
     return "SgVarArgStartOneOperandOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVarArgStartOneOperandOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVarArgStartOneOperandOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VA_START_ONE_OPERAND_OP)
        {
          printf ("Error in SgVarArgStartOneOperandOp::error(): SgVarArgStartOneOperandOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVarArgStartOneOperandOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VA_START_ONE_OPERAND_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVarArgStartOneOperandOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVarArgStartOneOperandOp::variant() const \n");
#endif
     assert(this != NULL);
     return VA_START_ONE_OPERAND_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVarArgStartOneOperandOp* isSgVarArgStartOneOperandOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVarArgStartOneOperandOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVarArgStartOneOperandOp* isSgVarArgStartOneOperandOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVarArgStartOneOperandOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVarArgStartOneOperandOp::~SgVarArgStartOneOperandOp ()
   {
#if 0
  // debugging information!
     printf ("In SgVarArgStartOneOperandOp::~SgVarArgStartOneOperandOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_expr
     p_operand_expr = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVarArgStartOneOperandOp::SgVarArgStartOneOperandOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVarArgStartOneOperandOp::SgVarArgStartOneOperandOp (Sg_File_Info* startOfConstruct, SgExpression* operand_expr, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_expr = operand_expr;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VA_START_ONE_OPERAND_OP == variant());
     post_construction_initialization();

  // Test the isSgVarArgStartOneOperandOp() function since it has been problematic
     assert(isSgVarArgStartOneOperandOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgNullExpression::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4837 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

  unsigned int SgNullExpression::cfgIndexForEnd() const {
    return 0;
  }

  std::vector<VirtualCFG::CFGEdge> SgNullExpression::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    ROSE_ASSERT (idx == 0);
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgNullExpression::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    ROSE_ASSERT (idx == 0);
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
    return result;
  }



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgNullExpression::get_type(void) const
   {
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNullExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNullExpression::variantT() const {
  return V_SgNullExpression;
}

#if 0
int
SgNullExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NULL_EXPR;
   }
#endif

const char*
SgNullExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNullExpression";  
   }

std::string
SgNullExpression::class_name() const
   {
     assert(this != NULL);
     return "SgNullExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNullExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNullExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NULL_EXPR)
        {
          printf ("Error in SgNullExpression::error(): SgNullExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNullExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NULL_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNullExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNullExpression::variant() const \n");
#endif
     assert(this != NULL);
     return NULL_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNullExpression* isSgNullExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNullExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNullExpression* isSgNullExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNullExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNullExpression::~SgNullExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgNullExpression::~SgNullExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNullExpression::SgNullExpression ( Sg_File_Info* startOfConstruct )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgNullExpression::SgNullExpression (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(NULL_EXPR == variant());
     post_construction_initialization();

  // Test the isSgNullExpression() function since it has been problematic
     assert(isSgNullExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgVariantExpression::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4858 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgVariantExpression::get_type(void) const
   {
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVariantExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVariantExpression::variantT() const {
  return V_SgVariantExpression;
}

#if 0
int
SgVariantExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VARIANT_EXPR;
   }
#endif

const char*
SgVariantExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVariantExpression";  
   }

std::string
SgVariantExpression::class_name() const
   {
     assert(this != NULL);
     return "SgVariantExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVariantExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVariantExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VARIANT_EXPR)
        {
          printf ("Error in SgVariantExpression::error(): SgVariantExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVariantExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VARIANT_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVariantExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVariantExpression::variant() const \n");
#endif
     assert(this != NULL);
     return VARIANT_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVariantExpression* isSgVariantExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVariantExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVariantExpression* isSgVariantExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVariantExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVariantExpression::~SgVariantExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgVariantExpression::~SgVariantExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVariantExpression::SgVariantExpression ( Sg_File_Info* startOfConstruct )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgVariantExpression::SgVariantExpression (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(VARIANT_EXPR == variant());
     post_construction_initialization();

  // Test the isSgVariantExpression() function since it has been problematic
     assert(isSgVariantExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgIntrinsicFn::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgIntrinsicFn::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgIntrinsicFn::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

void
SgIntrinsicFn::set_args ( SgExprListExp* args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_args != NULL && args != NULL && p_args != args)
        {
          printf ("Warning: args = %p overwriting valid pointer p_args = %p \n",args,p_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_args != NULL && args != NULL && p_args != args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_args = args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgIntrinsicFn::get_return_type () const
   {
     assert (this != NULL);
     return p_return_type;
   }

void
SgIntrinsicFn::set_return_type ( SgType* return_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_return_type != NULL && return_type != NULL && p_return_type != return_type)
        {
          printf ("Warning: return_type = %p overwriting valid pointer p_return_type = %p \n",return_type,p_return_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_return_type != NULL && return_type != NULL && p_return_type != return_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_return_type = return_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4960 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgIntrinsicFn::post_construction_initialization() 
   { }

SgType*
SgIntrinsicFn::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

void
SgIntrinsicFn::append_arg(SgExpression* what)
   {
     assert(this != NULL);
     if (p_args == NULL)
        {
       // set_args(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          set_args(newArgs);
        }

    // insert_arg(p_args->end(),what);
       p_args->append_expression(what);
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgIntrinsicFn::replace_expression(SgExpression *,SgExpression *)
   { return 0; }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIntrinsicFn::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIntrinsicFn::variantT() const {
  return V_SgIntrinsicFn;
}

#if 0
int
SgIntrinsicFn::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INTRINSICFN;
   }
#endif

const char*
SgIntrinsicFn::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIntrinsicFn";  
   }

std::string
SgIntrinsicFn::class_name() const
   {
     assert(this != NULL);
     return "SgIntrinsicFn";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIntrinsicFn::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIntrinsicFn::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INTRINSICFN)
        {
          printf ("Error in SgIntrinsicFn::error(): SgIntrinsicFn object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIntrinsicFn::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INTRINSICFN);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIntrinsicFn::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIntrinsicFn::variant() const \n");
#endif
     assert(this != NULL);
     return INTRINSICFN;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIntrinsicFn* isSgIntrinsicFn ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIntrinsicFn*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIntrinsicFn* isSgIntrinsicFn ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIntrinsicFn*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIntrinsicFn::~SgIntrinsicFn ()
   {
#if 0
  // debugging information!
     printf ("In SgIntrinsicFn::~SgIntrinsicFn (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for args
     p_args = NULL; // non list case 
  // case: not a listType for return_type
     p_return_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIntrinsicFn::SgIntrinsicFn ( Sg_File_Info* startOfConstruct, SgName name, SgExprListExp* args, SgType* return_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIntrinsicFn::SgIntrinsicFn (Sg_File_Info* startOfConstruct, SgName name, SgExprListExp* args, SgType* return_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_args = args;
     p_return_type = return_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INTRINSICFN == variant());
     post_construction_initialization();

  // Test the isSgIntrinsicFn() function since it has been problematic
     assert(isSgIntrinsicFn(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptExpression::get_lowerBound () const
   {
     assert (this != NULL);
     return p_lowerBound;
   }

void
SgSubscriptExpression::set_lowerBound ( SgExpression* lowerBound )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound)
        {
          printf ("Warning: lowerBound = %p overwriting valid pointer p_lowerBound = %p \n",lowerBound,p_lowerBound);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lowerBound = lowerBound;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptExpression::get_upperBound () const
   {
     assert (this != NULL);
     return p_upperBound;
   }

void
SgSubscriptExpression::set_upperBound ( SgExpression* upperBound )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_upperBound != NULL && upperBound != NULL && p_upperBound != upperBound)
        {
          printf ("Warning: upperBound = %p overwriting valid pointer p_upperBound = %p \n",upperBound,p_upperBound);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_upperBound != NULL && upperBound != NULL && p_upperBound != upperBound) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_upperBound = upperBound;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptExpression::get_stride () const
   {
     assert (this != NULL);
     return p_stride;
   }

void
SgSubscriptExpression::set_stride ( SgExpression* stride )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_stride != NULL && stride != NULL && p_stride != stride)
        {
          printf ("Warning: stride = %p overwriting valid pointer p_stride = %p \n",stride,p_stride);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_stride != NULL && stride != NULL && p_stride != stride) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_stride = stride;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4998 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgSubscriptExpression::post_construction_initialization() 
   { }

SgType*
SgSubscriptExpression::get_type() const
   {
     printf ("Not clear what the type should be for a SgSubscriptExpression: returning type of lower bound,upper bound, and string; or SgIntType if none are available. \n");
  // ROSE_ASSERT(false);

     SgType* returnType = NULL;

     bool isLowerBoundNullExpression = (isSgNullExpression(get_lowerBound()) != NULL);
     bool isUpperBoundNullExpression = (isSgNullExpression(get_upperBound()) != NULL);
     bool isStrideNullExpression     = (isSgNullExpression(get_stride()) != NULL);

  // Even if the stride was not specified it should default to unit stride (value == 1).
     ROSE_ASSERT(isStrideNullExpression == false);

     if (isLowerBoundNullExpression == true)
        {
       // There was no lower bound specified
          if (isUpperBoundNullExpression == true)
             {
            // There was no upper bound specified, so we have to assume SgIntType is OK!
               returnType = SgTypeInt::createType();
             }
            else
             {
               returnType = get_upperBound()->get_type();
             }
        }
       else
        {
          returnType = get_lowerBound()->get_type();
          if (isUpperBoundNullExpression == true)
             {
            // Not a problem since the lower bound was specified
             }
            else
             {
            // Just make sure that they are the same type, not clear how important this is!
               SgType* upperBoundType = get_upperBound()->get_type();
               ROSE_ASSERT(upperBoundType->variantT() == returnType->variantT());
             }
        }

     return returnType;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgSubscriptExpression::replace_expression(SgExpression *o, SgExpression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_upperBound()==o)
             {
               set_upperBound(n);
               return 1;  
             }
          else
             if(get_stride()==o)
                {
                  set_stride(n);
                  return 1;  
                } 
                else
                  return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSubscriptExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSubscriptExpression::variantT() const {
  return V_SgSubscriptExpression;
}

#if 0
int
SgSubscriptExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SUBSCRIPT_EXPR;
   }
#endif

const char*
SgSubscriptExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptExpression";  
   }

std::string
SgSubscriptExpression::class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSubscriptExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSubscriptExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SUBSCRIPT_EXPR)
        {
          printf ("Error in SgSubscriptExpression::error(): SgSubscriptExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSubscriptExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SUBSCRIPT_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSubscriptExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSubscriptExpression::variant() const \n");
#endif
     assert(this != NULL);
     return SUBSCRIPT_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSubscriptExpression* isSgSubscriptExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSubscriptExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSubscriptExpression* isSgSubscriptExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSubscriptExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSubscriptExpression::~SgSubscriptExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgSubscriptExpression::~SgSubscriptExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lowerBound
     p_lowerBound = NULL; // non list case 
  // case: not a listType for upperBound
     p_upperBound = NULL; // non list case 
  // case: not a listType for stride
     p_stride = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSubscriptExpression::SgSubscriptExpression ( Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* upperBound, SgExpression* stride )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSubscriptExpression::SgSubscriptExpression (Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* upperBound, SgExpression* stride) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lowerBound = lowerBound;
     p_upperBound = upperBound;
     p_stride = stride;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SUBSCRIPT_EXPR == variant());
     post_construction_initialization();

  // Test the isSgSubscriptExpression() function since it has been problematic
     assert(isSgSubscriptExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptColon::get_lowerBound () const
   {
     assert (this != NULL);
     return p_lowerBound;
   }

void
SgSubscriptColon::set_lowerBound ( SgExpression* lowerBound )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound)
        {
          printf ("Warning: lowerBound = %p overwriting valid pointer p_lowerBound = %p \n",lowerBound,p_lowerBound);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lowerBound = lowerBound;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptColon::get_stride () const
   {
     assert (this != NULL);
     return p_stride;
   }

void
SgSubscriptColon::set_stride ( SgExpression* stride )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_stride != NULL && stride != NULL && p_stride != stride)
        {
          printf ("Warning: stride = %p overwriting valid pointer p_stride = %p \n",stride,p_stride);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_stride != NULL && stride != NULL && p_stride != stride) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_stride = stride;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5079 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgSubscriptColon::post_construction_initialization() 
   { }


SgType*
SgSubscriptColon::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgSubscriptColon::replace_expression(SgExpression *o, SgExpression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;  
             } 
             else
               return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSubscriptColon::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSubscriptColon::variantT() const {
  return V_SgSubscriptColon;
}

#if 0
int
SgSubscriptColon::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SUBSCRIPT_COLON;
   }
#endif

const char*
SgSubscriptColon::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptColon";  
   }

std::string
SgSubscriptColon::class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptColon";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSubscriptColon::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSubscriptColon::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SUBSCRIPT_COLON)
        {
          printf ("Error in SgSubscriptColon::error(): SgSubscriptColon object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSubscriptColon::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SUBSCRIPT_COLON);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSubscriptColon::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSubscriptColon::variant() const \n");
#endif
     assert(this != NULL);
     return SUBSCRIPT_COLON;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSubscriptColon* isSgSubscriptColon ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSubscriptColon*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSubscriptColon* isSgSubscriptColon ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSubscriptColon*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSubscriptColon::~SgSubscriptColon ()
   {
#if 0
  // debugging information!
     printf ("In SgSubscriptColon::~SgSubscriptColon (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lowerBound
     p_lowerBound = NULL; // non list case 
  // case: not a listType for stride
     p_stride = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSubscriptColon::SgSubscriptColon ( Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSubscriptColon::SgSubscriptColon (Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lowerBound = lowerBound;
     p_stride = stride;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SUBSCRIPT_COLON == variant());
     post_construction_initialization();

  // Test the isSgSubscriptColon() function since it has been problematic
     assert(isSgSubscriptColon(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptAsterisk::get_lowerBound () const
   {
     assert (this != NULL);
     return p_lowerBound;
   }

void
SgSubscriptAsterisk::set_lowerBound ( SgExpression* lowerBound )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound)
        {
          printf ("Warning: lowerBound = %p overwriting valid pointer p_lowerBound = %p \n",lowerBound,p_lowerBound);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lowerBound = lowerBound;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgSubscriptAsterisk::get_stride () const
   {
     assert (this != NULL);
     return p_stride;
   }

void
SgSubscriptAsterisk::set_stride ( SgExpression* stride )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_stride != NULL && stride != NULL && p_stride != stride)
        {
          printf ("Warning: stride = %p overwriting valid pointer p_stride = %p \n",stride,p_stride);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_stride != NULL && stride != NULL && p_stride != stride) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_stride = stride;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5156 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgSubscriptAsterisk::post_construction_initialization() 
   { }

SgType*
SgSubscriptAsterisk::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgSubscriptAsterisk::replace_expression(SgExpression *o, SgExpression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;  
             } 
             else
               return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSubscriptAsterisk::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSubscriptAsterisk::variantT() const {
  return V_SgSubscriptAsterisk;
}

#if 0
int
SgSubscriptAsterisk::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SUBSCRIPT_ASTERISK;
   }
#endif

const char*
SgSubscriptAsterisk::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptAsterisk";  
   }

std::string
SgSubscriptAsterisk::class_name() const
   {
     assert(this != NULL);
     return "SgSubscriptAsterisk";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSubscriptAsterisk::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSubscriptAsterisk::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SUBSCRIPT_ASTERISK)
        {
          printf ("Error in SgSubscriptAsterisk::error(): SgSubscriptAsterisk object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSubscriptAsterisk::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SUBSCRIPT_ASTERISK);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSubscriptAsterisk::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSubscriptAsterisk::variant() const \n");
#endif
     assert(this != NULL);
     return SUBSCRIPT_ASTERISK;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSubscriptAsterisk* isSgSubscriptAsterisk ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSubscriptAsterisk*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSubscriptAsterisk* isSgSubscriptAsterisk ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSubscriptAsterisk*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSubscriptAsterisk::~SgSubscriptAsterisk ()
   {
#if 0
  // debugging information!
     printf ("In SgSubscriptAsterisk::~SgSubscriptAsterisk (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lowerBound
     p_lowerBound = NULL; // non list case 
  // case: not a listType for stride
     p_stride = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSubscriptAsterisk::SgSubscriptAsterisk ( Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgSubscriptAsterisk::SgSubscriptAsterisk (Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lowerBound = lowerBound;
     p_stride = stride;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SUBSCRIPT_ASTERISK == variant());
     post_construction_initialization();

  // Test the isSgSubscriptAsterisk() function since it has been problematic
     assert(isSgSubscriptAsterisk(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgColon::get_lowerBound () const
   {
     assert (this != NULL);
     return p_lowerBound;
   }

void
SgColon::set_lowerBound ( SgExpression* lowerBound )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound)
        {
          printf ("Warning: lowerBound = %p overwriting valid pointer p_lowerBound = %p \n",lowerBound,p_lowerBound);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lowerBound != NULL && lowerBound != NULL && p_lowerBound != lowerBound) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lowerBound = lowerBound;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgColon::get_stride () const
   {
     assert (this != NULL);
     return p_stride;
   }

void
SgColon::set_stride ( SgExpression* stride )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_stride != NULL && stride != NULL && p_stride != stride)
        {
          printf ("Warning: stride = %p overwriting valid pointer p_stride = %p \n",stride,p_stride);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_stride != NULL && stride != NULL && p_stride != stride) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_stride = stride;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5117 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgColon::post_construction_initialization() 
   { }


SgType*
SgColon::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgColon::replace_expression(SgExpression *o, SgExpression *n)
   {
     if(get_lowerBound()==o)
        {
          set_lowerBound(n);
          return 1;
        }
       else
          if(get_stride()==o)
             {
               set_stride(n);
               return 1;  
             } 
             else
               return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgColon::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgColon::variantT() const {
  return V_SgColon;
}

#if 0
int
SgColon::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return COLON;
   }
#endif

const char*
SgColon::sage_class_name() const
   {
     assert(this != NULL);
     return "SgColon";  
   }

std::string
SgColon::class_name() const
   {
     assert(this != NULL);
     return "SgColon";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgColon::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgColon::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != COLON)
        {
          printf ("Error in SgColon::error(): SgColon object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgColon::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == COLON);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgColon::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgColon::variant() const \n");
#endif
     assert(this != NULL);
     return COLON;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgColon* isSgColon ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgColon*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgColon* isSgColon ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgColon*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgColon::~SgColon ()
   {
#if 0
  // debugging information!
     printf ("In SgColon::~SgColon (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lowerBound
     p_lowerBound = NULL; // non list case 
  // case: not a listType for stride
     p_stride = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgColon::SgColon ( Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgColon::SgColon (Sg_File_Info* startOfConstruct, SgExpression* lowerBound, SgExpression* stride) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lowerBound = lowerBound;
     p_stride = stride;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(COLON == variant());
     post_construction_initialization();

  // Test the isSgColon() function since it has been problematic
     assert(isSgColon(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgUseOnlyExpression::get_access_list () const
   {
     assert (this != NULL);
     return p_access_list;
   }

void
SgUseOnlyExpression::set_access_list ( SgExprListExp* access_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_access_list != NULL && access_list != NULL && p_access_list != access_list)
        {
          printf ("Warning: access_list = %p overwriting valid pointer p_access_list = %p \n",access_list,p_access_list);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_access_list != NULL && access_list != NULL && p_access_list != access_list) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_access_list = access_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5193 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgUseOnlyExpression::post_construction_initialization() 
   { }

SgType*
SgUseOnlyExpression::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
UseOnlyExpression::replace_expression(SgExpression* o, SgExpression* n)
   {
     if(get_access_list()==o)
        {
          set_access_list(isSgExprListExp(n));
          return 1;
        }
       else
          return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUseOnlyExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUseOnlyExpression::variantT() const {
  return V_SgUseOnlyExpression;
}

#if 0
int
SgUseOnlyExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return USE_ONLY_EXPR;
   }
#endif

const char*
SgUseOnlyExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUseOnlyExpression";  
   }

std::string
SgUseOnlyExpression::class_name() const
   {
     assert(this != NULL);
     return "SgUseOnlyExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUseOnlyExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUseOnlyExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != USE_ONLY_EXPR)
        {
          printf ("Error in SgUseOnlyExpression::error(): SgUseOnlyExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUseOnlyExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == USE_ONLY_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUseOnlyExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUseOnlyExpression::variant() const \n");
#endif
     assert(this != NULL);
     return USE_ONLY_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUseOnlyExpression* isSgUseOnlyExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUseOnlyExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUseOnlyExpression* isSgUseOnlyExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUseOnlyExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUseOnlyExpression::~SgUseOnlyExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgUseOnlyExpression::~SgUseOnlyExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for access_list
     p_access_list = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUseOnlyExpression::SgUseOnlyExpression ( Sg_File_Info* startOfConstruct, SgExprListExp* access_list )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUseOnlyExpression::SgUseOnlyExpression (Sg_File_Info* startOfConstruct, SgExprListExp* access_list) sage_class_name() = %s \n",sage_class_name());
#endif

     p_access_list = access_list;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(USE_ONLY_EXPR == variant());
     post_construction_initialization();

  // Test the isSgUseOnlyExpression() function since it has been problematic
     assert(isSgUseOnlyExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgVarRefExp* 
SgIOImpliedDo::get_do_var () const
   {
     assert (this != NULL);
     return p_do_var;
   }

void
SgIOImpliedDo::set_do_var ( SgVarRefExp* do_var )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_do_var != NULL && do_var != NULL && p_do_var != do_var)
        {
          printf ("Warning: do_var = %p overwriting valid pointer p_do_var = %p \n",do_var,p_do_var);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_do_var != NULL && do_var != NULL && p_do_var != do_var) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_do_var = do_var;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOImpliedDo::get_first_val () const
   {
     assert (this != NULL);
     return p_first_val;
   }

void
SgIOImpliedDo::set_first_val ( SgExpression* first_val )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_first_val != NULL && first_val != NULL && p_first_val != first_val)
        {
          printf ("Warning: first_val = %p overwriting valid pointer p_first_val = %p \n",first_val,p_first_val);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_first_val != NULL && first_val != NULL && p_first_val != first_val) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_first_val = first_val;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOImpliedDo::get_last_val () const
   {
     assert (this != NULL);
     return p_last_val;
   }

void
SgIOImpliedDo::set_last_val ( SgExpression* last_val )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_last_val != NULL && last_val != NULL && p_last_val != last_val)
        {
          printf ("Warning: last_val = %p overwriting valid pointer p_last_val = %p \n",last_val,p_last_val);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_last_val != NULL && last_val != NULL && p_last_val != last_val) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_last_val = last_val;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOImpliedDo::get_increment () const
   {
     assert (this != NULL);
     return p_increment;
   }

void
SgIOImpliedDo::set_increment ( SgExpression* increment )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_increment != NULL && increment != NULL && p_increment != increment)
        {
          printf ("Warning: increment = %p overwriting valid pointer p_increment = %p \n",increment,p_increment);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_increment != NULL && increment != NULL && p_increment != increment) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_increment = increment;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgIOImpliedDo::get_object_list () const
   {
     assert (this != NULL);
     return p_object_list;
   }

void
SgIOImpliedDo::set_object_list ( SgExprListExp* object_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_object_list != NULL && object_list != NULL && p_object_list != object_list)
        {
          printf ("Warning: object_list = %p overwriting valid pointer p_object_list = %p \n",object_list,p_object_list);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_object_list != NULL && object_list != NULL && p_object_list != object_list) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_object_list = object_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5292 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgIOImpliedDo::post_construction_initialization() 
   { }

SgType*
SgIOImpliedDo::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgIOImpliedDo::replace_expression(SgExpression* o, SgExpression* n)
   {
     if(get_object_list()==o)
        {
          set_object_list(isSgExprListExp(n));
          return 1;
        }
       else
          return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIOImpliedDo::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIOImpliedDo::variantT() const {
  return V_SgIOImpliedDo;
}

#if 0
int
SgIOImpliedDo::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IO_IMPLIED_DO;
   }
#endif

const char*
SgIOImpliedDo::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIOImpliedDo";  
   }

std::string
SgIOImpliedDo::class_name() const
   {
     assert(this != NULL);
     return "SgIOImpliedDo";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIOImpliedDo::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIOImpliedDo::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IO_IMPLIED_DO)
        {
          printf ("Error in SgIOImpliedDo::error(): SgIOImpliedDo object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIOImpliedDo::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IO_IMPLIED_DO);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIOImpliedDo::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIOImpliedDo::variant() const \n");
#endif
     assert(this != NULL);
     return IO_IMPLIED_DO;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIOImpliedDo* isSgIOImpliedDo ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIOImpliedDo*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIOImpliedDo* isSgIOImpliedDo ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIOImpliedDo*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIOImpliedDo::~SgIOImpliedDo ()
   {
#if 0
  // debugging information!
     printf ("In SgIOImpliedDo::~SgIOImpliedDo (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for do_var
     p_do_var = NULL; // non list case 
  // case: not a listType for first_val
     p_first_val = NULL; // non list case 
  // case: not a listType for last_val
     p_last_val = NULL; // non list case 
  // case: not a listType for increment
     p_increment = NULL; // non list case 
  // case: not a listType for object_list
     p_object_list = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIOImpliedDo::SgIOImpliedDo ( Sg_File_Info* startOfConstruct, SgVarRefExp* do_var, SgExpression* first_val, SgExpression* last_val, SgExpression* increment, SgExprListExp* object_list )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIOImpliedDo::SgIOImpliedDo (Sg_File_Info* startOfConstruct, SgVarRefExp* do_var, SgExpression* first_val, SgExpression* last_val, SgExpression* increment, SgExprListExp* object_list) sage_class_name() = %s \n",sage_class_name());
#endif

     p_do_var = do_var;
     p_first_val = first_val;
     p_last_val = last_val;
     p_increment = increment;
     p_object_list = object_list;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IO_IMPLIED_DO == variant());
     post_construction_initialization();

  // Test the isSgIOImpliedDo() function since it has been problematic
     assert(isSgIOImpliedDo(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgIOItemExpression::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgIOItemExpression::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgIOItemExpression::get_io_item () const
   {
     assert (this != NULL);
     return p_io_item;
   }

void
SgIOItemExpression::set_io_item ( SgExpression* io_item )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_io_item != NULL && io_item != NULL && p_io_item != io_item)
        {
          printf ("Warning: io_item = %p overwriting valid pointer p_io_item = %p \n",io_item,p_io_item);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_io_item != NULL && io_item != NULL && p_io_item != io_item) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_io_item = io_item;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5261 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgIOItemExpression::post_construction_initialization() 
   { }

SgType*
SgIOItemExpression::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgIOItemExpression::replace_expression(SgExpression* o, SgExpression* n)
   {
     if(get_io_item()==o)
        {
          set_io_item(n);
          return 1;
        }
       else
          return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIOItemExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIOItemExpression::variantT() const {
  return V_SgIOItemExpression;
}

#if 0
int
SgIOItemExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IO_ITEM_EXPR;
   }
#endif

const char*
SgIOItemExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIOItemExpression";  
   }

std::string
SgIOItemExpression::class_name() const
   {
     assert(this != NULL);
     return "SgIOItemExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIOItemExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIOItemExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IO_ITEM_EXPR)
        {
          printf ("Error in SgIOItemExpression::error(): SgIOItemExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIOItemExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IO_ITEM_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIOItemExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIOItemExpression::variant() const \n");
#endif
     assert(this != NULL);
     return IO_ITEM_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIOItemExpression* isSgIOItemExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIOItemExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIOItemExpression* isSgIOItemExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIOItemExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIOItemExpression::~SgIOItemExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgIOItemExpression::~SgIOItemExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for io_item
     p_io_item = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIOItemExpression::SgIOItemExpression ( Sg_File_Info* startOfConstruct, SgName name, SgExpression* io_item )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIOItemExpression::SgIOItemExpression (Sg_File_Info* startOfConstruct, SgName name, SgExpression* io_item) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_io_item = io_item;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(IO_ITEM_EXPR == variant());
     post_construction_initialization();

  // Test the isSgIOItemExpression() function since it has been problematic
     assert(isSgIOItemExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgUseRenameExpression::get_oldname () const
   {
     assert (this != NULL);
     return p_oldname;
   }

void
SgUseRenameExpression::set_oldname ( SgExpression* oldname )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_oldname != NULL && oldname != NULL && p_oldname != oldname)
        {
          printf ("Warning: oldname = %p overwriting valid pointer p_oldname = %p \n",oldname,p_oldname);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_oldname != NULL && oldname != NULL && p_oldname != oldname) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_oldname = oldname;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgUseRenameExpression::get_newname () const
   {
     assert (this != NULL);
     return p_newname;
   }

void
SgUseRenameExpression::set_newname ( SgExpression* newname )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_newname != NULL && newname != NULL && p_newname != newname)
        {
          printf ("Warning: newname = %p overwriting valid pointer p_newname = %p \n",newname,p_newname);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_newname != NULL && newname != NULL && p_newname != newname) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_newname = newname;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 5224 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgUseRenameExpression::post_construction_initialization() 
   { }

SgType*
SgUseRenameExpression::get_type() const
   {
     printf ("Not clear what this type should be. \n");
     ROSE_ASSERT(false);
     return NULL;
   }

#if 0
// DQ (3/20/2007): This is an older function now depricated.
int
SgUseRenameExpression::replace_expression(SgExpression *o, SgExpression *n)
   {
     if(get_newname()==o)
        {
          set_newname(n);
          return 1;
        }
       else
          if(get_oldname()==o)
             {
               set_oldname(n);
               return 1;  
             } 
            else 
               return 0;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUseRenameExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUseRenameExpression::variantT() const {
  return V_SgUseRenameExpression;
}

#if 0
int
SgUseRenameExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return USE_RENAME_EXPR;
   }
#endif

const char*
SgUseRenameExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUseRenameExpression";  
   }

std::string
SgUseRenameExpression::class_name() const
   {
     assert(this != NULL);
     return "SgUseRenameExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUseRenameExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUseRenameExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != USE_RENAME_EXPR)
        {
          printf ("Error in SgUseRenameExpression::error(): SgUseRenameExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUseRenameExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == USE_RENAME_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUseRenameExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUseRenameExpression::variant() const \n");
#endif
     assert(this != NULL);
     return USE_RENAME_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUseRenameExpression* isSgUseRenameExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUseRenameExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUseRenameExpression* isSgUseRenameExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUseRenameExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUseRenameExpression::~SgUseRenameExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgUseRenameExpression::~SgUseRenameExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for oldname
     p_oldname = NULL; // non list case 
  // case: not a listType for newname
     p_newname = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUseRenameExpression::SgUseRenameExpression ( Sg_File_Info* startOfConstruct, SgExpression* oldname, SgExpression* newname )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUseRenameExpression::SgUseRenameExpression (Sg_File_Info* startOfConstruct, SgExpression* oldname, SgExpression* newname) sage_class_name() = %s \n",sage_class_name());
#endif

     p_oldname = oldname;
     p_newname = newname;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(USE_RENAME_EXPR == variant());
     post_construction_initialization();

  // Test the isSgUseRenameExpression() function since it has been problematic
     assert(isSgUseRenameExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgStatementExpression::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgStatement* 
SgStatementExpression::get_statement () const
   {
     assert (this != NULL);
     return p_statement;
   }

void
SgStatementExpression::set_statement ( SgStatement* statement )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_statement != NULL && statement != NULL && p_statement != statement)
        {
          printf ("Warning: statement = %p overwriting valid pointer p_statement = %p \n",statement,p_statement);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_statement != NULL && statement != NULL && p_statement != statement) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_statement = statement;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4861 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*
SgStatementExpression::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_statement != NULL);

  // DQ (7/21/2006): For now we implement this partially and fix it up later.
  // We might want to store the type explicitly since it might be difficult 
  // to compute for complex sequences of statements.  It appears that the 
  // type is just the type of the expression in the last statement of the block,
  // but it is not clear if it can be more complex than this!

  // The rules are: The last thing in the compound statement should be an expression 
  // followed by a semicolon; the value of this subexpression serves as the value of 
  // the entire construct. (If you use some other kind of statement last within the 
  // braces, the construct has type void, and thus effectively no value.).

  // printf ("SgStatementExpression::get_type() for GNU Statement Expression extension not implemented p_statement = %p = %s \n",p_statement,p_statement->class_name().c_str());
  // ROSE_ASSERT(false);

  // This is the default case (we can look at the last statement of the block later)
  // returnType = SgTypeVoid::createType();

  // DQ (8/6/2006): The rules for the type of a statement expression are that it is the 
  // type of the last expression in the statement list or void if the last statement is 
  // not an expression (expression statement, SgExpressionStatement).
     SgBasicBlock* block = isSgBasicBlock(p_statement);
     ROSE_ASSERT(block != NULL);

     SgStatementPtrList & statementList = block->getStatementList();
     ROSE_ASSERT(statementList.empty() == false);
     SgStatement* lastStatement = *(statementList.rbegin());
     SgExprStatement* expressionStatement = isSgExprStatement(lastStatement);
     if (expressionStatement != NULL)
        {
       // The type of the statement expression is the 
       // SgExpression* expression = expressionStatement->get_the_expr();
          SgExpression* expression = expressionStatement->get_expression();
          ROSE_ASSERT(expression != NULL);
          returnType = expression->get_type();
        }
       else
        {
       // This is the default type if last statement in block is not an expression statement (C++ standard)
          returnType = SgTypeVoid::createType();
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgStatementExpression::get_type() for GNU Statement Expression extension returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStatementExpression::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStatementExpression::variantT() const {
  return V_SgStatementExpression;
}

#if 0
int
SgStatementExpression::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return STMT_EXPR;
   }
#endif

const char*
SgStatementExpression::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStatementExpression";  
   }

std::string
SgStatementExpression::class_name() const
   {
     assert(this != NULL);
     return "SgStatementExpression";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStatementExpression::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStatementExpression::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != STMT_EXPR)
        {
          printf ("Error in SgStatementExpression::error(): SgStatementExpression object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStatementExpression::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == STMT_EXPR);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStatementExpression::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStatementExpression::variant() const \n");
#endif
     assert(this != NULL);
     return STMT_EXPR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStatementExpression* isSgStatementExpression ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStatementExpression*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStatementExpression* isSgStatementExpression ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStatementExpression*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStatementExpression::~SgStatementExpression ()
   {
#if 0
  // debugging information!
     printf ("In SgStatementExpression::~SgStatementExpression (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for statement
     p_statement = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStatementExpression::SgStatementExpression ( Sg_File_Info* startOfConstruct, SgStatement* statement )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgStatementExpression::SgStatementExpression (Sg_File_Info* startOfConstruct, SgStatement* statement) sage_class_name() = %s \n",sage_class_name());
#endif

     p_statement = statement;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(STMT_EXPR == variant());
     post_construction_initialization();

  // Test the isSgStatementExpression() function since it has been problematic
     assert(isSgStatementExpression(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAsmOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgAsmOp::asm_operand_constraint_enum 
SgAsmOp::get_constraint () const
   {
     assert (this != NULL);
     return p_constraint;
   }

void
SgAsmOp::set_constraint ( SgAsmOp::asm_operand_constraint_enum constraint )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_constraint = constraint;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgAsmOp::asm_operand_modifier_enum 
SgAsmOp::get_modifiers () const
   {
     assert (this != NULL);
     return p_modifiers;
   }

void
SgAsmOp::set_modifiers ( SgAsmOp::asm_operand_modifier_enum modifiers )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_modifiers = modifiers;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgAsmOp::get_expression () const
   {
     assert (this != NULL);
     return p_expression;
   }

void
SgAsmOp::set_expression ( SgExpression* expression )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression != NULL && expression != NULL && p_expression != expression)
        {
          printf ("Warning: expression = %p overwriting valid pointer p_expression = %p \n",expression,p_expression);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression != NULL && expression != NULL && p_expression != expression) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression = expression;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4919 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgType*
SgAsmOp::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_expression != NULL);

  // printf ("SgAsmOp::get_type() for asm operand not implemented p_expression = %p = %s \n",p_expression,p_expression->class_name().c_str());
  // ROSE_ASSERT(false);

  // This is the default case (we can look at the last statement of the block later)
     returnType = p_expression->get_type();
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAsmOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAsmOp::variantT() const {
  return V_SgAsmOp;
}

#if 0
int
SgAsmOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ASM_OP;
   }
#endif

const char*
SgAsmOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAsmOp";  
   }

std::string
SgAsmOp::class_name() const
   {
     assert(this != NULL);
     return "SgAsmOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAsmOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAsmOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ASM_OP)
        {
          printf ("Error in SgAsmOp::error(): SgAsmOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAsmOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ASM_OP);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAsmOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAsmOp::variant() const \n");
#endif
     assert(this != NULL);
     return ASM_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAsmOp* isSgAsmOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAsmOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAsmOp* isSgAsmOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAsmOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAsmOp::~SgAsmOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAsmOp::~SgAsmOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_expression;

  // case: not a listType for constraint
     p_constraint = SgAsmOp::e_invalid; // non list case 
  // case: not a listType for modifiers
     p_modifiers = SgAsmOp::e_unknown; // non list case 
  // case: not a listType for expression
     p_expression = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAsmOp::SgAsmOp ( Sg_File_Info* startOfConstruct, SgAsmOp::asm_operand_constraint_enum constraint, SgAsmOp::asm_operand_modifier_enum modifiers, SgExpression* expression )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAsmOp::SgAsmOp (Sg_File_Info* startOfConstruct, SgAsmOp::asm_operand_constraint_enum constraint, SgAsmOp::asm_operand_modifier_enum modifiers, SgExpression* expression) sage_class_name() = %s \n",sage_class_name());
#endif

     p_constraint = constraint;
     p_modifiers = modifiers;
     p_expression = expression;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ASM_OP == variant());
     post_construction_initialization();

  // Test the isSgAsmOp() function since it has been problematic
     assert(isSgAsmOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgInitializer::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgInitializer::get_is_explicit_cast () const
   {
     assert (this != NULL);
     return p_is_explicit_cast;
   }

void
SgInitializer::set_is_explicit_cast ( bool is_explicit_cast )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_is_explicit_cast = is_explicit_cast;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4024 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int SgInitializer::cfgIndexForEnd() const
   {
     return 1;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInitializer::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInitializer::variantT() const {
  return V_SgInitializer;
}

#if 0
int
SgInitializer::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPR_INIT;
   }
#endif

const char*
SgInitializer::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInitializer";  
   }

std::string
SgInitializer::class_name() const
   {
     assert(this != NULL);
     return "SgInitializer";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInitializer::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInitializer::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPR_INIT)
        {
          printf ("Error in SgInitializer::error(): SgInitializer object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInitializer::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPR_INIT);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInitializer::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInitializer::variant() const \n");
#endif
     assert(this != NULL);
     return EXPR_INIT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInitializer* isSgInitializer ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInitializer*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInitializer* isSgInitializer ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInitializer*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInitializer::~SgInitializer ()
   {
#if 0
  // debugging information!
     printf ("In SgInitializer::~SgInitializer (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for is_explicit_cast
     p_is_explicit_cast = true; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInitializer::SgInitializer ( Sg_File_Info* startOfConstruct )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgInitializer::SgInitializer (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_is_explicit_cast = true;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(EXPR_INIT == variant());
     post_construction_initialization();

  // Test the isSgInitializer() function since it has been problematic
     assert(isSgInitializer(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgAggregateInitializer::get_initializers () const
   {
     assert (this != NULL);
     return p_initializers;
   }

void
SgAggregateInitializer::set_initializers ( SgExprListExp* initializers )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_initializers != NULL && initializers != NULL && p_initializers != initializers)
        {
          printf ("Warning: initializers = %p overwriting valid pointer p_initializers = %p \n",initializers,p_initializers);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_initializers != NULL && initializers != NULL && p_initializers != initializers) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_initializers = initializers;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4033 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


std::vector<VirtualCFG::CFGEdge>
SgAggregateInitializer::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_initializers()->cfgForBeginning(), result); break;
       case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
       default: ROSE_ASSERT (!"Bad index for SgAggregateInitializer");
     }

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgAggregateInitializer::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
       case 1: makeEdge(this->get_initializers()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
       default: ROSE_ASSERT (!"Bad index for SgAggregateInitializer");
     }

     return result;
   }

void
SgAggregateInitializer::post_construction_initialization() 
   {
     if (get_initializers())
          get_initializers()->set_parent(this);
   }

#if 1
// DQ: trying to remove the nested iterator class
void
SgAggregateInitializer::append_initializer(SgExpression* what)
   {
     assert(this != NULL);

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
     ROSE_ASSERT(p_initializers != NULL);
     if(!p_initializers)
        {
       // set_initializers(new SgExprListExp(this->get_file_info()));
          SgExprListExp* newArgs = new SgExprListExp ( this->get_file_info() );
          assert(newArgs != NULL);
          newArgs->set_endOfConstruct( this->get_file_info() );
          set_initializers(newArgs);
        }

  // insert_initializer(p_initializers->end(),what);
     p_initializers->append_expression(what);
   }
#endif

#if 0
// DQ: trying to remove the nested iterator class
// SgAggregateInitializer::insert_initializer(const SgExpression::iterator& where, SgExpression* what) 
void
SgAggregateInitializer::insert_initializer(const SgExpressionPtrList::iterator& where, SgExpression* what) 
   {
     p_initializers->insert_expression(where,what);
   }
#endif

//#if 0
SgExpression*
SgAggregateInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_initializers();
        }
       else
          return 0;
   }
//#endif

int
SgAggregateInitializer::replace_expression(SgExpression* o, SgExpression* n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_initializers() == o)
        {
          set_initializers(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          return 0;
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgAggregateInitializer::get_type(void) const
   {
     return SgTypeDefault::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAggregateInitializer::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAggregateInitializer::variantT() const {
  return V_SgAggregateInitializer;
}

#if 0
int
SgAggregateInitializer::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return AGGREGATE_INIT;
   }
#endif

const char*
SgAggregateInitializer::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAggregateInitializer";  
   }

std::string
SgAggregateInitializer::class_name() const
   {
     assert(this != NULL);
     return "SgAggregateInitializer";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAggregateInitializer::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAggregateInitializer::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != AGGREGATE_INIT)
        {
          printf ("Error in SgAggregateInitializer::error(): SgAggregateInitializer object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAggregateInitializer::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == AGGREGATE_INIT);
     return SgInitializer::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAggregateInitializer::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAggregateInitializer::variant() const \n");
#endif
     assert(this != NULL);
     return AGGREGATE_INIT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAggregateInitializer* isSgAggregateInitializer ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAggregateInitializer*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAggregateInitializer* isSgAggregateInitializer ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAggregateInitializer*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAggregateInitializer::~SgAggregateInitializer ()
   {
#if 0
  // debugging information!
     printf ("In SgAggregateInitializer::~SgAggregateInitializer (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for initializers
     p_initializers = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAggregateInitializer::SgAggregateInitializer ( Sg_File_Info* startOfConstruct, SgExprListExp* initializers )
   : SgInitializer(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAggregateInitializer::SgAggregateInitializer (Sg_File_Info* startOfConstruct, SgExprListExp* initializers) sage_class_name() = %s \n",sage_class_name());
#endif

     p_initializers = initializers;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(AGGREGATE_INIT == variant());
     post_construction_initialization();

  // Test the isSgAggregateInitializer() function since it has been problematic
     assert(isSgAggregateInitializer(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgMemberFunctionDeclaration* 
SgConstructorInitializer::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgConstructorInitializer::set_declaration ( SgMemberFunctionDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgConstructorInitializer::get_args () const
   {
     assert (this != NULL);
     return p_args;
   }

void
SgConstructorInitializer::set_args ( SgExprListExp* args )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_args != NULL && args != NULL && p_args != args)
        {
          printf ("Warning: args = %p overwriting valid pointer p_args = %p \n",args,p_args);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_args != NULL && args != NULL && p_args != args) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_args = args;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgConstructorInitializer::get_expression_type () const
   {
     assert (this != NULL);
     return p_expression_type;
   }

void
SgConstructorInitializer::set_expression_type ( SgType* expression_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type)
        {
          printf ("Warning: expression_type = %p overwriting valid pointer p_expression_type = %p \n",expression_type,p_expression_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_expression_type != NULL && expression_type != NULL && p_expression_type != expression_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_expression_type = expression_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgConstructorInitializer::get_need_name () const
   {
     assert (this != NULL);
     return p_need_name;
   }

void
SgConstructorInitializer::set_need_name ( bool need_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_name = need_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgConstructorInitializer::get_need_qualifier () const
   {
     assert (this != NULL);
     return p_need_qualifier;
   }

void
SgConstructorInitializer::set_need_qualifier ( bool need_qualifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_qualifier = need_qualifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgConstructorInitializer::get_need_parenthesis_after_name () const
   {
     assert (this != NULL);
     return p_need_parenthesis_after_name;
   }

void
SgConstructorInitializer::set_need_parenthesis_after_name ( bool need_parenthesis_after_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_need_parenthesis_after_name = need_parenthesis_after_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgConstructorInitializer::get_associated_class_unknown () const
   {
     assert (this != NULL);
     return p_associated_class_unknown;
   }

void
SgConstructorInitializer::set_associated_class_unknown ( bool associated_class_unknown )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_associated_class_unknown = associated_class_unknown;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4139 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


std::vector<VirtualCFG::CFGEdge> SgConstructorInitializer::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_args()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgConstructorInitializer");
    }
    return result;
  }

std::vector<VirtualCFG::CFGEdge> SgConstructorInitializer::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_args()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index for SgConstructorInitializer");
    }
    return result;
  }

SgClassDeclaration*
SgConstructorInitializer::get_class_decl () const
   {
  // This function replaces access function for a data member that is 
  // now removed to permit the class to be more general as required to
  // handle constructors of primative types (e.g. "double* x = new double();")
  // Note that in this case the member function pointer "p_declaration" is NULL.

     SgClassDeclaration* returnType = NULL;

     ROSE_ASSERT(p_expression_type != NULL);
     SgClassType* classType = isSgClassType(p_expression_type);
     if (classType != NULL)
        {
          returnType = isSgClassDeclaration(classType->get_declaration());
          ROSE_ASSERT(returnType != NULL);
        }
       else
        {
       // verify that "p_declaration" is NULL in this case.
          ROSE_ASSERT(p_declaration == NULL);
        }

     return returnType;
   }

void
SgConstructorInitializer::post_construction_initialization()
   {
     ROSE_ASSERT(p_expression_type != NULL);
     if (p_declaration == NULL)
        {
       // This can be NULL for the case of an undeclared constructor.
          ROSE_ASSERT( (isSgClassType(p_expression_type) != NULL) || (p_associated_class_unknown == true) );
        }

  // DQ (11/15/2006): avoid setting newArgs this late in the process.
  // ROSE_ASSERT(p_args != NULL);
     if (p_args == NULL)
        {
       // Build an empty argument list

       // DQ (11/16/2006): Need to handle use in new constructors that don't have fileInfo parameters.
       // p_args = new SgExprListExp(New_File_Info(this));
          if (get_startOfConstruct() != NULL)
             {
               p_args = new SgExprListExp(New_File_Info(this));
               p_args->set_endOfConstruct(New_File_Info(this));
             }
            else
             {
               p_args = new SgExprListExp();
             }
          ROSE_ASSERT(p_args != NULL);
        }

  // if (get_args() != NULL)
  //      get_args()->set_parent(this);
     get_args()->set_parent(this);

     ROSE_ASSERT(p_args != NULL);
   }

#if 0
SgClassDeclaration* 
SgConstructorInitializer::get_class_decl () const
   {
     assert (this != NULL);

  // Look this up from the SgType that we now store explicitly instead of the SgClassDeclaration
  // return p_class_decl;

     SgClassDeclaration* classDeclaration = NULL;
     ROSE_ASSERT(this->get_type() != NULL);
     
     return classDeclaration;
   }
#endif

#if 0
// Need a feature in the grammar code generator to permit 
// user specification of the set_DATA member function
void
SgConstructorInitializer::set_declaration(SgMemberFunctionDeclaration* new_val)
   {
     p_declaration = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_declaration)p_declaration->set_parent(this);
#endif
   }

void
SgConstructorInitializer::set_args(SgExprListExp* new_val)
   {
     p_args = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_args)p_args->set_parent(this);
#endif
   }

void
SgConstructorInitializer::set_class_decl(SgClassDeclaration* new_val)
   {
     p_class_decl = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_class_decl)p_class_decl->set_parent(this);
#endif
   }
#endif

//#if 0
SgExpression*
SgConstructorInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_args();
        }
     return 0;
   }
//#endif

int
SgConstructorInitializer::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_args() == o)
        {
          set_args(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
          return 0;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4781 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (7/19/2006): Function suggested by Jeremiah Willcock and fixed up for general use by DQ
// A better fix (later) will allow us to save the SgType and not use a SgDefaultType for the
// special case below.
SgType*
SgConstructorInitializer::get_type(void) const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (8/5/2006): Now that we store the expression type explicitly this is a simpler function.
     SgType* returnType = p_expression_type;

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgConstructorInitializer::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgConstructorInitializer::variantT() const {
  return V_SgConstructorInitializer;
}

#if 0
int
SgConstructorInitializer::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CONSTRUCTOR_INIT;
   }
#endif

const char*
SgConstructorInitializer::sage_class_name() const
   {
     assert(this != NULL);
     return "SgConstructorInitializer";  
   }

std::string
SgConstructorInitializer::class_name() const
   {
     assert(this != NULL);
     return "SgConstructorInitializer";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgConstructorInitializer::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgConstructorInitializer::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CONSTRUCTOR_INIT)
        {
          printf ("Error in SgConstructorInitializer::error(): SgConstructorInitializer object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgConstructorInitializer::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CONSTRUCTOR_INIT);
     return SgInitializer::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgConstructorInitializer::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgConstructorInitializer::variant() const \n");
#endif
     assert(this != NULL);
     return CONSTRUCTOR_INIT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgConstructorInitializer* isSgConstructorInitializer ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgConstructorInitializer*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgConstructorInitializer* isSgConstructorInitializer ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgConstructorInitializer*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgConstructorInitializer::~SgConstructorInitializer ()
   {
#if 0
  // debugging information!
     printf ("In SgConstructorInitializer::~SgConstructorInitializer (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 
  // case: not a listType for args
     p_args = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 
  // case: not a listType for need_name
     p_need_name = false; // non list case 
  // case: not a listType for need_qualifier
     p_need_qualifier = false; // non list case 
  // case: not a listType for need_parenthesis_after_name
     p_need_parenthesis_after_name = false; // non list case 
  // case: not a listType for associated_class_unknown
     p_associated_class_unknown = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgConstructorInitializer::SgConstructorInitializer ( Sg_File_Info* startOfConstruct, SgMemberFunctionDeclaration* declaration, SgExprListExp* args, SgType* expression_type, bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown )
   : SgInitializer(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgConstructorInitializer::SgConstructorInitializer (Sg_File_Info* startOfConstruct, SgMemberFunctionDeclaration* declaration, SgExprListExp* args, SgType* expression_type, bool need_name, bool need_qualifier, bool need_parenthesis_after_name, bool associated_class_unknown) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;
     p_args = args;
     p_expression_type = expression_type;
     p_need_name = need_name;
     p_need_qualifier = need_qualifier;
     p_need_parenthesis_after_name = need_parenthesis_after_name;
     p_associated_class_unknown = associated_class_unknown;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CONSTRUCTOR_INIT == variant());
     post_construction_initialization();

  // Test the isSgConstructorInitializer() function since it has been problematic
     assert(isSgConstructorInitializer(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgAssignInitializer::get_operand_i () const
   {
     assert (this != NULL);
     return p_operand_i;
   }

void
SgAssignInitializer::set_operand_i ( SgExpression* operand_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_i != NULL && operand_i != NULL && p_operand_i != operand_i)
        {
          printf ("Warning: operand_i = %p overwriting valid pointer p_operand_i = %p \n",operand_i,p_operand_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_i != NULL && operand_i != NULL && p_operand_i != operand_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_i = operand_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 4305 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


  std::vector<VirtualCFG::CFGEdge> SgAssignInitializer::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_operand()->cfgForBeginning(), result); break;
      case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
      default: ROSE_ASSERT (!"Bad index for SgAssignInitializer");
    }
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgAssignInitializer::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    switch (idx) {
      case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
      case 1: makeEdge(this->get_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
      default: ROSE_ASSERT (!"Bad index for SgAssignInitializer");
    }
    return result;
  }

SgExpression*
SgAssignInitializer::get_operand() const
   { return get_operand_i(); }

void
SgAssignInitializer::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_operand() != NULL)
          get_operand()->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type(); 
   }

SgType*
SgAssignInitializer::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgAssignInitializer::get_type(): p_expression_type has been removed, getting the return type from the stored internal operand \n");

     ROSE_ASSERT(get_operand() != NULL);
     SgType* returnType = get_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

void
SgAssignInitializer::set_operand(SgExpression * exp)
   {
     set_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgExpression*
SgAssignInitializer::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_operand();
        } 
       else
          return 0;
   }

int
SgAssignInitializer::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_operand()==o)
        {
          set_operand(n);
          n->set_parent(this);
          return 1;
        }
       else
          return 0;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAssignInitializer::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAssignInitializer::variantT() const {
  return V_SgAssignInitializer;
}

#if 0
int
SgAssignInitializer::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ASSIGN_INIT;
   }
#endif

const char*
SgAssignInitializer::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAssignInitializer";  
   }

std::string
SgAssignInitializer::class_name() const
   {
     assert(this != NULL);
     return "SgAssignInitializer";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAssignInitializer::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAssignInitializer::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ASSIGN_INIT)
        {
          printf ("Error in SgAssignInitializer::error(): SgAssignInitializer object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAssignInitializer::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ASSIGN_INIT);
     return SgInitializer::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAssignInitializer::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAssignInitializer::variant() const \n");
#endif
     assert(this != NULL);
     return ASSIGN_INIT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAssignInitializer* isSgAssignInitializer ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAssignInitializer*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAssignInitializer* isSgAssignInitializer ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAssignInitializer*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAssignInitializer::~SgAssignInitializer ()
   {
#if 0
  // debugging information!
     printf ("In SgAssignInitializer::~SgAssignInitializer (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_i
     p_operand_i = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAssignInitializer::SgAssignInitializer ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgInitializer(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgAssignInitializer::SgAssignInitializer (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_i = operand_i;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ASSIGN_INIT == variant());
     post_construction_initialization();

  // Test the isSgAssignInitializer() function since it has been problematic
     assert(isSgAssignInitializer(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgValueExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgValueExp::get_originalExpressionTree () const
   {
     assert (this != NULL);
     return p_originalExpressionTree;
   }

void
SgValueExp::set_originalExpressionTree ( SgExpression* originalExpressionTree )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_originalExpressionTree != NULL && originalExpressionTree != NULL && p_originalExpressionTree != originalExpressionTree)
        {
          printf ("Warning: originalExpressionTree = %p overwriting valid pointer p_originalExpressionTree = %p \n",originalExpressionTree,p_originalExpressionTree);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_originalExpressionTree != NULL && originalExpressionTree != NULL && p_originalExpressionTree != originalExpressionTree) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_originalExpressionTree = originalExpressionTree;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2165 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


  unsigned int SgValueExp::cfgIndexForEnd() const {
    return 0;
  }

  std::vector<VirtualCFG::CFGEdge> SgValueExp::cfgOutEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    ROSE_ASSERT (idx == 0);
    makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result);
    return result;
  }

  std::vector<VirtualCFG::CFGEdge> SgValueExp::cfgInEdges(unsigned int idx) {
    std::vector<VirtualCFG::CFGEdge> result;
    ROSE_ASSERT (idx == 0);
    makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result);
    return result;
  }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgValueExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgValueExp::variantT() const {
  return V_SgValueExp;
}

#if 0
int
SgValueExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ValueExpTag;
   }
#endif

const char*
SgValueExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgValueExp";  
   }

std::string
SgValueExp::class_name() const
   {
     assert(this != NULL);
     return "SgValueExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgValueExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgValueExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ValueExpTag)
        {
          printf ("Error in SgValueExp::error(): SgValueExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgValueExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ValueExpTag);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgValueExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgValueExp::variant() const \n");
#endif
     assert(this != NULL);
     return ValueExpTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgValueExp* isSgValueExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgValueExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgValueExp* isSgValueExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgValueExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgValueExp::~SgValueExp ()
   {
#if 0
  // debugging information!
     printf ("In SgValueExp::~SgValueExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for originalExpressionTree
     p_originalExpressionTree = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgValueExp::SgValueExp ( Sg_File_Info* startOfConstruct )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgValueExp::SgValueExp (Sg_File_Info* startOfConstruct) sage_class_name() = %s \n",sage_class_name());
#endif

     p_originalExpressionTree = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ValueExpTag == variant());
     post_construction_initialization();

  // Test the isSgValueExp() function since it has been problematic
     assert(isSgValueExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgBoolValExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgBoolValExp::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgBoolValExp::set_value ( int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2187 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgBoolValExp::get_type(void) const
   {
     return SgTypeBool::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBoolValExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBoolValExp::variantT() const {
  return V_SgBoolValExp;
}

#if 0
int
SgBoolValExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BOOL_VAL;
   }
#endif

const char*
SgBoolValExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBoolValExp";  
   }

std::string
SgBoolValExp::class_name() const
   {
     assert(this != NULL);
     return "SgBoolValExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBoolValExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBoolValExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BOOL_VAL)
        {
          printf ("Error in SgBoolValExp::error(): SgBoolValExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBoolValExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BOOL_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBoolValExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBoolValExp::variant() const \n");
#endif
     assert(this != NULL);
     return BOOL_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBoolValExp* isSgBoolValExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBoolValExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBoolValExp* isSgBoolValExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBoolValExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBoolValExp::~SgBoolValExp ()
   {
#if 0
  // debugging information!
     printf ("In SgBoolValExp::~SgBoolValExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBoolValExp::SgBoolValExp ( Sg_File_Info* startOfConstruct, int value )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgBoolValExp::SgBoolValExp (Sg_File_Info* startOfConstruct, int value) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(BOOL_VAL == variant());
     post_construction_initialization();

  // Test the isSgBoolValExp() function since it has been problematic
     assert(isSgBoolValExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgStringVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgStringVal::set_value ( std::string value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgStringVal::get_wcharString () const
   {
     assert (this != NULL);
     return p_wcharString;
   }

void
SgStringVal::set_wcharString ( bool wcharString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_wcharString = wcharString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgStringVal::get_usesSingleQuotes () const
   {
     assert (this != NULL);
     return p_usesSingleQuotes;
   }

void
SgStringVal::set_usesSingleQuotes ( bool usesSingleQuotes )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_usesSingleQuotes = usesSingleQuotes;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2191 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgStringVal::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_value = (char*)0L;
   }

#if 0
SgStringVal::SgStringVal ( Sg_File_Info* file_info, string value )
   : SgValueExp(file_info)
   {
  // Build a custom constructor since we have to make a
  // copy (using strdup(char*)) of the input string (value)

  // Copy the string (else it is lost and not represented in the unparsed output code)
  // p_value = (value == 0)? 0 : strdup(value);
     p_value = value;

  // Test the variant virtual function
     assert(STRING_VAL == variant());
     post_construction_initialization();

  // Test the isSgStringVal() function since it has been problematic
     assert(isSgStringVal(this) != NULL);
   }
#endif

#if 0
SgStringVal::~SgStringVal()
   {
  // Delete the array of char (so use "delete []")
     delete [] p_value;
     p_value = NULL;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgStringVal::get_type(void) const
   {
     return SgTypeString::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgStringVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgStringVal::variantT() const {
  return V_SgStringVal;
}

#if 0
int
SgStringVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return STRING_VAL;
   }
#endif

const char*
SgStringVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgStringVal";  
   }

std::string
SgStringVal::class_name() const
   {
     assert(this != NULL);
     return "SgStringVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgStringVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgStringVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != STRING_VAL)
        {
          printf ("Error in SgStringVal::error(): SgStringVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgStringVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == STRING_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgStringVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgStringVal::variant() const \n");
#endif
     assert(this != NULL);
     return STRING_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgStringVal* isSgStringVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgStringVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgStringVal* isSgStringVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgStringVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgStringVal::~SgStringVal ()
   {
#if 0
  // debugging information!
     printf ("In SgStringVal::~SgStringVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = ""; // non list case 
  // case: not a listType for wcharString
     p_wcharString = false; // non list case 
  // case: not a listType for usesSingleQuotes
     p_usesSingleQuotes = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgStringVal::SgStringVal ( Sg_File_Info* startOfConstruct, std::string value )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgStringVal::SgStringVal (Sg_File_Info* startOfConstruct, std::string value) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_wcharString = false;
     p_usesSingleQuotes = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(STRING_VAL == variant());
     post_construction_initialization();

  // Test the isSgStringVal() function since it has been problematic
     assert(isSgStringVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgShortVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

short 
SgShortVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgShortVal::set_value ( short value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgShortVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgShortVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2232 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgShortVal::get_type(void) const
   {
     return SgTypeShort::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgShortVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgShortVal::variantT() const {
  return V_SgShortVal;
}

#if 0
int
SgShortVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SHORT_VAL;
   }
#endif

const char*
SgShortVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgShortVal";  
   }

std::string
SgShortVal::class_name() const
   {
     assert(this != NULL);
     return "SgShortVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgShortVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgShortVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SHORT_VAL)
        {
          printf ("Error in SgShortVal::error(): SgShortVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgShortVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SHORT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgShortVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgShortVal::variant() const \n");
#endif
     assert(this != NULL);
     return SHORT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgShortVal* isSgShortVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgShortVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgShortVal* isSgShortVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgShortVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgShortVal::~SgShortVal ()
   {
#if 0
  // debugging information!
     printf ("In SgShortVal::~SgShortVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgShortVal::SgShortVal ( Sg_File_Info* startOfConstruct, short value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgShortVal::SgShortVal (Sg_File_Info* startOfConstruct, short value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SHORT_VAL == variant());
     post_construction_initialization();

  // Test the isSgShortVal() function since it has been problematic
     assert(isSgShortVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgCharVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

char 
SgCharVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgCharVal::set_value ( char value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgCharVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgCharVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2236 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgCharVal::get_type(void) const
   {
     return SgTypeChar::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCharVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCharVal::variantT() const {
  return V_SgCharVal;
}

#if 0
int
SgCharVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CHAR_VAL;
   }
#endif

const char*
SgCharVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCharVal";  
   }

std::string
SgCharVal::class_name() const
   {
     assert(this != NULL);
     return "SgCharVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCharVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCharVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CHAR_VAL)
        {
          printf ("Error in SgCharVal::error(): SgCharVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCharVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CHAR_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCharVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCharVal::variant() const \n");
#endif
     assert(this != NULL);
     return CHAR_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCharVal* isSgCharVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCharVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCharVal* isSgCharVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCharVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCharVal::~SgCharVal ()
   {
#if 0
  // debugging information!
     printf ("In SgCharVal::~SgCharVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCharVal::SgCharVal ( Sg_File_Info* startOfConstruct, char value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgCharVal::SgCharVal (Sg_File_Info* startOfConstruct, char value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CHAR_VAL == variant());
     post_construction_initialization();

  // Test the isSgCharVal() function since it has been problematic
     assert(isSgCharVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnsignedCharVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned char 
SgUnsignedCharVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgUnsignedCharVal::set_value ( unsigned char value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgUnsignedCharVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgUnsignedCharVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2240 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgUnsignedCharVal::get_type(void) const
   {
     return SgTypeUnsignedChar::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnsignedCharVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnsignedCharVal::variantT() const {
  return V_SgUnsignedCharVal;
}

#if 0
int
SgUnsignedCharVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNSIGNED_CHAR_VAL;
   }
#endif

const char*
SgUnsignedCharVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedCharVal";  
   }

std::string
SgUnsignedCharVal::class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedCharVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnsignedCharVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnsignedCharVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNSIGNED_CHAR_VAL)
        {
          printf ("Error in SgUnsignedCharVal::error(): SgUnsignedCharVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnsignedCharVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNSIGNED_CHAR_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnsignedCharVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnsignedCharVal::variant() const \n");
#endif
     assert(this != NULL);
     return UNSIGNED_CHAR_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnsignedCharVal* isSgUnsignedCharVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnsignedCharVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnsignedCharVal* isSgUnsignedCharVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnsignedCharVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnsignedCharVal::~SgUnsignedCharVal ()
   {
#if 0
  // debugging information!
     printf ("In SgUnsignedCharVal::~SgUnsignedCharVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnsignedCharVal::SgUnsignedCharVal ( Sg_File_Info* startOfConstruct, unsigned char value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnsignedCharVal::SgUnsignedCharVal (Sg_File_Info* startOfConstruct, unsigned char value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNSIGNED_CHAR_VAL == variant());
     post_construction_initialization();

  // Test the isSgUnsignedCharVal() function since it has been problematic
     assert(isSgUnsignedCharVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned long 
SgWcharVal::get_valueUL () const
   {
     assert (this != NULL);
     return p_valueUL;
   }

void
SgWcharVal::set_valueUL ( unsigned long valueUL )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueUL = valueUL;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgWcharVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgWcharVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2244 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgWcharVal::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

wchar_t
SgWcharVal::get_value() const
   {
     return p_valueUL;
   }

void
SgWcharVal::set_value(wchar_t new_val)
   {
     p_valueUL = new_val;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgWcharVal::get_type(void) const
   {
     return SgTypeWchar::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgWcharVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgWcharVal::variantT() const {
  return V_SgWcharVal;
}

#if 0
int
SgWcharVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return WCHAR_VAL;
   }
#endif

const char*
SgWcharVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgWcharVal";  
   }

std::string
SgWcharVal::class_name() const
   {
     assert(this != NULL);
     return "SgWcharVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgWcharVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgWcharVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != WCHAR_VAL)
        {
          printf ("Error in SgWcharVal::error(): SgWcharVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgWcharVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == WCHAR_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgWcharVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgWcharVal::variant() const \n");
#endif
     assert(this != NULL);
     return WCHAR_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgWcharVal* isSgWcharVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgWcharVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgWcharVal* isSgWcharVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgWcharVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgWcharVal::~SgWcharVal ()
   {
#if 0
  // debugging information!
     printf ("In SgWcharVal::~SgWcharVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for valueUL
     p_valueUL = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgWcharVal::SgWcharVal ( Sg_File_Info* startOfConstruct, unsigned long valueUL, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgWcharVal::SgWcharVal (Sg_File_Info* startOfConstruct, unsigned long valueUL, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_valueUL = valueUL;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(WCHAR_VAL == variant());
     post_construction_initialization();

  // Test the isSgWcharVal() function since it has been problematic
     assert(isSgWcharVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnsignedShortVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned short 
SgUnsignedShortVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgUnsignedShortVal::set_value ( unsigned short value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgUnsignedShortVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgUnsignedShortVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2267 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgUnsignedShortVal::get_type(void) const
   {
     return SgTypeUnsignedShort::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnsignedShortVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnsignedShortVal::variantT() const {
  return V_SgUnsignedShortVal;
}

#if 0
int
SgUnsignedShortVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNSIGNED_SHORT_VAL;
   }
#endif

const char*
SgUnsignedShortVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedShortVal";  
   }

std::string
SgUnsignedShortVal::class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedShortVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnsignedShortVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnsignedShortVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNSIGNED_SHORT_VAL)
        {
          printf ("Error in SgUnsignedShortVal::error(): SgUnsignedShortVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnsignedShortVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNSIGNED_SHORT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnsignedShortVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnsignedShortVal::variant() const \n");
#endif
     assert(this != NULL);
     return UNSIGNED_SHORT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnsignedShortVal* isSgUnsignedShortVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnsignedShortVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnsignedShortVal* isSgUnsignedShortVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnsignedShortVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnsignedShortVal::~SgUnsignedShortVal ()
   {
#if 0
  // debugging information!
     printf ("In SgUnsignedShortVal::~SgUnsignedShortVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnsignedShortVal::SgUnsignedShortVal ( Sg_File_Info* startOfConstruct, unsigned short value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnsignedShortVal::SgUnsignedShortVal (Sg_File_Info* startOfConstruct, unsigned short value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNSIGNED_SHORT_VAL == variant());
     post_construction_initialization();

  // Test the isSgUnsignedShortVal() function since it has been problematic
     assert(isSgUnsignedShortVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgIntVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgIntVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgIntVal::set_value ( int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgIntVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgIntVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2271 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgIntVal::get_type(void) const
   {
     return SgTypeInt::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIntVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIntVal::variantT() const {
  return V_SgIntVal;
}

#if 0
int
SgIntVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INT_VAL;
   }
#endif

const char*
SgIntVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIntVal";  
   }

std::string
SgIntVal::class_name() const
   {
     assert(this != NULL);
     return "SgIntVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIntVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIntVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INT_VAL)
        {
          printf ("Error in SgIntVal::error(): SgIntVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIntVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIntVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIntVal::variant() const \n");
#endif
     assert(this != NULL);
     return INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIntVal* isSgIntVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIntVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIntVal* isSgIntVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIntVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIntVal::~SgIntVal ()
   {
#if 0
  // debugging information!
     printf ("In SgIntVal::~SgIntVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIntVal::SgIntVal ( Sg_File_Info* startOfConstruct, int value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgIntVal::SgIntVal (Sg_File_Info* startOfConstruct, int value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgIntVal() function since it has been problematic
     assert(isSgIntVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgEnumVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgEnumVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgEnumVal::set_value ( int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgEnumDeclaration* 
SgEnumVal::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgEnumVal::set_declaration ( SgEnumDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgEnumVal::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgEnumVal::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgEnumVal::get_requiresNameQualification () const
   {
     assert (this != NULL);
     return p_requiresNameQualification;
   }

void
SgEnumVal::set_requiresNameQualification ( bool requiresNameQualification )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_requiresNameQualification = requiresNameQualification;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2275 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgEnumVal::get_type(void) const
   {
     return SgTypeInt::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEnumVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEnumVal::variantT() const {
  return V_SgEnumVal;
}

#if 0
int
SgEnumVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ENUM_VAL;
   }
#endif

const char*
SgEnumVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEnumVal";  
   }

std::string
SgEnumVal::class_name() const
   {
     assert(this != NULL);
     return "SgEnumVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEnumVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEnumVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ENUM_VAL)
        {
          printf ("Error in SgEnumVal::error(): SgEnumVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEnumVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ENUM_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEnumVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEnumVal::variant() const \n");
#endif
     assert(this != NULL);
     return ENUM_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEnumVal* isSgEnumVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEnumVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEnumVal* isSgEnumVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEnumVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEnumVal::~SgEnumVal ()
   {
#if 0
  // debugging information!
     printf ("In SgEnumVal::~SgEnumVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for declaration
     p_declaration = NULL; // non list case 
  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for requiresNameQualification
     p_requiresNameQualification = false; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEnumVal::SgEnumVal ( Sg_File_Info* startOfConstruct, int value, SgEnumDeclaration* declaration, SgName name )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgEnumVal::SgEnumVal (Sg_File_Info* startOfConstruct, int value, SgEnumDeclaration* declaration, SgName name) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_declaration = declaration;
     p_name = name;
     p_requiresNameQualification = false;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ENUM_VAL == variant());
     post_construction_initialization();

  // Test the isSgEnumVal() function since it has been problematic
     assert(isSgEnumVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnsignedIntVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned int 
SgUnsignedIntVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgUnsignedIntVal::set_value ( unsigned int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgUnsignedIntVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgUnsignedIntVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2279 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgUnsignedIntVal::get_type(void) const
   {
     return SgTypeUnsignedInt::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnsignedIntVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnsignedIntVal::variantT() const {
  return V_SgUnsignedIntVal;
}

#if 0
int
SgUnsignedIntVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNSIGNED_INT_VAL;
   }
#endif

const char*
SgUnsignedIntVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedIntVal";  
   }

std::string
SgUnsignedIntVal::class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedIntVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnsignedIntVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnsignedIntVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNSIGNED_INT_VAL)
        {
          printf ("Error in SgUnsignedIntVal::error(): SgUnsignedIntVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnsignedIntVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNSIGNED_INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnsignedIntVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnsignedIntVal::variant() const \n");
#endif
     assert(this != NULL);
     return UNSIGNED_INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnsignedIntVal* isSgUnsignedIntVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnsignedIntVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnsignedIntVal* isSgUnsignedIntVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnsignedIntVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnsignedIntVal::~SgUnsignedIntVal ()
   {
#if 0
  // debugging information!
     printf ("In SgUnsignedIntVal::~SgUnsignedIntVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnsignedIntVal::SgUnsignedIntVal ( Sg_File_Info* startOfConstruct, unsigned int value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnsignedIntVal::SgUnsignedIntVal (Sg_File_Info* startOfConstruct, unsigned int value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNSIGNED_INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgUnsignedIntVal() function since it has been problematic
     assert(isSgUnsignedIntVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLongIntVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

long int 
SgLongIntVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgLongIntVal::set_value ( long int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgLongIntVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgLongIntVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2283 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgLongIntVal::get_type(void) const
   {
     return SgTypeLong::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLongIntVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLongIntVal::variantT() const {
  return V_SgLongIntVal;
}

#if 0
int
SgLongIntVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LONG_INT_VAL;
   }
#endif

const char*
SgLongIntVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLongIntVal";  
   }

std::string
SgLongIntVal::class_name() const
   {
     assert(this != NULL);
     return "SgLongIntVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLongIntVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLongIntVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LONG_INT_VAL)
        {
          printf ("Error in SgLongIntVal::error(): SgLongIntVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLongIntVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LONG_INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLongIntVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLongIntVal::variant() const \n");
#endif
     assert(this != NULL);
     return LONG_INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLongIntVal* isSgLongIntVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLongIntVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLongIntVal* isSgLongIntVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLongIntVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLongIntVal::~SgLongIntVal ()
   {
#if 0
  // debugging information!
     printf ("In SgLongIntVal::~SgLongIntVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLongIntVal::SgLongIntVal ( Sg_File_Info* startOfConstruct, long int value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgLongIntVal::SgLongIntVal (Sg_File_Info* startOfConstruct, long int value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LONG_INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgLongIntVal() function since it has been problematic
     assert(isSgLongIntVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLongLongIntVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

long long int 
SgLongLongIntVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgLongLongIntVal::set_value ( long long int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgLongLongIntVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgLongLongIntVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2287 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgLongLongIntVal::get_type(void) const
   {
     return SgTypeLong::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLongLongIntVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLongLongIntVal::variantT() const {
  return V_SgLongLongIntVal;
}

#if 0
int
SgLongLongIntVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LONG_LONG_INT_VAL;
   }
#endif

const char*
SgLongLongIntVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLongLongIntVal";  
   }

std::string
SgLongLongIntVal::class_name() const
   {
     assert(this != NULL);
     return "SgLongLongIntVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLongLongIntVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLongLongIntVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LONG_LONG_INT_VAL)
        {
          printf ("Error in SgLongLongIntVal::error(): SgLongLongIntVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLongLongIntVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LONG_LONG_INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLongLongIntVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLongLongIntVal::variant() const \n");
#endif
     assert(this != NULL);
     return LONG_LONG_INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLongLongIntVal* isSgLongLongIntVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLongLongIntVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLongLongIntVal* isSgLongLongIntVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLongLongIntVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLongLongIntVal::~SgLongLongIntVal ()
   {
#if 0
  // debugging information!
     printf ("In SgLongLongIntVal::~SgLongLongIntVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLongLongIntVal::SgLongLongIntVal ( Sg_File_Info* startOfConstruct, long long int value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgLongLongIntVal::SgLongLongIntVal (Sg_File_Info* startOfConstruct, long long int value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LONG_LONG_INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgLongLongIntVal() function since it has been problematic
     assert(isSgLongLongIntVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnsignedLongLongIntVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned long long int 
SgUnsignedLongLongIntVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgUnsignedLongLongIntVal::set_value ( unsigned long long int value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgUnsignedLongLongIntVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgUnsignedLongLongIntVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2291 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgUnsignedLongLongIntVal::get_type(void) const
   {
     return SgTypeUnsignedLongLong::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnsignedLongLongIntVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnsignedLongLongIntVal::variantT() const {
  return V_SgUnsignedLongLongIntVal;
}

#if 0
int
SgUnsignedLongLongIntVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNSIGNED_LONG_LONG_INT_VAL;
   }
#endif

const char*
SgUnsignedLongLongIntVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedLongLongIntVal";  
   }

std::string
SgUnsignedLongLongIntVal::class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedLongLongIntVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnsignedLongLongIntVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnsignedLongLongIntVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNSIGNED_LONG_LONG_INT_VAL)
        {
          printf ("Error in SgUnsignedLongLongIntVal::error(): SgUnsignedLongLongIntVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnsignedLongLongIntVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNSIGNED_LONG_LONG_INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnsignedLongLongIntVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnsignedLongLongIntVal::variant() const \n");
#endif
     assert(this != NULL);
     return UNSIGNED_LONG_LONG_INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnsignedLongLongIntVal* isSgUnsignedLongLongIntVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnsignedLongLongIntVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnsignedLongLongIntVal* isSgUnsignedLongLongIntVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnsignedLongLongIntVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnsignedLongLongIntVal::~SgUnsignedLongLongIntVal ()
   {
#if 0
  // debugging information!
     printf ("In SgUnsignedLongLongIntVal::~SgUnsignedLongLongIntVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnsignedLongLongIntVal::SgUnsignedLongLongIntVal ( Sg_File_Info* startOfConstruct, unsigned long long int value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnsignedLongLongIntVal::SgUnsignedLongLongIntVal (Sg_File_Info* startOfConstruct, unsigned long long int value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNSIGNED_LONG_LONG_INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgUnsignedLongLongIntVal() function since it has been problematic
     assert(isSgUnsignedLongLongIntVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnsignedLongVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned long 
SgUnsignedLongVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgUnsignedLongVal::set_value ( unsigned long value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgUnsignedLongVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgUnsignedLongVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2295 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgUnsignedLongVal::get_type(void) const
   {
     return SgTypeUnsignedLong::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnsignedLongVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnsignedLongVal::variantT() const {
  return V_SgUnsignedLongVal;
}

#if 0
int
SgUnsignedLongVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNSIGNED_LONG_INT_VAL;
   }
#endif

const char*
SgUnsignedLongVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedLongVal";  
   }

std::string
SgUnsignedLongVal::class_name() const
   {
     assert(this != NULL);
     return "SgUnsignedLongVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnsignedLongVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnsignedLongVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNSIGNED_LONG_INT_VAL)
        {
          printf ("Error in SgUnsignedLongVal::error(): SgUnsignedLongVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnsignedLongVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNSIGNED_LONG_INT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnsignedLongVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnsignedLongVal::variant() const \n");
#endif
     assert(this != NULL);
     return UNSIGNED_LONG_INT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnsignedLongVal* isSgUnsignedLongVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnsignedLongVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnsignedLongVal* isSgUnsignedLongVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnsignedLongVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnsignedLongVal::~SgUnsignedLongVal ()
   {
#if 0
  // debugging information!
     printf ("In SgUnsignedLongVal::~SgUnsignedLongVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnsignedLongVal::SgUnsignedLongVal ( Sg_File_Info* startOfConstruct, unsigned long value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnsignedLongVal::SgUnsignedLongVal (Sg_File_Info* startOfConstruct, unsigned long value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNSIGNED_LONG_INT_VAL == variant());
     post_construction_initialization();

  // Test the isSgUnsignedLongVal() function since it has been problematic
     assert(isSgUnsignedLongVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgFloatVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

float 
SgFloatVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgFloatVal::set_value ( float value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgFloatVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgFloatVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2299 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgFloatVal::get_type(void) const
   {
     return SgTypeFloat::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFloatVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFloatVal::variantT() const {
  return V_SgFloatVal;
}

#if 0
int
SgFloatVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FLOAT_VAL;
   }
#endif

const char*
SgFloatVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFloatVal";  
   }

std::string
SgFloatVal::class_name() const
   {
     assert(this != NULL);
     return "SgFloatVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFloatVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFloatVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FLOAT_VAL)
        {
          printf ("Error in SgFloatVal::error(): SgFloatVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFloatVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FLOAT_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFloatVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFloatVal::variant() const \n");
#endif
     assert(this != NULL);
     return FLOAT_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFloatVal* isSgFloatVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFloatVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFloatVal* isSgFloatVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFloatVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFloatVal::~SgFloatVal ()
   {
#if 0
  // debugging information!
     printf ("In SgFloatVal::~SgFloatVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0.0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFloatVal::SgFloatVal ( Sg_File_Info* startOfConstruct, float value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgFloatVal::SgFloatVal (Sg_File_Info* startOfConstruct, float value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FLOAT_VAL == variant());
     post_construction_initialization();

  // Test the isSgFloatVal() function since it has been problematic
     assert(isSgFloatVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgDoubleVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

double 
SgDoubleVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgDoubleVal::set_value ( double value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgDoubleVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgDoubleVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2303 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgDoubleVal::get_type(void) const
   {
     return SgTypeDouble::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDoubleVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDoubleVal::variantT() const {
  return V_SgDoubleVal;
}

#if 0
int
SgDoubleVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DOUBLE_VAL;
   }
#endif

const char*
SgDoubleVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDoubleVal";  
   }

std::string
SgDoubleVal::class_name() const
   {
     assert(this != NULL);
     return "SgDoubleVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDoubleVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDoubleVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DOUBLE_VAL)
        {
          printf ("Error in SgDoubleVal::error(): SgDoubleVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDoubleVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DOUBLE_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDoubleVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDoubleVal::variant() const \n");
#endif
     assert(this != NULL);
     return DOUBLE_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDoubleVal* isSgDoubleVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDoubleVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDoubleVal* isSgDoubleVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDoubleVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDoubleVal::~SgDoubleVal ()
   {
#if 0
  // debugging information!
     printf ("In SgDoubleVal::~SgDoubleVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0.0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDoubleVal::SgDoubleVal ( Sg_File_Info* startOfConstruct, double value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgDoubleVal::SgDoubleVal (Sg_File_Info* startOfConstruct, double value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DOUBLE_VAL == variant());
     post_construction_initialization();

  // Test the isSgDoubleVal() function since it has been problematic
     assert(isSgDoubleVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLongDoubleVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

long double 
SgLongDoubleVal::get_value () const
   {
     assert (this != NULL);
     return p_value;
   }

void
SgLongDoubleVal::set_value ( long double value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_value = value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgLongDoubleVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgLongDoubleVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2307 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4735 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgLongDoubleVal::get_type(void) const
   {
     return SgTypeLongDouble::createType();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLongDoubleVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLongDoubleVal::variantT() const {
  return V_SgLongDoubleVal;
}

#if 0
int
SgLongDoubleVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LONG_DOUBLE_VAL;
   }
#endif

const char*
SgLongDoubleVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLongDoubleVal";  
   }

std::string
SgLongDoubleVal::class_name() const
   {
     assert(this != NULL);
     return "SgLongDoubleVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLongDoubleVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLongDoubleVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LONG_DOUBLE_VAL)
        {
          printf ("Error in SgLongDoubleVal::error(): SgLongDoubleVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLongDoubleVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LONG_DOUBLE_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLongDoubleVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLongDoubleVal::variant() const \n");
#endif
     assert(this != NULL);
     return LONG_DOUBLE_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLongDoubleVal* isSgLongDoubleVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLongDoubleVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLongDoubleVal* isSgLongDoubleVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLongDoubleVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLongDoubleVal::~SgLongDoubleVal ()
   {
#if 0
  // debugging information!
     printf ("In SgLongDoubleVal::~SgLongDoubleVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for value
     p_value = 0.0; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLongDoubleVal::SgLongDoubleVal ( Sg_File_Info* startOfConstruct, long double value, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgLongDoubleVal::SgLongDoubleVal (Sg_File_Info* startOfConstruct, long double value, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_value = value;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LONG_DOUBLE_VAL == variant());
     post_construction_initialization();

  // Test the isSgLongDoubleVal() function since it has been problematic
     assert(isSgLongDoubleVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgComplexVal::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

long double 
SgComplexVal::get_real_value () const
   {
     assert (this != NULL);
     return p_real_value;
   }

void
SgComplexVal::set_real_value ( long double real_value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_real_value = real_value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

long double 
SgComplexVal::get_imaginary_value () const
   {
     assert (this != NULL);
     return p_imaginary_value;
   }

void
SgComplexVal::set_imaginary_value ( long double imaginary_value )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_imaginary_value = imaginary_value;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgComplexVal::get_precisionType () const
   {
     assert (this != NULL);
     return p_precisionType;
   }

void
SgComplexVal::set_precisionType ( SgType* precisionType )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_precisionType != NULL && precisionType != NULL && p_precisionType != precisionType)
        {
          printf ("Warning: precisionType = %p overwriting valid pointer p_precisionType = %p \n",precisionType,p_precisionType);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_precisionType != NULL && precisionType != NULL && p_precisionType != precisionType) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_precisionType = precisionType;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

std::string 
SgComplexVal::get_valueString () const
   {
     assert (this != NULL);
     return p_valueString;
   }

void
SgComplexVal::set_valueString ( std::string valueString )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_valueString = valueString;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2311 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4745 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgComplexVal::get_type(void) const
   {
     SgTypeComplex::floating_point_precision_enum precision = SgTypeComplex::e_errorPrecision;

  // Use the stored SgType to return the correct SgTypeComplex using the correct precision.
     ROSE_ASSERT(p_precisionType != NULL);
     switch(p_precisionType->variantT())
        {
          case V_SgTypeFloat:
               precision = SgTypeComplex::e_floatPrecision;
               break;
          case V_SgTypeDouble:
               precision = SgTypeComplex::e_doublePrecision;
               break;
          case V_SgTypeLongDouble:
               precision = SgTypeComplex::e_longDoublePrecision;
               break;

          default:
             {
               printf ("Error, default reached precisionType = %s \n",p_precisionType->class_name().c_str());
               ROSE_ASSERT(false);
               break;
             }
        }

  // returns a shared SgTypeComplex type
     return SgTypeComplex::createType(precision);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgComplexVal::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgComplexVal::variantT() const {
  return V_SgComplexVal;
}

#if 0
int
SgComplexVal::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return COMPLEX_VAL;
   }
#endif

const char*
SgComplexVal::sage_class_name() const
   {
     assert(this != NULL);
     return "SgComplexVal";  
   }

std::string
SgComplexVal::class_name() const
   {
     assert(this != NULL);
     return "SgComplexVal";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgComplexVal::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgComplexVal::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != COMPLEX_VAL)
        {
          printf ("Error in SgComplexVal::error(): SgComplexVal object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgComplexVal::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == COMPLEX_VAL);
     return SgValueExp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgComplexVal::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgComplexVal::variant() const \n");
#endif
     assert(this != NULL);
     return COMPLEX_VAL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgComplexVal* isSgComplexVal ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgComplexVal*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgComplexVal* isSgComplexVal ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgComplexVal*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgComplexVal::~SgComplexVal ()
   {
#if 0
  // debugging information!
     printf ("In SgComplexVal::~SgComplexVal (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for real_value
     p_real_value = 0.0; // non list case 
  // case: not a listType for imaginary_value
     p_imaginary_value = 0.0; // non list case 
  // case: not a listType for precisionType
     p_precisionType = NULL; // non list case 
  // case: not a listType for valueString
     p_valueString = ""; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgComplexVal::SgComplexVal ( Sg_File_Info* startOfConstruct, long double real_value, long double imaginary_value, SgType* precisionType, std::string valueString )
   : SgValueExp(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgComplexVal::SgComplexVal (Sg_File_Info* startOfConstruct, long double real_value, long double imaginary_value, SgType* precisionType, std::string valueString) sage_class_name() = %s \n",sage_class_name());
#endif

     p_real_value = real_value;
     p_imaginary_value = imaginary_value;
     p_precisionType = precisionType;
     p_valueString = valueString;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(COMPLEX_VAL == variant());
     post_construction_initialization();

  // Test the isSgComplexVal() function since it has been problematic
     assert(isSgComplexVal(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgBinaryOp::get_lhs_operand_i () const
   {
     assert (this != NULL);
     return p_lhs_operand_i;
   }

void
SgBinaryOp::set_lhs_operand_i ( SgExpression* lhs_operand_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_lhs_operand_i != NULL && lhs_operand_i != NULL && p_lhs_operand_i != lhs_operand_i)
        {
          printf ("Warning: lhs_operand_i = %p overwriting valid pointer p_lhs_operand_i = %p \n",lhs_operand_i,p_lhs_operand_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_lhs_operand_i != NULL && lhs_operand_i != NULL && p_lhs_operand_i != lhs_operand_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_lhs_operand_i = lhs_operand_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgBinaryOp::get_rhs_operand_i () const
   {
     assert (this != NULL);
     return p_rhs_operand_i;
   }

void
SgBinaryOp::set_rhs_operand_i ( SgExpression* rhs_operand_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_rhs_operand_i != NULL && rhs_operand_i != NULL && p_rhs_operand_i != rhs_operand_i)
        {
          printf ("Warning: rhs_operand_i = %p overwriting valid pointer p_rhs_operand_i = %p \n",rhs_operand_i,p_rhs_operand_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_rhs_operand_i != NULL && rhs_operand_i != NULL && p_rhs_operand_i != rhs_operand_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_rhs_operand_i = rhs_operand_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1425 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

unsigned int SgBinaryOp::cfgIndexForEnd() const
   {
     return 2;
   }

std::vector<VirtualCFG::CFGEdge>
SgBinaryOp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_lhs_operand()->cfgForBeginning(), result); break;
          case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_rhs_operand()->cfgForBeginning(), result); break;
          case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
          default: ROSE_ASSERT (!"Bad index for SgBinaryOp");
        }

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgBinaryOp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
          case 1: makeEdge(this->get_lhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
          case 2: makeEdge(this->get_rhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
          default: ROSE_ASSERT (!"Bad index for SgBinaryOp");
        }

     return result;
   }

void
SgBinaryOp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_lhs_operand())
          get_lhs_operand()->set_parent(this);
     if (get_rhs_operand())
          get_rhs_operand()->set_parent(this);
// #endif
   }

SgExpression*
SgBinaryOp::get_lhs_operand() const
   { return get_lhs_operand_i(); }

void
SgBinaryOp::set_lhs_operand(SgExpression * exp)
   {
     set_lhs_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp) 
        exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

int
SgBinaryOp::length() const
   {
     return 2;
   }

// I don't think this is used (so exclude it until we clearly need it)!
bool
SgBinaryOp::empty() const
   {
     return false;  // return 0;
   }

SgExpression*
SgBinaryOp::get_rhs_operand() const
   { return get_rhs_operand_i(); }

void
SgBinaryOp::set_rhs_operand(SgExpression * exp)
   {
     set_rhs_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp) 
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
SgBinaryOp::get_type() const
   {
  // We have to select one, so for now chose the lhs, it might be that 
  // we have to explicitly store the return type of binary operators.

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* lhsType = get_lhs_operand()->get_type();
     ROSE_ASSERT(lhsType != NULL);

     ROSE_ASSERT(get_rhs_operand()->get_type() != NULL);

  // DQ (9/27/2006): Ideally, this should not be set, though sometimes it is.
  // ROSE_ASSERT(p_expression_type != NULL);
     string expression_type_name = "NULL";
     if (p_expression_type != NULL)
        {
          expression_type_name = p_expression_type->class_name();
          printf ("Found an case where SgBinaryOp::p_expression_type != NULL on %s expression_type_name = %s \n",
               this->class_name().c_str(),expression_type_name.c_str());
        }

     return lhsType;
   }

SgExpression*
SgBinaryOp::get_next(int& n) const
   {
     if(n==0)
        {
          n++; 
          return get_lhs_operand();
        }
       else
        {
          if (n==1)
             {
               n++;
               return get_rhs_operand();
             }
        }

     return 0;
   }

int
SgBinaryOp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_lhs_operand() == o)
        {
          set_lhs_operand(n);
          return 1;
        }
       else
          if (get_rhs_operand() == o)
             {
               set_rhs_operand(n);
               return 1;  
             } 
            else 
             {
               printf ("Warning: inside of SgBinaryOp::replace_expression original SgExpression unidentified \n");
               return 0;
             }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBinaryOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBinaryOp::variantT() const {
  return V_SgBinaryOp;
}

#if 0
int
SgBinaryOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BINARY_EXPRESSION;
   }
#endif

const char*
SgBinaryOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBinaryOp";  
   }

std::string
SgBinaryOp::class_name() const
   {
     assert(this != NULL);
     return "SgBinaryOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBinaryOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBinaryOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BINARY_EXPRESSION)
        {
          printf ("Error in SgBinaryOp::error(): SgBinaryOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBinaryOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BINARY_EXPRESSION);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBinaryOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBinaryOp::variant() const \n");
#endif
     assert(this != NULL);
     return BINARY_EXPRESSION;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBinaryOp* isSgBinaryOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBinaryOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBinaryOp* isSgBinaryOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBinaryOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBinaryOp::~SgBinaryOp ()
   {
#if 0
  // debugging information!
     printf ("In SgBinaryOp::~SgBinaryOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for lhs_operand_i
     p_lhs_operand_i = NULL; // non list case 
  // case: not a listType for rhs_operand_i
     p_rhs_operand_i = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBinaryOp::SgBinaryOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgBinaryOp::SgBinaryOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_lhs_operand_i = lhs_operand_i;
     p_rhs_operand_i = rhs_operand_i;
     p_expression_type = expression_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(BINARY_EXPRESSION == variant());
     post_construction_initialization();

  // Test the isSgBinaryOp() function since it has been problematic
     assert(isSgBinaryOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgArrowExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2495 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgArrowExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgArrowExp, the type is the type of the rhs operand (e.g. "Aptr->x" where "x" is the data member of the pointer to class "A").

  // printf ("SgArrowExp::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* returnType = get_rhs_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgArrowExp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgArrowExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgArrowExp::variantT() const {
  return V_SgArrowExp;
}

#if 0
int
SgArrowExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return POINTST_OP;
   }
#endif

const char*
SgArrowExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgArrowExp";  
   }

std::string
SgArrowExp::class_name() const
   {
     assert(this != NULL);
     return "SgArrowExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgArrowExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgArrowExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != POINTST_OP)
        {
          printf ("Error in SgArrowExp::error(): SgArrowExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgArrowExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == POINTST_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgArrowExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgArrowExp::variant() const \n");
#endif
     assert(this != NULL);
     return POINTST_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgArrowExp* isSgArrowExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgArrowExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgArrowExp* isSgArrowExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgArrowExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgArrowExp::~SgArrowExp ()
   {
#if 0
  // debugging information!
     printf ("In SgArrowExp::~SgArrowExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgArrowExp::SgArrowExp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgArrowExp::SgArrowExp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(POINTST_OP == variant());
     post_construction_initialization();

  // Test the isSgArrowExp() function since it has been problematic
     assert(isSgArrowExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgDotExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2521 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgDotExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgDotExp, the type is the type of the rhs operand (e.g. "A.x" where "x" is the data member of the class "A").

  // printf ("SgDotExp::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* returnType = get_rhs_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgDotExp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDotExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDotExp::variantT() const {
  return V_SgDotExp;
}

#if 0
int
SgDotExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return RECORD_REF;
   }
#endif

const char*
SgDotExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDotExp";  
   }

std::string
SgDotExp::class_name() const
   {
     assert(this != NULL);
     return "SgDotExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDotExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDotExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != RECORD_REF)
        {
          printf ("Error in SgDotExp::error(): SgDotExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDotExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == RECORD_REF);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDotExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDotExp::variant() const \n");
#endif
     assert(this != NULL);
     return RECORD_REF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDotExp* isSgDotExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDotExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDotExp* isSgDotExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDotExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDotExp::~SgDotExp ()
   {
#if 0
  // debugging information!
     printf ("In SgDotExp::~SgDotExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDotExp::SgDotExp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgDotExp::SgDotExp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(RECORD_REF == variant());
     post_construction_initialization();

  // Test the isSgDotExp() function since it has been problematic
     assert(isSgDotExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgDotStarOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2547 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgDotStarOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgDotStarExp, the type is the type of the rhs operand (e.g. "A.*x" where "x" is a member function pointer of the class "A").

  // Comment from Jeremiah (7/20/2006)
  // In SOURCE_DOT_STAR_OPERATOR_EXPRESSION's get_type() method, the expression type is computed as the type of the RHS operand.  
  // This is most likely a pointer to member type, though, not the type of the underlying member (assuming the types of 
  // pointer-to-member expressions are set correctly).  The same issue applies to SOURCE_ARROW_STAR_OPERATOR_EXPRESSION.

  // printf ("SgDotStarOp::get_type(): p_expression_type has been removed, we have to compute the appropriate type from rhs = %s \n",get_rhs_operand()->class_name().c_str());

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* someType = get_rhs_operand()->get_type();

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType != NULL);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have 
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
       // DQ (7/31/2006): Added a new case so now this code is no longer a clone of what is used in SgPointerDerefExp and SgPntrArrRefExp.
          case V_SgPointerMemberType:
             {
               SgPointerMemberType* pointerMemberType = isSgPointerMemberType(someType);
               returnType = pointerMemberType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

          default:
             {
               printf ("Error: default reached in In SgDotStarOp::get_type() someType = %s \n",someType->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgDotStarOp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDotStarOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDotStarOp::variantT() const {
  return V_SgDotStarOp;
}

#if 0
int
SgDotStarOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DOTSTAR_OP;
   }
#endif

const char*
SgDotStarOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDotStarOp";  
   }

std::string
SgDotStarOp::class_name() const
   {
     assert(this != NULL);
     return "SgDotStarOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDotStarOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDotStarOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DOTSTAR_OP)
        {
          printf ("Error in SgDotStarOp::error(): SgDotStarOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDotStarOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DOTSTAR_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDotStarOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDotStarOp::variant() const \n");
#endif
     assert(this != NULL);
     return DOTSTAR_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDotStarOp* isSgDotStarOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDotStarOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDotStarOp* isSgDotStarOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDotStarOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDotStarOp::~SgDotStarOp ()
   {
#if 0
  // debugging information!
     printf ("In SgDotStarOp::~SgDotStarOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDotStarOp::SgDotStarOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgDotStarOp::SgDotStarOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DOTSTAR_OP == variant());
     post_construction_initialization();

  // Test the isSgDotStarOp() function since it has been problematic
     assert(isSgDotStarOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgArrowStarOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2631 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgArrowStarOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // For the SgArrowStarExp, the type is the type of the rhs operand (e.g. "A->*x" where "x" is a member function pointer of the pointer to the class "A").

  // printf ("SgArrowStarOp::get_type(): p_expression_type has been removed, we have to compute the appropriate type from rhs = %s \n",get_rhs_operand()->class_name().c_str());

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* someType = get_rhs_operand()->get_type();

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType != NULL);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have 
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
       // DQ (7/31/2006): Added a new case so now this code is no longer a clone of what is used in SgPointerDerefExp and SgPntrArrRefExp.
          case V_SgPointerMemberType:
             {
               SgPointerMemberType* pointerMemberType = isSgPointerMemberType(someType);
               returnType = pointerMemberType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

          default:
             {
               printf ("Error: default reached in In SgArrowStarOp::get_type() someType = %s \n",someType->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     ROSE_ASSERT(returnType != NULL);

  // printf ("SgArrowStarOp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgArrowStarOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgArrowStarOp::variantT() const {
  return V_SgArrowStarOp;
}

#if 0
int
SgArrowStarOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ARROWSTAR_OP;
   }
#endif

const char*
SgArrowStarOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgArrowStarOp";  
   }

std::string
SgArrowStarOp::class_name() const
   {
     assert(this != NULL);
     return "SgArrowStarOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgArrowStarOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgArrowStarOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ARROWSTAR_OP)
        {
          printf ("Error in SgArrowStarOp::error(): SgArrowStarOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgArrowStarOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ARROWSTAR_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgArrowStarOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgArrowStarOp::variant() const \n");
#endif
     assert(this != NULL);
     return ARROWSTAR_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgArrowStarOp* isSgArrowStarOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgArrowStarOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgArrowStarOp* isSgArrowStarOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgArrowStarOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgArrowStarOp::~SgArrowStarOp ()
   {
#if 0
  // debugging information!
     printf ("In SgArrowStarOp::~SgArrowStarOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgArrowStarOp::SgArrowStarOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgArrowStarOp::SgArrowStarOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ARROWSTAR_OP == variant());
     post_construction_initialization();

  // Test the isSgArrowStarOp() function since it has been problematic
     assert(isSgArrowStarOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgEqualityOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2727 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgEqualityOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEqualityOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEqualityOp::variantT() const {
  return V_SgEqualityOp;
}

#if 0
int
SgEqualityOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EQ_OP;
   }
#endif

const char*
SgEqualityOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEqualityOp";  
   }

std::string
SgEqualityOp::class_name() const
   {
     assert(this != NULL);
     return "SgEqualityOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEqualityOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEqualityOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EQ_OP)
        {
          printf ("Error in SgEqualityOp::error(): SgEqualityOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEqualityOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EQ_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEqualityOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEqualityOp::variant() const \n");
#endif
     assert(this != NULL);
     return EQ_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEqualityOp* isSgEqualityOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEqualityOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEqualityOp* isSgEqualityOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEqualityOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEqualityOp::~SgEqualityOp ()
   {
#if 0
  // debugging information!
     printf ("In SgEqualityOp::~SgEqualityOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEqualityOp::SgEqualityOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgEqualityOp::SgEqualityOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(EQ_OP == variant());
     post_construction_initialization();

  // Test the isSgEqualityOp() function since it has been problematic
     assert(isSgEqualityOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLessThanOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2732 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgLessThanOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLessThanOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLessThanOp::variantT() const {
  return V_SgLessThanOp;
}

#if 0
int
SgLessThanOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LT_OP;
   }
#endif

const char*
SgLessThanOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLessThanOp";  
   }

std::string
SgLessThanOp::class_name() const
   {
     assert(this != NULL);
     return "SgLessThanOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLessThanOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLessThanOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LT_OP)
        {
          printf ("Error in SgLessThanOp::error(): SgLessThanOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLessThanOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLessThanOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLessThanOp::variant() const \n");
#endif
     assert(this != NULL);
     return LT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLessThanOp* isSgLessThanOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLessThanOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLessThanOp* isSgLessThanOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLessThanOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLessThanOp::~SgLessThanOp ()
   {
#if 0
  // debugging information!
     printf ("In SgLessThanOp::~SgLessThanOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLessThanOp::SgLessThanOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgLessThanOp::SgLessThanOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(LT_OP == variant());
     post_construction_initialization();

  // Test the isSgLessThanOp() function since it has been problematic
     assert(isSgLessThanOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgGreaterThanOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2737 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgGreaterThanOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGreaterThanOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGreaterThanOp::variantT() const {
  return V_SgGreaterThanOp;
}

#if 0
int
SgGreaterThanOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GT_OP;
   }
#endif

const char*
SgGreaterThanOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGreaterThanOp";  
   }

std::string
SgGreaterThanOp::class_name() const
   {
     assert(this != NULL);
     return "SgGreaterThanOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGreaterThanOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGreaterThanOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GT_OP)
        {
          printf ("Error in SgGreaterThanOp::error(): SgGreaterThanOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGreaterThanOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGreaterThanOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGreaterThanOp::variant() const \n");
#endif
     assert(this != NULL);
     return GT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGreaterThanOp* isSgGreaterThanOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGreaterThanOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGreaterThanOp* isSgGreaterThanOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGreaterThanOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGreaterThanOp::~SgGreaterThanOp ()
   {
#if 0
  // debugging information!
     printf ("In SgGreaterThanOp::~SgGreaterThanOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGreaterThanOp::SgGreaterThanOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgGreaterThanOp::SgGreaterThanOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(GT_OP == variant());
     post_construction_initialization();

  // Test the isSgGreaterThanOp() function since it has been problematic
     assert(isSgGreaterThanOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgNotEqualOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2742 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgNotEqualOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNotEqualOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNotEqualOp::variantT() const {
  return V_SgNotEqualOp;
}

#if 0
int
SgNotEqualOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NE_OP;
   }
#endif

const char*
SgNotEqualOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNotEqualOp";  
   }

std::string
SgNotEqualOp::class_name() const
   {
     assert(this != NULL);
     return "SgNotEqualOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNotEqualOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNotEqualOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NE_OP)
        {
          printf ("Error in SgNotEqualOp::error(): SgNotEqualOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNotEqualOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NE_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNotEqualOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNotEqualOp::variant() const \n");
#endif
     assert(this != NULL);
     return NE_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNotEqualOp* isSgNotEqualOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNotEqualOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNotEqualOp* isSgNotEqualOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNotEqualOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNotEqualOp::~SgNotEqualOp ()
   {
#if 0
  // debugging information!
     printf ("In SgNotEqualOp::~SgNotEqualOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNotEqualOp::SgNotEqualOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgNotEqualOp::SgNotEqualOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(NE_OP == variant());
     post_construction_initialization();

  // Test the isSgNotEqualOp() function since it has been problematic
     assert(isSgNotEqualOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLessOrEqualOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2747 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgLessOrEqualOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLessOrEqualOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLessOrEqualOp::variantT() const {
  return V_SgLessOrEqualOp;
}

#if 0
int
SgLessOrEqualOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LE_OP;
   }
#endif

const char*
SgLessOrEqualOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLessOrEqualOp";  
   }

std::string
SgLessOrEqualOp::class_name() const
   {
     assert(this != NULL);
     return "SgLessOrEqualOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLessOrEqualOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLessOrEqualOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LE_OP)
        {
          printf ("Error in SgLessOrEqualOp::error(): SgLessOrEqualOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLessOrEqualOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LE_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLessOrEqualOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLessOrEqualOp::variant() const \n");
#endif
     assert(this != NULL);
     return LE_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLessOrEqualOp* isSgLessOrEqualOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLessOrEqualOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLessOrEqualOp* isSgLessOrEqualOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLessOrEqualOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLessOrEqualOp::~SgLessOrEqualOp ()
   {
#if 0
  // debugging information!
     printf ("In SgLessOrEqualOp::~SgLessOrEqualOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLessOrEqualOp::SgLessOrEqualOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgLessOrEqualOp::SgLessOrEqualOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(LE_OP == variant());
     post_construction_initialization();

  // Test the isSgLessOrEqualOp() function since it has been problematic
     assert(isSgLessOrEqualOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgGreaterOrEqualOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2752 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgGreaterOrEqualOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgGreaterOrEqualOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgGreaterOrEqualOp::variantT() const {
  return V_SgGreaterOrEqualOp;
}

#if 0
int
SgGreaterOrEqualOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return GE_OP;
   }
#endif

const char*
SgGreaterOrEqualOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgGreaterOrEqualOp";  
   }

std::string
SgGreaterOrEqualOp::class_name() const
   {
     assert(this != NULL);
     return "SgGreaterOrEqualOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgGreaterOrEqualOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgGreaterOrEqualOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != GE_OP)
        {
          printf ("Error in SgGreaterOrEqualOp::error(): SgGreaterOrEqualOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgGreaterOrEqualOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == GE_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgGreaterOrEqualOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgGreaterOrEqualOp::variant() const \n");
#endif
     assert(this != NULL);
     return GE_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgGreaterOrEqualOp* isSgGreaterOrEqualOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgGreaterOrEqualOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgGreaterOrEqualOp* isSgGreaterOrEqualOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgGreaterOrEqualOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgGreaterOrEqualOp::~SgGreaterOrEqualOp ()
   {
#if 0
  // debugging information!
     printf ("In SgGreaterOrEqualOp::~SgGreaterOrEqualOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgGreaterOrEqualOp::SgGreaterOrEqualOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgGreaterOrEqualOp::SgGreaterOrEqualOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(GE_OP == variant());
     post_construction_initialization();

  // Test the isSgGreaterOrEqualOp() function since it has been problematic
     assert(isSgGreaterOrEqualOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAddOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2761 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgAddOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAddOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAddOp::variantT() const {
  return V_SgAddOp;
}

#if 0
int
SgAddOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ADD_OP;
   }
#endif

const char*
SgAddOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAddOp";  
   }

std::string
SgAddOp::class_name() const
   {
     assert(this != NULL);
     return "SgAddOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAddOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAddOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ADD_OP)
        {
          printf ("Error in SgAddOp::error(): SgAddOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAddOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ADD_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAddOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAddOp::variant() const \n");
#endif
     assert(this != NULL);
     return ADD_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAddOp* isSgAddOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAddOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAddOp* isSgAddOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAddOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAddOp::~SgAddOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAddOp::~SgAddOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAddOp::SgAddOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgAddOp::SgAddOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ADD_OP == variant());
     post_construction_initialization();

  // Test the isSgAddOp() function since it has been problematic
     assert(isSgAddOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgSubtractOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2765 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgSubtractOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSubtractOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSubtractOp::variantT() const {
  return V_SgSubtractOp;
}

#if 0
int
SgSubtractOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SUBT_OP;
   }
#endif

const char*
SgSubtractOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSubtractOp";  
   }

std::string
SgSubtractOp::class_name() const
   {
     assert(this != NULL);
     return "SgSubtractOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSubtractOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSubtractOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SUBT_OP)
        {
          printf ("Error in SgSubtractOp::error(): SgSubtractOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSubtractOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SUBT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSubtractOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSubtractOp::variant() const \n");
#endif
     assert(this != NULL);
     return SUBT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSubtractOp* isSgSubtractOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSubtractOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSubtractOp* isSgSubtractOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSubtractOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSubtractOp::~SgSubtractOp ()
   {
#if 0
  // debugging information!
     printf ("In SgSubtractOp::~SgSubtractOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSubtractOp::SgSubtractOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgSubtractOp::SgSubtractOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(SUBT_OP == variant());
     post_construction_initialization();

  // Test the isSgSubtractOp() function since it has been problematic
     assert(isSgSubtractOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgMultiplyOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2769 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgMultiplyOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMultiplyOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMultiplyOp::variantT() const {
  return V_SgMultiplyOp;
}

#if 0
int
SgMultiplyOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MULT_OP;
   }
#endif

const char*
SgMultiplyOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMultiplyOp";  
   }

std::string
SgMultiplyOp::class_name() const
   {
     assert(this != NULL);
     return "SgMultiplyOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMultiplyOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMultiplyOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MULT_OP)
        {
          printf ("Error in SgMultiplyOp::error(): SgMultiplyOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMultiplyOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MULT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMultiplyOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMultiplyOp::variant() const \n");
#endif
     assert(this != NULL);
     return MULT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMultiplyOp* isSgMultiplyOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMultiplyOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMultiplyOp* isSgMultiplyOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMultiplyOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMultiplyOp::~SgMultiplyOp ()
   {
#if 0
  // debugging information!
     printf ("In SgMultiplyOp::~SgMultiplyOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMultiplyOp::SgMultiplyOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgMultiplyOp::SgMultiplyOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MULT_OP == variant());
     post_construction_initialization();

  // Test the isSgMultiplyOp() function since it has been problematic
     assert(isSgMultiplyOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgDivideOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2773 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgDivideOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDivideOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDivideOp::variantT() const {
  return V_SgDivideOp;
}

#if 0
int
SgDivideOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DIV_OP;
   }
#endif

const char*
SgDivideOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDivideOp";  
   }

std::string
SgDivideOp::class_name() const
   {
     assert(this != NULL);
     return "SgDivideOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDivideOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDivideOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DIV_OP)
        {
          printf ("Error in SgDivideOp::error(): SgDivideOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDivideOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DIV_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDivideOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDivideOp::variant() const \n");
#endif
     assert(this != NULL);
     return DIV_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDivideOp* isSgDivideOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDivideOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDivideOp* isSgDivideOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDivideOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDivideOp::~SgDivideOp ()
   {
#if 0
  // debugging information!
     printf ("In SgDivideOp::~SgDivideOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDivideOp::SgDivideOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgDivideOp::SgDivideOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DIV_OP == variant());
     post_construction_initialization();

  // Test the isSgDivideOp() function since it has been problematic
     assert(isSgDivideOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgIntegerDivideOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2777 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgIntegerDivideOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIntegerDivideOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIntegerDivideOp::variantT() const {
  return V_SgIntegerDivideOp;
}

#if 0
int
SgIntegerDivideOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INTEGER_DIV_OP;
   }
#endif

const char*
SgIntegerDivideOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIntegerDivideOp";  
   }

std::string
SgIntegerDivideOp::class_name() const
   {
     assert(this != NULL);
     return "SgIntegerDivideOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIntegerDivideOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIntegerDivideOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INTEGER_DIV_OP)
        {
          printf ("Error in SgIntegerDivideOp::error(): SgIntegerDivideOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIntegerDivideOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INTEGER_DIV_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIntegerDivideOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIntegerDivideOp::variant() const \n");
#endif
     assert(this != NULL);
     return INTEGER_DIV_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIntegerDivideOp* isSgIntegerDivideOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIntegerDivideOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIntegerDivideOp* isSgIntegerDivideOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIntegerDivideOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIntegerDivideOp::~SgIntegerDivideOp ()
   {
#if 0
  // debugging information!
     printf ("In SgIntegerDivideOp::~SgIntegerDivideOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIntegerDivideOp::SgIntegerDivideOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgIntegerDivideOp::SgIntegerDivideOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(INTEGER_DIV_OP == variant());
     post_construction_initialization();

  // Test the isSgIntegerDivideOp() function since it has been problematic
     assert(isSgIntegerDivideOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgModOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2781 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4487 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_ARITHMETIC_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgModOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * op_type = SgType::arithmetic_conversions(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     set_expression_type(op_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModOp::variantT() const {
  return V_SgModOp;
}

#if 0
int
SgModOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MOD_OP;
   }
#endif

const char*
SgModOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModOp";  
   }

std::string
SgModOp::class_name() const
   {
     assert(this != NULL);
     return "SgModOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MOD_OP)
        {
          printf ("Error in SgModOp::error(): SgModOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MOD_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModOp::variant() const \n");
#endif
     assert(this != NULL);
     return MOD_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModOp* isSgModOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModOp* isSgModOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModOp::~SgModOp ()
   {
#if 0
  // debugging information!
     printf ("In SgModOp::~SgModOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModOp::SgModOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgModOp::SgModOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MOD_OP == variant());
     post_construction_initialization();

  // Test the isSgModOp() function since it has been problematic
     assert(isSgModOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAndOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2785 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


bool
SgAndOp::cfgIsIndexInteresting(unsigned int idx) const
   {
     return idx == 1 || idx == 2;
   }

std::vector<VirtualCFG::CFGEdge>
SgAndOp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_lhs_operand()->cfgForBeginning(), result); break;
       case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_rhs_operand()->cfgForBeginning(), result);
	       makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 2), result); break;
       case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
       default: ROSE_ASSERT (!"Bad index in SgAndOp");
     }
     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgAndOp::cfgInEdges(unsigned int idx) 
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
       case 1: makeEdge(this->get_lhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
       case 2: makeEdge(this->get_rhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	       makeEdge(VirtualCFG::CFGNode(this, 1), VirtualCFG::CFGNode(this, idx), result); break;
       default: ROSE_ASSERT (!"Bad index in SgAndOp");
     }
     return result;
   }

SgType*
SgAndOp::get_type() const
   {
  // This function returns an integer representing the logical type 

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
  // SgType* returnType = SgTypeInt::SgTypeInt::createType();
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4509 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_INTEGER_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgAndOp::set_type()
   {
     set_expression_type(SgTypeInt::createType());
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAndOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAndOp::variantT() const {
  return V_SgAndOp;
}

#if 0
int
SgAndOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return AND_OP;
   }
#endif

const char*
SgAndOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAndOp";  
   }

std::string
SgAndOp::class_name() const
   {
     assert(this != NULL);
     return "SgAndOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAndOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAndOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != AND_OP)
        {
          printf ("Error in SgAndOp::error(): SgAndOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAndOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == AND_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAndOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAndOp::variant() const \n");
#endif
     assert(this != NULL);
     return AND_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAndOp* isSgAndOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAndOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAndOp* isSgAndOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAndOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAndOp::~SgAndOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAndOp::~SgAndOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAndOp::SgAndOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgAndOp::SgAndOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(AND_OP == variant());
     post_construction_initialization();

  // Test the isSgAndOp() function since it has been problematic
     assert(isSgAndOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgOrOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2838 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


bool
SgOrOp::cfgIsIndexInteresting(unsigned int idx) const 
   {
     return idx == 1 || idx == 2;
   }

std::vector<VirtualCFG::CFGEdge>
SgOrOp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_lhs_operand()->cfgForBeginning(), result); break;
       case 1: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_rhs_operand()->cfgForBeginning(), result);
	       makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::CFGNode(this, 2), result); break;
       case 2: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
       default: ROSE_ASSERT (!"Bad index in SgOrOp");
     }
     return result;
   }

   std::vector<VirtualCFG::CFGEdge> SgOrOp::cfgInEdges(unsigned int idx) {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx) {
       case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
       case 1: makeEdge(this->get_lhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
       case 2: makeEdge(this->get_rhs_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result);
	       makeEdge(VirtualCFG::CFGNode(this, 1), VirtualCFG::CFGNode(this, idx), result); break;
       default: ROSE_ASSERT (!"Bad index in SgOrOp");
     }
     return result;
   }

SgType*
SgOrOp::get_type() const
   {
  // This function returns an integer representing the logical type 

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 4509 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_INTEGER_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgOrOp::set_type()
   {
     set_expression_type(SgTypeInt::createType());
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgOrOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgOrOp::variantT() const {
  return V_SgOrOp;
}

#if 0
int
SgOrOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return OR_OP;
   }
#endif

const char*
SgOrOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgOrOp";  
   }

std::string
SgOrOp::class_name() const
   {
     assert(this != NULL);
     return "SgOrOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgOrOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgOrOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != OR_OP)
        {
          printf ("Error in SgOrOp::error(): SgOrOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgOrOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == OR_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgOrOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgOrOp::variant() const \n");
#endif
     assert(this != NULL);
     return OR_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgOrOp* isSgOrOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgOrOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgOrOp* isSgOrOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgOrOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgOrOp::~SgOrOp ()
   {
#if 0
  // debugging information!
     printf ("In SgOrOp::~SgOrOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgOrOp::SgOrOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgOrOp::SgOrOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(OR_OP == variant());
     post_construction_initialization();

  // Test the isSgOrOp() function since it has been problematic
     assert(isSgOrOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgBitXorOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2888 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4528 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_BIT_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgBitXorOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * int_type = SgType::integer_promotion(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     assert(int_type != NULL);
     set_expression_type(int_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBitXorOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBitXorOp::variantT() const {
  return V_SgBitXorOp;
}

#if 0
int
SgBitXorOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BITXOR_OP;
   }
#endif

const char*
SgBitXorOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBitXorOp";  
   }

std::string
SgBitXorOp::class_name() const
   {
     assert(this != NULL);
     return "SgBitXorOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBitXorOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBitXorOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BITXOR_OP)
        {
          printf ("Error in SgBitXorOp::error(): SgBitXorOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBitXorOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BITXOR_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBitXorOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBitXorOp::variant() const \n");
#endif
     assert(this != NULL);
     return BITXOR_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBitXorOp* isSgBitXorOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBitXorOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBitXorOp* isSgBitXorOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBitXorOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBitXorOp::~SgBitXorOp ()
   {
#if 0
  // debugging information!
     printf ("In SgBitXorOp::~SgBitXorOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBitXorOp::SgBitXorOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgBitXorOp::SgBitXorOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(BITXOR_OP == variant());
     post_construction_initialization();

  // Test the isSgBitXorOp() function since it has been problematic
     assert(isSgBitXorOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgBitAndOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2892 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4528 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_BIT_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgBitAndOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * int_type = SgType::integer_promotion(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     assert(int_type != NULL);
     set_expression_type(int_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBitAndOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBitAndOp::variantT() const {
  return V_SgBitAndOp;
}

#if 0
int
SgBitAndOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BITAND_OP;
   }
#endif

const char*
SgBitAndOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBitAndOp";  
   }

std::string
SgBitAndOp::class_name() const
   {
     assert(this != NULL);
     return "SgBitAndOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBitAndOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBitAndOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BITAND_OP)
        {
          printf ("Error in SgBitAndOp::error(): SgBitAndOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBitAndOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BITAND_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBitAndOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBitAndOp::variant() const \n");
#endif
     assert(this != NULL);
     return BITAND_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBitAndOp* isSgBitAndOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBitAndOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBitAndOp* isSgBitAndOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBitAndOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBitAndOp::~SgBitAndOp ()
   {
#if 0
  // debugging information!
     printf ("In SgBitAndOp::~SgBitAndOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBitAndOp::SgBitAndOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgBitAndOp::SgBitAndOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(BITAND_OP == variant());
     post_construction_initialization();

  // Test the isSgBitAndOp() function since it has been problematic
     assert(isSgBitAndOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgBitOrOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2896 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 4528 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_BIT_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgBitOrOp::set_type()
   {
     assert(get_lhs_operand() != NULL);
     assert(get_rhs_operand() != NULL);
     SgType * int_type = SgType::integer_promotion(get_lhs_operand()->get_type(), get_rhs_operand()->get_type());
     assert(int_type != NULL);
     set_expression_type(int_type);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBitOrOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBitOrOp::variantT() const {
  return V_SgBitOrOp;
}

#if 0
int
SgBitOrOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BITOR_OP;
   }
#endif

const char*
SgBitOrOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBitOrOp";  
   }

std::string
SgBitOrOp::class_name() const
   {
     assert(this != NULL);
     return "SgBitOrOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBitOrOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBitOrOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BITOR_OP)
        {
          printf ("Error in SgBitOrOp::error(): SgBitOrOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBitOrOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BITOR_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBitOrOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBitOrOp::variant() const \n");
#endif
     assert(this != NULL);
     return BITOR_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBitOrOp* isSgBitOrOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBitOrOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBitOrOp* isSgBitOrOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBitOrOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBitOrOp::~SgBitOrOp ()
   {
#if 0
  // debugging information!
     printf ("In SgBitOrOp::~SgBitOrOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBitOrOp::SgBitOrOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgBitOrOp::SgBitOrOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(BITOR_OP == variant());
     post_construction_initialization();

  // Test the isSgBitOrOp() function since it has been problematic
     assert(isSgBitOrOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgCommaOpExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2900 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgCommaOpExp::get_type() const
   {
  // DQ (10/2/2006): Comma operator's get_type function didn't previously exist, but it should 
  // because its semantics is different from the default SgBinaryOp::get_type() which returns 
  // the type associated with the lhs.  This returns the type of the rhs.
     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

     SgType* returnType = get_rhs_operand()->get_type();
     ROSE_ASSERT(returnType != NULL);

  // printf ("SgCommaOpExp::get_type(): get the type of the rhs operand returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCommaOpExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCommaOpExp::variantT() const {
  return V_SgCommaOpExp;
}

#if 0
int
SgCommaOpExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return COMMA_OP;
   }
#endif

const char*
SgCommaOpExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCommaOpExp";  
   }

std::string
SgCommaOpExp::class_name() const
   {
     assert(this != NULL);
     return "SgCommaOpExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCommaOpExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCommaOpExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != COMMA_OP)
        {
          printf ("Error in SgCommaOpExp::error(): SgCommaOpExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCommaOpExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == COMMA_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCommaOpExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCommaOpExp::variant() const \n");
#endif
     assert(this != NULL);
     return COMMA_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCommaOpExp* isSgCommaOpExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCommaOpExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCommaOpExp* isSgCommaOpExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCommaOpExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCommaOpExp::~SgCommaOpExp ()
   {
#if 0
  // debugging information!
     printf ("In SgCommaOpExp::~SgCommaOpExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCommaOpExp::SgCommaOpExp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgCommaOpExp::SgCommaOpExp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(COMMA_OP == variant());
     post_construction_initialization();

  // Test the isSgCommaOpExp() function since it has been problematic
     assert(isSgCommaOpExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLshiftOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2921 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLshiftOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLshiftOp::variantT() const {
  return V_SgLshiftOp;
}

#if 0
int
SgLshiftOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LSHIFT_OP;
   }
#endif

const char*
SgLshiftOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLshiftOp";  
   }

std::string
SgLshiftOp::class_name() const
   {
     assert(this != NULL);
     return "SgLshiftOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLshiftOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLshiftOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LSHIFT_OP)
        {
          printf ("Error in SgLshiftOp::error(): SgLshiftOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLshiftOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LSHIFT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLshiftOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLshiftOp::variant() const \n");
#endif
     assert(this != NULL);
     return LSHIFT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLshiftOp* isSgLshiftOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLshiftOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLshiftOp* isSgLshiftOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLshiftOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLshiftOp::~SgLshiftOp ()
   {
#if 0
  // debugging information!
     printf ("In SgLshiftOp::~SgLshiftOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLshiftOp::SgLshiftOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgLshiftOp::SgLshiftOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(LSHIFT_OP == variant());
     post_construction_initialization();

  // Test the isSgLshiftOp() function since it has been problematic
     assert(isSgLshiftOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgRshiftOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2924 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgRshiftOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgRshiftOp::variantT() const {
  return V_SgRshiftOp;
}

#if 0
int
SgRshiftOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return RSHIFT_OP;
   }
#endif

const char*
SgRshiftOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgRshiftOp";  
   }

std::string
SgRshiftOp::class_name() const
   {
     assert(this != NULL);
     return "SgRshiftOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgRshiftOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgRshiftOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != RSHIFT_OP)
        {
          printf ("Error in SgRshiftOp::error(): SgRshiftOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgRshiftOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == RSHIFT_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgRshiftOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgRshiftOp::variant() const \n");
#endif
     assert(this != NULL);
     return RSHIFT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgRshiftOp* isSgRshiftOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgRshiftOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgRshiftOp* isSgRshiftOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgRshiftOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgRshiftOp::~SgRshiftOp ()
   {
#if 0
  // debugging information!
     printf ("In SgRshiftOp::~SgRshiftOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgRshiftOp::SgRshiftOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgRshiftOp::SgRshiftOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(RSHIFT_OP == variant());
     post_construction_initialization();

  // Test the isSgRshiftOp() function since it has been problematic
     assert(isSgRshiftOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgPntrArrRefExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3504 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgPntrArrRefExp::get_type() const
   {
  // DQ (1/16/2006): In this function we want to return the base type of the array being referenced (lhs->get_type()).

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgPntrArrRefExp::get_type(): p_expression_type has been removed from many IR nodes \n");

  // ROSE_ASSERT(p_expression_type != NULL);
     if (p_expression_type != NULL)
        {
          printf ("In SgPntrArrRefExp::get_type(): p_expression_type = %s \n",p_expression_type->class_name().c_str());
        }

     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

  // SgType* returnType = get_lhs_operand()->get_type();
     SgType* someType = get_lhs_operand()->get_type();
     ROSE_ASSERT(someType != NULL);

  // This code should be shared between the SgPntrArrRefExp and the SgPointerDerefExp IR nodes
  // A better idea would be to have a function that strips off types based on a set of flags
  // that would control stripping of pointer references, array references, C++ references, 
  // modifiers, and typedefs.

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have 
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

       // DQ (10/3/2006): Added case of array reference of string type (assume it returns a char).
       // Once we have a wcharString type then we have to add that case to this list as well!
          case V_SgTypeString:
             {
            // SgTypeString* stringType = isSgTypeString(someType);
            // someType = stringType->get_base_type();
               returnType = SgTypeChar::createType();
               break;
             }

          default:
             {
#if 1
               printf ("Error: default reached in In SgPntrArrRefExp::get_type() someType = %s \n",someType->class_name().c_str());
               get_file_info()->display("location of error: debug");

            // DQ (9/27/2006): This can be a compiler generated IR nde so look at the parent.
               SgLocatedNode* locatedNode = isSgLocatedNode(get_parent());
               if (locatedNode != NULL)
                    locatedNode->get_file_info()->display("location of parent: debug");
#endif
               printf ("Error: default reached in In SgPntrArrRefExp::get_type() someType = %s \n",someType->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     ROSE_ASSERT(returnType != NULL);
  // printf ("In SgPntrArrRefExp::get_type(): returnType = %s \n",returnType->class_name().c_str());

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPntrArrRefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPntrArrRefExp::variantT() const {
  return V_SgPntrArrRefExp;
}

#if 0
int
SgPntrArrRefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ARRAY_OP;
   }
#endif

const char*
SgPntrArrRefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPntrArrRefExp";  
   }

std::string
SgPntrArrRefExp::class_name() const
   {
     assert(this != NULL);
     return "SgPntrArrRefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPntrArrRefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPntrArrRefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ARRAY_OP)
        {
          printf ("Error in SgPntrArrRefExp::error(): SgPntrArrRefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPntrArrRefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ARRAY_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPntrArrRefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPntrArrRefExp::variant() const \n");
#endif
     assert(this != NULL);
     return ARRAY_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPntrArrRefExp* isSgPntrArrRefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPntrArrRefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPntrArrRefExp* isSgPntrArrRefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPntrArrRefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPntrArrRefExp::~SgPntrArrRefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgPntrArrRefExp::~SgPntrArrRefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPntrArrRefExp::SgPntrArrRefExp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgPntrArrRefExp::SgPntrArrRefExp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ARRAY_OP == variant());
     post_construction_initialization();

  // Test the isSgPntrArrRefExp() function since it has been problematic
     assert(isSgPntrArrRefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgScopeOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3953 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgScopeOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgScopeOp::variantT() const {
  return V_SgScopeOp;
}

#if 0
int
SgScopeOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SCOPE_OP;
   }
#endif

const char*
SgScopeOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgScopeOp";  
   }

std::string
SgScopeOp::class_name() const
   {
     assert(this != NULL);
     return "SgScopeOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgScopeOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgScopeOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SCOPE_OP)
        {
          printf ("Error in SgScopeOp::error(): SgScopeOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgScopeOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SCOPE_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgScopeOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgScopeOp::variant() const \n");
#endif
     assert(this != NULL);
     return SCOPE_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgScopeOp* isSgScopeOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgScopeOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgScopeOp* isSgScopeOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgScopeOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgScopeOp::~SgScopeOp ()
   {
#if 0
  // debugging information!
     printf ("In SgScopeOp::~SgScopeOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgScopeOp::SgScopeOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgScopeOp::SgScopeOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(SCOPE_OP == variant());
     post_construction_initialization();

  // Test the isSgScopeOp() function since it has been problematic
     assert(isSgScopeOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3957 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAssignOp::variantT() const {
  return V_SgAssignOp;
}

#if 0
int
SgAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ASSIGN_OP;
   }
#endif

const char*
SgAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAssignOp";  
   }

std::string
SgAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ASSIGN_OP)
        {
          printf ("Error in SgAssignOp::error(): SgAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAssignOp* isSgAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAssignOp* isSgAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAssignOp::~SgAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAssignOp::~SgAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAssignOp::SgAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgAssignOp::SgAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgAssignOp() function since it has been problematic
     assert(isSgAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgPlusAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3961 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPlusAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPlusAssignOp::variantT() const {
  return V_SgPlusAssignOp;
}

#if 0
int
SgPlusAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PLUS_ASSIGN_OP;
   }
#endif

const char*
SgPlusAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPlusAssignOp";  
   }

std::string
SgPlusAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgPlusAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPlusAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPlusAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PLUS_ASSIGN_OP)
        {
          printf ("Error in SgPlusAssignOp::error(): SgPlusAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPlusAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PLUS_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPlusAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPlusAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return PLUS_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPlusAssignOp* isSgPlusAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPlusAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPlusAssignOp* isSgPlusAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPlusAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPlusAssignOp::~SgPlusAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgPlusAssignOp::~SgPlusAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPlusAssignOp::SgPlusAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgPlusAssignOp::SgPlusAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(PLUS_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgPlusAssignOp() function since it has been problematic
     assert(isSgPlusAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgMinusAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3965 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMinusAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMinusAssignOp::variantT() const {
  return V_SgMinusAssignOp;
}

#if 0
int
SgMinusAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MINUS_ASSIGN_OP;
   }
#endif

const char*
SgMinusAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMinusAssignOp";  
   }

std::string
SgMinusAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgMinusAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMinusAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMinusAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MINUS_ASSIGN_OP)
        {
          printf ("Error in SgMinusAssignOp::error(): SgMinusAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMinusAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MINUS_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMinusAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMinusAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return MINUS_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMinusAssignOp* isSgMinusAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMinusAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMinusAssignOp* isSgMinusAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMinusAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMinusAssignOp::~SgMinusAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgMinusAssignOp::~SgMinusAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMinusAssignOp::SgMinusAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgMinusAssignOp::SgMinusAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MINUS_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgMinusAssignOp() function since it has been problematic
     assert(isSgMinusAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAndAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3969 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAndAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAndAssignOp::variantT() const {
  return V_SgAndAssignOp;
}

#if 0
int
SgAndAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return AND_ASSIGN_OP;
   }
#endif

const char*
SgAndAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAndAssignOp";  
   }

std::string
SgAndAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgAndAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAndAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAndAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != AND_ASSIGN_OP)
        {
          printf ("Error in SgAndAssignOp::error(): SgAndAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAndAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == AND_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAndAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAndAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return AND_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAndAssignOp* isSgAndAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAndAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAndAssignOp* isSgAndAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAndAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAndAssignOp::~SgAndAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAndAssignOp::~SgAndAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAndAssignOp::SgAndAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgAndAssignOp::SgAndAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(AND_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgAndAssignOp() function since it has been problematic
     assert(isSgAndAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgIorAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3973 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIorAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIorAssignOp::variantT() const {
  return V_SgIorAssignOp;
}

#if 0
int
SgIorAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return IOR_ASSIGN_OP;
   }
#endif

const char*
SgIorAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIorAssignOp";  
   }

std::string
SgIorAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgIorAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIorAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIorAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != IOR_ASSIGN_OP)
        {
          printf ("Error in SgIorAssignOp::error(): SgIorAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIorAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == IOR_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIorAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIorAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return IOR_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIorAssignOp* isSgIorAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIorAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIorAssignOp* isSgIorAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIorAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIorAssignOp::~SgIorAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgIorAssignOp::~SgIorAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIorAssignOp::SgIorAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgIorAssignOp::SgIorAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(IOR_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgIorAssignOp() function since it has been problematic
     assert(isSgIorAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgMultAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3977 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMultAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMultAssignOp::variantT() const {
  return V_SgMultAssignOp;
}

#if 0
int
SgMultAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MULT_ASSIGN_OP;
   }
#endif

const char*
SgMultAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMultAssignOp";  
   }

std::string
SgMultAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgMultAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMultAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMultAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MULT_ASSIGN_OP)
        {
          printf ("Error in SgMultAssignOp::error(): SgMultAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMultAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MULT_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMultAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMultAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return MULT_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMultAssignOp* isSgMultAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMultAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMultAssignOp* isSgMultAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMultAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMultAssignOp::~SgMultAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgMultAssignOp::~SgMultAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMultAssignOp::SgMultAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgMultAssignOp::SgMultAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MULT_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgMultAssignOp() function since it has been problematic
     assert(isSgMultAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgDivAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3981 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDivAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDivAssignOp::variantT() const {
  return V_SgDivAssignOp;
}

#if 0
int
SgDivAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DIV_ASSIGN_OP;
   }
#endif

const char*
SgDivAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDivAssignOp";  
   }

std::string
SgDivAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgDivAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDivAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDivAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DIV_ASSIGN_OP)
        {
          printf ("Error in SgDivAssignOp::error(): SgDivAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDivAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DIV_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDivAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDivAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return DIV_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDivAssignOp* isSgDivAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDivAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDivAssignOp* isSgDivAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDivAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDivAssignOp::~SgDivAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgDivAssignOp::~SgDivAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDivAssignOp::SgDivAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgDivAssignOp::SgDivAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DIV_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgDivAssignOp() function since it has been problematic
     assert(isSgDivAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgModAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3985 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModAssignOp::variantT() const {
  return V_SgModAssignOp;
}

#if 0
int
SgModAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MOD_ASSIGN_OP;
   }
#endif

const char*
SgModAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModAssignOp";  
   }

std::string
SgModAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgModAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MOD_ASSIGN_OP)
        {
          printf ("Error in SgModAssignOp::error(): SgModAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MOD_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return MOD_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModAssignOp* isSgModAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModAssignOp* isSgModAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModAssignOp::~SgModAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgModAssignOp::~SgModAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModAssignOp::SgModAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgModAssignOp::SgModAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MOD_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgModAssignOp() function since it has been problematic
     assert(isSgModAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgXorAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3989 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgXorAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgXorAssignOp::variantT() const {
  return V_SgXorAssignOp;
}

#if 0
int
SgXorAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return XOR_ASSIGN_OP;
   }
#endif

const char*
SgXorAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgXorAssignOp";  
   }

std::string
SgXorAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgXorAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgXorAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgXorAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != XOR_ASSIGN_OP)
        {
          printf ("Error in SgXorAssignOp::error(): SgXorAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgXorAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == XOR_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgXorAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgXorAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return XOR_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgXorAssignOp* isSgXorAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgXorAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgXorAssignOp* isSgXorAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgXorAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgXorAssignOp::~SgXorAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgXorAssignOp::~SgXorAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgXorAssignOp::SgXorAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgXorAssignOp::SgXorAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(XOR_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgXorAssignOp() function since it has been problematic
     assert(isSgXorAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgLshiftAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3993 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLshiftAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLshiftAssignOp::variantT() const {
  return V_SgLshiftAssignOp;
}

#if 0
int
SgLshiftAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LSHIFT_ASSIGN_OP;
   }
#endif

const char*
SgLshiftAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLshiftAssignOp";  
   }

std::string
SgLshiftAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgLshiftAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLshiftAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLshiftAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LSHIFT_ASSIGN_OP)
        {
          printf ("Error in SgLshiftAssignOp::error(): SgLshiftAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLshiftAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LSHIFT_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLshiftAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLshiftAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return LSHIFT_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLshiftAssignOp* isSgLshiftAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLshiftAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLshiftAssignOp* isSgLshiftAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLshiftAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLshiftAssignOp::~SgLshiftAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgLshiftAssignOp::~SgLshiftAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLshiftAssignOp::SgLshiftAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgLshiftAssignOp::SgLshiftAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(LSHIFT_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgLshiftAssignOp() function since it has been problematic
     assert(isSgLshiftAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgRshiftAssignOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3997 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgRshiftAssignOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgRshiftAssignOp::variantT() const {
  return V_SgRshiftAssignOp;
}

#if 0
int
SgRshiftAssignOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return RSHIFT_ASSIGN_OP;
   }
#endif

const char*
SgRshiftAssignOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgRshiftAssignOp";  
   }

std::string
SgRshiftAssignOp::class_name() const
   {
     assert(this != NULL);
     return "SgRshiftAssignOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgRshiftAssignOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgRshiftAssignOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != RSHIFT_ASSIGN_OP)
        {
          printf ("Error in SgRshiftAssignOp::error(): SgRshiftAssignOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgRshiftAssignOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == RSHIFT_ASSIGN_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgRshiftAssignOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgRshiftAssignOp::variant() const \n");
#endif
     assert(this != NULL);
     return RSHIFT_ASSIGN_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgRshiftAssignOp* isSgRshiftAssignOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgRshiftAssignOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgRshiftAssignOp* isSgRshiftAssignOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgRshiftAssignOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgRshiftAssignOp::~SgRshiftAssignOp ()
   {
#if 0
  // debugging information!
     printf ("In SgRshiftAssignOp::~SgRshiftAssignOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgRshiftAssignOp::SgRshiftAssignOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgRshiftAssignOp::SgRshiftAssignOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(RSHIFT_ASSIGN_OP == variant());
     post_construction_initialization();

  // Test the isSgRshiftAssignOp() function since it has been problematic
     assert(isSgRshiftAssignOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4941 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgExponentiationOp::post_construction_initialization() 
   {
   }

#if 0
SgType*
SgExponentiationOp::get_type() const
   {
     return NULL;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgExponentiationOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgExponentiationOp::variantT() const {
  return V_SgExponentiationOp;
}

#if 0
int
SgExponentiationOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPONENTIATION_OP;
   }
#endif

const char*
SgExponentiationOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgExponentiationOp";  
   }

std::string
SgExponentiationOp::class_name() const
   {
     assert(this != NULL);
     return "SgExponentiationOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgExponentiationOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgExponentiationOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPONENTIATION_OP)
        {
          printf ("Error in SgExponentiationOp::error(): SgExponentiationOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgExponentiationOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPONENTIATION_OP);
     return SgBinaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgExponentiationOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgExponentiationOp::variant() const \n");
#endif
     assert(this != NULL);
     return EXPONENTIATION_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgExponentiationOp* isSgExponentiationOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgExponentiationOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgExponentiationOp* isSgExponentiationOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgExponentiationOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgExponentiationOp::~SgExponentiationOp ()
   {
#if 0
  // debugging information!
     printf ("In SgExponentiationOp::~SgExponentiationOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgExponentiationOp::SgExponentiationOp ( Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type )
   : SgBinaryOp(startOfConstruct, lhs_operand_i, rhs_operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgExponentiationOp::SgExponentiationOp (Sg_File_Info* startOfConstruct, SgExpression* lhs_operand_i, SgExpression* rhs_operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(EXPONENTIATION_OP == variant());
     post_construction_initialization();

  // Test the isSgExponentiationOp() function since it has been problematic
     assert(isSgExponentiationOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgUnaryOp::get_operand_i () const
   {
     assert (this != NULL);
     return p_operand_i;
   }

void
SgUnaryOp::set_operand_i ( SgExpression* operand_i )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_operand_i != NULL && operand_i != NULL && p_operand_i != operand_i)
        {
          printf ("Warning: operand_i = %p overwriting valid pointer p_operand_i = %p \n",operand_i,p_operand_i);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_operand_i != NULL && operand_i != NULL && p_operand_i != operand_i) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_operand_i = operand_i;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgUnaryOp::Sgop_mode 
SgUnaryOp::get_mode () const
   {
     assert (this != NULL);
     return p_mode;
   }

void
SgUnaryOp::set_mode ( SgUnaryOp::Sgop_mode mode )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_mode = mode;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1290 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


unsigned int
SgUnaryOp::cfgIndexForEnd() const 
   {
     return 1;
   }

std::vector<VirtualCFG::CFGEdge>
SgUnaryOp::cfgOutEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::CFGNode(this, idx), this->get_operand()->cfgForBeginning(), result); break;
          case 1: makeEdge(VirtualCFG::CFGNode(this, idx), VirtualCFG::getNodeJustAfterInContainer(this), result); break;
          default: ROSE_ASSERT (!"Bad index for SgUnaryOp");
        }

     return result;
   }

std::vector<VirtualCFG::CFGEdge>
SgUnaryOp::cfgInEdges(unsigned int idx)
   {
     std::vector<VirtualCFG::CFGEdge> result;
     switch (idx)
        {
          case 0: makeEdge(VirtualCFG::getNodeJustBeforeInContainer(this), VirtualCFG::CFGNode(this, idx), result); break;
          case 1: makeEdge(this->get_operand()->cfgForEnd(), VirtualCFG::CFGNode(this, idx), result); break;
          default: ROSE_ASSERT (!"Bad index for SgUnaryOp");
        }

     return result;
   }

void
SgUnaryOp::post_construction_initialization()
   {
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_operand())
          get_operand()->set_parent(this);
// #endif
     p_mode = SgUnaryOp::prefix;
   }

SgExpression*
SgUnaryOp::get_operand() const
   { return get_operand_i(); }

void
SgUnaryOp::set_operand(SgExpression * exp)
   {
     set_operand_i(exp);
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

SgType*
SgUnaryOp::get_type() const
   {
  // DQ (1/14/2006): Get the type from the operand
  // return get_expression_type();
  // printf ("SgUnaryOp::get_type(): getting type from operand \n");
     ROSE_ASSERT(get_operand() != NULL);

     SgType* returnType = get_operand()->get_type();

     return returnType;
   }

int
SgUnaryOp::length() const 
   { return 1;}

bool
SgUnaryOp::empty() const
   { return 0; }

// void SgUnaryOp::operator_unparse(const char * op, Unparse_Info & info, ostream & os);

#if 0
// This should be automatically generated!
int
SgUnaryOp::get_mode() 
   { return p_mode; }

void
SgUnaryOp::set_mode(Sgop_mode m)
   { p_mode=m; }
#endif

SgExpression*
SgUnaryOp::get_next (int &n) const
   {
     if(n)
        {
          return NULL;
        }
       else
        {
          n++;
          return get_operand();
        }
   }

int
SgUnaryOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a  
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand() == o)
        {
          set_operand(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgUnaryOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnaryOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnaryOp::variantT() const {
  return V_SgUnaryOp;
}

#if 0
int
SgUnaryOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNARY_EXPRESSION;
   }
#endif

const char*
SgUnaryOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnaryOp";  
   }

std::string
SgUnaryOp::class_name() const
   {
     assert(this != NULL);
     return "SgUnaryOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnaryOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnaryOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNARY_EXPRESSION)
        {
          printf ("Error in SgUnaryOp::error(): SgUnaryOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnaryOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNARY_EXPRESSION);
     return SgExpression::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnaryOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnaryOp::variant() const \n");
#endif
     assert(this != NULL);
     return UNARY_EXPRESSION;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnaryOp* isSgUnaryOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnaryOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnaryOp* isSgUnaryOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnaryOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnaryOp::~SgUnaryOp ()
   {
#if 0
  // debugging information!
     printf ("In SgUnaryOp::~SgUnaryOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for operand_i
     p_operand_i = NULL; // non list case 
  // case: not a listType for expression_type
     p_expression_type = NULL; // non list case 
  // case: not a listType for mode
     p_mode = prefix; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnaryOp::SgUnaryOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgExpression(startOfConstruct)
   {
#ifdef DEBUG
  // printf ("In SgUnaryOp::SgUnaryOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_operand_i = operand_i;
     p_expression_type = expression_type;
     p_mode = prefix;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(UNARY_EXPRESSION == variant());
     post_construction_initialization();

  // Test the isSgUnaryOp() function since it has been problematic
     assert(isSgUnaryOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgExpressionRoot::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1596 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
#if 0
void
SgExpressionRoot::initialize_root ( SgExpression* exp, SgStatement* stmt )
   {
  // The root of an expression should be an expression.  
  // If the expression's parent is a statement then the
  // statement should contain an expression root object.

  // stmt should always be initialized to calling object's this pointer
     ROSE_ASSERT(stmt != NULL);

  // set the parent of this expression to the calling statement
  // (this might be better off set to NULL or some other value!)
  // set_parent(stmt);
  // Let the parent of the expression root be NULL (since it really should be an expression type)
  // Access the parent through the p_statement pointer!
  // set_parent(NULL);
  // We can't call the set_parent function because it can't take a NULL pointer

  // We don't want to call set_statement since this will attempt to 
  // initialize the parent of stmt (which would be backwards)
  // set_statement(stmt);
  // p_statement = stmt;
  // call the modified set_statement function
     set_statement(stmt);

  // We use the SgExpressionRoot as the parent of the exp 
  // (this is the purpose of the SgExpressionRoot object)
// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (exp)
          exp->set_parent(this);
// #endif
     set_operand(exp);
   }
#endif

#if 0
// DQ (1/14/2006): set_type is removed
void
SgExpressionRoot::set_type()
   {
     if (get_operand())
          set_expression_type(get_operand()->get_type()); 
       else
          set_expression_type(SgTypeDefault::createType());
   }
#endif

#if 0
// DQ (12/17/2006): Removed to clean up code (not used, I think).
//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
void
SgExpressionRoot::set_statement( SgStatement* stmt )
   {
     set_parent(stmt);
   }

//QY:9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
SgStatement*
SgExpressionRoot::get_statement() const
   {
     if (get_parent() == 0)
        return 0;
     SgStatement* res= isSgStatement( get_parent());
     assert(res != 0);
     return res; 
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgExpressionRoot::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgExpressionRoot::variantT() const {
  return V_SgExpressionRoot;
}

#if 0
int
SgExpressionRoot::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return EXPRESSION_ROOT;
   }
#endif

const char*
SgExpressionRoot::sage_class_name() const
   {
     assert(this != NULL);
     return "SgExpressionRoot";  
   }

std::string
SgExpressionRoot::class_name() const
   {
     assert(this != NULL);
     return "SgExpressionRoot";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgExpressionRoot::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgExpressionRoot::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != EXPRESSION_ROOT)
        {
          printf ("Error in SgExpressionRoot::error(): SgExpressionRoot object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgExpressionRoot::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == EXPRESSION_ROOT);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgExpressionRoot::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgExpressionRoot::variant() const \n");
#endif
     assert(this != NULL);
     return EXPRESSION_ROOT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgExpressionRoot* isSgExpressionRoot ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgExpressionRoot*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgExpressionRoot* isSgExpressionRoot ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgExpressionRoot*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgExpressionRoot::~SgExpressionRoot ()
   {
#if 0
  // debugging information!
     printf ("In SgExpressionRoot::~SgExpressionRoot (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgExpressionRoot::SgExpressionRoot ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgExpressionRoot::SgExpressionRoot (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(EXPRESSION_ROOT == variant());
     post_construction_initialization();

  // Test the isSgExpressionRoot() function since it has been problematic
     assert(isSgExpressionRoot(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgMinusOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2927 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMinusOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMinusOp::variantT() const {
  return V_SgMinusOp;
}

#if 0
int
SgMinusOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNARY_MINUS_OP;
   }
#endif

const char*
SgMinusOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMinusOp";  
   }

std::string
SgMinusOp::class_name() const
   {
     assert(this != NULL);
     return "SgMinusOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMinusOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMinusOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNARY_MINUS_OP)
        {
          printf ("Error in SgMinusOp::error(): SgMinusOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMinusOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNARY_MINUS_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMinusOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMinusOp::variant() const \n");
#endif
     assert(this != NULL);
     return UNARY_MINUS_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMinusOp* isSgMinusOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMinusOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMinusOp* isSgMinusOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMinusOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMinusOp::~SgMinusOp ()
   {
#if 0
  // debugging information!
     printf ("In SgMinusOp::~SgMinusOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMinusOp::SgMinusOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgMinusOp::SgMinusOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(UNARY_MINUS_OP == variant());
     post_construction_initialization();

  // Test the isSgMinusOp() function since it has been problematic
     assert(isSgMinusOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgUnaryAddOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2930 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnaryAddOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnaryAddOp::variantT() const {
  return V_SgUnaryAddOp;
}

#if 0
int
SgUnaryAddOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UNARY_ADD_OP;
   }
#endif

const char*
SgUnaryAddOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnaryAddOp";  
   }

std::string
SgUnaryAddOp::class_name() const
   {
     assert(this != NULL);
     return "SgUnaryAddOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnaryAddOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnaryAddOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UNARY_ADD_OP)
        {
          printf ("Error in SgUnaryAddOp::error(): SgUnaryAddOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnaryAddOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UNARY_ADD_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnaryAddOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnaryAddOp::variant() const \n");
#endif
     assert(this != NULL);
     return UNARY_ADD_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnaryAddOp* isSgUnaryAddOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnaryAddOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnaryAddOp* isSgUnaryAddOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnaryAddOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnaryAddOp::~SgUnaryAddOp ()
   {
#if 0
  // debugging information!
     printf ("In SgUnaryAddOp::~SgUnaryAddOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnaryAddOp::SgUnaryAddOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgUnaryAddOp::SgUnaryAddOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(UNARY_ADD_OP == variant());
     post_construction_initialization();

  // Test the isSgUnaryAddOp() function since it has been problematic
     assert(isSgUnaryAddOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgNotOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 2756 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

#line 2710 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
SgNotOp::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and 
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must 
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ? 
                               static_cast<SgType*>(SgTypeInt::createType()) : 
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 4509 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


#if 0
#error "This code from SOURCE_INTEGER_OPERATOR_EXPRESSION should not be used"

// DQ (1/14/2006): set_type is removed
void
SgNotOp::set_type()
   {
     set_expression_type(SgTypeInt::createType());
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNotOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNotOp::variantT() const {
  return V_SgNotOp;
}

#if 0
int
SgNotOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NOT_OP;
   }
#endif

const char*
SgNotOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNotOp";  
   }

std::string
SgNotOp::class_name() const
   {
     assert(this != NULL);
     return "SgNotOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNotOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNotOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NOT_OP)
        {
          printf ("Error in SgNotOp::error(): SgNotOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNotOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NOT_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNotOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNotOp::variant() const \n");
#endif
     assert(this != NULL);
     return NOT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNotOp* isSgNotOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNotOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNotOp* isSgNotOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNotOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNotOp::~SgNotOp ()
   {
#if 0
  // debugging information!
     printf ("In SgNotOp::~SgNotOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNotOp::SgNotOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgNotOp::SgNotOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(NOT_OP == variant());
     post_construction_initialization();

  // Test the isSgNotOp() function since it has been problematic
     assert(isSgNotOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgPointerDerefExp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3069 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


// SgType* SgPointerDerefExp::get_type() const
SgType*
SgPointerDerefExp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // DQ (7/28/2006): This code can't be used for both the SgPointerDerefExp and the SgPntrArrRefExp IR nodes because 
  // it is a bit different (one node is a unary operator and the other is a binary operator).

  // This function returns the base type of the type returned from get_operand()->get_type() (which should be a SgPointerType).

     ROSE_ASSERT(get_operand() != NULL);

  // printf ("In SgPointerDerefExp::get_type(): get_operand() = %p = %s \n",get_operand(),get_operand()->class_name().c_str());

     SgType* someType = get_operand()->get_type();
     ROSE_ASSERT(someType != NULL);
#if 0
     printf ("In SgPointerDerefExp::get_type(): %s->get_type() = %p = %s \n",
          get_operand()->class_name().c_str(),get_operand()->get_type(),
          get_operand()->get_type()->class_name().c_str());
#endif
     if (p_expression_type != NULL)
        {
          printf ("In SgPointerDerefExp::get_type(): p_expression_type = %s \n",p_expression_type->class_name().c_str());
        }

  // This code should be shared between the SgPntrArrRefExp and the SgPointerDerefExp IR nodes
  // A better idea would be to have a function that strips off types based on a set of flags
  // that would control stripping of pointer references, array references, C++ references, 
  // modifiers, and typedefs.

     SgType* returnType = NULL;
     keepStripping:
     ROSE_ASSERT (someType);
     switch(someType->variantT())
        {
       // These cases all have base types and the pointer dereferencing returns the base type
       // But since p_base_type is placed at each of the different SgType IR nodes we have 
       // to handle each case separately.
          case V_SgPointerType:
             {
               SgPointerType* pointerType = isSgPointerType(someType);
               returnType = pointerType->get_base_type();
               break;
             }
          case V_SgArrayType:
             {
               SgArrayType* arrayType = isSgArrayType(someType);
               returnType = arrayType->get_base_type();
               break;
             }
          case V_SgTypedefType:
             {
               SgTypedefType* typedefType = isSgTypedefType(someType);
               someType = typedefType->get_base_type();
               goto keepStripping;
             }
          case V_SgReferenceType:
             {
               SgReferenceType* referenceType = isSgReferenceType(someType);
               someType = referenceType->get_base_type();
               goto keepStripping;
             }
          case V_SgModifierType:
             {
               SgModifierType* modifierType = isSgModifierType(someType);
               someType = modifierType->get_base_type();
               goto keepStripping;
             }

       // DQ (6/18/2007): The dereference of a function type is a function call so the type is it's return type (I think)
          case V_SgFunctionType:
             {
               SgFunctionType* functionType = isSgFunctionType(someType);
            // returnType = functionType->get_return_type();
               returnType = functionType;
               break;
             }
#if 0
       // DQ (10/3/2006): I think this is no longer required, since we fixed the case of sizeof taking an 
       // expression (not required to be an lvalue)!
       // DQ (9/30/2006): This case appears where the expression of sizeof is a literal (in this case a char*).
       // This can be a SgTypeChar for "sizeof('\x1234567890123456789012345678901234567890')", 
       // it is not clear how to handle this case, at present we just return the SgTypeChar type.
          case V_SgTypeChar:
             {
               returnType = someType;
               break;
             }
#endif
          default:
             {
#if 1
               printf ("Error: default reached in In SgPointerDerefExp::get_type() someType = %s \n",someType->class_name().c_str());
               get_file_info()->display("location of error: debug");

            // DQ (9/27/2006): This can be a compiler generated IR nde so look at the parent.
               SgLocatedNode* locatedNode = isSgLocatedNode(get_parent());
               if (locatedNode != NULL)
                    locatedNode->get_file_info()->display("location of parent: debug");
#endif
               ROSE_ASSERT(false);
             }
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPointerDerefExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPointerDerefExp::variantT() const {
  return V_SgPointerDerefExp;
}

#if 0
int
SgPointerDerefExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DEREF_OP;
   }
#endif

const char*
SgPointerDerefExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPointerDerefExp";  
   }

std::string
SgPointerDerefExp::class_name() const
   {
     assert(this != NULL);
     return "SgPointerDerefExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPointerDerefExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPointerDerefExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DEREF_OP)
        {
          printf ("Error in SgPointerDerefExp::error(): SgPointerDerefExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPointerDerefExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DEREF_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPointerDerefExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPointerDerefExp::variant() const \n");
#endif
     assert(this != NULL);
     return DEREF_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPointerDerefExp* isSgPointerDerefExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPointerDerefExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPointerDerefExp* isSgPointerDerefExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPointerDerefExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPointerDerefExp::~SgPointerDerefExp ()
   {
#if 0
  // debugging information!
     printf ("In SgPointerDerefExp::~SgPointerDerefExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPointerDerefExp::SgPointerDerefExp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgPointerDerefExp::SgPointerDerefExp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(DEREF_OP == variant());
     post_construction_initialization();

  // Test the isSgPointerDerefExp() function since it has been problematic
     assert(isSgPointerDerefExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgAddressOfOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3184 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgAddressOfOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // This function returns a pointer to the type return from get_operand()->get_type().

     ROSE_ASSERT(get_operand() != NULL);
     SgType* baseType = get_operand()->get_type();
     ROSE_ASSERT(baseType != NULL);

  // DQ (7/31/2006): Suggested change by Jeremiah.
  // SgType* returnType = SgPointerType::createType(baseType);
     SgClassDefinition* classDefinition = NULL;

  // DQ (7/31/2006): check if this is a data member of a class
  // (and save the class for the SgPointerMemberType::createType() function!)
     SgVarRefExp* varRefExp = isSgVarRefExp(get_operand());
     if (varRefExp != NULL)
        {
          ROSE_ASSERT(varRefExp->get_symbol() != NULL);
          ROSE_ASSERT(varRefExp->get_symbol()->get_declaration() != NULL);
          SgInitializedName* variable = varRefExp->get_symbol()->get_declaration();
          ROSE_ASSERT(variable != NULL);
          SgScopeStatement* scope = variable->get_scope();
          ROSE_ASSERT(scope != NULL);

          classDefinition = isSgClassDefinition(scope);
        }

  // printf ("In SgAddressOfOp::get_type(): classDefinition is valid = %s \n",(classDefinition != NULL) ? "true" : "false");

     SgType* returnType = NULL;
     if (classDefinition != NULL)
        {
          returnType = SgPointerMemberType::createType(baseType,classDefinition);
        }
       else
        {
          returnType = SgPointerType::createType(baseType);
        }

   //  ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgAddressOfOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgAddressOfOp::variantT() const {
  return V_SgAddressOfOp;
}

#if 0
int
SgAddressOfOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ADDRESS_OP;
   }
#endif

const char*
SgAddressOfOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgAddressOfOp";  
   }

std::string
SgAddressOfOp::class_name() const
   {
     assert(this != NULL);
     return "SgAddressOfOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgAddressOfOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgAddressOfOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ADDRESS_OP)
        {
          printf ("Error in SgAddressOfOp::error(): SgAddressOfOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgAddressOfOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ADDRESS_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgAddressOfOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgAddressOfOp::variant() const \n");
#endif
     assert(this != NULL);
     return ADDRESS_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgAddressOfOp* isSgAddressOfOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgAddressOfOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgAddressOfOp* isSgAddressOfOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgAddressOfOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgAddressOfOp::~SgAddressOfOp ()
   {
#if 0
  // debugging information!
     printf ("In SgAddressOfOp::~SgAddressOfOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgAddressOfOp::SgAddressOfOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgAddressOfOp::SgAddressOfOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(ADDRESS_OP == variant());
     post_construction_initialization();

  // Test the isSgAddressOfOp() function since it has been problematic
     assert(isSgAddressOfOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3235 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgMinusMinusOp::SgMinusMinusOp(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : SgUnaryOp(fi, exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this); 
   }

SgMinusMinusOp::SgMinusMinusOp(SgExpression * exp, Sgop_mode a_mode)
   : SgUnaryOp(exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this); 
   }

void
SgMinusMinusOp::post_construction_initialization()
   {
     set_mode(SgUnaryOp::prefix);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMinusMinusOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMinusMinusOp::variantT() const {
  return V_SgMinusMinusOp;
}

#if 0
int
SgMinusMinusOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MINUSMINUS_OP;
   }
#endif

const char*
SgMinusMinusOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMinusMinusOp";  
   }

std::string
SgMinusMinusOp::class_name() const
   {
     assert(this != NULL);
     return "SgMinusMinusOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMinusMinusOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMinusMinusOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MINUSMINUS_OP)
        {
          printf ("Error in SgMinusMinusOp::error(): SgMinusMinusOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMinusMinusOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MINUSMINUS_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMinusMinusOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMinusMinusOp::variant() const \n");
#endif
     assert(this != NULL);
     return MINUSMINUS_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMinusMinusOp* isSgMinusMinusOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMinusMinusOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMinusMinusOp* isSgMinusMinusOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMinusMinusOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMinusMinusOp::~SgMinusMinusOp ()
   {
#if 0
  // debugging information!
     printf ("In SgMinusMinusOp::~SgMinusMinusOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMinusMinusOp::SgMinusMinusOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgMinusMinusOp::SgMinusMinusOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MINUSMINUS_OP == variant());
     post_construction_initialization();

  // Test the isSgMinusMinusOp() function since it has been problematic
     assert(isSgMinusMinusOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3261 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

SgPlusPlusOp::SgPlusPlusOp(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : SgUnaryOp(fi, exp, NULL)
   {
     set_mode(a_mode); 
     if (exp)
          exp->set_parent(this);
   }

SgPlusPlusOp::SgPlusPlusOp( SgExpression * exp, Sgop_mode a_mode)
   : SgUnaryOp(exp, NULL)
   {
     set_mode(a_mode); 
     if (exp)
          exp->set_parent(this);
   }

void
SgPlusPlusOp::post_construction_initialization() 
   {
     set_mode(SgUnaryOp::prefix);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPlusPlusOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPlusPlusOp::variantT() const {
  return V_SgPlusPlusOp;
}

#if 0
int
SgPlusPlusOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return PLUSPLUS_OP;
   }
#endif

const char*
SgPlusPlusOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPlusPlusOp";  
   }

std::string
SgPlusPlusOp::class_name() const
   {
     assert(this != NULL);
     return "SgPlusPlusOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPlusPlusOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPlusPlusOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != PLUSPLUS_OP)
        {
          printf ("Error in SgPlusPlusOp::error(): SgPlusPlusOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPlusPlusOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == PLUSPLUS_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPlusPlusOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPlusPlusOp::variant() const \n");
#endif
     assert(this != NULL);
     return PLUSPLUS_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPlusPlusOp* isSgPlusPlusOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPlusPlusOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPlusPlusOp* isSgPlusPlusOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPlusPlusOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPlusPlusOp::~SgPlusPlusOp ()
   {
#if 0
  // debugging information!
     printf ("In SgPlusPlusOp::~SgPlusPlusOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPlusPlusOp::SgPlusPlusOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgPlusPlusOp::SgPlusPlusOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(PLUSPLUS_OP == variant());
     post_construction_initialization();

  // Test the isSgPlusPlusOp() function since it has been problematic
     assert(isSgPlusPlusOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgBitComplementOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3287 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgBitComplementOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgBitComplementOp::variantT() const {
  return V_SgBitComplementOp;
}

#if 0
int
SgBitComplementOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return BIT_COMPLEMENT_OP;
   }
#endif

const char*
SgBitComplementOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgBitComplementOp";  
   }

std::string
SgBitComplementOp::class_name() const
   {
     assert(this != NULL);
     return "SgBitComplementOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgBitComplementOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgBitComplementOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != BIT_COMPLEMENT_OP)
        {
          printf ("Error in SgBitComplementOp::error(): SgBitComplementOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgBitComplementOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == BIT_COMPLEMENT_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgBitComplementOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgBitComplementOp::variant() const \n");
#endif
     assert(this != NULL);
     return BIT_COMPLEMENT_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgBitComplementOp* isSgBitComplementOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgBitComplementOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgBitComplementOp* isSgBitComplementOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgBitComplementOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgBitComplementOp::~SgBitComplementOp ()
   {
#if 0
  // debugging information!
     printf ("In SgBitComplementOp::~SgBitComplementOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgBitComplementOp::SgBitComplementOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgBitComplementOp::SgBitComplementOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(BIT_COMPLEMENT_OP == variant());
     post_construction_initialization();

  // Test the isSgBitComplementOp() function since it has been problematic
     assert(isSgBitComplementOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgCastExp::cast_type_enum 
SgCastExp::get_cast_type () const
   {
     assert (this != NULL);
     return p_cast_type;
   }

void
SgCastExp::set_cast_type ( SgCastExp::cast_type_enum cast_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_cast_type = cast_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgCastExp::get_originalExpressionTree () const
   {
     assert (this != NULL);
     return p_originalExpressionTree;
   }

void
SgCastExp::set_originalExpressionTree ( SgExpression* originalExpressionTree )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_originalExpressionTree != NULL && originalExpressionTree != NULL && p_originalExpressionTree != originalExpressionTree)
        {
          printf ("Warning: originalExpressionTree = %p overwriting valid pointer p_originalExpressionTree = %p \n",originalExpressionTree,p_originalExpressionTree);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_originalExpressionTree != NULL && originalExpressionTree != NULL && p_originalExpressionTree != originalExpressionTree) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_originalExpressionTree = originalExpressionTree;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3466 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


void
SgCastExp::post_construction_initialization() 
   {
  // p_cast_type = c_cast_e;
     p_cast_type = e_C_style_cast;

  // DQ (1/14/2006): set_type is removed
  // set_type();
   }

// DQ (6/14/2005): Modified to make enum name consistant with elsewhere in ROSE (Sage III)
// SgCastExp::Sge_cast_type
SgCastExp::cast_type_enum
SgCastExp::cast_type()
   {
     return p_cast_type;
   }

SgType*
SgCastExp::get_type() const
   {
  // DQ (1/16/2006): In this function we want to return the stored p_expression_type.
  // This IR node has to store the type explicitly since there is no other way to 
  // recover what the cast is TO (since the operand stored what the cast in FROM).

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // printf ("SgCastOp::get_type(): p_expression_type has been removed from many IR nodes but is required for SgCastOp \n");

     ROSE_ASSERT(p_expression_type != NULL);
     return p_expression_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCastExp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCastExp::variantT() const {
  return V_SgCastExp;
}

#if 0
int
SgCastExp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CAST_OP;
   }
#endif

const char*
SgCastExp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCastExp";  
   }

std::string
SgCastExp::class_name() const
   {
     assert(this != NULL);
     return "SgCastExp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCastExp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCastExp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CAST_OP)
        {
          printf ("Error in SgCastExp::error(): SgCastExp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCastExp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CAST_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCastExp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCastExp::variant() const \n");
#endif
     assert(this != NULL);
     return CAST_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCastExp* isSgCastExp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCastExp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCastExp* isSgCastExp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCastExp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCastExp::~SgCastExp ()
   {
#if 0
  // debugging information!
     printf ("In SgCastExp::~SgCastExp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for cast_type
     p_cast_type = SgCastExp::e_C_style_cast; // non list case 
  // case: not a listType for originalExpressionTree
     p_originalExpressionTree = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCastExp::SgCastExp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type, SgCastExp::cast_type_enum cast_type )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgCastExp::SgCastExp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type, SgCastExp::cast_type_enum cast_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_cast_type = cast_type;
     p_originalExpressionTree = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CAST_OP == variant());
     post_construction_initialization();

  // Test the isSgCastExp() function since it has been problematic
     assert(isSgCastExp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 4415 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"

void
SgThrowOp::post_construction_initialization()
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypePtrListPtr 
SgThrowOp::get_typeList () const
   {
     assert (this != NULL);
     return p_typeList;
   }

void
SgThrowOp::set_typeList ( SgTypePtrListPtr typeList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_typeList = typeList;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgThrowOp::e_throw_kind 
SgThrowOp::get_throwKind () const
   {
     assert (this != NULL);
     return p_throwKind;
   }

void
SgThrowOp::set_throwKind ( SgThrowOp::e_throw_kind throwKind )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_throwKind = throwKind;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 4005 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Expression.code"


SgType*
SgThrowOp::get_type() const
   {
  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)

  // DQ (1/14/2006): For a list of types held internally it is not clear what to return.
  // So return a SgDefaultType as in Sage II previously.  Might be better to research
  // this in more details later.
     SgType* returnType = SgTypeDefault::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgThrowOp::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgThrowOp::variantT() const {
  return V_SgThrowOp;
}

#if 0
int
SgThrowOp::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return THROW_OP;
   }
#endif

const char*
SgThrowOp::sage_class_name() const
   {
     assert(this != NULL);
     return "SgThrowOp";  
   }

std::string
SgThrowOp::class_name() const
   {
     assert(this != NULL);
     return "SgThrowOp";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgThrowOp::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgThrowOp::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != THROW_OP)
        {
          printf ("Error in SgThrowOp::error(): SgThrowOp object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgThrowOp::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == THROW_OP);
     return SgUnaryOp::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgThrowOp::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgThrowOp::variant() const \n");
#endif
     assert(this != NULL);
     return THROW_OP;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgThrowOp* isSgThrowOp ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgThrowOp*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgThrowOp* isSgThrowOp ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgThrowOp*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgThrowOp::~SgThrowOp ()
   {
#if 0
  // debugging information!
     printf ("In SgThrowOp::~SgThrowOp (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: listType for typeList
  // case: listType (typeIsPointerToList == true) for typeList
     p_typeList = NULL;
  // case: not a listType for throwKind
     p_throwKind = SgThrowOp::unknown_throw; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgThrowOp::SgThrowOp ( Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type, SgTypePtrListPtr typeList, SgThrowOp::e_throw_kind throwKind )
   : SgUnaryOp(startOfConstruct, operand_i, expression_type)
   {
#ifdef DEBUG
  // printf ("In SgThrowOp::SgThrowOp (Sg_File_Info* startOfConstruct, SgExpression* operand_i, SgType* expression_type, SgTypePtrListPtr typeList, SgThrowOp::e_throw_kind throwKind) sage_class_name() = %s \n",sage_class_name());
#endif

     p_typeList = typeList;
     p_throwKind = throwKind;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(THROW_OP == variant());
     post_construction_initialization();

  // Test the isSgThrowOp() function since it has been problematic
     assert(isSgThrowOp(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgSymbol::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgSymbol::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgSymbol::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgSymbol::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgSymbol::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgSymbol::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgSymbol::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgSymbol::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgSymbol::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgSymbol::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 57 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

#if 1
// DQ (2/6/2007): This returns the basis for SgSymbol
SgNode*
SgSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif

// This function has been implement to support testing of the scope of 
// the declartion with the scope of where the symbols are placed 
// (within the inserion and checking og symbol tables).
SgScopeStatement*
SgSymbol::get_scope() const
   {
     SgScopeStatement* scope = NULL;
     const SgNode* basis = get_symbol_basis();

     ROSE_ASSERT(basis != NULL);
  // printf ("In SgSymbol::get_scope(): basis = %p = %s \n",basis,basis->class_name().c_str());

     const SgInitializedName* initializedName = isSgInitializedName(basis);
     if (initializedName != NULL)
        {
          scope = initializedName->get_scope();
        }

     const SgStatement* statement = isSgStatement(basis);
     if (statement != NULL)
        {
          scope = statement->get_scope();
        }

     ROSE_ASSERT(scope != NULL);
     return scope;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgSymbol::variantT() const {
  return V_SgSymbol;
}

#if 0
int
SgSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return SymbolTag;
   }
#endif

const char*
SgSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgSymbol";  
   }

std::string
SgSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != SymbolTag)
        {
          printf ("Error in SgSymbol::error(): SgSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == SymbolTag);
     return SgNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return SymbolTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgSymbol* isSgSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgSymbol* isSgSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgSymbol::~SgSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgSymbol::~SgSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgSymbol::SgSymbol (  )
   : SgNode()
   {
#ifdef DEBUG
  // printf ("In SgSymbol::SgSymbol () sage_class_name() = %s \n",sage_class_name());
#endif

     p_attributeMechanism = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(SymbolTag == variant());
     post_construction_initialization();

  // Test the isSgSymbol() function since it has been problematic
     assert(isSgSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgVariableSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgVariableSymbol::set_declaration ( SgInitializedName* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgVariableSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgVariableSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 123 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName 
SgVariableSymbol::get_name() const
   {
#if 0
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration() != NULL) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

#if 1
// DQ (2/6/2007): This returns the basis for the SgVariableSymbol (an SgInitializedName object)
SgNode*
SgVariableSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgVariableSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgVariableSymbol::variantT() const {
  return V_SgVariableSymbol;
}

#if 0
int
SgVariableSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return VARIABLE_NAME;
   }
#endif

const char*
SgVariableSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgVariableSymbol";  
   }

std::string
SgVariableSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgVariableSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgVariableSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgVariableSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != VARIABLE_NAME)
        {
          printf ("Error in SgVariableSymbol::error(): SgVariableSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgVariableSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == VARIABLE_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgVariableSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgVariableSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return VARIABLE_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgVariableSymbol* isSgVariableSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgVariableSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgVariableSymbol* isSgVariableSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgVariableSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgVariableSymbol::~SgVariableSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgVariableSymbol::~SgVariableSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgVariableSymbol::SgVariableSymbol ( SgInitializedName* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgVariableSymbol::SgVariableSymbol (SgInitializedName* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(VARIABLE_NAME == variant());
     post_construction_initialization();

  // Test the isSgVariableSymbol() function since it has been problematic
     assert(isSgVariableSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgName 
SgFunctionTypeSymbol::get_name () const
   {
     assert (this != NULL);
     return p_name;
   }

void
SgFunctionTypeSymbol::set_name ( SgName name )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_name = name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgFunctionTypeSymbol::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgFunctionTypeSymbol::set_type ( SgType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionTypeSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionTypeSymbol::variantT() const {
  return V_SgFunctionTypeSymbol;
}

#if 0
int
SgFunctionTypeSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNCTYPE_NAME;
   }
#endif

const char*
SgFunctionTypeSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionTypeSymbol";  
   }

std::string
SgFunctionTypeSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionTypeSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionTypeSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionTypeSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNCTYPE_NAME)
        {
          printf ("Error in SgFunctionTypeSymbol::error(): SgFunctionTypeSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionTypeSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNCTYPE_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionTypeSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionTypeSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return FUNCTYPE_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionTypeSymbol* isSgFunctionTypeSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionTypeSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionTypeSymbol* isSgFunctionTypeSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionTypeSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionTypeSymbol::~SgFunctionTypeSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionTypeSymbol::~SgFunctionTypeSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for type
     p_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionTypeSymbol::SgFunctionTypeSymbol ( SgName name, SgType* type )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgFunctionTypeSymbol::SgFunctionTypeSymbol (SgName name, SgType* type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_type = type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNCTYPE_NAME == variant());
     post_construction_initialization();

  // Test the isSgFunctionTypeSymbol() function since it has been problematic
     assert(isSgFunctionTypeSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDeclaration* 
SgClassSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgClassSymbol::set_declaration ( SgClassDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgClassSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgClassSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgClassSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgClassSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassSymbol::variantT() const {
  return V_SgClassSymbol;
}

#if 0
int
SgClassSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return CLASS_NAME;
   }
#endif

const char*
SgClassSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassSymbol";  
   }

std::string
SgClassSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgClassSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != CLASS_NAME)
        {
          printf ("Error in SgClassSymbol::error(): SgClassSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == CLASS_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return CLASS_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassSymbol* isSgClassSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassSymbol* isSgClassSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassSymbol::~SgClassSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgClassSymbol::~SgClassSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClassSymbol::SgClassSymbol ( SgClassDeclaration* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgClassSymbol::SgClassSymbol (SgClassDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(CLASS_NAME == variant());
     post_construction_initialization();

  // Test the isSgClassSymbol() function since it has been problematic
     assert(isSgClassSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTemplateDeclaration* 
SgTemplateSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgTemplateSymbol::set_declaration ( SgTemplateDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 176 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgTemplateSymbol::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
SgTemplateSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgTemplateSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgTemplateSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateSymbol::variantT() const {
  return V_SgTemplateSymbol;
}

#if 0
int
SgTemplateSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TEMPLATE_NAME;
   }
#endif

const char*
SgTemplateSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateSymbol";  
   }

std::string
SgTemplateSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TEMPLATE_NAME)
        {
          printf ("Error in SgTemplateSymbol::error(): SgTemplateSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TEMPLATE_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return TEMPLATE_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateSymbol* isSgTemplateSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateSymbol* isSgTemplateSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateSymbol::~SgTemplateSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateSymbol::~SgTemplateSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateSymbol::SgTemplateSymbol ( SgTemplateDeclaration* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgTemplateSymbol::SgTemplateSymbol (SgTemplateDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TEMPLATE_NAME == variant());
     post_construction_initialization();

  // Test the isSgTemplateSymbol() function since it has been problematic
     assert(isSgTemplateSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgEnumDeclaration* 
SgEnumSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgEnumSymbol::set_declaration ( SgEnumDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgEnumSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgEnumSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgEnumSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgEnumSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEnumSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEnumSymbol::variantT() const {
  return V_SgEnumSymbol;
}

#if 0
int
SgEnumSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return ENUM_NAME;
   }
#endif

const char*
SgEnumSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEnumSymbol";  
   }

std::string
SgEnumSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgEnumSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEnumSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEnumSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != ENUM_NAME)
        {
          printf ("Error in SgEnumSymbol::error(): SgEnumSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEnumSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == ENUM_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEnumSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEnumSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return ENUM_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEnumSymbol* isSgEnumSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEnumSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEnumSymbol* isSgEnumSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEnumSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEnumSymbol::~SgEnumSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgEnumSymbol::~SgEnumSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEnumSymbol::SgEnumSymbol ( SgEnumDeclaration* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgEnumSymbol::SgEnumSymbol (SgEnumDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(ENUM_NAME == variant());
     post_construction_initialization();

  // Test the isSgEnumSymbol() function since it has been problematic
     assert(isSgEnumSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgEnumFieldSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgEnumFieldSymbol::set_declaration ( SgInitializedName* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgEnumFieldSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgEnumFieldSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgEnumFieldSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgEnumFieldSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEnumFieldSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEnumFieldSymbol::variantT() const {
  return V_SgEnumFieldSymbol;
}

#if 0
int
SgEnumFieldSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FIELD_NAME;
   }
#endif

const char*
SgEnumFieldSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEnumFieldSymbol";  
   }

std::string
SgEnumFieldSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgEnumFieldSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEnumFieldSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEnumFieldSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FIELD_NAME)
        {
          printf ("Error in SgEnumFieldSymbol::error(): SgEnumFieldSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEnumFieldSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FIELD_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEnumFieldSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEnumFieldSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return FIELD_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEnumFieldSymbol* isSgEnumFieldSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEnumFieldSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEnumFieldSymbol* isSgEnumFieldSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEnumFieldSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEnumFieldSymbol::~SgEnumFieldSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgEnumFieldSymbol::~SgEnumFieldSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEnumFieldSymbol::SgEnumFieldSymbol ( SgInitializedName* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgEnumFieldSymbol::SgEnumFieldSymbol (SgInitializedName* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FIELD_NAME == variant());
     post_construction_initialization();

  // Test the isSgEnumFieldSymbol() function since it has been problematic
     assert(isSgEnumFieldSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypedefDeclaration* 
SgTypedefSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgTypedefSymbol::set_declaration ( SgTypedefDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgTypedefSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgTypedefSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgTypedefSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgTypedefSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypedefSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypedefSymbol::variantT() const {
  return V_SgTypedefSymbol;
}

#if 0
int
SgTypedefSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TYPEDEF_NAME;
   }
#endif

const char*
SgTypedefSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypedefSymbol";  
   }

std::string
SgTypedefSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgTypedefSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypedefSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypedefSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TYPEDEF_NAME)
        {
          printf ("Error in SgTypedefSymbol::error(): SgTypedefSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypedefSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TYPEDEF_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypedefSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypedefSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return TYPEDEF_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypedefSymbol* isSgTypedefSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypedefSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypedefSymbol* isSgTypedefSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypedefSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypedefSymbol::~SgTypedefSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgTypedefSymbol::~SgTypedefSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypedefSymbol::SgTypedefSymbol ( SgTypedefDeclaration* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgTypedefSymbol::SgTypedefSymbol (SgTypedefDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(TYPEDEF_NAME == variant());
     post_construction_initialization();

  // Test the isSgTypedefSymbol() function since it has been problematic
     assert(isSgTypedefSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgLabelStatement* 
SgLabelSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgLabelSymbol::set_declaration ( SgLabelStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 176 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgLabelSymbol::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
SgLabelSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgLabelSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgLabelSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgLabelSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgLabelSymbol::variantT() const {
  return V_SgLabelSymbol;
}

#if 0
int
SgLabelSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return LABEL_NAME;
   }
#endif

const char*
SgLabelSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgLabelSymbol";  
   }

std::string
SgLabelSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgLabelSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgLabelSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgLabelSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != LABEL_NAME)
        {
          printf ("Error in SgLabelSymbol::error(): SgLabelSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgLabelSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == LABEL_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgLabelSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgLabelSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return LABEL_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgLabelSymbol* isSgLabelSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgLabelSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgLabelSymbol* isSgLabelSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgLabelSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgLabelSymbol::~SgLabelSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgLabelSymbol::~SgLabelSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgLabelSymbol::SgLabelSymbol ( SgLabelStatement* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgLabelSymbol::SgLabelSymbol (SgLabelStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(LABEL_NAME == variant());
     post_construction_initialization();

  // Test the isSgLabelSymbol() function since it has been problematic
     assert(isSgLabelSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgDefaultSymbol::get_type () const
   {
     assert (this != NULL);
     return p_type;
   }

void
SgDefaultSymbol::set_type ( SgType* type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type != NULL && type != NULL && p_type != type)
        {
          printf ("Warning: type = %p overwriting valid pointer p_type = %p \n",type,p_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type != NULL && type != NULL && p_type != type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type = type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 226 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgDefaultSymbol::get_name() const 
   {
     return "Default_Symbol_Name";
   }

// DQ (2/6/2007): This returns the basis for the SHORT_DEFAULT_GET_NAME
SgNode*
SgDefaultSymbol::get_symbol_basis() const
   {
     return NULL;
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgDefaultSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgDefaultSymbol::variantT() const {
  return V_SgDefaultSymbol;
}

#if 0
int
SgDefaultSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return DEFAULT_NAME;
   }
#endif

const char*
SgDefaultSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgDefaultSymbol";  
   }

std::string
SgDefaultSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgDefaultSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgDefaultSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgDefaultSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != DEFAULT_NAME)
        {
          printf ("Error in SgDefaultSymbol::error(): SgDefaultSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgDefaultSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == DEFAULT_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgDefaultSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgDefaultSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return DEFAULT_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgDefaultSymbol* isSgDefaultSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgDefaultSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgDefaultSymbol* isSgDefaultSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgDefaultSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgDefaultSymbol::~SgDefaultSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgDefaultSymbol::~SgDefaultSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for type
     p_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgDefaultSymbol::SgDefaultSymbol ( SgType* type )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgDefaultSymbol::SgDefaultSymbol (SgType* type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_type = type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(DEFAULT_NAME == variant());
     post_construction_initialization();

  // Test the isSgDefaultSymbol() function since it has been problematic
     assert(isSgDefaultSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgNamespaceDeclarationStatement* 
SgNamespaceSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgNamespaceSymbol::set_declaration ( SgNamespaceDeclarationStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 176 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgNamespaceSymbol::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
SgNamespaceSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgNamespaceSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgNamespaceSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNamespaceSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNamespaceSymbol::variantT() const {
  return V_SgNamespaceSymbol;
}

#if 0
int
SgNamespaceSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return NAMESPACE_NAME;
   }
#endif

const char*
SgNamespaceSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceSymbol";  
   }

std::string
SgNamespaceSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgNamespaceSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNamespaceSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNamespaceSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != NAMESPACE_NAME)
        {
          printf ("Error in SgNamespaceSymbol::error(): SgNamespaceSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNamespaceSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == NAMESPACE_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNamespaceSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNamespaceSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return NAMESPACE_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNamespaceSymbol* isSgNamespaceSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNamespaceSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNamespaceSymbol* isSgNamespaceSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNamespaceSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNamespaceSymbol::~SgNamespaceSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgNamespaceSymbol::~SgNamespaceSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for name
     p_name = ""; // non list case 
  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNamespaceSymbol::SgNamespaceSymbol ( SgName name, SgNamespaceDeclarationStatement* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgNamespaceSymbol::SgNamespaceSymbol (SgName name, SgNamespaceDeclarationStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_name = name;
     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(NAMESPACE_NAME == variant());
     post_construction_initialization();

  // Test the isSgNamespaceSymbol() function since it has been problematic
     assert(isSgNamespaceSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgIntrinsicSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgIntrinsicSymbol::set_declaration ( SgInitializedName* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgIntrinsicSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgIntrinsicSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 374 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName 
SgIntrinsicSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

SgNode*
SgIntrinsicSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgIntrinsicSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgIntrinsicSymbol::variantT() const {
  return V_SgIntrinsicSymbol;
}

#if 0
int
SgIntrinsicSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INTRINSIC_SYMBOL;
   }
#endif

const char*
SgIntrinsicSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgIntrinsicSymbol";  
   }

std::string
SgIntrinsicSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgIntrinsicSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgIntrinsicSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgIntrinsicSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INTRINSIC_SYMBOL)
        {
          printf ("Error in SgIntrinsicSymbol::error(): SgIntrinsicSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgIntrinsicSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INTRINSIC_SYMBOL);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgIntrinsicSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgIntrinsicSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return INTRINSIC_SYMBOL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgIntrinsicSymbol* isSgIntrinsicSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgIntrinsicSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgIntrinsicSymbol* isSgIntrinsicSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgIntrinsicSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgIntrinsicSymbol::~SgIntrinsicSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgIntrinsicSymbol::~SgIntrinsicSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgIntrinsicSymbol::SgIntrinsicSymbol ( SgInitializedName* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgIntrinsicSymbol::SgIntrinsicSymbol (SgInitializedName* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INTRINSIC_SYMBOL == variant());
     post_construction_initialization();

  // Test the isSgIntrinsicSymbol() function since it has been problematic
     assert(isSgIntrinsicSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgModuleStatement* 
SgModuleSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgModuleSymbol::set_declaration ( SgModuleStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 176 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgModuleSymbol::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
SgModuleSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 311 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName 
SgModuleSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

// DQ (2/6/2007): This returns the basis for the SgModuleSymbol
SgNode*
SgModuleSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModuleSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModuleSymbol::variantT() const {
  return V_SgModuleSymbol;
}

#if 0
int
SgModuleSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MODULE_SYMBOL;
   }
#endif

const char*
SgModuleSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModuleSymbol";  
   }

std::string
SgModuleSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgModuleSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModuleSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModuleSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MODULE_SYMBOL)
        {
          printf ("Error in SgModuleSymbol::error(): SgModuleSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModuleSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MODULE_SYMBOL);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModuleSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModuleSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return MODULE_SYMBOL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModuleSymbol* isSgModuleSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModuleSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModuleSymbol* isSgModuleSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModuleSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModuleSymbol::~SgModuleSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgModuleSymbol::~SgModuleSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModuleSymbol::SgModuleSymbol ( SgModuleStatement* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgModuleSymbol::SgModuleSymbol (SgModuleStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(MODULE_SYMBOL == variant());
     post_construction_initialization();

  // Test the isSgModuleSymbol() function since it has been problematic
     assert(isSgModuleSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInterfaceStatement* 
SgInterfaceSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgInterfaceSymbol::set_declaration ( SgInterfaceStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 176 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgInterfaceSymbol::get_type() const 
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
SgInterfaceSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 405 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgInterfaceSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

SgNode*
SgInterfaceSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgInterfaceSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgInterfaceSymbol::variantT() const {
  return V_SgInterfaceSymbol;
}

#if 0
int
SgInterfaceSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return INTERFACE_SYMBOL;
   }
#endif

const char*
SgInterfaceSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgInterfaceSymbol";  
   }

std::string
SgInterfaceSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgInterfaceSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgInterfaceSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgInterfaceSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != INTERFACE_SYMBOL)
        {
          printf ("Error in SgInterfaceSymbol::error(): SgInterfaceSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgInterfaceSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == INTERFACE_SYMBOL);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgInterfaceSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgInterfaceSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return INTERFACE_SYMBOL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgInterfaceSymbol* isSgInterfaceSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgInterfaceSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgInterfaceSymbol* isSgInterfaceSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgInterfaceSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgInterfaceSymbol::~SgInterfaceSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgInterfaceSymbol::~SgInterfaceSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgInterfaceSymbol::SgInterfaceSymbol ( SgInterfaceStatement* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgInterfaceSymbol::SgInterfaceSymbol (SgInterfaceStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(INTERFACE_SYMBOL == variant());
     post_construction_initialization();

  // Test the isSgInterfaceSymbol() function since it has been problematic
     assert(isSgInterfaceSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgInitializedName* 
SgCommonSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgCommonSymbol::set_declaration ( SgInitializedName* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgCommonSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgCommonSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 343 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName 
SgCommonSymbol::get_name() const
   {
#if 1 
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      SgName theName;

      if (get_declaration()) 
         {
           theName = get_declaration()->get_name();
         } 
        else 
         {
           theName = SgName("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

SgNode*
SgCommonSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgCommonSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgCommonSymbol::variantT() const {
  return V_SgCommonSymbol;
}

#if 0
int
SgCommonSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return COMMON_SYMBOL;
   }
#endif

const char*
SgCommonSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgCommonSymbol";  
   }

std::string
SgCommonSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgCommonSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgCommonSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgCommonSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != COMMON_SYMBOL)
        {
          printf ("Error in SgCommonSymbol::error(): SgCommonSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgCommonSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == COMMON_SYMBOL);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgCommonSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgCommonSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return COMMON_SYMBOL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgCommonSymbol* isSgCommonSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgCommonSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgCommonSymbol* isSgCommonSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgCommonSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgCommonSymbol::~SgCommonSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgCommonSymbol::~SgCommonSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgCommonSymbol::SgCommonSymbol ( SgInitializedName* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgCommonSymbol::SgCommonSymbol (SgInitializedName* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(COMMON_SYMBOL == variant());
     post_construction_initialization();

  // Test the isSgCommonSymbol() function since it has been problematic
     assert(isSgCommonSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionDeclaration* 
SgFunctionSymbol::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgFunctionSymbol::set_declaration ( SgFunctionDeclaration* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgFunctionSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgFunctionSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgFunctionSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgFunctionSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionSymbol::variantT() const {
  return V_SgFunctionSymbol;
}

#if 0
int
SgFunctionSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return FUNCTION_NAME;
   }
#endif

const char*
SgFunctionSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionSymbol";  
   }

std::string
SgFunctionSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != FUNCTION_NAME)
        {
          printf ("Error in SgFunctionSymbol::error(): SgFunctionSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == FUNCTION_NAME);
     return SgSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return FUNCTION_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionSymbol* isSgFunctionSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionSymbol* isSgFunctionSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionSymbol::~SgFunctionSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionSymbol::~SgFunctionSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionSymbol::SgFunctionSymbol ( SgFunctionDeclaration* declaration )
   : SgSymbol()
   {
#ifdef DEBUG
  // printf ("In SgFunctionSymbol::SgFunctionSymbol (SgFunctionDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(FUNCTION_NAME == variant());
     post_construction_initialization();

  // Test the isSgFunctionSymbol() function since it has been problematic
     assert(isSgFunctionSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 158 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgType*
SgMemberFunctionSymbol::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
SgMemberFunctionSymbol::get_symbol_basis() const
   {
     return get_type();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 194 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"

SgName
SgMemberFunctionSymbol::get_name() const 
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgMemberFunctionSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 242 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Symbol.code"


SgMemberFunctionDeclaration*
SgMemberFunctionSymbol::get_declaration() const
   {
     SgFunctionDeclaration* funcionDeclaration = SgFunctionSymbol::get_declaration();
     if (funcionDeclaration == NULL)
          return NULL;
     SgMemberFunctionDeclaration* memberFuncionDeclaration = isSgMemberFunctionDeclaration(funcionDeclaration);
     ROSE_ASSERT(memberFuncionDeclaration != NULL);
     return memberFuncionDeclaration; 
   }

#if 1
// DQ (6/10/2007): This is now depricated in favor of a more uniform implementation for all symbols.
// This is used in the hidden list intersection code: 
//      astHiddenTypeAndDeclarationLists/HiddenList_Intersection.C
// and maybe else where as well.
SgClassDefinition*
SgMemberFunctionSymbol::get_scope() const
   {
  // DQ (7/28/2007): Call the base class instead
  // ROSE_ASSERT(get_declaration() != NULL);
  // return get_declaration()->get_class_scope();
     SgScopeStatement* scope = SgSymbol::get_scope();
     ROSE_ASSERT(scope != NULL);
     SgClassDefinition* classDefinition = isSgClassDefinition(scope);

     if (classDefinition == NULL)
        {
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgMemberFunctionSymbol::get_scope() (scope is not a SgClassDefinition, likely a pointer to member function): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif
        }
  // ROSE_ASSERT(classDefinition != NULL);

     return classDefinition;
   }
#endif
#if 0
// DQ (2/6/2007): This returns the basis for the DECLARATION
SgNode*
SgMemberFunctionSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMemberFunctionSymbol::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMemberFunctionSymbol::variantT() const {
  return V_SgMemberFunctionSymbol;
}

#if 0
int
SgMemberFunctionSymbol::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return MEMBER_FUNC_NAME;
   }
#endif

const char*
SgMemberFunctionSymbol::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionSymbol";  
   }

std::string
SgMemberFunctionSymbol::class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionSymbol";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMemberFunctionSymbol::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMemberFunctionSymbol::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != MEMBER_FUNC_NAME)
        {
          printf ("Error in SgMemberFunctionSymbol::error(): SgMemberFunctionSymbol object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMemberFunctionSymbol::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == MEMBER_FUNC_NAME);
     return SgFunctionSymbol::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMemberFunctionSymbol::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMemberFunctionSymbol::variant() const \n");
#endif
     assert(this != NULL);
     return MEMBER_FUNC_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMemberFunctionSymbol* isSgMemberFunctionSymbol ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMemberFunctionSymbol*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMemberFunctionSymbol* isSgMemberFunctionSymbol ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMemberFunctionSymbol*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMemberFunctionSymbol::~SgMemberFunctionSymbol ()
   {
#if 0
  // debugging information!
     printf ("In SgMemberFunctionSymbol::~SgMemberFunctionSymbol (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMemberFunctionSymbol::SgMemberFunctionSymbol ( SgFunctionDeclaration* declaration )
   : SgFunctionSymbol(declaration)
   {
#ifdef DEBUG
  // printf ("In SgMemberFunctionSymbol::SgMemberFunctionSymbol (SgFunctionDeclaration* declaration) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(MEMBER_FUNC_NAME == variant());
     post_construction_initialization();

  // Test the isSgMemberFunctionSymbol() function since it has been problematic
     assert(isSgMemberFunctionSymbol(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 1110 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


//! SgType default constructor (initializes all local variables)
SgType::SgType()
   : p_substitutedForTemplateParam(false),
     p_ref_to(NULL),
     p_ptr_to(NULL),
     p_modifiers(NULL),
     p_typedefs(NULL),
     p_attributeMechanism(NULL),
     p_type_kind(NULL)
   {
     ROSE_ASSERT(p_ref_to == NULL);
     ROSE_ASSERT(p_ptr_to == NULL);
     ROSE_ASSERT(p_modifiers == NULL);
     p_typedefs = new SgTypedefSeq();
     ROSE_ASSERT(p_typedefs != NULL);

     ROSE_ASSERT(p_type_kind == NULL);

  // DQ (1/25/2007): Let's try this again!
  // DQ (6/25/2006): Commented out to allow File I/O to work, I don't understand why it is required!
  // DQ (5/11/2006): Added to avoid NULL pointer
     p_typedefs->set_parent(this);
   }


SgType::SgType(const SgType & X)
   : p_substitutedForTemplateParam(X.p_substitutedForTemplateParam),
     p_ref_to(X.p_ref_to), 
     p_ptr_to(X.p_ptr_to),
     p_modifiers(X.p_modifiers),
     p_typedefs(X.p_typedefs),
     p_attributeMechanism(X.p_attributeMechanism),
     p_type_kind(X.p_type_kind)
   {
  // DQ (10/17/2007): This copy constructor is built to support the AST copy mechanism where for
  // some declarations that generate named types, the types are copied. and fixed up in a later 
  // phase (e.g. SgClassDeclaration::fixupCopy()).

  // I think if we copy X then we want to assume that it has these values, but it might
  // be acceptable if it didn't, but then a more complex copy would be required.

#if 0
  // DQ (10/17/2007) Commented out (see copytest2007_14.C).
     ROSE_ASSERT(p_ref_to == NULL);
     ROSE_ASSERT(p_ptr_to == NULL);
     ROSE_ASSERT(p_modifiers == NULL);
     ROSE_ASSERT(p_type_kind == NULL);
#endif

     p_typedefs = new SgTypedefSeq();
     ROSE_ASSERT(p_typedefs != NULL);
     p_typedefs->set_parent(this);
   }


#if 0
SgType::~SgType()
   {
     delete p_modifiers;
     delete p_typedefs;
   }
#endif

// SgName SgType::get_mangled(SgUnparse_Info& info)
SgName
SgType::get_mangled(void) const
   {
  // This should be an error, I think!
     printf ("ERROR: base calss get_mangled functions should not be called! \n");
     ROSE_ABORT();

     return "";
   }

#if 0
// DQ (3/2/2003): Implement get_parent from SgNode
SgNode*
SgType::get_parent() const
   {
     ROSE_ASSERT(this != NULL);
     return NULL;   // this is the original sage 2 code (but I think it should return p_parent)
  // return (SgType*) p_parent;
   }
#endif

#if 0
//! virtual functions define to return false
//! (will be overwritten on only a few of the derived classes)
bool SgType::isConst() const       { return false; }
bool SgType::isVolatile() const    { return false; }
bool SgType::isRestrict() const    { return false; }
bool SgType::isUPC_Shared() const  { return false; }
bool SgType::isUPC_Strict() const  { return false; }
bool SgType::isUPC_Relaxed() const { return false; }
#endif

#if 0
bool SgType::isExtern() const    { return false; }
bool SgType::isTypedef() const   { return false; }
bool SgType::isVirtual() const   { return false; }
bool SgType::isProtected() const { return false; }
bool SgType::isPrivate() const   { return false; }
bool SgType::isPublic() const    { return false; }
bool SgType::isAuto() const      { return false; }
#endif

// bool SgType::isGlobal() const    { return false; }
// bool SgType::isSync() const      { return false; }

#if 0
// These are unimplemented within SAGE 2
bool
SgType::isLong() const
   { return false; }

bool
SgType::isShort() const
   { return false; }
#endif

#if 0
// This codes was part of an experiment to distinguish struct tag { int x; } X; from struct tag X;
// It turns out that the declaration of the tag in this case in placed into the EDG orphan list
// as a type and that we don't require this mechanism (thought we might in the future so for now
// it is just commented out.
bool
SgType::isFirstDeclaration() const
   { return (p_useWithinDeclaration & e_first_declaration); }

void
SgType::setFirstDeclaration()
   { p_useWithinDeclaration |= e_first_declaration; }

void
SgType::unsetFirstDeclaration()
   { p_useWithinDeclaration &= ~e_first_declaration; }

bool
SgType::isAutonomousTagDeclaration() const
   { return (p_useWithinDeclaration & e_autonomous_tag_declaration); }

void
SgType::setAutonomousTagDeclaration()
   { p_useWithinDeclaration |= e_autonomous_tag_declaration; }

void
SgType::unsetAutonomousTagDeclaration()
   { p_useWithinDeclaration &= ~e_autonomous_tag_declaration; }
#endif

#if 0
SgModifierType*
SgType::matchModifiers (unsigned int f)
   {
     if (p_modifiers) 
        {
          return p_modifiers->match(this, f);
        } 
       else 
        {
          return (p_modifiers = new SgModifierNodes())->match(this, f);
        }
   }
#endif

bool
SgType::isIntegerType() const
   {
     const SgType* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
        {
          t = ((SgTypedefType *) t)->get_base_type();
          ROSE_ASSERT(t != NULL);
        }

     switch (variant())
        {
          case T_CHAR:	
          case T_SIGNED_CHAR:
          case T_UNSIGNED_CHAR:
          case T_SHORT:
          case T_SIGNED_SHORT:
          case T_UNSIGNED_SHORT:
          case T_INT:
          case T_SIGNED_INT:
          case T_UNSIGNED_INT:
          case T_LONG:
          case T_SIGNED_LONG:
          case T_UNSIGNED_LONG:
          case T_WCHAR:
          case T_LONG_LONG:
          case T_UNSIGNED_LONG_LONG:
          case T_BOOL:
               return true; // 1
               break;
          default:
               return false; // 0
        }
   }

bool
SgType::isFloatType() const
   {
     const SgType* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     switch (t->variant())
        {
          case T_FLOAT :
          case T_DOUBLE:
          case T_LONG_DOUBLE:
               return 1;
          default:
               return 0;
        }
   }

bool
SgType::isUnsignedType() const
   {
     switch (variant()) 
        {
          case T_UNSIGNED_CHAR:
          case T_UNSIGNED_SHORT:
          case T_UNSIGNED_INT:
               return 1;
               break;
          default:
               return 0;
        }
   }



SgType*
SgType::integer_promotion(SgType * t1, SgType * t2)
   {
     if(!t1) return t2; 
     if(!t2) return t1;

     if (t1->variant() == T_UNSIGNED_LONG || t2->variant() == T_UNSIGNED_LONG) 
          return SgTypeUnsignedLong::createType();

  // This should only be if long can hold unsigned int, not always true!!
     if (t1->variant() == T_UNSIGNED_INT || t2->variant() == T_UNSIGNED_INT) 
          return SgTypeLong::createType();

     if (t1->isUnsignedType()) 
          return t1;
       else
          if (t2->isUnsignedType() )
               return t2; 
            else
               return SgTypeInt::createType();
   }

SgType*
SgType::float_promotion( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2; 
     if(!t2) return t1;

     if (t1->variant() == T_LONG_DOUBLE)
          return t1;
       else
          if (t2->variant() == T_LONG_DOUBLE)
               return t2;
            else
               if (t1->variant() == T_DOUBLE)
                    return t1;
                 else
                    if (t2->variant() == T_DOUBLE)
                         return t2;
                      else
                         return t1;
   }

#if 0
// DQ (4/5/2004): Removed since it is not used anywhere!
SgType*
SgType::rmModifier ( SgType* t1, int which )
   {
     SgType* tmp_type = t1;

     ROSE_ASSERT(t1 != NULL);

     if(t1->variant()==T_MODIFIER)
        {
          SgModifierType *mod = (SgModifierType *) t1;
          ROSE_ASSERT(mod != NULL);

          SgType *btype = mod->get_base_type();

          int modval = mod->get_bitfield();

          if(mod->isSync() && (which & e_sync))
               modval &= ~SgModifierType::m_sync;

          if(mod->isGlobal() && (which & e_global))
               modval &= ~SgModifierType::m_global;

          if(mod->isConst() && (which & e_const))
               modval &= ~SgModifierType::m_const;

          tmp_type = (modval) ? SgModifierType::createType(btype,modval) : btype;
        }

     return tmp_type;
   }
#endif

#if 0
// DQ (4/5/2004): Removed since it is not used anywhere!
SgType*
SgType::addModifier(SgType *t1, int which)
   {
     SgType* tmp_type = t1;
     SgType* btype;
     int modval;

     ROSE_ASSERT(t1 != NULL);

     if(t1->variant()==T_MODIFIER)
        {
          SgModifierType *mod=(SgModifierType *) t1;
          btype=mod->get_base_type();
          modval=mod->get_bitfield();
        }
       else
        {
          btype=t1;
          modval=0;
        }

     if(which & e_sync)   modval |= SgModifierType::m_sync;
     if(which & e_global) modval |= SgModifierType::m_global;
     if(which & e_const)  modval |= SgModifierType::m_const;

     tmp_type = SgModifierType::createType(btype,modval);

     return tmp_type;
   }
#endif

SgType* 
SgType::arithmetic_conversions ( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2;
     if(!t2) return t1;

  // DQ (4/5/2004): Removed since it is the only use of rmModifier and e_sync is not used anywhere!
  // if (isSgModifierType(t1)) t1 = rmModifier(t1,e_sync);
  // if (isSgModifierType(t2)) t2 = rmModifier(t2,e_sync);

     if (t1->isFloatType() && t2->isIntegerType()) 
          return t1;

     if (t2->isFloatType() && t1->isIntegerType()) 
          return t2;

     if (t1->isIntegerType()) 
          return integer_promotion(t1,t2);
       else
          return float_promotion(t1,t2);
   }

SgType*
SgType::dereference() 
   {
  // This function does not recursively decend into types, so it should not use the lower 
  // level SgType::stripType() member function.

     SgType* t = this;
     ROSE_ASSERT(t != NULL);
     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     if (t->variant() == T_POINTER)
          return ((SgPointerType *) t)->get_base_type();
       else
          if (t->variant() == T_REFERENCE) 
               return ((SgReferenceType *) t)->get_base_type();
            else
               if(t->variant() == T_ARRAY)
                    return ((SgArrayType *) t)->get_base_type();
                 else
                    return (SgType*)t;
   }

SgType*
SgType::stripTypedefsAndModifiers() const
   {
  // DQ (6/30/2005): This function answers the question of what type is this? It recursively 
  // strips away typedefs until we reach something not typedefeds, thus we stop at any pointer 
  // or references (but not modifiers).
#if 0
     SgType *returnType = const_cast<SgType*>(this);
     ROSE_ASSERT(returnType != NULL);

     SgTypedefType* typedefType   = isSgTypedefType(returnType);
     SgModifierType* modifierType = isSgModifierType(returnType);
     while (typedefType != NULL || modifierType != NULL)
  // while (isSgTypedefType(returnType) != NULL || isSgModifierType(returnType) != NULL)
        {
          if (typedefType != NULL)
             {
               returnType = typedefType->get_base_type();
             }
          if (modifierType != NULL)
             {
               returnType = modifierType->get_base_type();
             }

       // reset the typedefType and modifierType variables
          typedefType  = isSgTypedefType(returnType);
          modifierType = isSgModifierType(returnType);          
        }

     ROSE_ASSERT (returnType != NULL);

     return returnType;
#else
  // DQ (10/11/2007): Modified this function to use SgType::stripType().
  // This uses a subset of the possible or'd values available with SgType::stripType()
     return stripType(STRIP_MODIFIER_TYPE | STRIP_TYPEDEF_TYPE);
#endif
   }

SgType*
SgType::findBaseType() const
   {
#if 0
// Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;


     while (true)
	{

	
	  if ( modType = isSgModifierType(currentType) )
	     {
         	 currentType = modType->get_base_type();
	     }
	  else if ( (refType = isSgReferenceType(currentType)) )
	     {
	       currentType = refType->get_base_type();
	     }
	  else if ( (pointType = isSgPointerType(currentType)) )
	     {
	       currentType = pointType->get_base_type();
	     }
	  else if ( (arrayType = isSgArrayType(currentType)) )
	     {
	       currentType = arrayType->get_base_type();
	     }
	  else if ( (typedefType = isSgTypedefType(currentType)) )
	     {
	    // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()

	       currentType = typedefType->get_base_type();
	     }
	  else {
	    // Exit the while(true){} loop!
	       break;
	  }

	}
#else
  // This uses the default value for SgType::stripType(), namely 
  // (bit_array == STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE)
     return stripType();
#endif
   }

SgType*
SgType::stripType(unsigned char bit_array) const
   {
  // This function forms the low level support for both SgType::findBaseType() 
  // and SgType::stripTypedefsAndModifiers().  It takes a default valued 
  // bit_array == (STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE)
  // Alternatively any of these value may be ORed together to for other combinations.

  // Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

     while (true)
        {
          if ( (bit_array & STRIP_MODIFIER_TYPE) && (modType = isSgModifierType(currentType)) )
             {
               currentType = modType->get_base_type();
             }
            else
             {
               if ( (bit_array & STRIP_REFERENCE_TYPE) &&  (refType = isSgReferenceType(currentType)) )
                  {
                    currentType = refType->get_base_type();
                  }
                 else
                  {
                    if ( (bit_array & STRIP_POINTER_TYPE) && (pointType = isSgPointerType(currentType)) )
                       {
                         currentType = pointType->get_base_type();
                       }
                      else
                       {
                         if ( (bit_array & STRIP_ARRAY_TYPE) && (arrayType = isSgArrayType(currentType)) )
                            {
                              currentType = arrayType->get_base_type();
                            }
                           else
                            {
                              if ( (bit_array & STRIP_TYPEDEF_TYPE) && (typedefType = isSgTypedefType(currentType)) )
                                 {
                                // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
                                   currentType = typedefType->get_base_type();
                                 }
                                else
                                 {
                                // Exit the while(true){} loop!
                                   break;
                                 }
                            }
                       }
                  }
             }
        }

     return currentType;
   }

#if 0
SgType*
SgType::stripType() const
   {
  // DQ (6/21/2005): strip type of all typedefs, modifiers, pointers, references, and array typing
     SgType* returnType = (SgType*) this;
     while ( (isSgTypedefType(returnType) != NULL) || 
             (isSgPointerType(returnType) != NULL) || 
             (isSgModifierType(returnType) != NULL) || 
             (isSgReferenceType(returnType) != NULL) || 
             (isSgArrayType(returnType) != NULL) )
        {
          returnType = returnType->findBaseType();
          ROSE_ASSERT (returnType != NULL);
       // printf ("In stripType(): returnType = %s hidden behind this = %s \n",returnType->sage_class_name(),sage_class_name());
        }

     return returnType;
   }
#endif


SgName
SgType::mangledNameSupport(SgName & fname, SgUnparse_Info & info) 
   {
  // DQ (4/27/2005): This protected function refactors code located into two places into a single implementation!
     SgName rtmp;

  // This only makes sense to call from either the SgFunctionType or the SgMemberFunctionType
     ROSE_ASSERT(isSgFunctionType(this) != NULL || isSgMemberFunctionType(this) != NULL);

     int len = fname.getString().size();
     std::string opstr  = "operator";
     std::string newstr = "new";
     std::string delstr = "delete";
     unsigned int m = opstr.size();

  // printf ("In SgType::mangledNameSupport(): class_name = %s len = %d m = %d fname = %s \n",sage_class_name(),len,m,fname.str());

     if (len > 0 && fname.getString().substr(0, m) == opstr)
        {
          if (fname.getString()[m]==' ')
             {
            // DQ (4/27/2005): "m+2" should be "m+1"
               if (fname.getString().substr(m + 1, newstr.size()) == newstr)
                  {
                 // DQ (4/27/2005): Added support for array new
                    int parenStart = m+1+newstr.size();
                    if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                         rtmp << "__na";
                      else
                         rtmp << "__nw";
                  }
                 else
                  {
                 // DQ (4/27/2005): Added support for array delete
                    if (fname.getString().substr(m + 1, delstr.size()) == delstr)
                       {
                         int deleteStringLength = delstr.size();
                         int parenStart = m+1+deleteStringLength;
                         if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                              rtmp << "__da";
                           else
                              rtmp << "__dl";
                       }
                      else
                       {
                      // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                      // This is the only part that is dependent upon either the SgFunctionType or SgMemberFunctionType.
                         SgFunctionType *functionType = isSgFunctionType(this);
                         ROSE_ASSERT(functionType != NULL);
                         ROSE_ASSERT(functionType->get_return_type() != NULL);

                         rtmp << "__op" << functionType->get_return_type()->get_mangled().str();
                       }
                  }
             }
            else
             {
            // real operator (suffix after the substring "operator ")

            // I think that this case could be used to handle "operator new", "operator new[]",
            // "operator delete", and "operator delete[]".

               SgName opname=&(fname.str()[m]);

               if (opname == SgName("->"))     rtmp << "__rf";
               else if (opname==SgName("->*")) rtmp << "__rm";
               else if (opname==SgName("=="))  rtmp << "__eq";
               else if (opname==SgName("<"))   rtmp << "__lt";
               else if (opname==SgName(">"))   rtmp << "__gt";
               else if (opname==SgName("!="))  rtmp << "__ne";
               else if (opname==SgName("<="))  rtmp << "__le";
               else if (opname==SgName(">="))  rtmp << "__ge";
               else if (opname==SgName("+"))   rtmp << "__pl";
               else if (opname==SgName("-"))   rtmp << "__mi";
               else if (opname==SgName("*"))   rtmp << "__ml";
               else if (opname==SgName("/"))   rtmp << "__dv";
               else if (opname==SgName("%"))   rtmp << "__md";
               else if (opname==SgName("&&"))  rtmp << "__aa";
               else if (opname==SgName("!"))   rtmp << "__nt";
               else if (opname==SgName("||"))  rtmp << "__oo";
               else if (opname==SgName("^"))   rtmp << "__er";
               else if (opname==SgName("&"))   rtmp << "__ad";
               else if (opname==SgName("|"))   rtmp << "__or";
               else if (opname==SgName(","))   rtmp << "__cm";
               else if (opname==SgName("<<"))  rtmp << "__ls";
               else if (opname==SgName(">>"))  rtmp << "__rs";
               else if (opname==SgName("--"))  rtmp << "__mm";
               else if (opname==SgName("++"))  rtmp << "__pp";
               else if (opname==SgName("~"))   rtmp << "__co";
               else if (opname==SgName("="))   rtmp << "__as";
               else if (opname==SgName("+="))  rtmp << "__apl";
               else if (opname==SgName("-="))  rtmp << "__ami";
               else if (opname==SgName("&="))  rtmp << "__aad";
               else if (opname==SgName("|="))  rtmp << "__aor";
               else if (opname==SgName("*="))  rtmp << "__amu";
               else if (opname==SgName("/="))  rtmp << "__adv";
               else if (opname==SgName("%="))  rtmp << "__amd";
               else if (opname==SgName("^="))  rtmp << "__aer";
               else if (opname==SgName("<<=")) rtmp << "__als";
               else if (opname==SgName(">>=")) rtmp << "__ars";
               else if (opname==SgName("()"))  rtmp << "__cl";
               else if (opname==SgName("[]"))  rtmp << "__xi";
               else
                  {
                 // printf ("In SgType::mangledNameSupport(): This case should never be reached (fname = %s) \n",fname.str());
                 // ROSE_ASSERT(false);

                 // DQ (1/8/2006): This is the case of a name that just happends to start with 
                 // the work "operator" (e.g. operator_takes_lvalue_operand, in test2005_198.C)
                 // the mangle form is just the unmodified function name.
                    rtmp = fname;
                  }
             }
        }
       else
          rtmp << fname.str();

     return rtmp;
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgType::get_substitutedForTemplateParam () const
   {
     assert (this != NULL);
     return p_substitutedForTemplateParam;
   }

void
SgType::set_substitutedForTemplateParam ( int substitutedForTemplateParam )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_substitutedForTemplateParam = substitutedForTemplateParam;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgReferenceType* 
SgType::get_ref_to () const
   {
     assert (this != NULL);
     return p_ref_to;
   }

void
SgType::set_ref_to ( SgReferenceType* ref_to )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_ref_to != NULL && ref_to != NULL && p_ref_to != ref_to)
        {
          printf ("Warning: ref_to = %p overwriting valid pointer p_ref_to = %p \n",ref_to,p_ref_to);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_ref_to != NULL && ref_to != NULL && p_ref_to != ref_to) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_ref_to = ref_to;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgPointerType* 
SgType::get_ptr_to () const
   {
     assert (this != NULL);
     return p_ptr_to;
   }

void
SgType::set_ptr_to ( SgPointerType* ptr_to )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_ptr_to != NULL && ptr_to != NULL && p_ptr_to != ptr_to)
        {
          printf ("Warning: ptr_to = %p overwriting valid pointer p_ptr_to = %p \n",ptr_to,p_ptr_to);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_ptr_to != NULL && ptr_to != NULL && p_ptr_to != ptr_to) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_ptr_to = ptr_to;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgModifierNodes* 
SgType::get_modifiers () const
   {
     assert (this != NULL);
     return p_modifiers;
   }

void
SgType::set_modifiers ( SgModifierNodes* modifiers )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_modifiers != NULL && modifiers != NULL && p_modifiers != modifiers)
        {
          printf ("Warning: modifiers = %p overwriting valid pointer p_modifiers = %p \n",modifiers,p_modifiers);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_modifiers != NULL && modifiers != NULL && p_modifiers != modifiers) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_modifiers = modifiers;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypedefSeq* 
SgType::get_typedefs () const
   {
     assert (this != NULL);
     return p_typedefs;
   }

void
SgType::set_typedefs ( SgTypedefSeq* typedefs )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_typedefs != NULL && typedefs != NULL && p_typedefs != typedefs)
        {
          printf ("Warning: typedefs = %p overwriting valid pointer p_typedefs = %p \n",typedefs,p_typedefs);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_typedefs != NULL && typedefs != NULL && p_typedefs != typedefs) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_typedefs = typedefs;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

AstAttributeMechanism* 
SgType::get_attributeMechanism () const
   {
     assert (this != NULL);
     return p_attributeMechanism;
   }

void
SgType::set_attributeMechanism ( AstAttributeMechanism* attributeMechanism )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism)
        {
          printf ("Warning: attributeMechanism = %p overwriting valid pointer p_attributeMechanism = %p \n",attributeMechanism,p_attributeMechanism);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_attributeMechanism != NULL && attributeMechanism != NULL && p_attributeMechanism != attributeMechanism) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_attributeMechanism = attributeMechanism;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 836 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Support.code"


#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
SgType::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

void
SgType::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
SgType::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
SgType::getAttribute(std::string s) const
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
SgType::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
SgType::removeAttribute(std::string s)
   {
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
SgType::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
SgType::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgType::get_type_kind () const
   {
     assert (this != NULL);
     return p_type_kind;
   }

void
SgType::set_type_kind ( SgExpression* type_kind )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_type_kind != NULL && type_kind != NULL && p_type_kind != type_kind)
        {
          printf ("Warning: type_kind = %p overwriting valid pointer p_type_kind = %p \n",type_kind,p_type_kind);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_type_kind != NULL && type_kind != NULL && p_type_kind != type_kind) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_type_kind = type_kind;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgType::variantT() const {
  return V_SgType;
}

#if 0
int
SgType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return TypeTag;
   }
#endif

const char*
SgType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgType";  
   }

std::string
SgType::class_name() const
   {
     assert(this != NULL);
     return "SgType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != TypeTag)
        {
          printf ("Error in SgType::error(): SgType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == TypeTag);
     return SgNode::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgType::variant() const \n");
#endif
     assert(this != NULL);
     return TypeTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgType* isSgType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgType* isSgType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgType::~SgType ()
   {
#if 0
  // debugging information!
     printf ("In SgType::~SgType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_typedefs;
     delete p_type_kind;

  // case: not a listType for substitutedForTemplateParam
     p_substitutedForTemplateParam = 0; // non list case 
  // case: not a listType for ref_to
     p_ref_to = NULL; // non list case 
  // case: not a listType for ptr_to
     p_ptr_to = NULL; // non list case 
  // case: not a listType for modifiers
     p_modifiers = NULL; // non list case 
  // case: not a listType for typedefs
     p_typedefs = NULL; // non list case 
  // case: not a listType for attributeMechanism
     p_attributeMechanism = NULL; // non list case 
  // case: not a listType for type_kind
     p_type_kind = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnknown::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnknown::variantT() const {
  return V_SgTypeUnknown;
}

#if 0
int
SgTypeUnknown::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNKNOWN;
   }
#endif

const char*
SgTypeUnknown::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnknown";  
   }

std::string
SgTypeUnknown::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnknown";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnknown::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnknown::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNKNOWN)
        {
          printf ("Error in SgTypeUnknown::error(): SgTypeUnknown object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnknown::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNKNOWN);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnknown SgTypeUnknown::builtin_type;
// SgTypeUnknown* SgTypeUnknown::builtin_type = new SgTypeUnknown();
SgTypeUnknown* SgTypeUnknown::p_builtin_type = NULL;

SgTypeUnknown*
SgTypeUnknown::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnknown object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnknown();
       // p_builtin_type = new SgTypeUnknown(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnknown::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnknown::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnknown::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnknown::get_mangled (void) const
   {
     return SgName("Unknown");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnknown::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnknown::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNKNOWN;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnknown* isSgTypeUnknown ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnknown*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnknown* isSgTypeUnknown ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnknown*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnknown::~SgTypeUnknown ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnknown::~SgTypeUnknown (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnknown::SgTypeUnknown (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnknown::SgTypeUnknown () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNKNOWN == variant());
     post_construction_initialization();

  // Test the isSgTypeUnknown() function since it has been problematic
     assert(isSgTypeUnknown(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeChar::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeChar::variantT() const {
  return V_SgTypeChar;
}

#if 0
int
SgTypeChar::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_CHAR;
   }
#endif

const char*
SgTypeChar::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeChar";  
   }

std::string
SgTypeChar::class_name() const
   {
     assert(this != NULL);
     return "SgTypeChar";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeChar::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeChar::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_CHAR)
        {
          printf ("Error in SgTypeChar::error(): SgTypeChar object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeChar::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_CHAR);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeChar SgTypeChar::builtin_type;
// SgTypeChar* SgTypeChar::builtin_type = new SgTypeChar();
SgTypeChar* SgTypeChar::p_builtin_type = NULL;

SgTypeChar*
SgTypeChar::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeChar object for the p_builtin_type \n");
          p_builtin_type = new SgTypeChar();
       // p_builtin_type = new SgTypeChar(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeChar::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeChar::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeChar::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeChar::get_mangled (void) const
   {
     return SgName("c");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeChar::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeChar::variant() const \n");
#endif
     assert(this != NULL);
     return T_CHAR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeChar* isSgTypeChar ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeChar*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeChar* isSgTypeChar ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeChar*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeChar::~SgTypeChar ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeChar::~SgTypeChar (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeChar::SgTypeChar (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeChar::SgTypeChar () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_CHAR == variant());
     post_construction_initialization();

  // Test the isSgTypeChar() function since it has been problematic
     assert(isSgTypeChar(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeSignedChar::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeSignedChar::variantT() const {
  return V_SgTypeSignedChar;
}

#if 0
int
SgTypeSignedChar::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_SIGNED_CHAR;
   }
#endif

const char*
SgTypeSignedChar::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedChar";  
   }

std::string
SgTypeSignedChar::class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedChar";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeSignedChar::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeSignedChar::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_SIGNED_CHAR)
        {
          printf ("Error in SgTypeSignedChar::error(): SgTypeSignedChar object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeSignedChar::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_SIGNED_CHAR);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeSignedChar SgTypeSignedChar::builtin_type;
// SgTypeSignedChar* SgTypeSignedChar::builtin_type = new SgTypeSignedChar();
SgTypeSignedChar* SgTypeSignedChar::p_builtin_type = NULL;

SgTypeSignedChar*
SgTypeSignedChar::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeSignedChar object for the p_builtin_type \n");
          p_builtin_type = new SgTypeSignedChar();
       // p_builtin_type = new SgTypeSignedChar(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeSignedChar::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeSignedChar::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeSignedChar::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeSignedChar::get_mangled (void) const
   {
     return SgName("si");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeSignedChar::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeSignedChar::variant() const \n");
#endif
     assert(this != NULL);
     return T_SIGNED_CHAR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeSignedChar* isSgTypeSignedChar ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeSignedChar*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeSignedChar* isSgTypeSignedChar ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeSignedChar*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeSignedChar::~SgTypeSignedChar ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeSignedChar::~SgTypeSignedChar (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeSignedChar::SgTypeSignedChar (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeSignedChar::SgTypeSignedChar () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_SIGNED_CHAR == variant());
     post_construction_initialization();

  // Test the isSgTypeSignedChar() function since it has been problematic
     assert(isSgTypeSignedChar(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnsignedChar::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnsignedChar::variantT() const {
  return V_SgTypeUnsignedChar;
}

#if 0
int
SgTypeUnsignedChar::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNSIGNED_CHAR;
   }
#endif

const char*
SgTypeUnsignedChar::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedChar";  
   }

std::string
SgTypeUnsignedChar::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedChar";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnsignedChar::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnsignedChar::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNSIGNED_CHAR)
        {
          printf ("Error in SgTypeUnsignedChar::error(): SgTypeUnsignedChar object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnsignedChar::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNSIGNED_CHAR);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnsignedChar SgTypeUnsignedChar::builtin_type;
// SgTypeUnsignedChar* SgTypeUnsignedChar::builtin_type = new SgTypeUnsignedChar();
SgTypeUnsignedChar* SgTypeUnsignedChar::p_builtin_type = NULL;

SgTypeUnsignedChar*
SgTypeUnsignedChar::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnsignedChar object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnsignedChar();
       // p_builtin_type = new SgTypeUnsignedChar(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnsignedChar::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnsignedChar::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnsignedChar::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnsignedChar::get_mangled (void) const
   {
     return SgName("Uc");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnsignedChar::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnsignedChar::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNSIGNED_CHAR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnsignedChar* isSgTypeUnsignedChar ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnsignedChar*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnsignedChar* isSgTypeUnsignedChar ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnsignedChar*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnsignedChar::~SgTypeUnsignedChar ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnsignedChar::~SgTypeUnsignedChar (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnsignedChar::SgTypeUnsignedChar (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnsignedChar::SgTypeUnsignedChar () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNSIGNED_CHAR == variant());
     post_construction_initialization();

  // Test the isSgTypeUnsignedChar() function since it has been problematic
     assert(isSgTypeUnsignedChar(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeShort::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeShort::variantT() const {
  return V_SgTypeShort;
}

#if 0
int
SgTypeShort::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_SHORT;
   }
#endif

const char*
SgTypeShort::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeShort";  
   }

std::string
SgTypeShort::class_name() const
   {
     assert(this != NULL);
     return "SgTypeShort";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeShort::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeShort::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_SHORT)
        {
          printf ("Error in SgTypeShort::error(): SgTypeShort object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeShort::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_SHORT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeShort SgTypeShort::builtin_type;
// SgTypeShort* SgTypeShort::builtin_type = new SgTypeShort();
SgTypeShort* SgTypeShort::p_builtin_type = NULL;

SgTypeShort*
SgTypeShort::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeShort object for the p_builtin_type \n");
          p_builtin_type = new SgTypeShort();
       // p_builtin_type = new SgTypeShort(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeShort::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeShort::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeShort::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeShort::get_mangled (void) const
   {
     return SgName("s");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeShort::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeShort::variant() const \n");
#endif
     assert(this != NULL);
     return T_SHORT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeShort* isSgTypeShort ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeShort*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeShort* isSgTypeShort ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeShort*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeShort::~SgTypeShort ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeShort::~SgTypeShort (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeShort::SgTypeShort (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeShort::SgTypeShort () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_SHORT == variant());
     post_construction_initialization();

  // Test the isSgTypeShort() function since it has been problematic
     assert(isSgTypeShort(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeSignedShort::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeSignedShort::variantT() const {
  return V_SgTypeSignedShort;
}

#if 0
int
SgTypeSignedShort::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_SIGNED_SHORT;
   }
#endif

const char*
SgTypeSignedShort::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedShort";  
   }

std::string
SgTypeSignedShort::class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedShort";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeSignedShort::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeSignedShort::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_SIGNED_SHORT)
        {
          printf ("Error in SgTypeSignedShort::error(): SgTypeSignedShort object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeSignedShort::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_SIGNED_SHORT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeSignedShort SgTypeSignedShort::builtin_type;
// SgTypeSignedShort* SgTypeSignedShort::builtin_type = new SgTypeSignedShort();
SgTypeSignedShort* SgTypeSignedShort::p_builtin_type = NULL;

SgTypeSignedShort*
SgTypeSignedShort::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeSignedShort object for the p_builtin_type \n");
          p_builtin_type = new SgTypeSignedShort();
       // p_builtin_type = new SgTypeSignedShort(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeSignedShort::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeSignedShort::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeSignedShort::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeSignedShort::get_mangled (void) const
   {
     return SgName("Ss");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeSignedShort::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeSignedShort::variant() const \n");
#endif
     assert(this != NULL);
     return T_SIGNED_SHORT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeSignedShort* isSgTypeSignedShort ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeSignedShort*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeSignedShort* isSgTypeSignedShort ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeSignedShort*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeSignedShort::~SgTypeSignedShort ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeSignedShort::~SgTypeSignedShort (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeSignedShort::SgTypeSignedShort (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeSignedShort::SgTypeSignedShort () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_SIGNED_SHORT == variant());
     post_construction_initialization();

  // Test the isSgTypeSignedShort() function since it has been problematic
     assert(isSgTypeSignedShort(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnsignedShort::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnsignedShort::variantT() const {
  return V_SgTypeUnsignedShort;
}

#if 0
int
SgTypeUnsignedShort::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNSIGNED_SHORT;
   }
#endif

const char*
SgTypeUnsignedShort::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedShort";  
   }

std::string
SgTypeUnsignedShort::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedShort";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnsignedShort::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnsignedShort::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNSIGNED_SHORT)
        {
          printf ("Error in SgTypeUnsignedShort::error(): SgTypeUnsignedShort object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnsignedShort::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNSIGNED_SHORT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnsignedShort SgTypeUnsignedShort::builtin_type;
// SgTypeUnsignedShort* SgTypeUnsignedShort::builtin_type = new SgTypeUnsignedShort();
SgTypeUnsignedShort* SgTypeUnsignedShort::p_builtin_type = NULL;

SgTypeUnsignedShort*
SgTypeUnsignedShort::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnsignedShort object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnsignedShort();
       // p_builtin_type = new SgTypeUnsignedShort(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnsignedShort::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnsignedShort::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnsignedShort::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnsignedShort::get_mangled (void) const
   {
     return SgName("Us");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnsignedShort::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnsignedShort::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNSIGNED_SHORT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnsignedShort* isSgTypeUnsignedShort ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnsignedShort*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnsignedShort* isSgTypeUnsignedShort ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnsignedShort*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnsignedShort::~SgTypeUnsignedShort ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnsignedShort::~SgTypeUnsignedShort (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnsignedShort::SgTypeUnsignedShort (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnsignedShort::SgTypeUnsignedShort () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNSIGNED_SHORT == variant());
     post_construction_initialization();

  // Test the isSgTypeUnsignedShort() function since it has been problematic
     assert(isSgTypeUnsignedShort(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 3617 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

const int SgTypeInt::maxBitLength = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeInt SgTypeInt::builtin_type[maxBitLength];
#if 0
#if defined __x86_64__
// 64 bit support
SgTypeInt* SgTypeInt::p_builtin_type[maxBitLength] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
#else
// 32 bit support
SgTypeInt* SgTypeInt::p_builtin_type[maxBitLength] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
#endif
#else
// DQ (1/31/2006): Convert to a single builtin pointer rather than an array of them.
// I don't think we really need an array of these internally.
SgTypeInt* SgTypeInt::p_builtin_type = NULL;
#endif

SgTypeInt*
SgTypeInt::createType(int bitLength) 
   {
#if 0
     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeInt objects within the builtin_type array (for bit modified types) \n");
       // Allocate all the required integer types (we require 32 of them for 
       // 32 bit architectures because "int i:n" (where "n" is the number of 
       // bits), forms a valid type).
          for (int i=0; i < maxBitLength; i++)
             {
               p_builtin_type[bitLength] = new SgTypeInt();
             }
        }
     firstCallToFunction = false;

     ROSE_ASSERT(bitLength < maxBitLength);

  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type[bitLength].p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type[bitLength];
     ROSE_ASSERT(p_builtin_type[bitLength] != NULL);
     p_builtin_type[bitLength]->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type[bitLength];
#else
  // DQ (1/31/2006): Convert to a single builtin pointer rather than an array of them.
  // I don't think we really need an array of these internally.
     if (p_builtin_type == NULL)
        {
          p_builtin_type = new SgTypeInt(bitLength);
        }
     ROSE_ASSERT(p_builtin_type != NULL);
     return p_builtin_type;
#endif
   }

#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeInt::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     for (int i=0; i < SgTypeInt::maxBitLength; i++)
          SgTypeInt::builtin_type[i].executeVisitorMemberFunction(visitor);
   }
#endif


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgTypeInt::get_field_size () const
   {
     assert (this != NULL);
     return p_field_size;
   }

void
SgTypeInt::set_field_size ( int field_size )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_field_size = field_size;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1846 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeInt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeInt::variantT() const {
  return V_SgTypeInt;
}

#if 0
int
SgTypeInt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_INT;
   }
#endif

const char*
SgTypeInt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeInt";  
   }

std::string
SgTypeInt::class_name() const
   {
     assert(this != NULL);
     return "SgTypeInt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeInt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeInt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_INT)
        {
          printf ("Error in SgTypeInt::error(): SgTypeInt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeInt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_INT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeInt::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeInt::get_mangled (void) const
   {
     return SgName("i");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeInt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeInt::variant() const \n");
#endif
     assert(this != NULL);
     return T_INT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeInt* isSgTypeInt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeInt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeInt* isSgTypeInt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeInt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeInt::~SgTypeInt ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeInt::~SgTypeInt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for field_size
     p_field_size = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeInt::SgTypeInt ( int field_size )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeInt::SgTypeInt (int field_size) sage_class_name() = %s \n",sage_class_name());
#endif

     p_field_size = field_size;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_INT == variant());
     post_construction_initialization();

  // Test the isSgTypeInt() function since it has been problematic
     assert(isSgTypeInt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeSignedInt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeSignedInt::variantT() const {
  return V_SgTypeSignedInt;
}

#if 0
int
SgTypeSignedInt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_SIGNED_INT;
   }
#endif

const char*
SgTypeSignedInt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedInt";  
   }

std::string
SgTypeSignedInt::class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedInt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeSignedInt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeSignedInt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_SIGNED_INT)
        {
          printf ("Error in SgTypeSignedInt::error(): SgTypeSignedInt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeSignedInt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_SIGNED_INT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeSignedInt SgTypeSignedInt::builtin_type;
// SgTypeSignedInt* SgTypeSignedInt::builtin_type = new SgTypeSignedInt();
SgTypeSignedInt* SgTypeSignedInt::p_builtin_type = NULL;

SgTypeSignedInt*
SgTypeSignedInt::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeSignedInt object for the p_builtin_type \n");
          p_builtin_type = new SgTypeSignedInt();
       // p_builtin_type = new SgTypeSignedInt(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeSignedInt::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeSignedInt::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeSignedInt::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeSignedInt::get_mangled (void) const
   {
     return SgName("Si");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeSignedInt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeSignedInt::variant() const \n");
#endif
     assert(this != NULL);
     return T_SIGNED_INT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeSignedInt* isSgTypeSignedInt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeSignedInt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeSignedInt* isSgTypeSignedInt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeSignedInt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeSignedInt::~SgTypeSignedInt ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeSignedInt::~SgTypeSignedInt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeSignedInt::SgTypeSignedInt (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeSignedInt::SgTypeSignedInt () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_SIGNED_INT == variant());
     post_construction_initialization();

  // Test the isSgTypeSignedInt() function since it has been problematic
     assert(isSgTypeSignedInt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnsignedInt::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnsignedInt::variantT() const {
  return V_SgTypeUnsignedInt;
}

#if 0
int
SgTypeUnsignedInt::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNSIGNED_INT;
   }
#endif

const char*
SgTypeUnsignedInt::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedInt";  
   }

std::string
SgTypeUnsignedInt::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedInt";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnsignedInt::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnsignedInt::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNSIGNED_INT)
        {
          printf ("Error in SgTypeUnsignedInt::error(): SgTypeUnsignedInt object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnsignedInt::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNSIGNED_INT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnsignedInt SgTypeUnsignedInt::builtin_type;
// SgTypeUnsignedInt* SgTypeUnsignedInt::builtin_type = new SgTypeUnsignedInt();
SgTypeUnsignedInt* SgTypeUnsignedInt::p_builtin_type = NULL;

SgTypeUnsignedInt*
SgTypeUnsignedInt::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnsignedInt object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnsignedInt();
       // p_builtin_type = new SgTypeUnsignedInt(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnsignedInt::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnsignedInt::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnsignedInt::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnsignedInt::get_mangled (void) const
   {
     return SgName("Ui");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnsignedInt::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnsignedInt::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNSIGNED_INT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnsignedInt* isSgTypeUnsignedInt ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnsignedInt*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnsignedInt* isSgTypeUnsignedInt ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnsignedInt*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnsignedInt::~SgTypeUnsignedInt ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnsignedInt::~SgTypeUnsignedInt (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnsignedInt::SgTypeUnsignedInt (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnsignedInt::SgTypeUnsignedInt () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNSIGNED_INT == variant());
     post_construction_initialization();

  // Test the isSgTypeUnsignedInt() function since it has been problematic
     assert(isSgTypeUnsignedInt(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeLong::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeLong::variantT() const {
  return V_SgTypeLong;
}

#if 0
int
SgTypeLong::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_LONG;
   }
#endif

const char*
SgTypeLong::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeLong";  
   }

std::string
SgTypeLong::class_name() const
   {
     assert(this != NULL);
     return "SgTypeLong";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeLong::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeLong::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_LONG)
        {
          printf ("Error in SgTypeLong::error(): SgTypeLong object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeLong::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_LONG);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeLong SgTypeLong::builtin_type;
// SgTypeLong* SgTypeLong::builtin_type = new SgTypeLong();
SgTypeLong* SgTypeLong::p_builtin_type = NULL;

SgTypeLong*
SgTypeLong::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeLong object for the p_builtin_type \n");
          p_builtin_type = new SgTypeLong();
       // p_builtin_type = new SgTypeLong(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeLong::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeLong::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeLong::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeLong::get_mangled (void) const
   {
     return SgName("l");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeLong::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeLong::variant() const \n");
#endif
     assert(this != NULL);
     return T_LONG;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeLong* isSgTypeLong ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeLong*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeLong* isSgTypeLong ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeLong*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeLong::~SgTypeLong ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeLong::~SgTypeLong (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeLong::SgTypeLong (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeLong::SgTypeLong () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_LONG == variant());
     post_construction_initialization();

  // Test the isSgTypeLong() function since it has been problematic
     assert(isSgTypeLong(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeSignedLong::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeSignedLong::variantT() const {
  return V_SgTypeSignedLong;
}

#if 0
int
SgTypeSignedLong::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_SIGNED_LONG;
   }
#endif

const char*
SgTypeSignedLong::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedLong";  
   }

std::string
SgTypeSignedLong::class_name() const
   {
     assert(this != NULL);
     return "SgTypeSignedLong";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeSignedLong::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeSignedLong::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_SIGNED_LONG)
        {
          printf ("Error in SgTypeSignedLong::error(): SgTypeSignedLong object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeSignedLong::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_SIGNED_LONG);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeSignedLong SgTypeSignedLong::builtin_type;
// SgTypeSignedLong* SgTypeSignedLong::builtin_type = new SgTypeSignedLong();
SgTypeSignedLong* SgTypeSignedLong::p_builtin_type = NULL;

SgTypeSignedLong*
SgTypeSignedLong::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeSignedLong object for the p_builtin_type \n");
          p_builtin_type = new SgTypeSignedLong();
       // p_builtin_type = new SgTypeSignedLong(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeSignedLong::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeSignedLong::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeSignedLong::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeSignedLong::get_mangled (void) const
   {
     return SgName("Sl");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeSignedLong::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeSignedLong::variant() const \n");
#endif
     assert(this != NULL);
     return T_SIGNED_LONG;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeSignedLong* isSgTypeSignedLong ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeSignedLong*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeSignedLong* isSgTypeSignedLong ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeSignedLong*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeSignedLong::~SgTypeSignedLong ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeSignedLong::~SgTypeSignedLong (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeSignedLong::SgTypeSignedLong (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeSignedLong::SgTypeSignedLong () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_SIGNED_LONG == variant());
     post_construction_initialization();

  // Test the isSgTypeSignedLong() function since it has been problematic
     assert(isSgTypeSignedLong(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnsignedLong::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnsignedLong::variantT() const {
  return V_SgTypeUnsignedLong;
}

#if 0
int
SgTypeUnsignedLong::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNSIGNED_LONG;
   }
#endif

const char*
SgTypeUnsignedLong::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedLong";  
   }

std::string
SgTypeUnsignedLong::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedLong";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnsignedLong::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnsignedLong::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNSIGNED_LONG)
        {
          printf ("Error in SgTypeUnsignedLong::error(): SgTypeUnsignedLong object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnsignedLong::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNSIGNED_LONG);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnsignedLong SgTypeUnsignedLong::builtin_type;
// SgTypeUnsignedLong* SgTypeUnsignedLong::builtin_type = new SgTypeUnsignedLong();
SgTypeUnsignedLong* SgTypeUnsignedLong::p_builtin_type = NULL;

SgTypeUnsignedLong*
SgTypeUnsignedLong::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnsignedLong object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnsignedLong();
       // p_builtin_type = new SgTypeUnsignedLong(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnsignedLong::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnsignedLong::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnsignedLong::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnsignedLong::get_mangled (void) const
   {
     return SgName("Ul");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnsignedLong::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnsignedLong::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNSIGNED_LONG;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnsignedLong* isSgTypeUnsignedLong ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnsignedLong*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnsignedLong* isSgTypeUnsignedLong ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnsignedLong*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnsignedLong::~SgTypeUnsignedLong ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnsignedLong::~SgTypeUnsignedLong (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnsignedLong::SgTypeUnsignedLong (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnsignedLong::SgTypeUnsignedLong () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNSIGNED_LONG == variant());
     post_construction_initialization();

  // Test the isSgTypeUnsignedLong() function since it has been problematic
     assert(isSgTypeUnsignedLong(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeVoid::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeVoid::variantT() const {
  return V_SgTypeVoid;
}

#if 0
int
SgTypeVoid::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_VOID;
   }
#endif

const char*
SgTypeVoid::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeVoid";  
   }

std::string
SgTypeVoid::class_name() const
   {
     assert(this != NULL);
     return "SgTypeVoid";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeVoid::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeVoid::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_VOID)
        {
          printf ("Error in SgTypeVoid::error(): SgTypeVoid object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeVoid::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_VOID);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeVoid SgTypeVoid::builtin_type;
// SgTypeVoid* SgTypeVoid::builtin_type = new SgTypeVoid();
SgTypeVoid* SgTypeVoid::p_builtin_type = NULL;

SgTypeVoid*
SgTypeVoid::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeVoid object for the p_builtin_type \n");
          p_builtin_type = new SgTypeVoid();
       // p_builtin_type = new SgTypeVoid(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeVoid::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeVoid::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeVoid::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeVoid::get_mangled (void) const
   {
     return SgName("v");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeVoid::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeVoid::variant() const \n");
#endif
     assert(this != NULL);
     return T_VOID;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeVoid* isSgTypeVoid ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeVoid*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeVoid* isSgTypeVoid ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeVoid*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeVoid::~SgTypeVoid ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeVoid::~SgTypeVoid (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeVoid::SgTypeVoid (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeVoid::SgTypeVoid () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_VOID == variant());
     post_construction_initialization();

  // Test the isSgTypeVoid() function since it has been problematic
     assert(isSgTypeVoid(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeGlobalVoid::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeGlobalVoid::variantT() const {
  return V_SgTypeGlobalVoid;
}

#if 0
int
SgTypeGlobalVoid::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_GLOBAL_VOID;
   }
#endif

const char*
SgTypeGlobalVoid::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeGlobalVoid";  
   }

std::string
SgTypeGlobalVoid::class_name() const
   {
     assert(this != NULL);
     return "SgTypeGlobalVoid";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeGlobalVoid::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeGlobalVoid::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_GLOBAL_VOID)
        {
          printf ("Error in SgTypeGlobalVoid::error(): SgTypeGlobalVoid object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeGlobalVoid::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_GLOBAL_VOID);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeGlobalVoid SgTypeGlobalVoid::builtin_type;
// SgTypeGlobalVoid* SgTypeGlobalVoid::builtin_type = new SgTypeGlobalVoid();
SgTypeGlobalVoid* SgTypeGlobalVoid::p_builtin_type = NULL;

SgTypeGlobalVoid*
SgTypeGlobalVoid::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeGlobalVoid object for the p_builtin_type \n");
          p_builtin_type = new SgTypeGlobalVoid();
       // p_builtin_type = new SgTypeGlobalVoid(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeGlobalVoid::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeGlobalVoid::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeGlobalVoid::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeGlobalVoid::get_mangled (void) const
   {
     return SgName("gv");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeGlobalVoid::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeGlobalVoid::variant() const \n");
#endif
     assert(this != NULL);
     return T_GLOBAL_VOID;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeGlobalVoid* isSgTypeGlobalVoid ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeGlobalVoid*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeGlobalVoid* isSgTypeGlobalVoid ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeGlobalVoid*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeGlobalVoid::~SgTypeGlobalVoid ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeGlobalVoid::~SgTypeGlobalVoid (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeGlobalVoid::SgTypeGlobalVoid (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeGlobalVoid::SgTypeGlobalVoid () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_GLOBAL_VOID == variant());
     post_construction_initialization();

  // Test the isSgTypeGlobalVoid() function since it has been problematic
     assert(isSgTypeGlobalVoid(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeWchar::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeWchar::variantT() const {
  return V_SgTypeWchar;
}

#if 0
int
SgTypeWchar::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_WCHAR;
   }
#endif

const char*
SgTypeWchar::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeWchar";  
   }

std::string
SgTypeWchar::class_name() const
   {
     assert(this != NULL);
     return "SgTypeWchar";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeWchar::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeWchar::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_WCHAR)
        {
          printf ("Error in SgTypeWchar::error(): SgTypeWchar object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeWchar::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_WCHAR);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeWchar SgTypeWchar::builtin_type;
// SgTypeWchar* SgTypeWchar::builtin_type = new SgTypeWchar();
SgTypeWchar* SgTypeWchar::p_builtin_type = NULL;

SgTypeWchar*
SgTypeWchar::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeWchar object for the p_builtin_type \n");
          p_builtin_type = new SgTypeWchar();
       // p_builtin_type = new SgTypeWchar(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeWchar::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeWchar::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeWchar::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeWchar::get_mangled (void) const
   {
     return SgName("wc");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeWchar::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeWchar::variant() const \n");
#endif
     assert(this != NULL);
     return T_WCHAR;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeWchar* isSgTypeWchar ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeWchar*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeWchar* isSgTypeWchar ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeWchar*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeWchar::~SgTypeWchar ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeWchar::~SgTypeWchar (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeWchar::SgTypeWchar (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeWchar::SgTypeWchar () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_WCHAR == variant());
     post_construction_initialization();

  // Test the isSgTypeWchar() function since it has been problematic
     assert(isSgTypeWchar(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeFloat::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeFloat::variantT() const {
  return V_SgTypeFloat;
}

#if 0
int
SgTypeFloat::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_FLOAT;
   }
#endif

const char*
SgTypeFloat::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeFloat";  
   }

std::string
SgTypeFloat::class_name() const
   {
     assert(this != NULL);
     return "SgTypeFloat";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeFloat::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeFloat::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_FLOAT)
        {
          printf ("Error in SgTypeFloat::error(): SgTypeFloat object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeFloat::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_FLOAT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeFloat SgTypeFloat::builtin_type;
// SgTypeFloat* SgTypeFloat::builtin_type = new SgTypeFloat();
SgTypeFloat* SgTypeFloat::p_builtin_type = NULL;

SgTypeFloat*
SgTypeFloat::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeFloat object for the p_builtin_type \n");
          p_builtin_type = new SgTypeFloat();
       // p_builtin_type = new SgTypeFloat(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeFloat::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeFloat::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeFloat::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeFloat::get_mangled (void) const
   {
     return SgName("f");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeFloat::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeFloat::variant() const \n");
#endif
     assert(this != NULL);
     return T_FLOAT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeFloat* isSgTypeFloat ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeFloat*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeFloat* isSgTypeFloat ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeFloat*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeFloat::~SgTypeFloat ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeFloat::~SgTypeFloat (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeFloat::SgTypeFloat (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeFloat::SgTypeFloat () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_FLOAT == variant());
     post_construction_initialization();

  // Test the isSgTypeFloat() function since it has been problematic
     assert(isSgTypeFloat(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeDouble::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeDouble::variantT() const {
  return V_SgTypeDouble;
}

#if 0
int
SgTypeDouble::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_DOUBLE;
   }
#endif

const char*
SgTypeDouble::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeDouble";  
   }

std::string
SgTypeDouble::class_name() const
   {
     assert(this != NULL);
     return "SgTypeDouble";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeDouble::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeDouble::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_DOUBLE)
        {
          printf ("Error in SgTypeDouble::error(): SgTypeDouble object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeDouble::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_DOUBLE);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeDouble SgTypeDouble::builtin_type;
// SgTypeDouble* SgTypeDouble::builtin_type = new SgTypeDouble();
SgTypeDouble* SgTypeDouble::p_builtin_type = NULL;

SgTypeDouble*
SgTypeDouble::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeDouble object for the p_builtin_type \n");
          p_builtin_type = new SgTypeDouble();
       // p_builtin_type = new SgTypeDouble(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeDouble::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeDouble::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeDouble::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeDouble::get_mangled (void) const
   {
     return SgName("d");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeDouble::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeDouble::variant() const \n");
#endif
     assert(this != NULL);
     return T_DOUBLE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeDouble* isSgTypeDouble ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeDouble*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeDouble* isSgTypeDouble ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeDouble*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeDouble::~SgTypeDouble ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeDouble::~SgTypeDouble (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeDouble::SgTypeDouble (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeDouble::SgTypeDouble () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_DOUBLE == variant());
     post_construction_initialization();

  // Test the isSgTypeDouble() function since it has been problematic
     assert(isSgTypeDouble(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeLongLong::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeLongLong::variantT() const {
  return V_SgTypeLongLong;
}

#if 0
int
SgTypeLongLong::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_LONG_LONG;
   }
#endif

const char*
SgTypeLongLong::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeLongLong";  
   }

std::string
SgTypeLongLong::class_name() const
   {
     assert(this != NULL);
     return "SgTypeLongLong";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeLongLong::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeLongLong::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_LONG_LONG)
        {
          printf ("Error in SgTypeLongLong::error(): SgTypeLongLong object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeLongLong::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_LONG_LONG);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeLongLong SgTypeLongLong::builtin_type;
// SgTypeLongLong* SgTypeLongLong::builtin_type = new SgTypeLongLong();
SgTypeLongLong* SgTypeLongLong::p_builtin_type = NULL;

SgTypeLongLong*
SgTypeLongLong::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeLongLong object for the p_builtin_type \n");
          p_builtin_type = new SgTypeLongLong();
       // p_builtin_type = new SgTypeLongLong(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeLongLong::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeLongLong::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeLongLong::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeLongLong::get_mangled (void) const
   {
     return SgName("L");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeLongLong::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeLongLong::variant() const \n");
#endif
     assert(this != NULL);
     return T_LONG_LONG;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeLongLong* isSgTypeLongLong ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeLongLong*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeLongLong* isSgTypeLongLong ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeLongLong*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeLongLong::~SgTypeLongLong ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeLongLong::~SgTypeLongLong (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeLongLong::SgTypeLongLong (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeLongLong::SgTypeLongLong () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_LONG_LONG == variant());
     post_construction_initialization();

  // Test the isSgTypeLongLong() function since it has been problematic
     assert(isSgTypeLongLong(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeUnsignedLongLong::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeUnsignedLongLong::variantT() const {
  return V_SgTypeUnsignedLongLong;
}

#if 0
int
SgTypeUnsignedLongLong::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_UNSIGNED_LONG_LONG;
   }
#endif

const char*
SgTypeUnsignedLongLong::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedLongLong";  
   }

std::string
SgTypeUnsignedLongLong::class_name() const
   {
     assert(this != NULL);
     return "SgTypeUnsignedLongLong";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeUnsignedLongLong::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeUnsignedLongLong::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_UNSIGNED_LONG_LONG)
        {
          printf ("Error in SgTypeUnsignedLongLong::error(): SgTypeUnsignedLongLong object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeUnsignedLongLong::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_UNSIGNED_LONG_LONG);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeUnsignedLongLong SgTypeUnsignedLongLong::builtin_type;
// SgTypeUnsignedLongLong* SgTypeUnsignedLongLong::builtin_type = new SgTypeUnsignedLongLong();
SgTypeUnsignedLongLong* SgTypeUnsignedLongLong::p_builtin_type = NULL;

SgTypeUnsignedLongLong*
SgTypeUnsignedLongLong::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeUnsignedLongLong object for the p_builtin_type \n");
          p_builtin_type = new SgTypeUnsignedLongLong();
       // p_builtin_type = new SgTypeUnsignedLongLong(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeUnsignedLongLong::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeUnsignedLongLong::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeUnsignedLongLong::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeUnsignedLongLong::get_mangled (void) const
   {
     return SgName("UL");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeUnsignedLongLong::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeUnsignedLongLong::variant() const \n");
#endif
     assert(this != NULL);
     return T_UNSIGNED_LONG_LONG;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeUnsignedLongLong* isSgTypeUnsignedLongLong ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeUnsignedLongLong*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeUnsignedLongLong* isSgTypeUnsignedLongLong ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeUnsignedLongLong*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeUnsignedLongLong::~SgTypeUnsignedLongLong ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeUnsignedLongLong::~SgTypeUnsignedLongLong (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeUnsignedLongLong::SgTypeUnsignedLongLong (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeUnsignedLongLong::SgTypeUnsignedLongLong () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_UNSIGNED_LONG_LONG == variant());
     post_construction_initialization();

  // Test the isSgTypeUnsignedLongLong() function since it has been problematic
     assert(isSgTypeUnsignedLongLong(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeLongDouble::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeLongDouble::variantT() const {
  return V_SgTypeLongDouble;
}

#if 0
int
SgTypeLongDouble::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_LONG_DOUBLE;
   }
#endif

const char*
SgTypeLongDouble::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeLongDouble";  
   }

std::string
SgTypeLongDouble::class_name() const
   {
     assert(this != NULL);
     return "SgTypeLongDouble";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeLongDouble::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeLongDouble::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_LONG_DOUBLE)
        {
          printf ("Error in SgTypeLongDouble::error(): SgTypeLongDouble object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeLongDouble::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_LONG_DOUBLE);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeLongDouble SgTypeLongDouble::builtin_type;
// SgTypeLongDouble* SgTypeLongDouble::builtin_type = new SgTypeLongDouble();
SgTypeLongDouble* SgTypeLongDouble::p_builtin_type = NULL;

SgTypeLongDouble*
SgTypeLongDouble::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeLongDouble object for the p_builtin_type \n");
          p_builtin_type = new SgTypeLongDouble();
       // p_builtin_type = new SgTypeLongDouble(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeLongDouble::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeLongDouble::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeLongDouble::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeLongDouble::get_mangled (void) const
   {
     return SgName("ld");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeLongDouble::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeLongDouble::variant() const \n");
#endif
     assert(this != NULL);
     return T_LONG_DOUBLE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeLongDouble* isSgTypeLongDouble ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeLongDouble*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeLongDouble* isSgTypeLongDouble ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeLongDouble*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeLongDouble::~SgTypeLongDouble ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeLongDouble::~SgTypeLongDouble (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeLongDouble::SgTypeLongDouble (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeLongDouble::SgTypeLongDouble () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_LONG_DOUBLE == variant());
     post_construction_initialization();

  // Test the isSgTypeLongDouble() function since it has been problematic
     assert(isSgTypeLongDouble(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeString::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeString::variantT() const {
  return V_SgTypeString;
}

#if 0
int
SgTypeString::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_STRING;
   }
#endif

const char*
SgTypeString::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeString";  
   }

std::string
SgTypeString::class_name() const
   {
     assert(this != NULL);
     return "SgTypeString";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeString::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeString::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_STRING)
        {
          printf ("Error in SgTypeString::error(): SgTypeString object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeString::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_STRING);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeString SgTypeString::builtin_type;
// SgTypeString* SgTypeString::builtin_type = new SgTypeString();
SgTypeString* SgTypeString::p_builtin_type = NULL;

SgTypeString*
SgTypeString::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeString object for the p_builtin_type \n");
          p_builtin_type = new SgTypeString();
       // p_builtin_type = new SgTypeString(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeString::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeString::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeString::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeString::get_mangled (void) const
   {
     return SgName("str");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeString::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeString::variant() const \n");
#endif
     assert(this != NULL);
     return T_STRING;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeString* isSgTypeString ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeString*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeString* isSgTypeString ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeString*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeString::~SgTypeString ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeString::~SgTypeString (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeString::SgTypeString (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeString::SgTypeString () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_STRING == variant());
     post_construction_initialization();

  // Test the isSgTypeString() function since it has been problematic
     assert(isSgTypeString(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeBool::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeBool::variantT() const {
  return V_SgTypeBool;
}

#if 0
int
SgTypeBool::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_BOOL;
   }
#endif

const char*
SgTypeBool::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeBool";  
   }

std::string
SgTypeBool::class_name() const
   {
     assert(this != NULL);
     return "SgTypeBool";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeBool::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeBool::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_BOOL)
        {
          printf ("Error in SgTypeBool::error(): SgTypeBool object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeBool::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_BOOL);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeBool SgTypeBool::builtin_type;
// SgTypeBool* SgTypeBool::builtin_type = new SgTypeBool();
SgTypeBool* SgTypeBool::p_builtin_type = NULL;

SgTypeBool*
SgTypeBool::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeBool object for the p_builtin_type \n");
          p_builtin_type = new SgTypeBool();
       // p_builtin_type = new SgTypeBool(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeBool::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeBool::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeBool::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeBool::get_mangled (void) const
   {
     return SgName("b");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeBool::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeBool::variant() const \n");
#endif
     assert(this != NULL);
     return T_BOOL;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeBool* isSgTypeBool ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeBool*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeBool* isSgTypeBool ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeBool*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeBool::~SgTypeBool ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeBool::~SgTypeBool (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeBool::SgTypeBool (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeBool::SgTypeBool () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_BOOL == variant());
     post_construction_initialization();

  // Test the isSgTypeBool() function since it has been problematic
     assert(isSgTypeBool(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3769 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgReferenceType*
SgReferenceType::createType(SgType* base_type)
   {
     assert(base_type != NULL);
     if (base_type->p_ref_to)
        {
          return base_type->p_ref_to;
        }
       else
        {
          SgReferenceType* newType = new SgReferenceType(base_type);
          assert(newType != NULL);

          base_type->p_ref_to = newType;
          assert(base_type->p_ref_to != NULL);

          return base_type->p_ref_to;
       // return (base_type->ref_to = new SgReferenceType(base_type));
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgReferenceType::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgReferenceType::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 919 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


/*! Returns a mangled name representation of types with base types
 *  (e.g., pointer, reference).
 */
SgName
SgReferenceType::get_mangled (void) const
   {
     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type);
     SgName base_name = base_type->get_mangled();

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In SgReferenceType::get_mangled(), empty base type name found \n");
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "R" << "b__" // start tag
                  << base_name.str () // base type
                  << "__" << "R" << "e__"; // end tag
     return mangled_name;
   }

#if 0
// Old version of function
SgName
SgReferenceType::get_mangled ( SgUnparse_Info & info )
   {
     SgName tmp("R");

  // DQ (3/15/2005): Should be be using a qualified name???

     ROSE_ASSERT(get_base_type() != NULL);
     ROSE_ASSERT(get_base_type()->get_mangled(info).get_length() > 0);
     tmp << get_base_type()->get_mangled(info).str();

#if 0
     printf ("###########  In SgReferenceType::get_mangled(): tmp = %s (get_base_type() = %s is a %s) ########## \n",
          tmp.str(),get_base_type()->get_mangled(info).str(),get_base_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 1927 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgReferenceType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgReferenceType::variantT() const {
  return V_SgReferenceType;
}

#if 0
int
SgReferenceType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_REFERENCE;
   }
#endif

const char*
SgReferenceType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgReferenceType";  
   }

std::string
SgReferenceType::class_name() const
   {
     assert(this != NULL);
     return "SgReferenceType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgReferenceType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgReferenceType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_REFERENCE)
        {
          printf ("Error in SgReferenceType::error(): SgReferenceType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgReferenceType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_REFERENCE);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgReferenceType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgReferenceType::variant() const \n");
#endif
     assert(this != NULL);
     return T_REFERENCE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgReferenceType* isSgReferenceType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgReferenceType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgReferenceType* isSgReferenceType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgReferenceType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgReferenceType::~SgReferenceType ()
   {
#if 0
  // debugging information!
     printf ("In SgReferenceType::~SgReferenceType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for base_type
     p_base_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgReferenceType::SgReferenceType ( SgType* base_type )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgReferenceType::SgReferenceType (SgType* base_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_type = base_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_REFERENCE == variant());
     post_construction_initialization();

  // Test the isSgReferenceType() function since it has been problematic
     assert(isSgReferenceType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3816 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgModifierType*
SgModifierType::createType(SgType* base_type, unsigned int f)
   {
     assert(base_type != NULL);

  // DQ (4/13/2004): See if we can get rid of this function, but first lets find out where it is called!
  // This is part of the work to reorganize now modifiers are used internally.
  // return base_type->matchModifiers(f);

     printf ("Error, no longer supported! \n");
     ROSE_ASSERT (false);

     return NULL;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgModifierType::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgModifierType::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2167 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// mask some bit on or off
// void set_modifier   (int flag);
// void unset_modifier (int flag);

SgTypeModifier &
SgModifierType::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

// RV (2/2/2006): Created this 'const' version.
const SgTypeModifier &
SgModifierType::get_typeModifier (void) const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

#if 0
bool
SgModifierType::isSync() const
   {
  // CC++ specific modifier!
     return p_bitfield & m_sync; 
   }

bool
SgModifierType::isGlobal() const
   { return p_bitfield & m_global; }
#endif
#if 0
void
SgModifierType::unsetSync()
   { p_bitfield &= ~m_sync; }

void
SgModifierType::setSync()
   {
  // DQ (12/7/2003): != is meaningless
  // p_bitfield != m_sync; 
     p_bitfield |= m_sync; 
   }

void
SgModifierType::unsetGlobal()
   { p_bitfield &= ~m_global; }

void
SgModifierType::setGlobal()
   { 
  // DQ (12/7/2003): != is meaningless
  // p_bitfield != m_global; 
     p_bitfield |= m_global; 
   }
#endif

#if 0
// Access the function at the lower level typeModifier, storageModifier, or accessModifier objects
bool SgModifierType::isRestrict() const    { return p_typeModifier.isRestrict(); }
bool SgModifierType::isConst() const       { return p_typeModifier.get_constVolatileModifier().isConst(); }
bool SgModifierType::isVolatile() const    { return p_typeModifier.get_constVolatileModifier().isVolatile(); }
bool SgModifierType::isUPC_Shared() const  { return p_typeModifier.get_upcModifier().isUPC_Shared(); }
bool SgModifierType::isUPC_Strict() const  { return p_typeModifier.get_upcModifier().isUPC_Strict(); }
bool SgModifierType::isUPC_Relaxed() const { return p_typeModifier.get_upcModifier().isUPC_Relaxed(); }

void SgModifierType::unsetRestrict()    { p_typeModifier.unsetRestrict(); }
void SgModifierType::setRestrict()      { p_typeModifier.setRestrict(); }
#endif

#if 0
void SgModifierType::unsetConst()       { p_typeModifier.get_constVolatileModifier().unsetConst(); }
void SgModifierType::setConst()         { p_typeModifier.get_constVolatileModifier().setConst();   }
void SgModifierType::unsetVolatile()    { p_typeModifier.get_constVolatileModifier().unsetVolatile(); }
void SgModifierType::setVolatile()      { p_typeModifier.get_constVolatileModifier().setVolatile();   }
void SgModifierType::unsetUPC_Shared()  { p_typeModifier.get_upcModifier().unsetUPC_Shared(); }
void SgModifierType::setUPC_Shared()    { p_typeModifier.get_upcModifier().setUPC_Shared(); }
void SgModifierType::unsetUPC_Strict()  { p_typeModifier.get_upcModifier().unsetUPC_Strict(); }
void SgModifierType::setUPC_Strict()    { p_typeModifier.get_upcModifier().setUPC_Strict(); }
void SgModifierType::unsetUPC_Relaxed() { p_typeModifier.get_upcModifier().unsetUPC_Relaxed(); }
void SgModifierType::setUPC_Relaxed()   { p_typeModifier.get_upcModifier().setUPC_Relaxed(); }
#endif

#if 0
bool SgModifierType::isExtern() const      { return p_storageModifier.isExtern(); }
bool SgModifierType::isStatic() const      { return p_storageModifier.isStatic(); }
bool SgModifierType::isAuto() const        { return p_storageModifier.isAuto(); }
bool SgModifierType::isUnspecified() const { return p_storageModifier.isUnspecified(); }
bool SgModifierType::isTypedef() const     { return p_storageModifier.isTypedef(); }
bool SgModifierType::isRegister() const    { return p_storageModifier.isRegister(); }
bool SgModifierType::isAsm() const         { return p_storageModifier.isAsm(); }
bool SgModifierType::isVirtual() const     { return p_accessModifier.isVirtual(); }
bool SgModifierType::isProtected() const   { return p_accessModifier.isProtected(); }
bool SgModifierType::isPrivate() const     { return p_accessModifier.isPrivate(); }
bool SgModifierType::isPublic() const      { return p_accessModifier.isPublic(); }

void SgModifierType::setExtern()        { p_storageModifier.setExtern(); }
void SgModifierType::setStatic()        { p_storageModifier.setStatic(); }
void SgModifierType::setAuto()          { p_storageModifier.setAuto();   }
void SgModifierType::setUnspecified()   { p_storageModifier.setUnspecified(); }
void SgModifierType::setTypedef()       { p_storageModifier.setTypedef(); }
void SgModifierType::setRegister()      { p_storageModifier.setRegister(); }
void SgModifierType::setAsm()           { p_storageModifier.setAsm(); }
void SgModifierType::setPrivate()       { p_accessModifier.setPrivate(); }
void SgModifierType::setProtected()     { p_accessModifier.setProtected(); }
void SgModifierType::setPublic()        { p_accessModifier.setPublic(); }
void SgModifierType::setVirtual()       { p_accessModifier.setVirtual(); }
#endif

#if 0
unsigned int
SgModifierType::bitfield(void)
   { return p_bitfield; }
#endif

// RV (1/31/2006): Removed dependence on SgUnparse_Info
SgName
SgModifierType::get_mangled (void) const
   {
     SgName mangled_name;

     const SgTypeModifier& type_mod = get_typeModifier ();
     const SgConstVolatileModifier& cv_mod =
       type_mod.get_constVolatileModifier ();
     const SgUPC_AccessModifier& upc_mod =
       type_mod.get_upcModifier ();
 
     if (cv_mod.isConst())       mangled_name << "C";
     if (cv_mod.isVolatile())    mangled_name << "V";
  // DQ (4/22/2004): Removed support for CC++
  // if (isSync())        mangled_name << "SYN";
  // if (isGlobal())      mangled_name << "GLB";
     if (type_mod.isRestrict())    mangled_name << "RST";
     if (upc_mod.isUPC_Shared())  mangled_name << "SHD";
     if (upc_mod.isUPC_Strict())  mangled_name << "STR";
     if (upc_mod.isUPC_Relaxed()) mangled_name << "RLX";
 
     mangled_name << get_base_type ()->get_mangled ().str ();
     return mangled_name;
   }

#if 0
// Older code
SgName
SgModifierType::get_mangled(SgUnparse_Info& info)
   {
     SgName tmp;
     if (get_typeModifier().get_constVolatileModifier().isConst())       tmp << "C";
     if (get_typeModifier().get_constVolatileModifier().isVolatile())    tmp << "V";
  // DQ (4/22/2004): Removed support for CC++
  // if (isSync())        tmp << "SYN";
  // if (isGlobal())      tmp << "GLB";
     if (get_typeModifier().isRestrict())    tmp << "RST";
     if (get_typeModifier().get_upcModifier().isUPC_Shared())  tmp << "SHD";
     if (get_typeModifier().get_upcModifier().isUPC_Strict())  tmp << "STR";
     if (get_typeModifier().get_upcModifier().isUPC_Relaxed()) tmp << "RLX";

     tmp << get_base_type()->get_mangled(info).str();

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgModifierType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgModifierType::variantT() const {
  return V_SgModifierType;
}

#if 0
int
SgModifierType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_MODIFIER;
   }
#endif

const char*
SgModifierType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgModifierType";  
   }

std::string
SgModifierType::class_name() const
   {
     assert(this != NULL);
     return "SgModifierType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgModifierType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgModifierType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_MODIFIER)
        {
          printf ("Error in SgModifierType::error(): SgModifierType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgModifierType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_MODIFIER);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgModifierType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgModifierType::variant() const \n");
#endif
     assert(this != NULL);
     return T_MODIFIER;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgModifierType* isSgModifierType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgModifierType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgModifierType* isSgModifierType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgModifierType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgModifierType::~SgModifierType ()
   {
#if 0
  // debugging information!
     printf ("In SgModifierType::~SgModifierType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for base_type
     p_base_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgModifierType::SgModifierType ( SgType* base_type )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgModifierType::SgModifierType (SgType* base_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_type = base_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_MODIFIER == variant());
     post_construction_initialization();

  // Test the isSgModifierType() function since it has been problematic
     assert(isSgModifierType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3794 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgArrayType*
SgArrayType::createType ( SgType* base_type, SgExpression* idx )
   {
     SgArrayType* returnType = new SgArrayType(base_type, idx);
     assert(returnType != NULL);

  // DQ (2/20/2007): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (idx != NULL)
        {
          ROSE_ASSERT(idx->get_parent() == NULL);
          idx->set_parent(returnType);
        }

     return returnType;
  // return new SgArrayType(base_type, idx);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgArrayType::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgArrayType::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExpression* 
SgArrayType::get_index () const
   {
     assert (this != NULL);
     return p_index;
   }

void
SgArrayType::set_index ( SgExpression* index )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_index != NULL && index != NULL && p_index != index)
        {
          printf ("Warning: index = %p overwriting valid pointer p_index = %p \n",index,p_index);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_index != NULL && index != NULL && p_index != index) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_index = index;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgExprListExp* 
SgArrayType::get_dim_info () const
   {
     assert (this != NULL);
     return p_dim_info;
   }

void
SgArrayType::set_dim_info ( SgExprListExp* dim_info )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_dim_info != NULL && dim_info != NULL && p_dim_info != dim_info)
        {
          printf ("Warning: dim_info = %p overwriting valid pointer p_dim_info = %p \n",dim_info,p_dim_info);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_dim_info != NULL && dim_info != NULL && p_dim_info != dim_info) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_dim_info = dim_info;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

int 
SgArrayType::get_rank () const
   {
     assert (this != NULL);
     return p_rank;
   }

void
SgArrayType::set_rank ( int rank )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_rank = rank;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 3240 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

// RV (1/31/2006): Changed the form of the mangled name to include begin/end tags.
SgName
SgArrayType::get_mangled (void) const
   {
     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);
     SgName base_name  = base_type->get_mangled();

     const SgExpression* index_exp = get_index();
     SgName index_name;
     if (index_exp != NULL)
        {
          index_name = index_exp->unparseToString();
        }

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In SgArrayType::get_mangled(), empty base type name found \n");
          base_name = "unnamed_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     if (index_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In SgArrayType::get_mangled(), no empty base type name found \n");
          index_name = "unnamed_index";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "_Ab_"
                  << base_name.str ()
                  << "_index_"
                  << index_name.str ()
                  << "_Ae_";

  // printf ("SgArrayType::get_mangled(): mangled_name = %s \n",mangled_name.str());

     return mangled_name;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgArrayType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgArrayType::variantT() const {
  return V_SgArrayType;
}

#if 0
int
SgArrayType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_ARRAY;
   }
#endif

const char*
SgArrayType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgArrayType";  
   }

std::string
SgArrayType::class_name() const
   {
     assert(this != NULL);
     return "SgArrayType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgArrayType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgArrayType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_ARRAY)
        {
          printf ("Error in SgArrayType::error(): SgArrayType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgArrayType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_ARRAY);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgArrayType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgArrayType::variant() const \n");
#endif
     assert(this != NULL);
     return T_ARRAY;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgArrayType* isSgArrayType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgArrayType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgArrayType* isSgArrayType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgArrayType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgArrayType::~SgArrayType ()
   {
#if 0
  // debugging information!
     printf ("In SgArrayType::~SgArrayType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_index;
     delete p_dim_info;

  // case: not a listType for base_type
     p_base_type = NULL; // non list case 
  // case: not a listType for index
     p_index = NULL; // non list case 
  // case: not a listType for dim_info
     p_dim_info = NULL; // non list case 
  // case: not a listType for rank
     p_rank = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgArrayType::SgArrayType ( SgType* base_type, SgExpression* index )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgArrayType::SgArrayType (SgType* base_type, SgExpression* index) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_type = base_type;
     p_index = index;
     p_dim_info = NULL;
     p_rank = 0;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_ARRAY == variant());
     post_construction_initialization();

  // Test the isSgArrayType() function since it has been problematic
     assert(isSgArrayType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeEllipse::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeEllipse::variantT() const {
  return V_SgTypeEllipse;
}

#if 0
int
SgTypeEllipse::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_ELLIPSE;
   }
#endif

const char*
SgTypeEllipse::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeEllipse";  
   }

std::string
SgTypeEllipse::class_name() const
   {
     assert(this != NULL);
     return "SgTypeEllipse";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeEllipse::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeEllipse::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_ELLIPSE)
        {
          printf ("Error in SgTypeEllipse::error(): SgTypeEllipse object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeEllipse::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_ELLIPSE);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeEllipse SgTypeEllipse::builtin_type;
// SgTypeEllipse* SgTypeEllipse::builtin_type = new SgTypeEllipse();
SgTypeEllipse* SgTypeEllipse::p_builtin_type = NULL;

SgTypeEllipse*
SgTypeEllipse::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeEllipse object for the p_builtin_type \n");
          p_builtin_type = new SgTypeEllipse();
       // p_builtin_type = new SgTypeEllipse(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeEllipse::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeEllipse::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeEllipse::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeEllipse::get_mangled (void) const
   {
     return SgName("e");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeEllipse::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeEllipse::variant() const \n");
#endif
     assert(this != NULL);
     return T_ELLIPSE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeEllipse* isSgTypeEllipse ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeEllipse*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeEllipse* isSgTypeEllipse ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeEllipse*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeEllipse::~SgTypeEllipse ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeEllipse::~SgTypeEllipse (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeEllipse::SgTypeEllipse (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeEllipse::SgTypeEllipse () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_ELLIPSE == variant());
     post_construction_initialization();

  // Test the isSgTypeEllipse() function since it has been problematic
     assert(isSgTypeEllipse(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3739 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"




// End of memberFunctionString
// Start of memberFunctionString
#line 2067 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTemplateType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTemplateType::variantT() const {
  return V_SgTemplateType;
}

#if 0
int
SgTemplateType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_TEMPLATE;
   }
#endif

const char*
SgTemplateType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTemplateType";  
   }

std::string
SgTemplateType::class_name() const
   {
     assert(this != NULL);
     return "SgTemplateType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTemplateType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTemplateType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_TEMPLATE)
        {
          printf ("Error in SgTemplateType::error(): SgTemplateType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTemplateType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_TEMPLATE);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTemplateType::get_mangled ( SgUnparse_Info & info )
SgName
SgTemplateType::get_mangled (void) const
   {
     return SgName("MANGLED_ID_STRING");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTemplateType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTemplateType::variant() const \n");
#endif
     assert(this != NULL);
     return T_TEMPLATE;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTemplateType* isSgTemplateType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTemplateType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTemplateType* isSgTemplateType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTemplateType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTemplateType::~SgTemplateType ()
   {
#if 0
  // debugging information!
     printf ("In SgTemplateType::~SgTemplateType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTemplateType::SgTemplateType (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTemplateType::SgTemplateType () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_TEMPLATE == variant());
     post_construction_initialization();

  // Test the isSgTemplateType() function since it has been problematic
     assert(isSgTemplateType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3834 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgQualifiedNameType*
SgQualifiedNameType::createType(SgType* base_type, unsigned int f)
   {
     assert(base_type != NULL);

  // DQ (12/21/2005): This is a copy of the function from SgModifierType 
  // (I think we need it to override the base class implementation).

     printf ("Error, this function SgQualifiedNameType should not have been called! \n");
     ROSE_ASSERT (false);

     return NULL;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgQualifiedNameType::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgQualifiedNameType::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 2335 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgQualifiedNameType::p_defaultQualifiedNamePtrList;

SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgQualifiedNameType::set_qualifiedNameList( const SgQualifiedNamePtrList & x )
   {
     p_qualifiedNameList = x;
   }

SgName
SgQualifiedNameType::get_prefix() const
   {
     SgName tmp;

#if 1
     SgQualifiedNamePtrList::const_iterator i = p_qualifiedNameList.begin();
     while(i != p_qualifiedNameList.end())
        {
          printf ("Found a qualified name \n");
          if (isSgGlobal((*i)->get_scope()) != NULL)
             {
               printf ("Output the global scope qualifier \n");
               tmp << "::";
             }
            else
             {
            // Use the generated name until we are ready to select between generated or stored qualified names
               printf ("Use the generated name until we are ready to select between generated or stored qualified names \n");
             }
          i++;
        }
#else
     printf ("Error: SgQualifiedNameType::get_prefix() not used! \n");
     ROSE_ASSERT(false);
#endif

     return tmp;
   }

#if 1
// SgName SgQualifiedNameType::get_mangled (SgUnparse_Info & info)
SgName
SgQualifiedNameType::get_mangled (void) const
   {
     SgName tmp;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // info.set_name();
  // printf ("In SgQualifiedNameType::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled (SgNO_UNPARSE_INFO);

  // printf ("WARNING: The generated name in SgQualifiedNameType::get_mangled() should use a prefix generated from mangled names \n");

#if 1
  // SgName qualifiedName = get_prefix();

  // tmp << qualifiedName.str() << get_base_type()->get_mangled(info).str();

  // DQ (10/10/2006): The base_type should be fully qualified before mangling, so I don't think we need the prefix!
  // tmp << qualifiedName.str() << get_base_type()->get_mangled().str();
     tmp << "qualified_name_" << get_base_type()->get_mangled().str();
#else
     printf ("Error: SgQualifiedNameType::get_mangled() not used! \n");
     ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgQualifiedNameType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgQualifiedNameType::variantT() const {
  return V_SgQualifiedNameType;
}

#if 0
int
SgQualifiedNameType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_QUALIFIED_NAME;
   }
#endif

const char*
SgQualifiedNameType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgQualifiedNameType";  
   }

std::string
SgQualifiedNameType::class_name() const
   {
     assert(this != NULL);
     return "SgQualifiedNameType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgQualifiedNameType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgQualifiedNameType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_QUALIFIED_NAME)
        {
          printf ("Error in SgQualifiedNameType::error(): SgQualifiedNameType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgQualifiedNameType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_QUALIFIED_NAME);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgQualifiedNameType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgQualifiedNameType::variant() const \n");
#endif
     assert(this != NULL);
     return T_QUALIFIED_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgQualifiedNameType* isSgQualifiedNameType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgQualifiedNameType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgQualifiedNameType* isSgQualifiedNameType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgQualifiedNameType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgQualifiedNameType::~SgQualifiedNameType ()
   {
#if 0
  // debugging information!
     printf ("In SgQualifiedNameType::~SgQualifiedNameType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for base_type
     p_base_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgQualifiedNameType::SgQualifiedNameType ( SgType* base_type )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgQualifiedNameType::SgQualifiedNameType (SgType* base_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_type = base_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_QUALIFIED_NAME == variant());
     post_construction_initialization();

  // Test the isSgQualifiedNameType() function since it has been problematic
     assert(isSgQualifiedNameType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 3852 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (8/27/2006): This code is used for both SgTypeComplex and SgTypeImaginary.

// DQ (8/10/2006): Three kinds of SgComplex IR nodes (for float, double, and long double) 
// which we want to be able to share within the AST.
SgTypeComplex* SgTypeComplex::p_builtin_float_complex       = NULL;
SgTypeComplex* SgTypeComplex::p_builtin_double_complex      = NULL;
SgTypeComplex* SgTypeComplex::p_builtin_long_double_complex = NULL;

SgTypeComplex*
SgTypeComplex::createType(SgTypeComplex::floating_point_precision_enum precision)
   {
  // This function build any of three versions of Complex type IR nodes, but enforces sharing between the different versions.
     static bool firstCallToFunctionForFloatPrecision      = true;
     static bool firstCallToFunctionForDoublePrecision     = true;
     static bool firstCallToFunctionForLongDoublePrecision = true;

     SgTypeComplex* returnType = NULL;
     switch (precision)
        {
          case e_floatPrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForFloatPrecision == true)
                  {
                    p_builtin_float_complex = new SgTypeComplex(precision);
                  }
               firstCallToFunctionForFloatPrecision = false;
               returnType = p_builtin_float_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          case e_doublePrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForDoublePrecision == true)
                  {
                    p_builtin_double_complex = new SgTypeComplex(precision);
                  }
               firstCallToFunctionForDoublePrecision = false;
               returnType = p_builtin_double_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          case e_longDoublePrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForLongDoublePrecision == true)
                  {
                    p_builtin_long_double_complex = new SgTypeComplex(precision);
                  }
               firstCallToFunctionForLongDoublePrecision = false;
               returnType = p_builtin_long_double_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          default:
               printf ("Error: precision out of range (%d) \n",precision);
               ROSE_ASSERT(false);
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypeComplex::floating_point_precision_enum 
SgTypeComplex::get_precision () const
   {
     assert (this != NULL);
     return p_precision;
   }

void
SgTypeComplex::set_precision ( SgTypeComplex::floating_point_precision_enum precision )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_precision = precision;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeComplex::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeComplex::variantT() const {
  return V_SgTypeComplex;
}

#if 0
int
SgTypeComplex::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_COMPLEX;
   }
#endif

const char*
SgTypeComplex::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeComplex";  
   }

std::string
SgTypeComplex::class_name() const
   {
     assert(this != NULL);
     return "SgTypeComplex";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeComplex::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeComplex::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_COMPLEX)
        {
          printf ("Error in SgTypeComplex::error(): SgTypeComplex object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeComplex::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_COMPLEX);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeComplex::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeComplex::get_mangled (void) const
   {
     return SgName("Complex");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeComplex::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeComplex::variant() const \n");
#endif
     assert(this != NULL);
     return T_COMPLEX;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeComplex* isSgTypeComplex ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeComplex*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeComplex* isSgTypeComplex ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeComplex*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeComplex::~SgTypeComplex ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeComplex::~SgTypeComplex (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for precision
     p_precision = SgTypeComplex::e_errorPrecision; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeComplex::SgTypeComplex ( SgTypeComplex::floating_point_precision_enum precision )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeComplex::SgTypeComplex (SgTypeComplex::floating_point_precision_enum precision) sage_class_name() = %s \n",sage_class_name());
#endif

     p_precision = precision;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_COMPLEX == variant());
     post_construction_initialization();

  // Test the isSgTypeComplex() function since it has been problematic
     assert(isSgTypeComplex(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 3852 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (8/27/2006): This code is used for both SgTypeComplex and SgTypeImaginary.

// DQ (8/10/2006): Three kinds of SgComplex IR nodes (for float, double, and long double) 
// which we want to be able to share within the AST.
SgTypeImaginary* SgTypeImaginary::p_builtin_float_complex       = NULL;
SgTypeImaginary* SgTypeImaginary::p_builtin_double_complex      = NULL;
SgTypeImaginary* SgTypeImaginary::p_builtin_long_double_complex = NULL;

SgTypeImaginary*
SgTypeImaginary::createType(SgTypeImaginary::floating_point_precision_enum precision)
   {
  // This function build any of three versions of Complex type IR nodes, but enforces sharing between the different versions.
     static bool firstCallToFunctionForFloatPrecision      = true;
     static bool firstCallToFunctionForDoublePrecision     = true;
     static bool firstCallToFunctionForLongDoublePrecision = true;

     SgTypeImaginary* returnType = NULL;
     switch (precision)
        {
          case e_floatPrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForFloatPrecision == true)
                  {
                    p_builtin_float_complex = new SgTypeImaginary(precision);
                  }
               firstCallToFunctionForFloatPrecision = false;
               returnType = p_builtin_float_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          case e_doublePrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForDoublePrecision == true)
                  {
                    p_builtin_double_complex = new SgTypeImaginary(precision);
                  }
               firstCallToFunctionForDoublePrecision = false;
               returnType = p_builtin_double_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          case e_longDoublePrecision:
             {
            // This is protection that is required to support file I/O and the unknown order of static initialization.
               if (firstCallToFunctionForLongDoublePrecision == true)
                  {
                    p_builtin_long_double_complex = new SgTypeImaginary(precision);
                  }
               firstCallToFunctionForLongDoublePrecision = false;
               returnType = p_builtin_long_double_complex;
               ROSE_ASSERT(returnType != NULL);
               break;
             }

          default:
               printf ("Error: precision out of range (%d) \n",precision);
               ROSE_ASSERT(false);
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgTypeImaginary::floating_point_precision_enum 
SgTypeImaginary::get_precision () const
   {
     assert (this != NULL);
     return p_precision;
   }

void
SgTypeImaginary::set_precision ( SgTypeImaginary::floating_point_precision_enum precision )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_precision = precision;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeImaginary::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeImaginary::variantT() const {
  return V_SgTypeImaginary;
}

#if 0
int
SgTypeImaginary::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_IMAGINARY;
   }
#endif

const char*
SgTypeImaginary::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeImaginary";  
   }

std::string
SgTypeImaginary::class_name() const
   {
     assert(this != NULL);
     return "SgTypeImaginary";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeImaginary::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeImaginary::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_IMAGINARY)
        {
          printf ("Error in SgTypeImaginary::error(): SgTypeImaginary object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeImaginary::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_IMAGINARY);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeImaginary::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeImaginary::get_mangled (void) const
   {
     return SgName("Imaginary");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeImaginary::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeImaginary::variant() const \n");
#endif
     assert(this != NULL);
     return T_IMAGINARY;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeImaginary* isSgTypeImaginary ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeImaginary*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeImaginary* isSgTypeImaginary ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeImaginary*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeImaginary::~SgTypeImaginary ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeImaginary::~SgTypeImaginary (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for precision
     p_precision = SgTypeImaginary::e_errorPrecision; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeImaginary::SgTypeImaginary ( SgTypeImaginary::floating_point_precision_enum precision )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeImaginary::SgTypeImaginary (SgTypeImaginary::floating_point_precision_enum precision) sage_class_name() = %s \n",sage_class_name());
#endif

     p_precision = precision;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_IMAGINARY == variant());
     post_construction_initialization();

  // Test the isSgTypeImaginary() function since it has been problematic
     assert(isSgTypeImaginary(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypeDefault::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypeDefault::variantT() const {
  return V_SgTypeDefault;
}

#if 0
int
SgTypeDefault::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_DEFAULT;
   }
#endif

const char*
SgTypeDefault::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypeDefault";  
   }

std::string
SgTypeDefault::class_name() const
   {
     assert(this != NULL);
     return "SgTypeDefault";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypeDefault::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypeDefault::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_DEFAULT)
        {
          printf ("Error in SgTypeDefault::error(): SgTypeDefault object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypeDefault::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_DEFAULT);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeDefault SgTypeDefault::builtin_type;
// SgTypeDefault* SgTypeDefault::builtin_type = new SgTypeDefault();
SgTypeDefault* SgTypeDefault::p_builtin_type = NULL;

SgTypeDefault*
SgTypeDefault::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeDefault object for the p_builtin_type \n");
          p_builtin_type = new SgTypeDefault();
       // p_builtin_type = new SgTypeDefault(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypeDefault::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypeDefault::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgTypeDefault::get_mangled ( SgUnparse_Info & info )
SgName
SgTypeDefault::get_mangled (void) const
   {
     return SgName("u");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypeDefault::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypeDefault::variant() const \n");
#endif
     assert(this != NULL);
     return T_DEFAULT;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypeDefault* isSgTypeDefault ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypeDefault*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypeDefault* isSgTypeDefault ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypeDefault*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypeDefault::~SgTypeDefault ()
   {
#if 0
  // debugging information!
     printf ("In SgTypeDefault::~SgTypeDefault (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypeDefault::SgTypeDefault (  )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgTypeDefault::SgTypeDefault () sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_DEFAULT == variant());
     post_construction_initialization();

  // Test the isSgTypeDefault() function since it has been problematic
     assert(isSgTypeDefault(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3458 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgFunctionType*
SgFunctionType::createType(SgPartialFunctionType* ft)
   {
  // The problem with this function is that I have not added the name mangling into SAGE 3 yet!

     ROSE_ASSERT(ft != NULL);

#if 1
  // DQ (3/29/2006): 
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle 
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is build (and parent pointers 
  // are set).  If functions are created then the function type table must also be updated.
     SgFunctionType* theType = new SgFunctionType(ft);

  // DQ (6/21/2006): Since we mangle the return type into the mangled function as part of building 
  // the symbol table we don't have to worry about sharing function types that would have different 
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());
#else
  // printf ("In SgFunctionType::createType(SgPartialFunctionType* ft): calling ft->get_mangled_type \n");
  // SgName nname = ft->get_mangled_type();

  // DQ (3/29/2006): experiment with generating a unique name for the function type table lookup
  // This will avoid calling the get_mangled_type() function durring the construction 
  // of the AST.  Because the name will be unique there will be no collision in the 
  // function type symbol table.  The function type symbol tabel will then have to
  // be rebuilt after the AST is build (in a post-processing phase).
     static int functionCounter = 0;
     string baseName = "function_";
     string mangleName = baseName + StringUtility::numberToString(functionCounter++);
     SgName nname = mangleName;

#if 0
     SgName nname = "NOT YET SUPPORTED IN SAGE3 YET"; // ft->get_mangled_type();
     printf ("WARNING: Name mangling not yet suppported in SAGE 3! (required in SgFunctionType::createType()) \n");
#endif

  // check the function type table
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // SgType *t = Sgfunc_type_table.lookup_function_type(nname);
     ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
     SgType *t = get_globalFunctionTypeTable()->lookup_function_type(nname);

     SgFunctionType *theType = isSgFunctionType(t);
  // if(!theType)
     if(theType == NULL)
        {
       // printf ("##### Building a default type since theType == NULL \n");
          theType = new SgFunctionType(ft);
          ROSE_ASSERT(theType != NULL);
       // DQ (1/31/2006): Modified to build all types in the memory pools
       // Sgfunc_type_table.insert_function_type(nname, theType);
          ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
          get_globalFunctionTypeTable()->insert_function_type(nname, theType);
        }
       else
          theType->set_orig_return_type(ft->get_return_type());

  // Commented out to avoid deleting the input data (poor design, I think)
  // delete ft;
#endif

     ROSE_ASSERT(theType != NULL);
     return theType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgFunctionType::get_return_type () const
   {
     assert (this != NULL);
     return p_return_type;
   }

void
SgFunctionType::set_return_type ( SgType* return_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_return_type != NULL && return_type != NULL && p_return_type != return_type)
        {
          printf ("Warning: return_type = %p overwriting valid pointer p_return_type = %p \n",return_type,p_return_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_return_type != NULL && return_type != NULL && p_return_type != return_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_return_type = return_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgFunctionType::get_has_ellipses () const
   {
     assert (this != NULL);
     return p_has_ellipses;
   }

void
SgFunctionType::set_has_ellipses ( bool has_ellipses )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_has_ellipses = has_ellipses;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgFunctionType::get_orig_return_type () const
   {
     assert (this != NULL);
     return p_orig_return_type;
   }

void
SgFunctionType::set_orig_return_type ( SgType* orig_return_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_orig_return_type != NULL && orig_return_type != NULL && p_orig_return_type != orig_return_type)
        {
          printf ("Warning: orig_return_type = %p overwriting valid pointer p_orig_return_type = %p \n",orig_return_type,p_orig_return_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_orig_return_type != NULL && orig_return_type != NULL && p_orig_return_type != orig_return_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_orig_return_type = orig_return_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgFunctionParameterTypeList* 
SgFunctionType::get_argument_list () const
   {
     assert (this != NULL);
     return p_argument_list;
   }

void
SgFunctionType::set_argument_list ( SgFunctionParameterTypeList* argument_list )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_argument_list != NULL && argument_list != NULL && p_argument_list != argument_list)
        {
          printf ("Warning: argument_list = %p overwriting valid pointer p_argument_list = %p \n",argument_list,p_argument_list);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_argument_list != NULL && argument_list != NULL && p_argument_list != argument_list) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_argument_list = argument_list;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2424 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// Specialized constructor
SgFunctionType::SgFunctionType(SgPartialFunctionType *ft)
   {
     assert(ft != NULL);
     p_return_type      = ft->p_return_type;
     p_has_ellipses     = ft->p_has_ellipses;

#if 0
     p_orig_return_type = ft->p_return_type;

  // DQ (6/25/2006): Handle the allocation of the SgFunctionParameterTypeList in one place if possible!
  // This is part of debugging the AST File I/O.

  /* process argument type */
     p_argument_list = new SgFunctionParameterTypeList();
     ROSE_ASSERT(p_argument_list != NULL);

  // DQ (5/11/2006): Set the parent to avoid having NULL pointers
     p_argument_list->set_parent(this);
#else
     post_construction_initialization();
#endif

     SgTypePtrList::iterator p = ft->get_arguments().begin();
  // printf ("PartialFunctionType->get_arguments().size() = %zu \n",ft->get_arguments().size());
     while(p != ft->get_arguments().end())
        {
       // printf ("     function argument = %p = %s \n",*p,(*p)->sage_class_name());
          append_argument((*p));
          p++;
        }
   }

void
SgFunctionType::post_construction_initialization () 
   {
     p_orig_return_type = NULL;
     p_argument_list    = new SgFunctionParameterTypeList();
     ROSE_ASSERT(p_argument_list != NULL);

  // DQ (6/25/2006): Commented out to allow File I/O to work, I don't understand why it is required!
  // DQ (5/11/2006): Set the parent to avoid having NULL pointers
     p_argument_list->set_parent(this);

  // DQ (6/22/2006): Initialize the orig_return_type
     ROSE_ASSERT(p_return_type != NULL);
     set_orig_return_type(p_return_type);
     ROSE_ASSERT(p_orig_return_type != NULL);

   }

const SgTypePtrList & 
SgFunctionType::get_arguments() const 
   { return p_argument_list->get_arguments(); }

SgTypePtrList & 
SgFunctionType::get_arguments() 
   { return p_argument_list->get_arguments(); }

void
SgFunctionType::append_argument( SgType* what) 
   {
    p_argument_list->append_argument(what);
   }

void
SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_argument_list->insert_argument(where,what);
   }


// RV (1/31/2006): Changed the form of the mangled name.
SgName
SgFunctionType::get_mangled (void) const
   {
  // process argument type
     const SgTypePtrList& args = get_arguments ();
     SgName arg_names = mangleTypes (args.begin (), args.end ());

  // process return type
     const SgType* ret_type = get_return_type ();
     ROSE_ASSERT (ret_type);
     SgName ret_name = ret_type->get_mangled ();

  // Build complete mangled name
     SgName mangled_name;
     mangled_name << "_Fb_" // begin function signature
                  << ret_name.str () // return type
                  << "_Gb_" // argument list begin
                  << arg_names.str () // argument types
                  << "_Fe_" // end function signature
       ;

#if 0
     printf ("In SgFunctionType::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
    }


#if 0
// virtual SgName SgFunctionType::get_mangled_name ( SgUnparse_Info & info );
SgName
SgFunctionType::get_mangled_name(SgUnparse_Info& info) 
   {
     SgName rtmp;
  // SgDeclarationStatement *dstmt = info.get_decl_stmt();
     SgFunctionDeclaration *dstmt = isSgFunctionDeclaration(info.get_decl_stmt());
     ROSE_ASSERT (dstmt != NULL);
     SgName fname = info.get_name();

  // int len = strlen(fname.str());
  // SgName tmp(fname);
  // char *opstr  = "operator";
  // char *newstr = "new";
  // char *delstr = "delete";
  // int m = strlen(opstr);

#if 0
     printf ("In SgFunctionType::get_mangled_name(): fname = %s \n",fname.str());
     printf ("     unused function qualified name = %s \n",dstmt->get_qualified_name().str());
#endif

#if 0
  // DQ (4/28/2005): These should be false since this is not a member function
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isConstructor() == false);
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isConversion()  == false);
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isDestructor()  == false);

  // DQ (4/29/2005): This is all that we need since non-member function can never be 
  // constructor, destructors, or conversion operators.
     rtmp = mangledNameSupport(fname,info);
#else
     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor()) rtmp << "__dt";
            else
               if (dstmt->get_specialFunctionModifier().isConversion())
                  {
                    rtmp << "__conversion__";
                 // rtmp = mangledNameSupport(fname,info);
                  }
                 else
                  {
                 // These are just normal functions
                 // ROSE_ASSERT (dstmt->get_specialFunctionModifier().isOperator());
                    rtmp = mangledNameSupport(fname,info);
                  }
#endif

     string mangledName = rtmp.str();
     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

#if 0
     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor())
               rtmp << "__dt";
            else
#if 1
             {
               rtmp = mangledNameSupport(fname,info);
             }
#else
               if (len > 0 && strncmp(fname.str(),opstr,m) == 0)
                  {
                    if (fname.str()[m]==' ')
                       {
                      // DQ (4/27/2005): "m+2" should be "m+1"
                         if (strncmp(&(fname.str()[m+1]),newstr,strlen(newstr)) == 0)
                            {
                           // DQ (4/27/2005): Added support for array new
                              int newStringLength = strlen(newstr);
                              int parenStart = m+1+newStringLength;
                              if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                   rtmp << "__na";
                                else
                                   rtmp << "__nw";
                            }
                           else
                            {
                           // DQ (4/27/2005): Added support for array delete
                              if (strncmp(&(fname.str()[m+1]),delstr,strlen(delstr)) == 0)
                                 {
                                   int deleteStringLength = strlen(delstr);
                                   int parenStart = m+1+deleteStringLength;
                                   if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                        rtmp << "__da";
                                     else
                                        rtmp << "__dl";
                                 }
                                else
                                 {
                                // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
                                 }
                            }
                       }
                      else
                       {
                      // real operator  
                         SgName opname=&(fname.str()[m]);
                         if(opname==SgName("->"))        rtmp << "__rf";
                         else if (opname==SgName("->*")) rtmp << "__rm";
                         else if (opname==SgName("=="))  rtmp << "__eq";
                         else if (opname==SgName("<"))   rtmp << "__lt";
                         else if (opname==SgName(">"))   rtmp << "__gt";
                         else if (opname==SgName("!="))  rtmp << "__ne";
                         else if (opname==SgName("<="))  rtmp << "__le";
                         else if (opname==SgName(">="))  rtmp << "__ge";
                         else if (opname==SgName("+"))   rtmp << "__pl";
                         else if (opname==SgName("-"))   rtmp << "__mi";
                         else if (opname==SgName("*"))   rtmp << "__ml";
                         else if (opname==SgName("/"))   rtmp << "__dv";
                         else if (opname==SgName("%"))   rtmp << "__md";
                         else if (opname==SgName("&&"))  rtmp << "__aa";
                         else if (opname==SgName("!"))   rtmp << "__nt";
                         else if (opname==SgName("||"))  rtmp << "__oo";
                         else if (opname==SgName("^"))   rtmp << "__er";
                         else if (opname==SgName("&"))   rtmp << "__ad";
                         else if (opname==SgName("|"))   rtmp << "__or";
                         else if (opname==SgName(","))   rtmp << "__cm";
                         else if (opname==SgName("<<"))  rtmp << "__ls";
                         else if (opname==SgName(">>"))  rtmp << "__rs";
                         else if (opname==SgName("--"))  rtmp << "__mm";
                         else if (opname==SgName("++"))  rtmp << "__pp";
                         else if (opname==SgName("~"))   rtmp << "__co";
                         else if (opname==SgName("="))   rtmp << "__as";
                         else if (opname==SgName("+="))  rtmp << "__apl";
                         else if (opname==SgName("-="))  rtmp << "__ami";
                         else if (opname==SgName("&="))  rtmp << "__aad";
                         else if (opname==SgName("|="))  rtmp << "__aor";
                         else if (opname==SgName("*="))  rtmp << "__amu";
                         else if (opname==SgName("/="))  rtmp << "__adv";
                         else if (opname==SgName("%="))  rtmp << "__amd";
                         else if (opname==SgName("^="))  rtmp << "__aer";
                         else if (opname==SgName("<<=")) rtmp << "__als";
                         else if (opname==SgName(">>=")) rtmp << "__ars";
                         else if (opname==SgName("()"))  rtmp << "__cl";
                         else if (opname==SgName("[]"))  rtmp << "__xi";
                         else
                            {
                              printf ("In SgFunctionType::get_mangled_name(): This case should never be reached (fname = %s) \n",fname.str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
                 else
                    rtmp << fname.str();
#endif
#endif

     return rtmp;
   }
#endif

#if 0
// Old code

// this routine can do 2 things,
// mangle a type - without funcname and class name(if member function)
// mangle a complete function declaration with name and class name
SgName
SgFunctionType::get_mangled(SgUnparse_Info & info)
   {
     SgName tmp;

  // printf ("In SgFunctionType::get_mangled(SgUnparse_Info&) info.PrintName() = %s \n",(info.PrintName() == true) ? "true" : "false");

  /* should have a name to start with */
     if (info.PrintName())
        {
       // DQ (6/23/2005): This path is taken for constructors, destructors and conversion operators (I think!)
       // SgName name = get_mangled_name(info);
       // printf ("In SgFunctionType::get_mangled(SgUnparse_Info&): (assuming info.PrintName() == true): name = %s \n",name.str());
       // tmp << get_mangled_name(info).str();
          tmp << name.str();
        }

     tmp << "__";
     tmp << "F";

  /* process argument type */
     SgTypePtrList::iterator p = get_arguments().begin();
     while(p != get_arguments().end())
        {
          tmp << (*p)->get_mangled(info).str();

       // DQ (5/2/2005): Added to handle function arguments which are templates
          tmp = fixupTemplateNameForMangledNameSupport(tmp);

          p++;
        }

  /* process return type */
     SgName returnTypeName = get_return_type()->get_mangled(info);
  // tmp << "_" << get_return_type()->get_mangled(info).str();
     tmp << "_" << returnTypeName.str();

  // DQ (5/2/2005): Added to handle function arguments which are templates
     tmp = fixupTemplateNameForMangledNameSupport(tmp);

#if 0
     printf ("########## In SgFunctionType::get_mangled(): tmp = %s (returnTypeName = %s is a %s) ########## \n",
          tmp.str(),returnTypeName.str(),get_return_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif

//! \deprecated by RV (1/31/2006)
SgName
SgFunctionType::get_mangled_type () 
   { 
     return get_mangled();
   }

#if 0
SgName 
SgFunctionType::get_mangled_type () 
   { 
     SgUnparse_Info info;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // info.set_name();
  // printf ("In SgFunctionType::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled (SgNO_UNPARSE_INFO);
     return get_mangled (info);
   }
#endif


// SgFunctionType* SgFunctionType::mkAnotherType(SgType *);
// void sym_print(ostream& os);

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgFunctionType::get_symbol_from_symbol_table() const
   {
     return SgNode::get_globalFunctionTypeTable()->get_function_type_table()->find(this);
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgFunctionType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgFunctionType::variantT() const {
  return V_SgFunctionType;
}

#if 0
int
SgFunctionType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_FUNCTION;
   }
#endif

const char*
SgFunctionType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgFunctionType";  
   }

std::string
SgFunctionType::class_name() const
   {
     assert(this != NULL);
     return "SgFunctionType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgFunctionType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgFunctionType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_FUNCTION)
        {
          printf ("Error in SgFunctionType::error(): SgFunctionType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgFunctionType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_FUNCTION);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgFunctionType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgFunctionType::variant() const \n");
#endif
     assert(this != NULL);
     return T_FUNCTION;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgFunctionType* isSgFunctionType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgFunctionType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgFunctionType* isSgFunctionType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgFunctionType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgFunctionType::~SgFunctionType ()
   {
#if 0
  // debugging information!
     printf ("In SgFunctionType::~SgFunctionType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     
     delete p_argument_list;

  // case: not a listType for return_type
     p_return_type = NULL; // non list case 
  // case: not a listType for has_ellipses
     p_has_ellipses = TRUE; // non list case 
  // case: not a listType for orig_return_type
     p_orig_return_type = NULL; // non list case 
  // case: not a listType for argument_list
     p_argument_list = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgFunctionType::SgFunctionType ( SgType* return_type, bool has_ellipses )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgFunctionType::SgFunctionType (SgType* return_type, bool has_ellipses) sage_class_name() = %s \n",sage_class_name());
#endif

     p_return_type = return_type;
     p_has_ellipses = has_ellipses;
     p_orig_return_type = NULL;
     p_argument_list = NULL;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_FUNCTION == variant());
     post_construction_initialization();

  // Test the isSgFunctionType() function since it has been problematic
     assert(isSgFunctionType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3533 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgMemberFunctionType*
SgMemberFunctionType::createType(SgPartialFunctionType* ft)
   {
     ROSE_ASSERT(ft != NULL);
  // printf ("In SgMemberFunctionType::createType(SgPartialFunctionType* ft): calling ft->get_mangled_type \n");
  // SgName nname = ft->get_mangled_type();

#if 1
  // DQ (3/29/2006): 
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle 
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is build (and parent pointers 
  // are set).  If functions are created then the function type table must also be updated.
     SgMemberFunctionType* theType = new SgMemberFunctionType(ft);

  // DQ (6/22/2006): Since we mangle the return type into the mangled function as part of building 
  // the symbol table we don't have to worry about sharing function types that would have different 
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());
#else
  // DQ (3/29/2006): experiment with generating a unique name for the function type table lookup
  // This will avoid calling the get_mangled_type() function durring the construction 
  // of the AST.  Because the name will be unique there will be no collision in the 
  // function type symbol table.  The function type symbol tabel will then have to
  // be rebuilt after the AST is build (in a post-processing phase).
     static int functionCounter = 0;
     string baseName = "memberfunction_";
     string mangleName = baseName + StringUtility::numberToString(functionCounter++);
     SgName nname = mangleName;

#if 0
     SgName nname = "NOT YET SUPPORTED"; // ft->get_mangled_type();
     printf ("WARNING: Name mangling not yet suppported in SAGE 3! (required in SgFunctionType::createType()) \n");
#endif

  // check the function type table
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // SgType *t = Sgfunc_type_table.lookup_function_type(nname);
     ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
     SgType *t = get_globalFunctionTypeTable()->lookup_function_type(nname);
     SgMemberFunctionType* theType = isSgMemberFunctionType(t);
  // if (!theType)
     if (theType == NULL)
        {
          theType = new SgMemberFunctionType(ft);
          ROSE_ASSERT(theType != NULL);
       // printf ("In SgMemberFunctionType::createType(): insert function type into symbol table: nname = %s \n",nname.str());
       // Sgfunc_type_table.insert_function_type(nname, theType);
          ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
          get_globalFunctionTypeTable()->insert_function_type(nname, theType);
        }
       else
        {
       // printf ("In SgMemberFunctionType::createType(): function type found in symbol table: nname = %s \n",nname.str());
          theType->set_orig_return_type(ft->get_return_type());
        }

  // DQ: commented out the delete of the input structure (poor design, I think)
  // delete ft;
#endif

     ROSE_ASSERT(theType != NULL);
     return theType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDefinition* 
SgMemberFunctionType::get_struct_name () const
   {
     assert (this != NULL);
     return p_struct_name;
   }

void
SgMemberFunctionType::set_struct_name ( SgClassDefinition* struct_name )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_struct_name != NULL && struct_name != NULL && p_struct_name != struct_name)
        {
          printf ("Warning: struct_name = %p overwriting valid pointer p_struct_name = %p \n",struct_name,p_struct_name);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_struct_name != NULL && struct_name != NULL && p_struct_name != struct_name) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_struct_name = struct_name;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

unsigned int 
SgMemberFunctionType::get_mfunc_specifier () const
   {
     assert (this != NULL);
     return p_mfunc_specifier;
   }

void
SgMemberFunctionType::set_mfunc_specifier ( unsigned int mfunc_specifier )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_mfunc_specifier = mfunc_specifier;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2815 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


SgMemberFunctionType::SgMemberFunctionType ( SgPartialFunctionType* ft )
   : SgFunctionType(ft)
   {
     p_struct_name     = ft->p_struct_name;
     p_mfunc_specifier = ft->p_mfunc_specifier;
   }

void
SgMemberFunctionType::post_construction_initialization()
   { 
     p_struct_name=0; 
     p_mfunc_specifier = 0;
   }

// static SgMemberFunctionType* createType(SgPartialFunctionType *);

// RV (2/1/2006): Made a 'const' member function.
int
SgMemberFunctionType::isConstFunc() const
   { return (p_mfunc_specifier & e_const); }

void
SgMemberFunctionType::setConstFunc()
   { p_mfunc_specifier |= e_const; }

void
SgMemberFunctionType::unsetConstFunc()
   { p_mfunc_specifier &= ~e_const; }

// RV (2/1/2006): Made a 'const' member function.
int
SgMemberFunctionType::isVolatileFunc() const
   { return (p_mfunc_specifier & e_volatile); }

void
SgMemberFunctionType::setVolatileFunc()
   { p_mfunc_specifier |= e_volatile; }

void
SgMemberFunctionType::unsetVolatileFunc()
   { p_mfunc_specifier &= ~e_volatile; }

SgName
SgMemberFunctionType::get_mangled_name (void) const
   {
     return get_mangled ();
   }
 
// RV (1/31/2006): Changed form of mangling to include begin/end tags.
SgName
SgMemberFunctionType::get_mangled (void) const
   {
  // Member-function specific information (class name, const/volatile qualifiers)
     SgName mangled_cls_tag;

  // Compute class scope
  //! \todo Figure out why member function types are sometimes used
  //! incorrectly in place of plain function types.
     const SgClassDefinition* cls = get_struct_name ();
     if (cls)
       {
         SgName class_scope = cls->get_mangled_name ();
         mangled_cls_tag += class_scope;
       }

  // Append modifiers
     if (isConstFunc ())
       mangled_cls_tag << "_cf";
     if (isVolatileFunc ())
       mangled_cls_tag << "_vf";

  // Mangle the function type without qualifiers
     SgName basic_func_type = SgFunctionType::get_mangled ();

  // Compute mangled member function pointer type
     SgName mangled_name;
     if (mangled_cls_tag.get_length () > 0)
       mangled_name << "__MFb_" << mangled_cls_tag.str (); // really is a member function
     mangled_name << "_" << basic_func_type.str (); // Append standard argument signature.
     return mangled_name;
   }


#if 0
SgName
SgMemberFunctionType::get_mangled_type()
   { 
     SgUnparse_Info info;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // printf ("In SgMemberFunctionType::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled(SgNO_UNPARSE_INFO);
     return get_mangled(info);
   }
#endif

#if 0
// SgMemberFunctionType::get_mangled_name(SgUnparse_Info&);

//! This function repreents the name mangleing support for unparsing
SgName
SgMemberFunctionType::get_mangled_name(SgUnparse_Info& info) 
   {
     SgName rtmp;
  // SgDeclarationStatement *dstmt = info.get_decl_stmt();
     SgFunctionDeclaration *dstmt = isSgFunctionDeclaration(info.get_decl_stmt());
     ROSE_ASSERT (dstmt != NULL);
     SgName fname = info.get_name();

  // int len = strlen(fname.str());
  // SgName tmp(fname);
  // char *opstr  = "operator";
  // char *newstr = "new";
  // char *delstr = "delete";
  // int m = strlen(opstr);

  // printf ("In SgMemberFunctionType::get_mangled_name(): fname = %s \n",fname.str());

#if 0
  // ***** What about cast operators !!! *****
     if (dstmt->get_specialFunctionModifier().isConversion())
        {
          printf ("Found a conversion operator in SgMemberFunctionType::get_mangled_name \n");
        }

     if (dstmt->get_specialFunctionModifier().isOperator())
        {
          printf ("Found an operator in SgMemberFunctionType::get_mangled_name \n");
        }
#endif

     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor()) rtmp << "__dt";
            else
               if (dstmt->get_specialFunctionModifier().isConversion())
                  {
                    rtmp << "__conversion__";
                 // rtmp = mangledNameSupport(fname,info);
                  }
                 else
                  {
                 // These are just normal member functions
                 // ROSE_ASSERT (dstmt->get_specialFunctionModifier().isOperator());
                    rtmp = mangledNameSupport(fname,info);
                  }

     string mangledName = rtmp.str();
     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

  // printf ("Leaving SgMemberFunctionType::get_mangled_name(): mangledName = %s \n",mangledName.c_str());

#if 0
            // This code has been refactored and place in a seperate function: mangledNameSupport()
               if (len > 0 && strncmp(fname.str(),opstr,m)==0)
                  {
                    if (fname.str()[m]==' ')
                       {
#if 0
                         if (strncmp(&(fname.str()[m+2]),newstr,strlen(newstr)))
                              rtmp << "__nw"; 
                           else
                              if (strncmp(&(fname.str()[m+2]),delstr, strlen(delstr)))
                                   rtmp << "__dl";
                                else
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
#else
                      // DQ (4/27/2005): "m+2" should be "m+1"
                         if (strncmp(&(fname.str()[m+1]),newstr,strlen(newstr)) == 0)
                            {
                           // DQ (4/27/2005): Added support for array new
                              int newStringLength = strlen(newstr);
                              int parenStart = m+1+newStringLength;
                              if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                   rtmp << "__na";
                                else
                                   rtmp << "__nw";
                            }
                           else
                            {
                           // DQ (4/27/2005): Added support for array delete
                              if (strncmp(&(fname.str()[m+1]),delstr,strlen(delstr)) == 0)
                                 {
                                   int deleteStringLength = strlen(delstr);
                                   int parenStart = m+1+deleteStringLength;
                                   if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                        rtmp << "__da";
                                     else
                                        rtmp << "__dl";
                                 }
                                else
                                 {
                                // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
                                 }
                            }
#endif
                       }
                      else
                       {
                      // real operator  
                         SgName opname=&(fname.str()[m]);
                         if (opname==SgName("->"))       rtmp << "__rf";
                         else if (opname==SgName("->*")) rtmp << "__rm";
                         else if (opname==SgName("=="))  rtmp << "__eq";
                         else if (opname==SgName("<"))   rtmp << "__lt";
                         else if (opname==SgName(">"))   rtmp << "__gt";
                         else if (opname==SgName("!="))  rtmp << "__ne";
                         else if (opname==SgName("<="))  rtmp << "__le";
                         else if (opname==SgName(">="))  rtmp << "__ge";
                         else if (opname==SgName("+"))   rtmp << "__pl";
                         else if (opname==SgName("-"))   rtmp << "__mi";
                         else if (opname==SgName("*"))   rtmp << "__ml";
                         else if (opname==SgName("/"))   rtmp << "__dv";
                         else if (opname==SgName("%"))   rtmp << "__md";
                         else if (opname==SgName("&&"))  rtmp << "__aa";
                         else if (opname==SgName("!"))   rtmp << "__nt";
                         else if (opname==SgName("||"))  rtmp << "__oo";
                         else if (opname==SgName("^"))   rtmp << "__er";
                         else if (opname==SgName("&"))   rtmp << "__ad";
                         else if (opname==SgName("|"))   rtmp << "__or";
                         else if (opname==SgName(","))   rtmp << "__cm";
                         else if (opname==SgName("<<"))  rtmp << "__ls";
                         else if (opname==SgName(">>"))  rtmp << "__rs";
                         else if (opname==SgName("--"))  rtmp << "__mm";
                         else if (opname==SgName("++"))  rtmp << "__pp";
                         else if (opname==SgName("~"))   rtmp << "__co";
                         else if (opname==SgName("="))   rtmp << "__as";
                         else if (opname==SgName("+="))  rtmp << "__apl";
                         else if (opname==SgName("-="))  rtmp << "__ami";
                         else if (opname==SgName("&="))  rtmp << "__aad";
                         else if (opname==SgName("|="))  rtmp << "__aor";
                         else if (opname==SgName("*="))  rtmp << "__amu";
                         else if (opname==SgName("/="))  rtmp << "__adv";
                         else if (opname==SgName("%="))  rtmp << "__amd";
                         else if (opname==SgName("^="))  rtmp << "__aer";
                         else if (opname==SgName("<<=")) rtmp << "__als";
                         else if (opname==SgName(">>=")) rtmp << "__ars";
                         else if (opname==SgName("()"))  rtmp << "__cl";
                         else if (opname==SgName("[]"))  rtmp << "__xi";
                         else
                            {
                              printf ("In SgMemberFunctionType::get_mangled_name(): This case should never be reached (fname = %s) \n",fname.str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
                 else
                    rtmp << fname.str();
#endif

     return rtmp;
   }
#endif

#if 0
//! This function repreents the name mangling support for unparsing
/*! this routine can do 2 things,
    mangle a type with class name - without funcname 
    mangle a complete function declaration with name and class name
 */
SgName
SgMemberFunctionType::get_mangled(SgUnparse_Info & info)
   {
     SgName tmp;

  // printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&) info.PrintName() = %s \n",(info.PrintName() == true) ? "true" : "false");

  /* should have a name to start with */
     if (info.PrintName())
        {
       // DQ (6/23/2005): This path is taken for constructors, destructors and conversion operators (I think!)
       // tmp << get_mangled_name(info).str();
       // SgName name = get_mangled_name(info);
       // printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): (assuming info.PrintName() == true): name = %s \n",name.str());
          tmp << name.str();
        }
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): #1 tmp = %s \n",tmp.str());
#endif
     tmp << "__";
  // if(info.PrintName()) { // only if needs to print name
     if (p_struct_name != NULL)
        {
       // a member function
          int cnt=0;
          SgName p_nm = p_struct_name->get_mangled_qualified_name(cnt);
          if(cnt>1)
               tmp << "Q" << cnt << p_nm.str();
            else
               tmp << p_nm.str(); 
        }
     // }
     tmp << "F";
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): #2 tmp = %s \n",tmp.str());
#endif
  /* process argument type */
     SgTypePtrList::iterator p = get_arguments().begin();
     while (p != get_arguments().end())
        {
          tmp << (*p)->get_mangled(info).str();

       // DQ (5/2/2005): Added to handle function arguments which are templates
          tmp = fixupTemplateNameForMangledNameSupport(tmp);

          p++;
        }
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): #3 tmp = %s \n",tmp.str());
#endif
  /* process return type */
     SgName returnTypeName = get_return_type()->get_mangled(info);
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): get_return_type() = %s returnTypeName = %s \n",
          get_return_type()->sage_class_name(),returnTypeName.str());
#endif

     returnTypeName = fixupTemplateNameForMangledNameSupport(returnTypeName);
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): #4 tmp = %s \n",tmp.str());
#endif
  // tmp << "_" << get_return_type()->get_mangled(info).str();
     tmp << "_" << returnTypeName.str();

     if (isConstFunc())
          tmp << "_cf";

     if (isVolatileFunc())
          tmp << "_vf";
#if 0
     printf ("In SgMemberFunctionType::get_mangled(SgUnparse_Info&): #5 tmp = %s \n",tmp.str());
#endif
#if 0
     printf ("###########  In SgMemberFunctionType::get_mangled(): tmp = %s (returnTypeName = %s is a %s) ########## \n",
          tmp.str(),returnTypeName.str(),get_return_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif


// SgMemberFunctionType * mkAnotherType(SgType *);
SgMemberFunctionType *
SgMemberFunctionType::mkAnotherType(SgType *rtype)
   {
     if (rtype == get_return_type())
          return NULL;

     SgPartialFunctionType *part_type = SgPartialFunctionType::createType(rtype);

  /* process argument type */
     SgTypePtrList::iterator p = this->get_arguments().begin();
     while (p != this->get_arguments().end())
        {
          part_type->append_argument((*p));
          p++;
        }
     part_type->set_struct_name(this->get_struct_name());
     part_type->set_mfunc_specifier(this->get_mfunc_specifier());

     SgMemberFunctionType *ntype = SgMemberFunctionType::createType(part_type);
     if (ntype == this)
          return NULL;
       else
          return ntype;
   }




// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgMemberFunctionType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgMemberFunctionType::variantT() const {
  return V_SgMemberFunctionType;
}

#if 0
int
SgMemberFunctionType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_MEMBERFUNCTION;
   }
#endif

const char*
SgMemberFunctionType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionType";  
   }

std::string
SgMemberFunctionType::class_name() const
   {
     assert(this != NULL);
     return "SgMemberFunctionType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgMemberFunctionType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgMemberFunctionType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_MEMBERFUNCTION)
        {
          printf ("Error in SgMemberFunctionType::error(): SgMemberFunctionType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgMemberFunctionType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_MEMBERFUNCTION);
     return SgFunctionType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgMemberFunctionType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgMemberFunctionType::variant() const \n");
#endif
     assert(this != NULL);
     return T_MEMBERFUNCTION;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgMemberFunctionType* isSgMemberFunctionType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgMemberFunctionType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgMemberFunctionType* isSgMemberFunctionType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgMemberFunctionType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgMemberFunctionType::~SgMemberFunctionType ()
   {
#if 0
  // debugging information!
     printf ("In SgMemberFunctionType::~SgMemberFunctionType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for struct_name
     p_struct_name = NULL; // non list case 
  // case: not a listType for mfunc_specifier
     p_mfunc_specifier = 0; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgMemberFunctionType::SgMemberFunctionType ( SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier )
   : SgFunctionType(return_type, has_ellipses)
   {
#ifdef DEBUG
  // printf ("In SgMemberFunctionType::SgMemberFunctionType (SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier) sage_class_name() = %s \n",sage_class_name());
#endif

     p_struct_name = struct_name;
     p_mfunc_specifier = mfunc_specifier;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_MEMBERFUNCTION == variant());
     post_construction_initialization();

  // Test the isSgMemberFunctionType() function since it has been problematic
     assert(isSgMemberFunctionType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgUnknownMemberFunctionType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgUnknownMemberFunctionType::variantT() const {
  return V_SgUnknownMemberFunctionType;
}

#if 0
int
SgUnknownMemberFunctionType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return UnknownMemberFunctionTag;
   }
#endif

const char*
SgUnknownMemberFunctionType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgUnknownMemberFunctionType";  
   }

std::string
SgUnknownMemberFunctionType::class_name() const
   {
     assert(this != NULL);
     return "SgUnknownMemberFunctionType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgUnknownMemberFunctionType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgUnknownMemberFunctionType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != UnknownMemberFunctionTag)
        {
          printf ("Error in SgUnknownMemberFunctionType::error(): SgUnknownMemberFunctionType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgUnknownMemberFunctionType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == UnknownMemberFunctionTag);
     return SgMemberFunctionType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgUnknownMemberFunctionType SgUnknownMemberFunctionType::builtin_type;
// SgUnknownMemberFunctionType* SgUnknownMemberFunctionType::builtin_type = new SgUnknownMemberFunctionType();
SgUnknownMemberFunctionType* SgUnknownMemberFunctionType::p_builtin_type = NULL;

SgUnknownMemberFunctionType*
SgUnknownMemberFunctionType::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgUnknownMemberFunctionType object for the p_builtin_type \n");
          p_builtin_type = new SgUnknownMemberFunctionType();
       // p_builtin_type = new SgUnknownMemberFunctionType(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgUnknownMemberFunctionType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgUnknownMemberFunctionType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgUnknownMemberFunctionType::get_mangled ( SgUnparse_Info & info )
SgName
SgUnknownMemberFunctionType::get_mangled (void) const
   {
     return SgName("MANGLED_ID_STRING");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgUnknownMemberFunctionType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgUnknownMemberFunctionType::variant() const \n");
#endif
     assert(this != NULL);
     return UnknownMemberFunctionTag;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgUnknownMemberFunctionType* isSgUnknownMemberFunctionType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgUnknownMemberFunctionType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgUnknownMemberFunctionType* isSgUnknownMemberFunctionType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgUnknownMemberFunctionType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgUnknownMemberFunctionType::~SgUnknownMemberFunctionType ()
   {
#if 0
  // debugging information!
     printf ("In SgUnknownMemberFunctionType::~SgUnknownMemberFunctionType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgUnknownMemberFunctionType::SgUnknownMemberFunctionType ( SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier )
   : SgMemberFunctionType(return_type, has_ellipses, struct_name, mfunc_specifier)
   {
#ifdef DEBUG
  // printf ("In SgUnknownMemberFunctionType::SgUnknownMemberFunctionType (SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(UnknownMemberFunctionTag == variant());
     post_construction_initialization();

  // Test the isSgUnknownMemberFunctionType() function since it has been problematic
     assert(isSgUnknownMemberFunctionType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3369 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgPartialFunctionType* 
SgPartialFunctionType::createType(SgType* rtype)
   {
  // return new SgPartialFunctionType(rtype);

     SgPartialFunctionType* returnType = new SgPartialFunctionType(rtype);
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 3230 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

//! This is an empty function (no data to initialize)
void
SgPartialFunctionType::post_construction_initialization () 
   {
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPartialFunctionType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPartialFunctionType::variantT() const {
  return V_SgPartialFunctionType;
}

#if 0
int
SgPartialFunctionType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_PARTIAL_FUNCTION;
   }
#endif

const char*
SgPartialFunctionType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPartialFunctionType";  
   }

std::string
SgPartialFunctionType::class_name() const
   {
     assert(this != NULL);
     return "SgPartialFunctionType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPartialFunctionType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPartialFunctionType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_PARTIAL_FUNCTION)
        {
          printf ("Error in SgPartialFunctionType::error(): SgPartialFunctionType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPartialFunctionType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_PARTIAL_FUNCTION);
     return SgMemberFunctionType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPartialFunctionType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPartialFunctionType::variant() const \n");
#endif
     assert(this != NULL);
     return T_PARTIAL_FUNCTION;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPartialFunctionType* isSgPartialFunctionType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPartialFunctionType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPartialFunctionType* isSgPartialFunctionType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPartialFunctionType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPartialFunctionType::~SgPartialFunctionType ()
   {
#if 0
  // debugging information!
     printf ("In SgPartialFunctionType::~SgPartialFunctionType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPartialFunctionType::SgPartialFunctionType ( SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier )
   : SgMemberFunctionType(return_type, has_ellipses, struct_name, mfunc_specifier)
   {
#ifdef DEBUG
  // printf ("In SgPartialFunctionType::SgPartialFunctionType (SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_PARTIAL_FUNCTION == variant());
     post_construction_initialization();

  // Test the isSgPartialFunctionType() function since it has been problematic
     assert(isSgPartialFunctionType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPartialFunctionModifierType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPartialFunctionModifierType::variantT() const {
  return V_SgPartialFunctionModifierType;
}

#if 0
int
SgPartialFunctionModifierType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_PARTIAL_FUNCTION_MODIFIER;
   }
#endif

const char*
SgPartialFunctionModifierType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPartialFunctionModifierType";  
   }

std::string
SgPartialFunctionModifierType::class_name() const
   {
     assert(this != NULL);
     return "SgPartialFunctionModifierType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPartialFunctionModifierType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPartialFunctionModifierType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_PARTIAL_FUNCTION_MODIFIER)
        {
          printf ("Error in SgPartialFunctionModifierType::error(): SgPartialFunctionModifierType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPartialFunctionModifierType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_PARTIAL_FUNCTION_MODIFIER);
     return SgPartialFunctionType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgPartialFunctionModifierType SgPartialFunctionModifierType::builtin_type;
// SgPartialFunctionModifierType* SgPartialFunctionModifierType::builtin_type = new SgPartialFunctionModifierType();
SgPartialFunctionModifierType* SgPartialFunctionModifierType::p_builtin_type = NULL;

SgPartialFunctionModifierType*
SgPartialFunctionModifierType::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgPartialFunctionModifierType object for the p_builtin_type \n");
          p_builtin_type = new SgPartialFunctionModifierType();
       // p_builtin_type = new SgPartialFunctionModifierType(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgPartialFunctionModifierType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgPartialFunctionModifierType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 904 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName SgPartialFunctionModifierType::get_mangled ( SgUnparse_Info & info )
SgName
SgPartialFunctionModifierType::get_mangled (void) const
   {
     return SgName("MANGLED_ID_STRING");
   }
#endif


// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPartialFunctionModifierType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPartialFunctionModifierType::variant() const \n");
#endif
     assert(this != NULL);
     return T_PARTIAL_FUNCTION_MODIFIER;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPartialFunctionModifierType* isSgPartialFunctionModifierType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPartialFunctionModifierType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPartialFunctionModifierType* isSgPartialFunctionModifierType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPartialFunctionModifierType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPartialFunctionModifierType::~SgPartialFunctionModifierType ()
   {
#if 0
  // debugging information!
     printf ("In SgPartialFunctionModifierType::~SgPartialFunctionModifierType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPartialFunctionModifierType::SgPartialFunctionModifierType ( SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier )
   : SgPartialFunctionType(return_type, has_ellipses, struct_name, mfunc_specifier)
   {
#ifdef DEBUG
  // printf ("In SgPartialFunctionModifierType::SgPartialFunctionModifierType (SgType* return_type, bool has_ellipses, SgClassDefinition* struct_name, unsigned int mfunc_specifier) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_PARTIAL_FUNCTION_MODIFIER == variant());
     post_construction_initialization();

  // Test the isSgPartialFunctionModifierType() function since it has been problematic
     assert(isSgPartialFunctionModifierType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement* 
SgNamedType::get_declaration () const
   {
     assert (this != NULL);
     return p_declaration;
   }

void
SgNamedType::set_declaration ( SgDeclarationStatement* declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_declaration != NULL && declaration != NULL && p_declaration != declaration)
        {
          printf ("Warning: declaration = %p overwriting valid pointer p_declaration = %p \n",declaration,p_declaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_declaration != NULL && declaration != NULL && p_declaration != declaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_declaration = declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

bool 
SgNamedType::get_autonomous_declaration () const
   {
     assert (this != NULL);
     return p_autonomous_declaration;
   }

void
SgNamedType::set_autonomous_declaration ( bool autonomous_declaration )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_autonomous_declaration = autonomous_declaration;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1931 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgNamedType::p_defaultQualifiedNamePtrList;

SgNamedType::SgNamedType ( const SgNamedType & X )
   {
     p_declaration            = X.p_declaration;
 	  p_autonomous_declaration = X.p_autonomous_declaration;

     ROSE_ASSERT(p_declaration != NULL);
   }

SgName
SgNamedType::get_name() const
   {
     printf ("Error: base class SgNamedType::get_name() called! \n");
     ROSE_ABORT();

     return SgName();
   }


SgName
SgNamedType::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In SgNamedType::get_qualified_name() for %p = %s name = %s \n",this,sage_class_name(),get_name().str());

     ROSE_ASSERT(get_declaration() != NULL);

  // DQ (6/23/2005): This does not appear to be required any more (I think)
  // ROSE_ASSERT(get_declaration()->get_parent() != NULL);

#if 0
     printf ("In SgNamedType::get_qualified_name() get_declaration() = %p = %s at: \n",get_declaration(),get_declaration()->sage_class_name());
     get_declaration()->get_file_info()->display("In SgNamedType::get_qualified_name(): location of declaration");
#endif

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_declaration()->get_scope();
     ROSE_ASSERT(scope != NULL);

  // printf ("In SgNamedType::get_qualified_name(): scope->sage_class_name() = %s \n",scope->sage_class_name());

     SgName returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In SgNamedType::get_qualified_name() returnName = %s \n",returnName.str());

  // printf ("Exiting at end of SgNamedType::get_qualified_name() \n");
  // ROSE_ASSERT(false);

     return returnName;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgNamedType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgNamedType::variantT() const {
  return V_SgNamedType;
}

#if 0
int
SgNamedType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_NAME;
   }
#endif

const char*
SgNamedType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgNamedType";  
   }

std::string
SgNamedType::class_name() const
   {
     assert(this != NULL);
     return "SgNamedType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgNamedType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgNamedType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_NAME)
        {
          printf ("Error in SgNamedType::error(): SgNamedType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgNamedType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_NAME);
     return SgType::error();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 3304 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


// DQ (1/31/2006): Modified to build all types in the memory pools
// SgNamedType SgNamedType::builtin_type;
// SgNamedType* SgNamedType::builtin_type = new SgNamedType();
SgNamedType* SgNamedType::p_builtin_type = NULL;

SgNamedType*
SgNamedType::createType(void) 
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor 
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgNamedType object for the p_builtin_type \n");
          p_builtin_type = new SgNamedType();
       // p_builtin_type = new SgNamedType(NULL,true,NULL,0);
        }
     firstCallToFunction = false;

     ROSE_ASSERT(p_builtin_type != NULL);
     p_builtin_type->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgNamedType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgNamedType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgNamedType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgNamedType::variant() const \n");
#endif
     assert(this != NULL);
     return T_NAME;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgNamedType* isSgNamedType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgNamedType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgNamedType* isSgNamedType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgNamedType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgNamedType::~SgNamedType ()
   {
#if 0
  // debugging information!
     printf ("In SgNamedType::~SgNamedType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for declaration
     p_declaration = NULL; // non list case 
  // case: not a listType for autonomous_declaration
     p_autonomous_declaration = TRUE; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgNamedType::SgNamedType ( SgDeclarationStatement* declaration )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgNamedType::SgNamedType (SgDeclarationStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif

     p_declaration = declaration;
     p_autonomous_declaration = TRUE;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_NAME == variant());
     post_construction_initialization();

  // Test the isSgNamedType() function since it has been problematic
     assert(isSgNamedType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3711 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgClassType*
SgClassType::createType(SgClassDeclaration * cd)
   {
     ROSE_ASSERT(cd != NULL);

#if 0
     printf ("cd = %p = %s cd->get_definition() = %p = %s \n",
          cd,cd->sage_class_name(),
          cd->get_definition(),(cd->get_definition() != NULL) ? cd->get_definition()->sage_class_name() : "NULL");
     printf ("cd->get_type() = %p \n",cd->get_type());
     printf ("cd = %p cd->get_definingDeclaration()         = %p \n",cd,cd->get_definingDeclaration());
     printf ("cd = %p cd->get_firstNondefiningDeclaration() = %p \n",cd,cd->get_firstNondefiningDeclaration());
#endif

     if (!cd->get_type()) 
        {
          SgClassType* newType = new SgClassType(cd);
          ROSE_ASSERT(newType != NULL);
          cd->set_type(newType);
       // cd->set_type(new SgClassType(cd));
        }
     return (SgClassType*) cd->get_type();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgClassType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgClassType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 1992 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgClassType::SgClassType ( const SgClassType & X )
   : SgNamedType(X)
   {
   }


SgName
SgClassType::get_name() const
   {
     if(get_declaration()) 
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

#if 0
SgName
SgClassType::get_mangled(SgUnparse_Info&)
   {
     return get_name();
   }
#endif

// RV (1/31/2006): Changed behavior to return a fully-qualified, mangled name.
/*! Returns a mangled name (with embedded, mangled qualifiers).
 *  \note If the class is anonymous, e.g.,
 *    typedef struct { int a; char b; } tag_t;
 *  then this routine returns an empty name.
 */
SgName
SgClassType::get_mangled (void) const
   {
     SgName mangled_name;
     if (get_name ().get_length () != 0) // not anonymous
       {
         const SgClassDeclaration* cls_decl = isSgClassDeclaration (get_declaration ());
         if (cls_decl)
           mangled_name = cls_decl->get_mangled_name ();
       }
     return mangled_name;
   }

#if 0
// Older code
SgName
SgClassType::get_mangled(SgUnparse_Info&)
   {
     SgName tmp;
  // todo: what should be done when the class name is nil (anonymous class?)

#if 0
     SgName name = get_name();
     if (!name.is_null())
        {
          tmp << strlen(name.str()) << name.str();
        }
#else
     SgName name = get_qualified_name();
  // printf ("Using get_qualified_name() instead of get_name() in get_mangled() name = %s \n",name.str());
     if (!name.is_null())
        {
       // DQ (6/23/2005): type names put into the symbol table (function symbol table) should be name qualified (maybe)
       // tmp << strlen(get_name().str()) << get_name().str();
       // tmp << strlen(get_mangled_name().str()) << get_mangled_name().str();
          tmp << strlen(name.str()) << name.str();
        }
#endif

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgClassType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgClassType::variantT() const {
  return V_SgClassType;
}

#if 0
int
SgClassType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_CLASS;
   }
#endif

const char*
SgClassType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgClassType";  
   }

std::string
SgClassType::class_name() const
   {
     assert(this != NULL);
     return "SgClassType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgClassType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgClassType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_CLASS)
        {
          printf ("Error in SgClassType::error(): SgClassType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgClassType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_CLASS);
     return SgNamedType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgClassType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgClassType::variant() const \n");
#endif
     assert(this != NULL);
     return T_CLASS;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgClassType* isSgClassType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgClassType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgClassType* isSgClassType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgClassType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgClassType::~SgClassType ()
   {
#if 0
  // debugging information!
     printf ("In SgClassType::~SgClassType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgClassType::SgClassType ( SgDeclarationStatement* declaration )
   : SgNamedType(declaration)
   {
#ifdef DEBUG
  // printf ("In SgClassType::SgClassType (SgDeclarationStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_CLASS == variant());
     post_construction_initialization();

  // Test the isSgClassType() function since it has been problematic
     assert(isSgClassType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3693 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgEnumType*
SgEnumType::createType(SgEnumDeclaration* cd)
   {
     SgEnumType* returnType = NULL;
  // return cd->get_type() ? cd->get_type() : new SgEnumType(cd); 

     assert(cd != NULL);
     returnType = cd->get_type();
     if (returnType == NULL)
          returnType = new SgEnumType(cd);

     assert(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgEnumType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgEnumType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 2072 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


SgEnumType::SgEnumType ( const SgEnumType & X )
   : SgNamedType(X)
   {
   }

SgName
SgEnumType::get_name() const
   {
     if(get_declaration())
          return isSgEnumDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

// RV (2/1/2006): Updated to use the declaration's mangling routine.
SgName
SgEnumType::get_mangled (void) const
    {
     const SgEnumDeclaration* decl = isSgEnumDeclaration (get_declaration());
     ROSE_ASSERT (decl);
     return decl->get_mangled_name ();
   }

#if 0
// Older code 
SgName
SgEnumType::get_mangled(SgUnparse_Info&)
   {
  // DQ (6/23/2005): Use the qualified name here
  // return get_name();
     return get_qualified_name();
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgEnumType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgEnumType::variantT() const {
  return V_SgEnumType;
}

#if 0
int
SgEnumType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_ENUM;
   }
#endif

const char*
SgEnumType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgEnumType";  
   }

std::string
SgEnumType::class_name() const
   {
     assert(this != NULL);
     return "SgEnumType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgEnumType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgEnumType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_ENUM)
        {
          printf ("Error in SgEnumType::error(): SgEnumType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgEnumType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_ENUM);
     return SgNamedType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgEnumType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgEnumType::variant() const \n");
#endif
     assert(this != NULL);
     return T_ENUM;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgEnumType* isSgEnumType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgEnumType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgEnumType* isSgEnumType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgEnumType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgEnumType::~SgEnumType ()
   {
#if 0
  // debugging information!
     printf ("In SgEnumType::~SgEnumType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     


#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgEnumType::SgEnumType ( SgDeclarationStatement* declaration )
   : SgNamedType(declaration)
   {
#ifdef DEBUG
  // printf ("In SgEnumType::SgEnumType (SgDeclarationStatement* declaration) sage_class_name() = %s \n",sage_class_name());
#endif



  // Test the variant virtual function
     assert(T_ENUM == variant());
     post_construction_initialization();

  // Test the isSgEnumType() function since it has been problematic
     assert(isSgEnumType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3384 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgTypedefType*
SgTypedefType::createType(SgTypedefDeclaration *decl) 
   {
#if 1
  // printf ("Inside of SgTypedefType::createType() \n");
     assert(decl != NULL);
  // if (!decl->get_type())
     if (decl->get_type() == NULL)
        {
          assert(decl->get_base_type() != NULL);

          ROSE_ASSERT (decl->get_base_type() != NULL);
          ROSE_ASSERT (decl->get_base_type()->p_typedefs != NULL);
       // printf ("Before loop over typedef chain: (decl->get_base_type()->p_typedefs)->get_typedefs().size() = %d \n",
       //      (decl->get_base_type()->p_typedefs)->get_typedefs().size());

          SgTypePtrList::iterator i = ((decl->get_base_type()->p_typedefs)->get_typedefs().begin());
          while (i != ((decl->get_base_type()->p_typedefs)->get_typedefs().end()))
             {
            // printf ("In loop over typedef chain \n");

            // SgName dname = decl->get_name();
            // SgTypedefType *tptr= isSgTypedefType((*i).irep());
               ROSE_ASSERT( (*i) != NULL);
               SgTypedefType *tptr= isSgTypedefType(*i);
               ROSE_ASSERT(tptr != NULL);
               if( (decl->get_name() == tptr->get_name()) && 
                   (decl->get_parent_scope() == tptr->get_parent_scope()) )
                    return (tptr);
               i++;
             }

       // decl->set_type(new SgTypedefType(decl, decl->get_parent_scope()));

       // debugging code
       // decl->get_file_info()->display("declration used in SgTypedefType::createType()");

       // Parent scope is NULL for declarations in global scope
       // ROSE_ASSERT (decl->get_parent_scope() != NULL);
          SgTypedefType* tempType =
               new SgTypedefType(decl, decl->get_parent_scope());
          ROSE_ASSERT (tempType != NULL);
          decl->set_type(tempType);

          ROSE_ASSERT (decl->get_type() != NULL);
          ROSE_ASSERT (decl->get_base_type() != NULL);
          ROSE_ASSERT (decl->get_base_type()->p_typedefs != NULL);

       // printf ("Before updating list: (decl->get_base_type()->p_typedefs)->get_typedefs().size() = %d \n",
       //      (decl->get_base_type()->p_typedefs)->get_typedefs().size());

          (decl->get_base_type()->p_typedefs)->get_typedefs().push_back(decl->get_type());
        }

  // printf ("Leaving SgTypedefType::createType() \n");

     ROSE_ASSERT(decl != NULL);
     ROSE_ASSERT(decl->get_type() != NULL);  // I think we can assert this!

     ROSE_ASSERT ((decl->get_base_type()->p_typedefs)->get_typedefs().size() > 0);

     return decl->get_type();
#else
     printf ("Exiting in SgTypedefType::createType() \n");
     ROSE_ABORT();

     return NULL;
#endif
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1802 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
SgTypedefType::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     SgTypedefType::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgSymbol* 
SgTypedefType::get_parent_scope () const
   {
     assert (this != NULL);
     return p_parent_scope;
   }

void
SgTypedefType::set_parent_scope ( SgSymbol* parent_scope )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_parent_scope != NULL && parent_scope != NULL && p_parent_scope != parent_scope)
        {
          printf ("Warning: parent_scope = %p overwriting valid pointer p_parent_scope = %p \n",parent_scope,p_parent_scope);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_parent_scope != NULL && parent_scope != NULL && p_parent_scope != parent_scope) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_parent_scope = parent_scope;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 2111 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


SgTypedefType::SgTypedefType ( const SgTypedefType & X )
// : SgNamedType(X.get_declaration())
   : SgNamedType(X), p_parent_scope(X.p_parent_scope)
   {
  // DQ (10/18/2007): This copy constructor is to support the AST copy mechansim, specifically 
  // to permit the SgTypedefSeq to be updated with new copies of SgTypedefType objects.

  // DQ (10/19/2007): Make sure that this is true (though we could not test it before building the base class.
     ROSE_ASSERT( X.get_declaration() != NULL);

  // Typedefs need to setup the fixup the SgTypedefSeq list.
     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(X.get_declaration());
     ROSE_ASSERT( typedefDeclaration != NULL);
     SgType* baseType = typedefDeclaration->get_base_type();
     ROSE_ASSERT(baseType != NULL);

  // Fixup the SgTypedefSeq object.
     baseType->get_typedefs()->append_typedef(this);
   }

SgName
SgTypedefType::get_name() const
   {
     if (get_declaration() != NULL)
        {
          return isSgTypedefDeclaration(get_declaration())->get_name();
        }
       else
        {
          printf ("Warning: Returning an empty name from SgTypedefType::get_name() \n");
          return SgName((char *)0L);
        }
   }

SgType*
SgTypedefType::get_base_type() const
   {
  // DQ (6/30/2005): Added assertion (I think this makes sense!)
     ROSE_ASSERT(isSgTypedefDeclaration(get_declaration()) != NULL);
     return (get_declaration() != NULL) ? isSgTypedefDeclaration(get_declaration())->get_base_type() : NULL;
   }

// RV (2/1/2006): Updated to use the declaration's mangling routine.
SgName
SgTypedefType::get_mangled (void) const
   {
     const SgTypedefDeclaration* decl = isSgTypedefDeclaration (get_declaration());
     ROSE_ASSERT (decl);
     return decl->get_mangled_name();
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgTypedefType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgTypedefType::variantT() const {
  return V_SgTypedefType;
}

#if 0
int
SgTypedefType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_TYPEDEF;
   }
#endif

const char*
SgTypedefType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgTypedefType";  
   }

std::string
SgTypedefType::class_name() const
   {
     assert(this != NULL);
     return "SgTypedefType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgTypedefType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgTypedefType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_TYPEDEF)
        {
          printf ("Error in SgTypedefType::error(): SgTypedefType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgTypedefType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_TYPEDEF);
     return SgNamedType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgTypedefType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgTypedefType::variant() const \n");
#endif
     assert(this != NULL);
     return T_TYPEDEF;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgTypedefType* isSgTypedefType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgTypedefType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgTypedefType* isSgTypedefType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgTypedefType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgTypedefType::~SgTypedefType ()
   {
#if 0
  // debugging information!
     printf ("In SgTypedefType::~SgTypedefType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for parent_scope
     p_parent_scope = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgTypedefType::SgTypedefType ( SgDeclarationStatement* declaration, SgSymbol* parent_scope )
   : SgNamedType(declaration)
   {
#ifdef DEBUG
  // printf ("In SgTypedefType::SgTypedefType (SgDeclarationStatement* declaration, SgSymbol* parent_scope) sage_class_name() = %s \n",sage_class_name());
#endif

     p_parent_scope = parent_scope;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_TYPEDEF == variant());
     post_construction_initialization();

  // Test the isSgTypedefType() function since it has been problematic
     assert(isSgTypedefType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3744 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgPointerType*
SgPointerType::createType(SgType* base_type)
   {
     assert(base_type != NULL);
     if (base_type->p_ptr_to)
        {
          return base_type->p_ptr_to;
        }
       else
        {
          SgPointerType* newType = new SgPointerType(base_type);
          assert(newType != NULL);

          base_type->p_ptr_to = newType;
          assert(base_type->p_ptr_to != NULL);

          return base_type->p_ptr_to;
       // return (base_type->ptr_to = new SgPointerType(base_type));
        }
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgType* 
SgPointerType::get_base_type () const
   {
     assert (this != NULL);
     return p_base_type;
   }

void
SgPointerType::set_base_type ( SgType* base_type )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_base_type != NULL && base_type != NULL && p_base_type != base_type)
        {
          printf ("Warning: base_type = %p overwriting valid pointer p_base_type = %p \n",base_type,p_base_type);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_base_type != NULL && base_type != NULL && p_base_type != base_type) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_base_type = base_type;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 919 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"


/*! Returns a mangled name representation of types with base types
 *  (e.g., pointer, reference).
 */
SgName
SgPointerType::get_mangled (void) const
   {
     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type);
     SgName base_name = base_type->get_mangled();

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In SgPointerType::get_mangled(), empty base type name found \n");
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "P" << "b__" // start tag
                  << base_name.str () // base type
                  << "__" << "P" << "e__"; // end tag
     return mangled_name;
   }

#if 0
// Old version of function
SgName
SgPointerType::get_mangled ( SgUnparse_Info & info )
   {
     SgName tmp("P");

  // DQ (3/15/2005): Should be be using a qualified name???

     ROSE_ASSERT(get_base_type() != NULL);
     ROSE_ASSERT(get_base_type()->get_mangled(info).get_length() > 0);
     tmp << get_base_type()->get_mangled(info).str();

#if 0
     printf ("###########  In SgPointerType::get_mangled(): tmp = %s (get_base_type() = %s is a %s) ########## \n",
          tmp.str(),get_base_type()->get_mangled(info).str(),get_base_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 1919 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPointerType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPointerType::variantT() const {
  return V_SgPointerType;
}

#if 0
int
SgPointerType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_POINTER;
   }
#endif

const char*
SgPointerType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPointerType";  
   }

std::string
SgPointerType::class_name() const
   {
     assert(this != NULL);
     return "SgPointerType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPointerType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPointerType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_POINTER)
        {
          printf ("Error in SgPointerType::error(): SgPointerType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPointerType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_POINTER);
     return SgType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPointerType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPointerType::variant() const \n");
#endif
     assert(this != NULL);
     return T_POINTER;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPointerType* isSgPointerType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPointerType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPointerType* isSgPointerType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPointerType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPointerType::~SgPointerType ()
   {
#if 0
  // debugging information!
     printf ("In SgPointerType::~SgPointerType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for base_type
     p_base_type = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPointerType::SgPointerType ( SgType* base_type )
   : SgType()
   {
#ifdef DEBUG
  // printf ("In SgPointerType::SgPointerType (SgType* base_type) sage_class_name() = %s \n",sage_class_name());
#endif

     p_base_type = base_type;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_POINTER == variant());
     post_construction_initialization();

  // Test the isSgPointerType() function since it has been problematic
     assert(isSgPointerType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions specific to each node in the grammar
// ********************************************************

#line 6 "../Grammar/grammarClassDefinitionMacros.macro before marker MEMBER_FUNCTION_DEFINITIONS"

#line 1 ""

#line 1 ""
// Start of memberFunctionString
#line 3606 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

SgPointerMemberType*
SgPointerMemberType::createType ( SgType* base_type, SgClassDefinition *class_definition )
   {
     SgPointerMemberType* returnType = new SgPointerMemberType(base_type,class_definition);
     assert(returnType != NULL);
     return returnType;
   }



// End of memberFunctionString
// Start of memberFunctionString
#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro"

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgClassDefinition* 
SgPointerMemberType::get_class_of () const
   {
     assert (this != NULL);
     return p_class_of;
   }

void
SgPointerMemberType::set_class_of ( SgClassDefinition* class_of )
   {
     assert (this != NULL);
     set_isModified(true);
     
#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_class_of != NULL && class_of != NULL && p_class_of != class_of)
        {
          printf ("Warning: class_of = %p overwriting valid pointer p_class_of = %p \n",class_of,p_class_of);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_class_of != NULL && class_of != NULL && p_class_of != class_of) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_class_of = class_of;
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 974 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"

// RV (2/3/2006): Updated this routine to use the mangling of the parent type.
SgName
SgPointerMemberType::get_mangled (void) const
   {
  // Generate a pointer type _without_ the class name in it
     string base_str = SgPointerType::get_mangled ().getString ();

  // Mangle the class name
     const SgClassDefinition* cls_def = get_class_of ();
     ROSE_ASSERT (cls_def);
     string cls_name = cls_def->get_mangled_name ().getString ();

  // Now embed the fully qualified class name in it
     string mangled_name (base_str);
     const string ptr_begin_tag ("__Pb__");
     string::size_type pos_begin = mangled_name.find (ptr_begin_tag);
     mangled_name.replace (pos_begin, ptr_begin_tag.size (),
                           "__PMb__" + cls_name);
 
     return SgName (mangled_name.c_str ());
   }

#if 0
// Old code
SgName
SgPointerMemberType::get_mangled ( SgUnparse_Info& info )
   {
     SgName tmp("M");
     int cnt = 0;
     ROSE_ASSERT(get_class_of() != NULL);
     tmp << get_class_of()->get_mangled_qualified_name(cnt).str();

#if 0
     printf ("###########  In SgPointerMemberType::get_mangled(): tmp = %s (get_base_type() = %s is a %s) ########## \n",
          tmp.str(),get_class_of()->get_mangled_qualified_name(cnt).str(),get_class_of()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif



// End of memberFunctionString
// Start of memberFunctionString
#line 1923 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Type.code"



// End of memberFunctionString
// Start of memberFunctionString
#line 331 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Common.code"

// *** COMMON CODE SECTION BEGINS HERE ***

int
SgPointerMemberType::getVariant() const
   {
     // This function is used in ROSE while "variant()" is used in SAGE 
     assert(this != NULL);
     return variant();
   }

// This function is used in ROSE in treeTraversal code
// eventually replaces getVariant() and variant()
// though after variant() has been removed for a while we will
// want to change the name of variantT() back to variant()
// (since the "T" was ment to stand for temporary).
// When this happens the variantT() will be depricated.
VariantT
SgPointerMemberType::variantT() const {
  return V_SgPointerMemberType;
}

#if 0
int
SgPointerMemberType::variant() const
   {
     // This function is used in SAGE
     assert(this != NULL);
     return T_MEMBER_POINTER;
   }
#endif

const char*
SgPointerMemberType::sage_class_name() const
   {
     assert(this != NULL);
     return "SgPointerMemberType";  
   }

std::string
SgPointerMemberType::class_name() const
   {
     assert(this != NULL);
     return "SgPointerMemberType";  
   }

// DQ (11/26/2005): Support for visitor pattern mechanims
// (inferior to ROSE traversal mechanism, experimental).
void
SgPointerMemberType::executeVisitorMemberFunction (ROSE_VisitorPattern & visitor)
   {
     ROSE_ASSERT(this != NULL);
     visitor.visit(this);
   }

// *** COMMON CODE SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
#line 1387 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/Node.code"


#if 0
//! Error checking support
/*! Verifies the following:
       - working getVariant() member function
       - calls base class's error() member function
    Every class has one of these functions.
 */
bool
SgPointerMemberType::error()
   {
  // Put error checking here

     ROSE_ASSERT (this != NULL);
     if (getVariant() != T_MEMBER_POINTER)
        {
          printf ("Error in SgPointerMemberType::error(): SgPointerMemberType object has a %s variant \n",
               Cxx_GrammarTerminalNames[getVariant()].name);
       // printf ("Error in SgPointerMemberType::error() \n");
          ROSE_ABORT();
        }

     ROSE_ASSERT (getVariant() == T_MEMBER_POINTER);
     return SgPointerType::error();
   }
#endif



// End of memberFunctionString

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarVariantFunctionDefinitionMacros.macro"

int
SgPointerMemberType::variant() const
   {
  // This function is generated from grammarVariantFunctionDefinitionMacros.macro
#ifdef DEBUG
  // printf ("In SgPointerMemberType::variant() const \n");
#endif
     assert(this != NULL);
     return T_MEMBER_POINTER;
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarIsClassNameFunctionDefinitionMacros.macro"

SgPointerMemberType* isSgPointerMemberType ( SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<SgPointerMemberType*>(inputDerivedClassPointer);
   }

// DQ (11/8/2003): Added version of functions taking const pointer
const SgPointerMemberType* isSgPointerMemberType ( const SgNode* inputDerivedClassPointer )
   {
     return dynamic_cast<const SgPointerMemberType*>(inputDerivedClassPointer);
   }



#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"

/** 
\brief Generated destructor

This destructor is automatically generated (by ROSETTA). This destructor
only frees memory of data members associated with the parts of the current IR node which 
are NOT traversed. Those data members that are part of a traversal can be freed using
a traversal (calling this destructor on all children in a post-order traversal).  Such 
a traversal which deletes a whole AST is provided by DeleteSgTree(SgNode*).

\internal  All IR nodes with data members specified using setDataPrototype() within ROSETTA
     are specified as NO_DELETE is also specified as DEF_TRAVERSAL.  Those marked as
     NO_TRAVERSAL can be marked as NO_DELETE or DEF_DELETE.

\note All SgSymbol IR nodes are deleted when the symbol table is deleted.  Currently most
     SgType IR nodes are not deleted (since they are shared).  Also, all STL lists of
     pointers are not yet implemented to call delete on eash pointer in the container.
     (This could be done by derivation from the STL containers to define containers that
     automatically deleted their members.)

*/
SgPointerMemberType::~SgPointerMemberType ()
   {
#if 0
  // debugging information!
     printf ("In SgPointerMemberType::~SgPointerMemberType (destructor) \n");
#endif

#if 1
  // DQ (6/25/2006): Commented out destructor body to allow the File I/O to work.
     

  // case: not a listType for class_of
     p_class_of = NULL; // non list case 

#line 32 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarDestructorDefinitionMacros.macro"
#endif
   }


#line 1 ""

#line 1 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

// Generated constructor
SgPointerMemberType::SgPointerMemberType ( SgType* base_type, SgClassDefinition* class_of )
   : SgPointerType(base_type)
   {
#ifdef DEBUG
  // printf ("In SgPointerMemberType::SgPointerMemberType (SgType* base_type, SgClassDefinition* class_of) sage_class_name() = %s \n",sage_class_name());
#endif

     p_class_of = class_of;

#line 11 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarConstructorDefinitionMacros.macro"

  // Test the variant virtual function
     assert(T_MEMBER_POINTER == variant());
     post_construction_initialization();

  // Test the isSgPointerMemberType() function since it has been problematic
     assert(isSgPointerMemberType(this) != NULL);
   }


#line 1 ""

#line 1 ""

#line 6 "../Grammar/grammarClassDefinitionMacros.macro after marker MEMBER_FUNCTION_DEFINITIONS"

#line 7 "/home/dquinlan/ROSE/NEW_ROSE/src/ROSETTA/Grammar/grammarClassDefinitionMacros.macro"

// ********************************************************
// member functions common across all array grammar objects
// ********************************************************



#line 1 ""

#line 1 ""

void outputSizeOfIntermediateRepresentation()
   {
     printf ("     Size of AstAttributeMechanism                     = %lu \n",(unsigned long) sizeof(AstAttributeMechanism));
     printf ("     Size of SgModifier                                = %lu \n",(unsigned long) sizeof(SgModifier));
     printf ("     Size of SgBitAttribute                            = %lu \n",(unsigned long) sizeof(SgBitAttribute));
     printf ("     Size of SgAttribute                               = %lu \n",(unsigned long) sizeof(SgAttribute));
     printf ("     Size of SgGraphNode                               = %lu \n",(unsigned long) sizeof(SgGraphNode));
     printf ("     Size of SgGraphEdge                               = %lu \n",(unsigned long) sizeof(SgGraphEdge));
     printf ("     Size of SgGraph                                   = %lu \n",(unsigned long) sizeof(SgGraph));
     printf ("     Size of SgSupport                                 = %lu \n",(unsigned long) sizeof(SgSupport));
     printf ("     Size of SgPartialFunctionType                     = %lu \n",(unsigned long) sizeof(SgPartialFunctionType));
     printf ("     Size of SgMemberFunctionType                      = %lu \n",(unsigned long) sizeof(SgMemberFunctionType));
     printf ("     Size of SgFunctionType                            = %lu \n",(unsigned long) sizeof(SgFunctionType));
     printf ("     Size of SgPointerType                             = %lu \n",(unsigned long) sizeof(SgPointerType));
     printf ("     Size of SgNamedType                               = %lu \n",(unsigned long) sizeof(SgNamedType));
     printf ("     Size of SgType                                    = %lu \n",(unsigned long) sizeof(SgType));
     printf ("     Size of SgInitializer                             = %lu \n",(unsigned long) sizeof(SgInitializer));
     printf ("     Size of SgUnaryOp                                 = %lu \n",(unsigned long) sizeof(SgUnaryOp));
     printf ("     Size of SgBinaryOp                                = %lu \n",(unsigned long) sizeof(SgBinaryOp));
     printf ("     Size of SgValueExp                                = %lu \n",(unsigned long) sizeof(SgValueExp));
     printf ("     Size of SgExpression                              = %lu \n",(unsigned long) sizeof(SgExpression));
     printf ("     Size of SgFortranDo                               = %lu \n",(unsigned long) sizeof(SgFortranDo));
     printf ("     Size of SgIOControlStatement                      = %lu \n",(unsigned long) sizeof(SgIOControlStatement));
     printf ("     Size of SgClassDeclaration                        = %lu \n",(unsigned long) sizeof(SgClassDeclaration));
     printf ("     Size of SgClassDefinition                         = %lu \n",(unsigned long) sizeof(SgClassDefinition));
     printf ("     Size of SgScopeStatement                          = %lu \n",(unsigned long) sizeof(SgScopeStatement));
     printf ("     Size of SgMemberFunctionDeclaration               = %lu \n",(unsigned long) sizeof(SgMemberFunctionDeclaration));
     printf ("     Size of SgFunctionDeclaration                     = %lu \n",(unsigned long) sizeof(SgFunctionDeclaration));
     printf ("     Size of SgC_PreprocessorDirectiveStatement        = %lu \n",(unsigned long) sizeof(SgC_PreprocessorDirectiveStatement));
     printf ("     Size of SgClinkageDeclarationStatement            = %lu \n",(unsigned long) sizeof(SgClinkageDeclarationStatement));
     printf ("     Size of SgDeclarationStatement                    = %lu \n",(unsigned long) sizeof(SgDeclarationStatement));
     printf ("     Size of SgStatement                               = %lu \n",(unsigned long) sizeof(SgStatement));
     printf ("     Size of SgFunctionSymbol                          = %lu \n",(unsigned long) sizeof(SgFunctionSymbol));
     printf ("     Size of SgSymbol                                  = %lu \n",(unsigned long) sizeof(SgSymbol));
     printf ("     Size of SgLocatedNode                             = %lu \n",(unsigned long) sizeof(SgLocatedNode));
     printf ("     Size of SgNode                                    = %lu \n",(unsigned long) sizeof(SgNode));
     printf ("     Size of SgSymbolTable                             = %lu \n",(unsigned long) sizeof(SgSymbolTable));
     printf ("     Size of SgInitializedName                         = %lu \n",(unsigned long) sizeof(SgInitializedName));
     printf ("     Size of SgName                                    = %lu \n",(unsigned long) sizeof(SgName));
     printf ("     Size of SgPragma                                  = %lu \n",(unsigned long) sizeof(SgPragma));
     printf ("     Size of SgModifierNodes                           = %lu \n",(unsigned long) sizeof(SgModifierNodes));
     printf ("     Size of SgConstVolatileModifier                   = %lu \n",(unsigned long) sizeof(SgConstVolatileModifier));
     printf ("     Size of SgStorageModifier                         = %lu \n",(unsigned long) sizeof(SgStorageModifier));
     printf ("     Size of SgAccessModifier                          = %lu \n",(unsigned long) sizeof(SgAccessModifier));
     printf ("     Size of SgFunctionModifier                        = %lu \n",(unsigned long) sizeof(SgFunctionModifier));
     printf ("     Size of SgUPC_AccessModifier                      = %lu \n",(unsigned long) sizeof(SgUPC_AccessModifier));
     printf ("     Size of SgLinkageModifier                         = %lu \n",(unsigned long) sizeof(SgLinkageModifier));
     printf ("     Size of SgSpecialFunctionModifier                 = %lu \n",(unsigned long) sizeof(SgSpecialFunctionModifier));
     printf ("     Size of SgTypeModifier                            = %lu \n",(unsigned long) sizeof(SgTypeModifier));
     printf ("     Size of SgElaboratedTypeModifier                  = %lu \n",(unsigned long) sizeof(SgElaboratedTypeModifier));
     printf ("     Size of SgBaseClassModifier                       = %lu \n",(unsigned long) sizeof(SgBaseClassModifier));
     printf ("     Size of SgDeclarationModifier                     = %lu \n",(unsigned long) sizeof(SgDeclarationModifier));
     printf ("     Size of Sg_File_Info                              = %lu \n",(unsigned long) sizeof(Sg_File_Info));
     printf ("     Size of SgFile                                    = %lu \n",(unsigned long) sizeof(SgFile));
     printf ("     Size of SgFileList                                = %lu \n",(unsigned long) sizeof(SgFileList));
     printf ("     Size of SgDirectory                               = %lu \n",(unsigned long) sizeof(SgDirectory));
     printf ("     Size of SgDirectoryList                           = %lu \n",(unsigned long) sizeof(SgDirectoryList));
     printf ("     Size of SgProject                                 = %lu \n",(unsigned long) sizeof(SgProject));
     printf ("     Size of SgOptions                                 = %lu \n",(unsigned long) sizeof(SgOptions));
     printf ("     Size of SgUnparse_Info                            = %lu \n",(unsigned long) sizeof(SgUnparse_Info));
     printf ("     Size of SgFuncDecl_attr                           = %lu \n",(unsigned long) sizeof(SgFuncDecl_attr));
     printf ("     Size of SgClassDecl_attr                          = %lu \n",(unsigned long) sizeof(SgClassDecl_attr));
     printf ("     Size of SgTypedefSeq                              = %lu \n",(unsigned long) sizeof(SgTypedefSeq));
     printf ("     Size of SgFunctionParameterTypeList               = %lu \n",(unsigned long) sizeof(SgFunctionParameterTypeList));
     printf ("     Size of SgTemplateParameter                       = %lu \n",(unsigned long) sizeof(SgTemplateParameter));
     printf ("     Size of SgTemplateArgument                        = %lu \n",(unsigned long) sizeof(SgTemplateArgument));
     printf ("     Size of SgTemplateParameterList                   = %lu \n",(unsigned long) sizeof(SgTemplateParameterList));
     printf ("     Size of SgTemplateArgumentList                    = %lu \n",(unsigned long) sizeof(SgTemplateArgumentList));
     printf ("     Size of SgBaseClass                               = %lu \n",(unsigned long) sizeof(SgBaseClass));
     printf ("     Size of SgDirectedGraph                           = %lu \n",(unsigned long) sizeof(SgDirectedGraph));
     printf ("     Size of SgDirectedGraphNode                       = %lu \n",(unsigned long) sizeof(SgDirectedGraphNode));
     printf ("     Size of SgDirectedGraphEdge                       = %lu \n",(unsigned long) sizeof(SgDirectedGraphEdge));
     printf ("     Size of SgQualifiedName                           = %lu \n",(unsigned long) sizeof(SgQualifiedName));
     printf ("     Size of SgTypeUnknown                             = %lu \n",(unsigned long) sizeof(SgTypeUnknown));
     printf ("     Size of SgTypeChar                                = %lu \n",(unsigned long) sizeof(SgTypeChar));
     printf ("     Size of SgTypeSignedChar                          = %lu \n",(unsigned long) sizeof(SgTypeSignedChar));
     printf ("     Size of SgTypeUnsignedChar                        = %lu \n",(unsigned long) sizeof(SgTypeUnsignedChar));
     printf ("     Size of SgTypeShort                               = %lu \n",(unsigned long) sizeof(SgTypeShort));
     printf ("     Size of SgTypeSignedShort                         = %lu \n",(unsigned long) sizeof(SgTypeSignedShort));
     printf ("     Size of SgTypeUnsignedShort                       = %lu \n",(unsigned long) sizeof(SgTypeUnsignedShort));
     printf ("     Size of SgTypeInt                                 = %lu \n",(unsigned long) sizeof(SgTypeInt));
     printf ("     Size of SgTypeSignedInt                           = %lu \n",(unsigned long) sizeof(SgTypeSignedInt));
     printf ("     Size of SgTypeUnsignedInt                         = %lu \n",(unsigned long) sizeof(SgTypeUnsignedInt));
     printf ("     Size of SgTypeLong                                = %lu \n",(unsigned long) sizeof(SgTypeLong));
     printf ("     Size of SgTypeSignedLong                          = %lu \n",(unsigned long) sizeof(SgTypeSignedLong));
     printf ("     Size of SgTypeUnsignedLong                        = %lu \n",(unsigned long) sizeof(SgTypeUnsignedLong));
     printf ("     Size of SgTypeVoid                                = %lu \n",(unsigned long) sizeof(SgTypeVoid));
     printf ("     Size of SgTypeGlobalVoid                          = %lu \n",(unsigned long) sizeof(SgTypeGlobalVoid));
     printf ("     Size of SgTypeWchar                               = %lu \n",(unsigned long) sizeof(SgTypeWchar));
     printf ("     Size of SgTypeFloat                               = %lu \n",(unsigned long) sizeof(SgTypeFloat));
     printf ("     Size of SgTypeDouble                              = %lu \n",(unsigned long) sizeof(SgTypeDouble));
     printf ("     Size of SgTypeLongLong                            = %lu \n",(unsigned long) sizeof(SgTypeLongLong));
     printf ("     Size of SgTypeUnsignedLongLong                    = %lu \n",(unsigned long) sizeof(SgTypeUnsignedLongLong));
     printf ("     Size of SgTypeLongDouble                          = %lu \n",(unsigned long) sizeof(SgTypeLongDouble));
     printf ("     Size of SgTypeString                              = %lu \n",(unsigned long) sizeof(SgTypeString));
     printf ("     Size of SgTypeBool                                = %lu \n",(unsigned long) sizeof(SgTypeBool));
     printf ("     Size of SgTypeComplex                             = %lu \n",(unsigned long) sizeof(SgTypeComplex));
     printf ("     Size of SgTypeImaginary                           = %lu \n",(unsigned long) sizeof(SgTypeImaginary));
     printf ("     Size of SgTypeDefault                             = %lu \n",(unsigned long) sizeof(SgTypeDefault));
     printf ("     Size of SgPointerMemberType                       = %lu \n",(unsigned long) sizeof(SgPointerMemberType));
     printf ("     Size of SgReferenceType                           = %lu \n",(unsigned long) sizeof(SgReferenceType));
     printf ("     Size of SgClassType                               = %lu \n",(unsigned long) sizeof(SgClassType));
     printf ("     Size of SgTemplateType                            = %lu \n",(unsigned long) sizeof(SgTemplateType));
     printf ("     Size of SgEnumType                                = %lu \n",(unsigned long) sizeof(SgEnumType));
     printf ("     Size of SgTypedefType                             = %lu \n",(unsigned long) sizeof(SgTypedefType));
     printf ("     Size of SgModifierType                            = %lu \n",(unsigned long) sizeof(SgModifierType));
     printf ("     Size of SgPartialFunctionModifierType             = %lu \n",(unsigned long) sizeof(SgPartialFunctionModifierType));
     printf ("     Size of SgArrayType                               = %lu \n",(unsigned long) sizeof(SgArrayType));
     printf ("     Size of SgTypeEllipse                             = %lu \n",(unsigned long) sizeof(SgTypeEllipse));
     printf ("     Size of SgUnknownMemberFunctionType               = %lu \n",(unsigned long) sizeof(SgUnknownMemberFunctionType));
     printf ("     Size of SgQualifiedNameType                       = %lu \n",(unsigned long) sizeof(SgQualifiedNameType));
     printf ("     Size of SgExprListExp                             = %lu \n",(unsigned long) sizeof(SgExprListExp));
     printf ("     Size of SgVarRefExp                               = %lu \n",(unsigned long) sizeof(SgVarRefExp));
     printf ("     Size of SgClassNameRefExp                         = %lu \n",(unsigned long) sizeof(SgClassNameRefExp));
     printf ("     Size of SgFunctionRefExp                          = %lu \n",(unsigned long) sizeof(SgFunctionRefExp));
     printf ("     Size of SgMemberFunctionRefExp                    = %lu \n",(unsigned long) sizeof(SgMemberFunctionRefExp));
     printf ("     Size of SgFunctionCallExp                         = %lu \n",(unsigned long) sizeof(SgFunctionCallExp));
     printf ("     Size of SgSizeOfOp                                = %lu \n",(unsigned long) sizeof(SgSizeOfOp));
     printf ("     Size of SgVarArgStartOp                           = %lu \n",(unsigned long) sizeof(SgVarArgStartOp));
     printf ("     Size of SgVarArgStartOneOperandOp                 = %lu \n",(unsigned long) sizeof(SgVarArgStartOneOperandOp));
     printf ("     Size of SgVarArgOp                                = %lu \n",(unsigned long) sizeof(SgVarArgOp));
     printf ("     Size of SgVarArgEndOp                             = %lu \n",(unsigned long) sizeof(SgVarArgEndOp));
     printf ("     Size of SgVarArgCopyOp                            = %lu \n",(unsigned long) sizeof(SgVarArgCopyOp));
     printf ("     Size of SgTypeIdOp                                = %lu \n",(unsigned long) sizeof(SgTypeIdOp));
     printf ("     Size of SgConditionalExp                          = %lu \n",(unsigned long) sizeof(SgConditionalExp));
     printf ("     Size of SgNewExp                                  = %lu \n",(unsigned long) sizeof(SgNewExp));
     printf ("     Size of SgDeleteExp                               = %lu \n",(unsigned long) sizeof(SgDeleteExp));
     printf ("     Size of SgThisExp                                 = %lu \n",(unsigned long) sizeof(SgThisExp));
     printf ("     Size of SgRefExp                                  = %lu \n",(unsigned long) sizeof(SgRefExp));
     printf ("     Size of SgAggregateInitializer                    = %lu \n",(unsigned long) sizeof(SgAggregateInitializer));
     printf ("     Size of SgConstructorInitializer                  = %lu \n",(unsigned long) sizeof(SgConstructorInitializer));
     printf ("     Size of SgAssignInitializer                       = %lu \n",(unsigned long) sizeof(SgAssignInitializer));
     printf ("     Size of SgExpressionRoot                          = %lu \n",(unsigned long) sizeof(SgExpressionRoot));
     printf ("     Size of SgMinusOp                                 = %lu \n",(unsigned long) sizeof(SgMinusOp));
     printf ("     Size of SgUnaryAddOp                              = %lu \n",(unsigned long) sizeof(SgUnaryAddOp));
     printf ("     Size of SgNotOp                                   = %lu \n",(unsigned long) sizeof(SgNotOp));
     printf ("     Size of SgPointerDerefExp                         = %lu \n",(unsigned long) sizeof(SgPointerDerefExp));
     printf ("     Size of SgAddressOfOp                             = %lu \n",(unsigned long) sizeof(SgAddressOfOp));
     printf ("     Size of SgMinusMinusOp                            = %lu \n",(unsigned long) sizeof(SgMinusMinusOp));
     printf ("     Size of SgPlusPlusOp                              = %lu \n",(unsigned long) sizeof(SgPlusPlusOp));
     printf ("     Size of SgBitComplementOp                         = %lu \n",(unsigned long) sizeof(SgBitComplementOp));
     printf ("     Size of SgCastExp                                 = %lu \n",(unsigned long) sizeof(SgCastExp));
     printf ("     Size of SgThrowOp                                 = %lu \n",(unsigned long) sizeof(SgThrowOp));
     printf ("     Size of SgArrowExp                                = %lu \n",(unsigned long) sizeof(SgArrowExp));
     printf ("     Size of SgDotExp                                  = %lu \n",(unsigned long) sizeof(SgDotExp));
     printf ("     Size of SgDotStarOp                               = %lu \n",(unsigned long) sizeof(SgDotStarOp));
     printf ("     Size of SgArrowStarOp                             = %lu \n",(unsigned long) sizeof(SgArrowStarOp));
     printf ("     Size of SgEqualityOp                              = %lu \n",(unsigned long) sizeof(SgEqualityOp));
     printf ("     Size of SgLessThanOp                              = %lu \n",(unsigned long) sizeof(SgLessThanOp));
     printf ("     Size of SgGreaterThanOp                           = %lu \n",(unsigned long) sizeof(SgGreaterThanOp));
     printf ("     Size of SgNotEqualOp                              = %lu \n",(unsigned long) sizeof(SgNotEqualOp));
     printf ("     Size of SgLessOrEqualOp                           = %lu \n",(unsigned long) sizeof(SgLessOrEqualOp));
     printf ("     Size of SgGreaterOrEqualOp                        = %lu \n",(unsigned long) sizeof(SgGreaterOrEqualOp));
     printf ("     Size of SgAddOp                                   = %lu \n",(unsigned long) sizeof(SgAddOp));
     printf ("     Size of SgSubtractOp                              = %lu \n",(unsigned long) sizeof(SgSubtractOp));
     printf ("     Size of SgMultiplyOp                              = %lu \n",(unsigned long) sizeof(SgMultiplyOp));
     printf ("     Size of SgDivideOp                                = %lu \n",(unsigned long) sizeof(SgDivideOp));
     printf ("     Size of SgIntegerDivideOp                         = %lu \n",(unsigned long) sizeof(SgIntegerDivideOp));
     printf ("     Size of SgModOp                                   = %lu \n",(unsigned long) sizeof(SgModOp));
     printf ("     Size of SgAndOp                                   = %lu \n",(unsigned long) sizeof(SgAndOp));
     printf ("     Size of SgOrOp                                    = %lu \n",(unsigned long) sizeof(SgOrOp));
     printf ("     Size of SgBitXorOp                                = %lu \n",(unsigned long) sizeof(SgBitXorOp));
     printf ("     Size of SgBitAndOp                                = %lu \n",(unsigned long) sizeof(SgBitAndOp));
     printf ("     Size of SgBitOrOp                                 = %lu \n",(unsigned long) sizeof(SgBitOrOp));
     printf ("     Size of SgCommaOpExp                              = %lu \n",(unsigned long) sizeof(SgCommaOpExp));
     printf ("     Size of SgLshiftOp                                = %lu \n",(unsigned long) sizeof(SgLshiftOp));
     printf ("     Size of SgRshiftOp                                = %lu \n",(unsigned long) sizeof(SgRshiftOp));
     printf ("     Size of SgPntrArrRefExp                           = %lu \n",(unsigned long) sizeof(SgPntrArrRefExp));
     printf ("     Size of SgScopeOp                                 = %lu \n",(unsigned long) sizeof(SgScopeOp));
     printf ("     Size of SgAssignOp                                = %lu \n",(unsigned long) sizeof(SgAssignOp));
     printf ("     Size of SgPlusAssignOp                            = %lu \n",(unsigned long) sizeof(SgPlusAssignOp));
     printf ("     Size of SgMinusAssignOp                           = %lu \n",(unsigned long) sizeof(SgMinusAssignOp));
     printf ("     Size of SgAndAssignOp                             = %lu \n",(unsigned long) sizeof(SgAndAssignOp));
     printf ("     Size of SgIorAssignOp                             = %lu \n",(unsigned long) sizeof(SgIorAssignOp));
     printf ("     Size of SgMultAssignOp                            = %lu \n",(unsigned long) sizeof(SgMultAssignOp));
     printf ("     Size of SgDivAssignOp                             = %lu \n",(unsigned long) sizeof(SgDivAssignOp));
     printf ("     Size of SgModAssignOp                             = %lu \n",(unsigned long) sizeof(SgModAssignOp));
     printf ("     Size of SgXorAssignOp                             = %lu \n",(unsigned long) sizeof(SgXorAssignOp));
     printf ("     Size of SgLshiftAssignOp                          = %lu \n",(unsigned long) sizeof(SgLshiftAssignOp));
     printf ("     Size of SgRshiftAssignOp                          = %lu \n",(unsigned long) sizeof(SgRshiftAssignOp));
     printf ("     Size of SgBoolValExp                              = %lu \n",(unsigned long) sizeof(SgBoolValExp));
     printf ("     Size of SgStringVal                               = %lu \n",(unsigned long) sizeof(SgStringVal));
     printf ("     Size of SgShortVal                                = %lu \n",(unsigned long) sizeof(SgShortVal));
     printf ("     Size of SgCharVal                                 = %lu \n",(unsigned long) sizeof(SgCharVal));
     printf ("     Size of SgUnsignedCharVal                         = %lu \n",(unsigned long) sizeof(SgUnsignedCharVal));
     printf ("     Size of SgWcharVal                                = %lu \n",(unsigned long) sizeof(SgWcharVal));
     printf ("     Size of SgUnsignedShortVal                        = %lu \n",(unsigned long) sizeof(SgUnsignedShortVal));
     printf ("     Size of SgIntVal                                  = %lu \n",(unsigned long) sizeof(SgIntVal));
     printf ("     Size of SgEnumVal                                 = %lu \n",(unsigned long) sizeof(SgEnumVal));
     printf ("     Size of SgUnsignedIntVal                          = %lu \n",(unsigned long) sizeof(SgUnsignedIntVal));
     printf ("     Size of SgLongIntVal                              = %lu \n",(unsigned long) sizeof(SgLongIntVal));
     printf ("     Size of SgLongLongIntVal                          = %lu \n",(unsigned long) sizeof(SgLongLongIntVal));
     printf ("     Size of SgUnsignedLongLongIntVal                  = %lu \n",(unsigned long) sizeof(SgUnsignedLongLongIntVal));
     printf ("     Size of SgUnsignedLongVal                         = %lu \n",(unsigned long) sizeof(SgUnsignedLongVal));
     printf ("     Size of SgFloatVal                                = %lu \n",(unsigned long) sizeof(SgFloatVal));
     printf ("     Size of SgDoubleVal                               = %lu \n",(unsigned long) sizeof(SgDoubleVal));
     printf ("     Size of SgLongDoubleVal                           = %lu \n",(unsigned long) sizeof(SgLongDoubleVal));
     printf ("     Size of SgComplexVal                              = %lu \n",(unsigned long) sizeof(SgComplexVal));
     printf ("     Size of SgNullExpression                          = %lu \n",(unsigned long) sizeof(SgNullExpression));
     printf ("     Size of SgVariantExpression                       = %lu \n",(unsigned long) sizeof(SgVariantExpression));
     printf ("     Size of SgStatementExpression                     = %lu \n",(unsigned long) sizeof(SgStatementExpression));
     printf ("     Size of SgAsmOp                                   = %lu \n",(unsigned long) sizeof(SgAsmOp));
     printf ("     Size of SgIntrinsicFn                             = %lu \n",(unsigned long) sizeof(SgIntrinsicFn));
     printf ("     Size of SgSubscriptExpression                     = %lu \n",(unsigned long) sizeof(SgSubscriptExpression));
     printf ("     Size of SgSubscriptColon                          = %lu \n",(unsigned long) sizeof(SgSubscriptColon));
     printf ("     Size of SgColon                                   = %lu \n",(unsigned long) sizeof(SgColon));
     printf ("     Size of SgSubscriptAsterisk                       = %lu \n",(unsigned long) sizeof(SgSubscriptAsterisk));
     printf ("     Size of SgUseOnlyExpression                       = %lu \n",(unsigned long) sizeof(SgUseOnlyExpression));
     printf ("     Size of SgUseRenameExpression                     = %lu \n",(unsigned long) sizeof(SgUseRenameExpression));
     printf ("     Size of SgIOItemExpression                        = %lu \n",(unsigned long) sizeof(SgIOItemExpression));
     printf ("     Size of SgIOImpliedDo                             = %lu \n",(unsigned long) sizeof(SgIOImpliedDo));
     printf ("     Size of SgExponentiationOp                        = %lu \n",(unsigned long) sizeof(SgExponentiationOp));
     printf ("     Size of SgForStatement                            = %lu \n",(unsigned long) sizeof(SgForStatement));
     printf ("     Size of SgForInitStatement                        = %lu \n",(unsigned long) sizeof(SgForInitStatement));
     printf ("     Size of SgCatchStatementSeq                       = %lu \n",(unsigned long) sizeof(SgCatchStatementSeq));
     printf ("     Size of SgFunctionParameterList                   = %lu \n",(unsigned long) sizeof(SgFunctionParameterList));
     printf ("     Size of SgCtorInitializerList                     = %lu \n",(unsigned long) sizeof(SgCtorInitializerList));
     printf ("     Size of SgBasicBlock                              = %lu \n",(unsigned long) sizeof(SgBasicBlock));
     printf ("     Size of SgGlobal                                  = %lu \n",(unsigned long) sizeof(SgGlobal));
     printf ("     Size of SgIfStmt                                  = %lu \n",(unsigned long) sizeof(SgIfStmt));
     printf ("     Size of SgFunctionDefinition                      = %lu \n",(unsigned long) sizeof(SgFunctionDefinition));
     printf ("     Size of SgWhileStmt                               = %lu \n",(unsigned long) sizeof(SgWhileStmt));
     printf ("     Size of SgDoWhileStmt                             = %lu \n",(unsigned long) sizeof(SgDoWhileStmt));
     printf ("     Size of SgSwitchStatement                         = %lu \n",(unsigned long) sizeof(SgSwitchStatement));
     printf ("     Size of SgCatchOptionStmt                         = %lu \n",(unsigned long) sizeof(SgCatchOptionStmt));
     printf ("     Size of SgVariableDeclaration                     = %lu \n",(unsigned long) sizeof(SgVariableDeclaration));
     printf ("     Size of SgVariableDefinition                      = %lu \n",(unsigned long) sizeof(SgVariableDefinition));
     printf ("     Size of SgEnumDeclaration                         = %lu \n",(unsigned long) sizeof(SgEnumDeclaration));
     printf ("     Size of SgAsmStmt                                 = %lu \n",(unsigned long) sizeof(SgAsmStmt));
     printf ("     Size of SgTypedefDeclaration                      = %lu \n",(unsigned long) sizeof(SgTypedefDeclaration));
     printf ("     Size of SgFunctionTypeTable                       = %lu \n",(unsigned long) sizeof(SgFunctionTypeTable));
     printf ("     Size of SgExprStatement                           = %lu \n",(unsigned long) sizeof(SgExprStatement));
     printf ("     Size of SgLabelStatement                          = %lu \n",(unsigned long) sizeof(SgLabelStatement));
     printf ("     Size of SgCaseOptionStmt                          = %lu \n",(unsigned long) sizeof(SgCaseOptionStmt));
     printf ("     Size of SgTryStmt                                 = %lu \n",(unsigned long) sizeof(SgTryStmt));
     printf ("     Size of SgDefaultOptionStmt                       = %lu \n",(unsigned long) sizeof(SgDefaultOptionStmt));
     printf ("     Size of SgBreakStmt                               = %lu \n",(unsigned long) sizeof(SgBreakStmt));
     printf ("     Size of SgContinueStmt                            = %lu \n",(unsigned long) sizeof(SgContinueStmt));
     printf ("     Size of SgReturnStmt                              = %lu \n",(unsigned long) sizeof(SgReturnStmt));
     printf ("     Size of SgGotoStatement                           = %lu \n",(unsigned long) sizeof(SgGotoStatement));
     printf ("     Size of SgSpawnStmt                               = %lu \n",(unsigned long) sizeof(SgSpawnStmt));
     printf ("     Size of SgNullStatement                           = %lu \n",(unsigned long) sizeof(SgNullStatement));
     printf ("     Size of SgVariantStatement                        = %lu \n",(unsigned long) sizeof(SgVariantStatement));
     printf ("     Size of SgPragmaDeclaration                       = %lu \n",(unsigned long) sizeof(SgPragmaDeclaration));
     printf ("     Size of SgTemplateDeclaration                     = %lu \n",(unsigned long) sizeof(SgTemplateDeclaration));
     printf ("     Size of SgTemplateInstantiationDecl               = %lu \n",(unsigned long) sizeof(SgTemplateInstantiationDecl));
     printf ("     Size of SgTemplateInstantiationDefn               = %lu \n",(unsigned long) sizeof(SgTemplateInstantiationDefn));
     printf ("     Size of SgTemplateInstantiationFunctionDecl       = %lu \n",(unsigned long) sizeof(SgTemplateInstantiationFunctionDecl));
     printf ("     Size of SgTemplateInstantiationMemberFunctionDecl = %lu \n",(unsigned long) sizeof(SgTemplateInstantiationMemberFunctionDecl));
     printf ("     Size of SgProgramHeaderStatement                  = %lu \n",(unsigned long) sizeof(SgProgramHeaderStatement));
     printf ("     Size of SgProcedureHeaderStatement                = %lu \n",(unsigned long) sizeof(SgProcedureHeaderStatement));
     printf ("     Size of SgFortranNonblockedDo                     = %lu \n",(unsigned long) sizeof(SgFortranNonblockedDo));
     printf ("     Size of SgInterfaceStatement                      = %lu \n",(unsigned long) sizeof(SgInterfaceStatement));
     printf ("     Size of SgParameterStatement                      = %lu \n",(unsigned long) sizeof(SgParameterStatement));
     printf ("     Size of SgCommonBlock                             = %lu \n",(unsigned long) sizeof(SgCommonBlock));
     printf ("     Size of SgModuleStatement                         = %lu \n",(unsigned long) sizeof(SgModuleStatement));
     printf ("     Size of SgUseStatement                            = %lu \n",(unsigned long) sizeof(SgUseStatement));
     printf ("     Size of SgStopOrPauseStatement                    = %lu \n",(unsigned long) sizeof(SgStopOrPauseStatement));
     printf ("     Size of SgIOStatement                             = %lu \n",(unsigned long) sizeof(SgIOStatement));
     printf ("     Size of SgInputOutputStatement                    = %lu \n",(unsigned long) sizeof(SgInputOutputStatement));
     printf ("     Size of SgOpenStatement                           = %lu \n",(unsigned long) sizeof(SgOpenStatement));
     printf ("     Size of SgCloseStatement                          = %lu \n",(unsigned long) sizeof(SgCloseStatement));
     printf ("     Size of SgInquireStatement                        = %lu \n",(unsigned long) sizeof(SgInquireStatement));
     printf ("     Size of SgIOFileControlStmt                       = %lu \n",(unsigned long) sizeof(SgIOFileControlStmt));
     printf ("     Size of SgBlockDataStatement                      = %lu \n",(unsigned long) sizeof(SgBlockDataStatement));
     printf ("     Size of SgImplicitStatement                       = %lu \n",(unsigned long) sizeof(SgImplicitStatement));
     printf ("     Size of SgStatementFunctionStatement              = %lu \n",(unsigned long) sizeof(SgStatementFunctionStatement));
     printf ("     Size of SgWhereStatement                          = %lu \n",(unsigned long) sizeof(SgWhereStatement));
     printf ("     Size of SgNullifyStatement                        = %lu \n",(unsigned long) sizeof(SgNullifyStatement));
     printf ("     Size of SgEquivalenceStatement                    = %lu \n",(unsigned long) sizeof(SgEquivalenceStatement));
     printf ("     Size of SgDerivedTypeStatement                    = %lu \n",(unsigned long) sizeof(SgDerivedTypeStatement));
     printf ("     Size of SgAttributeSpecificationStatement         = %lu \n",(unsigned long) sizeof(SgAttributeSpecificationStatement));
     printf ("     Size of SgAllocateStatement                       = %lu \n",(unsigned long) sizeof(SgAllocateStatement));
     printf ("     Size of SgDeallocateStatement                     = %lu \n",(unsigned long) sizeof(SgDeallocateStatement));
     printf ("     Size of SgContainsStatement                       = %lu \n",(unsigned long) sizeof(SgContainsStatement));
     printf ("     Size of SgSequenceStatement                       = %lu \n",(unsigned long) sizeof(SgSequenceStatement));
     printf ("     Size of SgElseWhereStatement                      = %lu \n",(unsigned long) sizeof(SgElseWhereStatement));
     printf ("     Size of SgArithmeticIfStatement                   = %lu \n",(unsigned long) sizeof(SgArithmeticIfStatement));
     printf ("     Size of SgAssignStatement                         = %lu \n",(unsigned long) sizeof(SgAssignStatement));
     printf ("     Size of SgComputedGotoStatement                   = %lu \n",(unsigned long) sizeof(SgComputedGotoStatement));
     printf ("     Size of SgAssignedGotoStatement                   = %lu \n",(unsigned long) sizeof(SgAssignedGotoStatement));
     printf ("     Size of SgNamespaceDeclarationStatement           = %lu \n",(unsigned long) sizeof(SgNamespaceDeclarationStatement));
     printf ("     Size of SgNamespaceAliasDeclarationStatement      = %lu \n",(unsigned long) sizeof(SgNamespaceAliasDeclarationStatement));
     printf ("     Size of SgNamespaceDefinitionStatement            = %lu \n",(unsigned long) sizeof(SgNamespaceDefinitionStatement));
     printf ("     Size of SgUsingDeclarationStatement               = %lu \n",(unsigned long) sizeof(SgUsingDeclarationStatement));
     printf ("     Size of SgUsingDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgUsingDirectiveStatement));
     printf ("     Size of SgTemplateInstantiationDirectiveStatement = %lu \n",(unsigned long) sizeof(SgTemplateInstantiationDirectiveStatement));
     printf ("     Size of SgIncludeDirectiveStatement               = %lu \n",(unsigned long) sizeof(SgIncludeDirectiveStatement));
     printf ("     Size of SgDefineDirectiveStatement                = %lu \n",(unsigned long) sizeof(SgDefineDirectiveStatement));
     printf ("     Size of SgUndefDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgUndefDirectiveStatement));
     printf ("     Size of SgIfdefDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgIfdefDirectiveStatement));
     printf ("     Size of SgIfndefDirectiveStatement                = %lu \n",(unsigned long) sizeof(SgIfndefDirectiveStatement));
     printf ("     Size of SgIfDirectiveStatement                    = %lu \n",(unsigned long) sizeof(SgIfDirectiveStatement));
     printf ("     Size of SgDeadIfDirectiveStatement                = %lu \n",(unsigned long) sizeof(SgDeadIfDirectiveStatement));
     printf ("     Size of SgElseDirectiveStatement                  = %lu \n",(unsigned long) sizeof(SgElseDirectiveStatement));
     printf ("     Size of SgElseifDirectiveStatement                = %lu \n",(unsigned long) sizeof(SgElseifDirectiveStatement));
     printf ("     Size of SgEndifDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgEndifDirectiveStatement));
     printf ("     Size of SgLineDirectiveStatement                  = %lu \n",(unsigned long) sizeof(SgLineDirectiveStatement));
     printf ("     Size of SgWarningDirectiveStatement               = %lu \n",(unsigned long) sizeof(SgWarningDirectiveStatement));
     printf ("     Size of SgErrorDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgErrorDirectiveStatement));
     printf ("     Size of SgEmptyDirectiveStatement                 = %lu \n",(unsigned long) sizeof(SgEmptyDirectiveStatement));
     printf ("     Size of SgClinkageStartStatement                  = %lu \n",(unsigned long) sizeof(SgClinkageStartStatement));
     printf ("     Size of SgClinkageEndStatement                    = %lu \n",(unsigned long) sizeof(SgClinkageEndStatement));
     printf ("     Size of SgVariableSymbol                          = %lu \n",(unsigned long) sizeof(SgVariableSymbol));
     printf ("     Size of SgFunctionTypeSymbol                      = %lu \n",(unsigned long) sizeof(SgFunctionTypeSymbol));
     printf ("     Size of SgClassSymbol                             = %lu \n",(unsigned long) sizeof(SgClassSymbol));
     printf ("     Size of SgTemplateSymbol                          = %lu \n",(unsigned long) sizeof(SgTemplateSymbol));
     printf ("     Size of SgEnumSymbol                              = %lu \n",(unsigned long) sizeof(SgEnumSymbol));
     printf ("     Size of SgEnumFieldSymbol                         = %lu \n",(unsigned long) sizeof(SgEnumFieldSymbol));
     printf ("     Size of SgTypedefSymbol                           = %lu \n",(unsigned long) sizeof(SgTypedefSymbol));
     printf ("     Size of SgMemberFunctionSymbol                    = %lu \n",(unsigned long) sizeof(SgMemberFunctionSymbol));
     printf ("     Size of SgLabelSymbol                             = %lu \n",(unsigned long) sizeof(SgLabelSymbol));
     printf ("     Size of SgDefaultSymbol                           = %lu \n",(unsigned long) sizeof(SgDefaultSymbol));
     printf ("     Size of SgNamespaceSymbol                         = %lu \n",(unsigned long) sizeof(SgNamespaceSymbol));
     printf ("     Size of SgIntrinsicSymbol                         = %lu \n",(unsigned long) sizeof(SgIntrinsicSymbol));
     printf ("     Size of SgModuleSymbol                            = %lu \n",(unsigned long) sizeof(SgModuleSymbol));
     printf ("     Size of SgInterfaceSymbol                         = %lu \n",(unsigned long) sizeof(SgInterfaceSymbol));
     printf ("     Size of SgCommonSymbol                            = %lu \n",(unsigned long) sizeof(SgCommonSymbol));
     printf ("     Size of SgToken                                   = %lu \n",(unsigned long) sizeof(SgToken));
   }


void traverseMemoryPoolVisitorPattern ( ROSE_VisitorPattern & visitor )
   {
     SgModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgBitAttribute::traverseMemoryPoolVisitorPattern(visitor);
     SgAttribute::traverseMemoryPoolVisitorPattern(visitor);
     SgGraphNode::traverseMemoryPoolVisitorPattern(visitor);
     SgGraphEdge::traverseMemoryPoolVisitorPattern(visitor);
     SgGraph::traverseMemoryPoolVisitorPattern(visitor);
     SgSupport::traverseMemoryPoolVisitorPattern(visitor);
     SgPartialFunctionType::traverseMemoryPoolVisitorPattern(visitor);
     SgMemberFunctionType::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionType::traverseMemoryPoolVisitorPattern(visitor);
     SgPointerType::traverseMemoryPoolVisitorPattern(visitor);
     SgNamedType::traverseMemoryPoolVisitorPattern(visitor);
     SgType::traverseMemoryPoolVisitorPattern(visitor);
     SgInitializer::traverseMemoryPoolVisitorPattern(visitor);
     SgUnaryOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBinaryOp::traverseMemoryPoolVisitorPattern(visitor);
     SgValueExp::traverseMemoryPoolVisitorPattern(visitor);
     SgExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgFortranDo::traverseMemoryPoolVisitorPattern(visitor);
     SgIOControlStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgClassDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgClassDefinition::traverseMemoryPoolVisitorPattern(visitor);
     SgScopeStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgMemberFunctionDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgC_PreprocessorDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgClinkageDeclarationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgDeclarationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgLocatedNode::traverseMemoryPoolVisitorPattern(visitor);
     SgNode::traverseMemoryPoolVisitorPattern(visitor);
     SgSymbolTable::traverseMemoryPoolVisitorPattern(visitor);
     SgInitializedName::traverseMemoryPoolVisitorPattern(visitor);
     SgName::traverseMemoryPoolVisitorPattern(visitor);
     SgPragma::traverseMemoryPoolVisitorPattern(visitor);
     SgModifierNodes::traverseMemoryPoolVisitorPattern(visitor);
     SgConstVolatileModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgStorageModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgAccessModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgUPC_AccessModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgLinkageModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgSpecialFunctionModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgElaboratedTypeModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgBaseClassModifier::traverseMemoryPoolVisitorPattern(visitor);
     SgDeclarationModifier::traverseMemoryPoolVisitorPattern(visitor);
     Sg_File_Info::traverseMemoryPoolVisitorPattern(visitor);
     SgFile::traverseMemoryPoolVisitorPattern(visitor);
     SgFileList::traverseMemoryPoolVisitorPattern(visitor);
     SgDirectory::traverseMemoryPoolVisitorPattern(visitor);
     SgDirectoryList::traverseMemoryPoolVisitorPattern(visitor);
     SgProject::traverseMemoryPoolVisitorPattern(visitor);
     SgOptions::traverseMemoryPoolVisitorPattern(visitor);
     SgUnparse_Info::traverseMemoryPoolVisitorPattern(visitor);
     SgFuncDecl_attr::traverseMemoryPoolVisitorPattern(visitor);
     SgClassDecl_attr::traverseMemoryPoolVisitorPattern(visitor);
     SgTypedefSeq::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionParameterTypeList::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateParameter::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateArgument::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateParameterList::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateArgumentList::traverseMemoryPoolVisitorPattern(visitor);
     SgBaseClass::traverseMemoryPoolVisitorPattern(visitor);
     SgDirectedGraph::traverseMemoryPoolVisitorPattern(visitor);
     SgDirectedGraphNode::traverseMemoryPoolVisitorPattern(visitor);
     SgDirectedGraphEdge::traverseMemoryPoolVisitorPattern(visitor);
     SgQualifiedName::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnknown::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeChar::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeSignedChar::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnsignedChar::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeShort::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeSignedShort::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnsignedShort::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeInt::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeSignedInt::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnsignedInt::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeLong::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeSignedLong::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnsignedLong::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeVoid::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeGlobalVoid::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeWchar::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeFloat::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeDouble::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeLongLong::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeUnsignedLongLong::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeLongDouble::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeString::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeBool::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeComplex::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeImaginary::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeDefault::traverseMemoryPoolVisitorPattern(visitor);
     SgPointerMemberType::traverseMemoryPoolVisitorPattern(visitor);
     SgReferenceType::traverseMemoryPoolVisitorPattern(visitor);
     SgClassType::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateType::traverseMemoryPoolVisitorPattern(visitor);
     SgEnumType::traverseMemoryPoolVisitorPattern(visitor);
     SgTypedefType::traverseMemoryPoolVisitorPattern(visitor);
     SgModifierType::traverseMemoryPoolVisitorPattern(visitor);
     SgPartialFunctionModifierType::traverseMemoryPoolVisitorPattern(visitor);
     SgArrayType::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeEllipse::traverseMemoryPoolVisitorPattern(visitor);
     SgUnknownMemberFunctionType::traverseMemoryPoolVisitorPattern(visitor);
     SgQualifiedNameType::traverseMemoryPoolVisitorPattern(visitor);
     SgExprListExp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgClassNameRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgMemberFunctionRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionCallExp::traverseMemoryPoolVisitorPattern(visitor);
     SgSizeOfOp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarArgStartOp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarArgStartOneOperandOp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarArgOp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarArgEndOp::traverseMemoryPoolVisitorPattern(visitor);
     SgVarArgCopyOp::traverseMemoryPoolVisitorPattern(visitor);
     SgTypeIdOp::traverseMemoryPoolVisitorPattern(visitor);
     SgConditionalExp::traverseMemoryPoolVisitorPattern(visitor);
     SgNewExp::traverseMemoryPoolVisitorPattern(visitor);
     SgDeleteExp::traverseMemoryPoolVisitorPattern(visitor);
     SgThisExp::traverseMemoryPoolVisitorPattern(visitor);
     SgRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgAggregateInitializer::traverseMemoryPoolVisitorPattern(visitor);
     SgConstructorInitializer::traverseMemoryPoolVisitorPattern(visitor);
     SgAssignInitializer::traverseMemoryPoolVisitorPattern(visitor);
     SgExpressionRoot::traverseMemoryPoolVisitorPattern(visitor);
     SgMinusOp::traverseMemoryPoolVisitorPattern(visitor);
     SgUnaryAddOp::traverseMemoryPoolVisitorPattern(visitor);
     SgNotOp::traverseMemoryPoolVisitorPattern(visitor);
     SgPointerDerefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgAddressOfOp::traverseMemoryPoolVisitorPattern(visitor);
     SgMinusMinusOp::traverseMemoryPoolVisitorPattern(visitor);
     SgPlusPlusOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBitComplementOp::traverseMemoryPoolVisitorPattern(visitor);
     SgCastExp::traverseMemoryPoolVisitorPattern(visitor);
     SgThrowOp::traverseMemoryPoolVisitorPattern(visitor);
     SgArrowExp::traverseMemoryPoolVisitorPattern(visitor);
     SgDotExp::traverseMemoryPoolVisitorPattern(visitor);
     SgDotStarOp::traverseMemoryPoolVisitorPattern(visitor);
     SgArrowStarOp::traverseMemoryPoolVisitorPattern(visitor);
     SgEqualityOp::traverseMemoryPoolVisitorPattern(visitor);
     SgLessThanOp::traverseMemoryPoolVisitorPattern(visitor);
     SgGreaterThanOp::traverseMemoryPoolVisitorPattern(visitor);
     SgNotEqualOp::traverseMemoryPoolVisitorPattern(visitor);
     SgLessOrEqualOp::traverseMemoryPoolVisitorPattern(visitor);
     SgGreaterOrEqualOp::traverseMemoryPoolVisitorPattern(visitor);
     SgAddOp::traverseMemoryPoolVisitorPattern(visitor);
     SgSubtractOp::traverseMemoryPoolVisitorPattern(visitor);
     SgMultiplyOp::traverseMemoryPoolVisitorPattern(visitor);
     SgDivideOp::traverseMemoryPoolVisitorPattern(visitor);
     SgIntegerDivideOp::traverseMemoryPoolVisitorPattern(visitor);
     SgModOp::traverseMemoryPoolVisitorPattern(visitor);
     SgAndOp::traverseMemoryPoolVisitorPattern(visitor);
     SgOrOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBitXorOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBitAndOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBitOrOp::traverseMemoryPoolVisitorPattern(visitor);
     SgCommaOpExp::traverseMemoryPoolVisitorPattern(visitor);
     SgLshiftOp::traverseMemoryPoolVisitorPattern(visitor);
     SgRshiftOp::traverseMemoryPoolVisitorPattern(visitor);
     SgPntrArrRefExp::traverseMemoryPoolVisitorPattern(visitor);
     SgScopeOp::traverseMemoryPoolVisitorPattern(visitor);
     SgAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgPlusAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgMinusAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgAndAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgIorAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgMultAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgDivAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgModAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgXorAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgLshiftAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgRshiftAssignOp::traverseMemoryPoolVisitorPattern(visitor);
     SgBoolValExp::traverseMemoryPoolVisitorPattern(visitor);
     SgStringVal::traverseMemoryPoolVisitorPattern(visitor);
     SgShortVal::traverseMemoryPoolVisitorPattern(visitor);
     SgCharVal::traverseMemoryPoolVisitorPattern(visitor);
     SgUnsignedCharVal::traverseMemoryPoolVisitorPattern(visitor);
     SgWcharVal::traverseMemoryPoolVisitorPattern(visitor);
     SgUnsignedShortVal::traverseMemoryPoolVisitorPattern(visitor);
     SgIntVal::traverseMemoryPoolVisitorPattern(visitor);
     SgEnumVal::traverseMemoryPoolVisitorPattern(visitor);
     SgUnsignedIntVal::traverseMemoryPoolVisitorPattern(visitor);
     SgLongIntVal::traverseMemoryPoolVisitorPattern(visitor);
     SgLongLongIntVal::traverseMemoryPoolVisitorPattern(visitor);
     SgUnsignedLongLongIntVal::traverseMemoryPoolVisitorPattern(visitor);
     SgUnsignedLongVal::traverseMemoryPoolVisitorPattern(visitor);
     SgFloatVal::traverseMemoryPoolVisitorPattern(visitor);
     SgDoubleVal::traverseMemoryPoolVisitorPattern(visitor);
     SgLongDoubleVal::traverseMemoryPoolVisitorPattern(visitor);
     SgComplexVal::traverseMemoryPoolVisitorPattern(visitor);
     SgNullExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgVariantExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgStatementExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgAsmOp::traverseMemoryPoolVisitorPattern(visitor);
     SgIntrinsicFn::traverseMemoryPoolVisitorPattern(visitor);
     SgSubscriptExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgSubscriptColon::traverseMemoryPoolVisitorPattern(visitor);
     SgColon::traverseMemoryPoolVisitorPattern(visitor);
     SgSubscriptAsterisk::traverseMemoryPoolVisitorPattern(visitor);
     SgUseOnlyExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgUseRenameExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgIOItemExpression::traverseMemoryPoolVisitorPattern(visitor);
     SgIOImpliedDo::traverseMemoryPoolVisitorPattern(visitor);
     SgExponentiationOp::traverseMemoryPoolVisitorPattern(visitor);
     SgForStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgForInitStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgCatchStatementSeq::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionParameterList::traverseMemoryPoolVisitorPattern(visitor);
     SgCtorInitializerList::traverseMemoryPoolVisitorPattern(visitor);
     SgBasicBlock::traverseMemoryPoolVisitorPattern(visitor);
     SgGlobal::traverseMemoryPoolVisitorPattern(visitor);
     SgIfStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionDefinition::traverseMemoryPoolVisitorPattern(visitor);
     SgWhileStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgDoWhileStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgSwitchStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgCatchOptionStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgVariableDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgVariableDefinition::traverseMemoryPoolVisitorPattern(visitor);
     SgEnumDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgAsmStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgTypedefDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionTypeTable::traverseMemoryPoolVisitorPattern(visitor);
     SgExprStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgLabelStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgCaseOptionStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgTryStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgDefaultOptionStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgBreakStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgContinueStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgReturnStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgGotoStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgSpawnStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgNullStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgVariantStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgPragmaDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateDeclaration::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateInstantiationDecl::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateInstantiationDefn::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateInstantiationFunctionDecl::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateInstantiationMemberFunctionDecl::traverseMemoryPoolVisitorPattern(visitor);
     SgProgramHeaderStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgProcedureHeaderStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgFortranNonblockedDo::traverseMemoryPoolVisitorPattern(visitor);
     SgInterfaceStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgParameterStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgCommonBlock::traverseMemoryPoolVisitorPattern(visitor);
     SgModuleStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgUseStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgStopOrPauseStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIOStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgInputOutputStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgOpenStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgCloseStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgInquireStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIOFileControlStmt::traverseMemoryPoolVisitorPattern(visitor);
     SgBlockDataStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgImplicitStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgStatementFunctionStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgWhereStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgNullifyStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgEquivalenceStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgDerivedTypeStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgAttributeSpecificationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgAllocateStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgDeallocateStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgContainsStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgSequenceStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgElseWhereStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgArithmeticIfStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgAssignStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgComputedGotoStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgAssignedGotoStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgNamespaceDeclarationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgNamespaceAliasDeclarationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgNamespaceDefinitionStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgUsingDeclarationStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgUsingDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateInstantiationDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIncludeDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgDefineDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgUndefDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIfdefDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIfndefDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgIfDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgDeadIfDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgElseDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgElseifDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgEndifDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgLineDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgWarningDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgErrorDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgEmptyDirectiveStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgClinkageStartStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgClinkageEndStatement::traverseMemoryPoolVisitorPattern(visitor);
     SgVariableSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgFunctionTypeSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgClassSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgTemplateSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgEnumSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgEnumFieldSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgTypedefSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgMemberFunctionSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgLabelSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgDefaultSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgNamespaceSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgIntrinsicSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgModuleSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgInterfaceSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgCommonSymbol::traverseMemoryPoolVisitorPattern(visitor);
     SgToken::traverseMemoryPoolVisitorPattern(visitor);
   }



void traverseMemoryPoolNodes ( ROSE_VisitTraversal & visit )
   {
     SgModifier::traverseMemoryPoolNodes(visit);
     SgBitAttribute::traverseMemoryPoolNodes(visit);
     SgAttribute::traverseMemoryPoolNodes(visit);
     SgGraphNode::traverseMemoryPoolNodes(visit);
     SgGraphEdge::traverseMemoryPoolNodes(visit);
     SgGraph::traverseMemoryPoolNodes(visit);
     SgSupport::traverseMemoryPoolNodes(visit);
     SgPartialFunctionType::traverseMemoryPoolNodes(visit);
     SgMemberFunctionType::traverseMemoryPoolNodes(visit);
     SgFunctionType::traverseMemoryPoolNodes(visit);
     SgPointerType::traverseMemoryPoolNodes(visit);
     SgNamedType::traverseMemoryPoolNodes(visit);
     SgType::traverseMemoryPoolNodes(visit);
     SgInitializer::traverseMemoryPoolNodes(visit);
     SgUnaryOp::traverseMemoryPoolNodes(visit);
     SgBinaryOp::traverseMemoryPoolNodes(visit);
     SgValueExp::traverseMemoryPoolNodes(visit);
     SgExpression::traverseMemoryPoolNodes(visit);
     SgFortranDo::traverseMemoryPoolNodes(visit);
     SgIOControlStatement::traverseMemoryPoolNodes(visit);
     SgClassDeclaration::traverseMemoryPoolNodes(visit);
     SgClassDefinition::traverseMemoryPoolNodes(visit);
     SgScopeStatement::traverseMemoryPoolNodes(visit);
     SgMemberFunctionDeclaration::traverseMemoryPoolNodes(visit);
     SgFunctionDeclaration::traverseMemoryPoolNodes(visit);
     SgC_PreprocessorDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgClinkageDeclarationStatement::traverseMemoryPoolNodes(visit);
     SgDeclarationStatement::traverseMemoryPoolNodes(visit);
     SgStatement::traverseMemoryPoolNodes(visit);
     SgFunctionSymbol::traverseMemoryPoolNodes(visit);
     SgSymbol::traverseMemoryPoolNodes(visit);
     SgLocatedNode::traverseMemoryPoolNodes(visit);
     SgNode::traverseMemoryPoolNodes(visit);
     SgSymbolTable::traverseMemoryPoolNodes(visit);
     SgInitializedName::traverseMemoryPoolNodes(visit);
     SgName::traverseMemoryPoolNodes(visit);
     SgPragma::traverseMemoryPoolNodes(visit);
     SgModifierNodes::traverseMemoryPoolNodes(visit);
     SgConstVolatileModifier::traverseMemoryPoolNodes(visit);
     SgStorageModifier::traverseMemoryPoolNodes(visit);
     SgAccessModifier::traverseMemoryPoolNodes(visit);
     SgFunctionModifier::traverseMemoryPoolNodes(visit);
     SgUPC_AccessModifier::traverseMemoryPoolNodes(visit);
     SgLinkageModifier::traverseMemoryPoolNodes(visit);
     SgSpecialFunctionModifier::traverseMemoryPoolNodes(visit);
     SgTypeModifier::traverseMemoryPoolNodes(visit);
     SgElaboratedTypeModifier::traverseMemoryPoolNodes(visit);
     SgBaseClassModifier::traverseMemoryPoolNodes(visit);
     SgDeclarationModifier::traverseMemoryPoolNodes(visit);
     Sg_File_Info::traverseMemoryPoolNodes(visit);
     SgFile::traverseMemoryPoolNodes(visit);
     SgFileList::traverseMemoryPoolNodes(visit);
     SgDirectory::traverseMemoryPoolNodes(visit);
     SgDirectoryList::traverseMemoryPoolNodes(visit);
     SgProject::traverseMemoryPoolNodes(visit);
     SgOptions::traverseMemoryPoolNodes(visit);
     SgUnparse_Info::traverseMemoryPoolNodes(visit);
     SgFuncDecl_attr::traverseMemoryPoolNodes(visit);
     SgClassDecl_attr::traverseMemoryPoolNodes(visit);
     SgTypedefSeq::traverseMemoryPoolNodes(visit);
     SgFunctionParameterTypeList::traverseMemoryPoolNodes(visit);
     SgTemplateParameter::traverseMemoryPoolNodes(visit);
     SgTemplateArgument::traverseMemoryPoolNodes(visit);
     SgTemplateParameterList::traverseMemoryPoolNodes(visit);
     SgTemplateArgumentList::traverseMemoryPoolNodes(visit);
     SgBaseClass::traverseMemoryPoolNodes(visit);
     SgDirectedGraph::traverseMemoryPoolNodes(visit);
     SgDirectedGraphNode::traverseMemoryPoolNodes(visit);
     SgDirectedGraphEdge::traverseMemoryPoolNodes(visit);
     SgQualifiedName::traverseMemoryPoolNodes(visit);
     SgTypeUnknown::traverseMemoryPoolNodes(visit);
     SgTypeChar::traverseMemoryPoolNodes(visit);
     SgTypeSignedChar::traverseMemoryPoolNodes(visit);
     SgTypeUnsignedChar::traverseMemoryPoolNodes(visit);
     SgTypeShort::traverseMemoryPoolNodes(visit);
     SgTypeSignedShort::traverseMemoryPoolNodes(visit);
     SgTypeUnsignedShort::traverseMemoryPoolNodes(visit);
     SgTypeInt::traverseMemoryPoolNodes(visit);
     SgTypeSignedInt::traverseMemoryPoolNodes(visit);
     SgTypeUnsignedInt::traverseMemoryPoolNodes(visit);
     SgTypeLong::traverseMemoryPoolNodes(visit);
     SgTypeSignedLong::traverseMemoryPoolNodes(visit);
     SgTypeUnsignedLong::traverseMemoryPoolNodes(visit);
     SgTypeVoid::traverseMemoryPoolNodes(visit);
     SgTypeGlobalVoid::traverseMemoryPoolNodes(visit);
     SgTypeWchar::traverseMemoryPoolNodes(visit);
     SgTypeFloat::traverseMemoryPoolNodes(visit);
     SgTypeDouble::traverseMemoryPoolNodes(visit);
     SgTypeLongLong::traverseMemoryPoolNodes(visit);
     SgTypeUnsignedLongLong::traverseMemoryPoolNodes(visit);
     SgTypeLongDouble::traverseMemoryPoolNodes(visit);
     SgTypeString::traverseMemoryPoolNodes(visit);
     SgTypeBool::traverseMemoryPoolNodes(visit);
     SgTypeComplex::traverseMemoryPoolNodes(visit);
     SgTypeImaginary::traverseMemoryPoolNodes(visit);
     SgTypeDefault::traverseMemoryPoolNodes(visit);
     SgPointerMemberType::traverseMemoryPoolNodes(visit);
     SgReferenceType::traverseMemoryPoolNodes(visit);
     SgClassType::traverseMemoryPoolNodes(visit);
     SgTemplateType::traverseMemoryPoolNodes(visit);
     SgEnumType::traverseMemoryPoolNodes(visit);
     SgTypedefType::traverseMemoryPoolNodes(visit);
     SgModifierType::traverseMemoryPoolNodes(visit);
     SgPartialFunctionModifierType::traverseMemoryPoolNodes(visit);
     SgArrayType::traverseMemoryPoolNodes(visit);
     SgTypeEllipse::traverseMemoryPoolNodes(visit);
     SgUnknownMemberFunctionType::traverseMemoryPoolNodes(visit);
     SgQualifiedNameType::traverseMemoryPoolNodes(visit);
     SgExprListExp::traverseMemoryPoolNodes(visit);
     SgVarRefExp::traverseMemoryPoolNodes(visit);
     SgClassNameRefExp::traverseMemoryPoolNodes(visit);
     SgFunctionRefExp::traverseMemoryPoolNodes(visit);
     SgMemberFunctionRefExp::traverseMemoryPoolNodes(visit);
     SgFunctionCallExp::traverseMemoryPoolNodes(visit);
     SgSizeOfOp::traverseMemoryPoolNodes(visit);
     SgVarArgStartOp::traverseMemoryPoolNodes(visit);
     SgVarArgStartOneOperandOp::traverseMemoryPoolNodes(visit);
     SgVarArgOp::traverseMemoryPoolNodes(visit);
     SgVarArgEndOp::traverseMemoryPoolNodes(visit);
     SgVarArgCopyOp::traverseMemoryPoolNodes(visit);
     SgTypeIdOp::traverseMemoryPoolNodes(visit);
     SgConditionalExp::traverseMemoryPoolNodes(visit);
     SgNewExp::traverseMemoryPoolNodes(visit);
     SgDeleteExp::traverseMemoryPoolNodes(visit);
     SgThisExp::traverseMemoryPoolNodes(visit);
     SgRefExp::traverseMemoryPoolNodes(visit);
     SgAggregateInitializer::traverseMemoryPoolNodes(visit);
     SgConstructorInitializer::traverseMemoryPoolNodes(visit);
     SgAssignInitializer::traverseMemoryPoolNodes(visit);
     SgExpressionRoot::traverseMemoryPoolNodes(visit);
     SgMinusOp::traverseMemoryPoolNodes(visit);
     SgUnaryAddOp::traverseMemoryPoolNodes(visit);
     SgNotOp::traverseMemoryPoolNodes(visit);
     SgPointerDerefExp::traverseMemoryPoolNodes(visit);
     SgAddressOfOp::traverseMemoryPoolNodes(visit);
     SgMinusMinusOp::traverseMemoryPoolNodes(visit);
     SgPlusPlusOp::traverseMemoryPoolNodes(visit);
     SgBitComplementOp::traverseMemoryPoolNodes(visit);
     SgCastExp::traverseMemoryPoolNodes(visit);
     SgThrowOp::traverseMemoryPoolNodes(visit);
     SgArrowExp::traverseMemoryPoolNodes(visit);
     SgDotExp::traverseMemoryPoolNodes(visit);
     SgDotStarOp::traverseMemoryPoolNodes(visit);
     SgArrowStarOp::traverseMemoryPoolNodes(visit);
     SgEqualityOp::traverseMemoryPoolNodes(visit);
     SgLessThanOp::traverseMemoryPoolNodes(visit);
     SgGreaterThanOp::traverseMemoryPoolNodes(visit);
     SgNotEqualOp::traverseMemoryPoolNodes(visit);
     SgLessOrEqualOp::traverseMemoryPoolNodes(visit);
     SgGreaterOrEqualOp::traverseMemoryPoolNodes(visit);
     SgAddOp::traverseMemoryPoolNodes(visit);
     SgSubtractOp::traverseMemoryPoolNodes(visit);
     SgMultiplyOp::traverseMemoryPoolNodes(visit);
     SgDivideOp::traverseMemoryPoolNodes(visit);
     SgIntegerDivideOp::traverseMemoryPoolNodes(visit);
     SgModOp::traverseMemoryPoolNodes(visit);
     SgAndOp::traverseMemoryPoolNodes(visit);
     SgOrOp::traverseMemoryPoolNodes(visit);
     SgBitXorOp::traverseMemoryPoolNodes(visit);
     SgBitAndOp::traverseMemoryPoolNodes(visit);
     SgBitOrOp::traverseMemoryPoolNodes(visit);
     SgCommaOpExp::traverseMemoryPoolNodes(visit);
     SgLshiftOp::traverseMemoryPoolNodes(visit);
     SgRshiftOp::traverseMemoryPoolNodes(visit);
     SgPntrArrRefExp::traverseMemoryPoolNodes(visit);
     SgScopeOp::traverseMemoryPoolNodes(visit);
     SgAssignOp::traverseMemoryPoolNodes(visit);
     SgPlusAssignOp::traverseMemoryPoolNodes(visit);
     SgMinusAssignOp::traverseMemoryPoolNodes(visit);
     SgAndAssignOp::traverseMemoryPoolNodes(visit);
     SgIorAssignOp::traverseMemoryPoolNodes(visit);
     SgMultAssignOp::traverseMemoryPoolNodes(visit);
     SgDivAssignOp::traverseMemoryPoolNodes(visit);
     SgModAssignOp::traverseMemoryPoolNodes(visit);
     SgXorAssignOp::traverseMemoryPoolNodes(visit);
     SgLshiftAssignOp::traverseMemoryPoolNodes(visit);
     SgRshiftAssignOp::traverseMemoryPoolNodes(visit);
     SgBoolValExp::traverseMemoryPoolNodes(visit);
     SgStringVal::traverseMemoryPoolNodes(visit);
     SgShortVal::traverseMemoryPoolNodes(visit);
     SgCharVal::traverseMemoryPoolNodes(visit);
     SgUnsignedCharVal::traverseMemoryPoolNodes(visit);
     SgWcharVal::traverseMemoryPoolNodes(visit);
     SgUnsignedShortVal::traverseMemoryPoolNodes(visit);
     SgIntVal::traverseMemoryPoolNodes(visit);
     SgEnumVal::traverseMemoryPoolNodes(visit);
     SgUnsignedIntVal::traverseMemoryPoolNodes(visit);
     SgLongIntVal::traverseMemoryPoolNodes(visit);
     SgLongLongIntVal::traverseMemoryPoolNodes(visit);
     SgUnsignedLongLongIntVal::traverseMemoryPoolNodes(visit);
     SgUnsignedLongVal::traverseMemoryPoolNodes(visit);
     SgFloatVal::traverseMemoryPoolNodes(visit);
     SgDoubleVal::traverseMemoryPoolNodes(visit);
     SgLongDoubleVal::traverseMemoryPoolNodes(visit);
     SgComplexVal::traverseMemoryPoolNodes(visit);
     SgNullExpression::traverseMemoryPoolNodes(visit);
     SgVariantExpression::traverseMemoryPoolNodes(visit);
     SgStatementExpression::traverseMemoryPoolNodes(visit);
     SgAsmOp::traverseMemoryPoolNodes(visit);
     SgIntrinsicFn::traverseMemoryPoolNodes(visit);
     SgSubscriptExpression::traverseMemoryPoolNodes(visit);
     SgSubscriptColon::traverseMemoryPoolNodes(visit);
     SgColon::traverseMemoryPoolNodes(visit);
     SgSubscriptAsterisk::traverseMemoryPoolNodes(visit);
     SgUseOnlyExpression::traverseMemoryPoolNodes(visit);
     SgUseRenameExpression::traverseMemoryPoolNodes(visit);
     SgIOItemExpression::traverseMemoryPoolNodes(visit);
     SgIOImpliedDo::traverseMemoryPoolNodes(visit);
     SgExponentiationOp::traverseMemoryPoolNodes(visit);
     SgForStatement::traverseMemoryPoolNodes(visit);
     SgForInitStatement::traverseMemoryPoolNodes(visit);
     SgCatchStatementSeq::traverseMemoryPoolNodes(visit);
     SgFunctionParameterList::traverseMemoryPoolNodes(visit);
     SgCtorInitializerList::traverseMemoryPoolNodes(visit);
     SgBasicBlock::traverseMemoryPoolNodes(visit);
     SgGlobal::traverseMemoryPoolNodes(visit);
     SgIfStmt::traverseMemoryPoolNodes(visit);
     SgFunctionDefinition::traverseMemoryPoolNodes(visit);
     SgWhileStmt::traverseMemoryPoolNodes(visit);
     SgDoWhileStmt::traverseMemoryPoolNodes(visit);
     SgSwitchStatement::traverseMemoryPoolNodes(visit);
     SgCatchOptionStmt::traverseMemoryPoolNodes(visit);
     SgVariableDeclaration::traverseMemoryPoolNodes(visit);
     SgVariableDefinition::traverseMemoryPoolNodes(visit);
     SgEnumDeclaration::traverseMemoryPoolNodes(visit);
     SgAsmStmt::traverseMemoryPoolNodes(visit);
     SgTypedefDeclaration::traverseMemoryPoolNodes(visit);
     SgFunctionTypeTable::traverseMemoryPoolNodes(visit);
     SgExprStatement::traverseMemoryPoolNodes(visit);
     SgLabelStatement::traverseMemoryPoolNodes(visit);
     SgCaseOptionStmt::traverseMemoryPoolNodes(visit);
     SgTryStmt::traverseMemoryPoolNodes(visit);
     SgDefaultOptionStmt::traverseMemoryPoolNodes(visit);
     SgBreakStmt::traverseMemoryPoolNodes(visit);
     SgContinueStmt::traverseMemoryPoolNodes(visit);
     SgReturnStmt::traverseMemoryPoolNodes(visit);
     SgGotoStatement::traverseMemoryPoolNodes(visit);
     SgSpawnStmt::traverseMemoryPoolNodes(visit);
     SgNullStatement::traverseMemoryPoolNodes(visit);
     SgVariantStatement::traverseMemoryPoolNodes(visit);
     SgPragmaDeclaration::traverseMemoryPoolNodes(visit);
     SgTemplateDeclaration::traverseMemoryPoolNodes(visit);
     SgTemplateInstantiationDecl::traverseMemoryPoolNodes(visit);
     SgTemplateInstantiationDefn::traverseMemoryPoolNodes(visit);
     SgTemplateInstantiationFunctionDecl::traverseMemoryPoolNodes(visit);
     SgTemplateInstantiationMemberFunctionDecl::traverseMemoryPoolNodes(visit);
     SgProgramHeaderStatement::traverseMemoryPoolNodes(visit);
     SgProcedureHeaderStatement::traverseMemoryPoolNodes(visit);
     SgFortranNonblockedDo::traverseMemoryPoolNodes(visit);
     SgInterfaceStatement::traverseMemoryPoolNodes(visit);
     SgParameterStatement::traverseMemoryPoolNodes(visit);
     SgCommonBlock::traverseMemoryPoolNodes(visit);
     SgModuleStatement::traverseMemoryPoolNodes(visit);
     SgUseStatement::traverseMemoryPoolNodes(visit);
     SgStopOrPauseStatement::traverseMemoryPoolNodes(visit);
     SgIOStatement::traverseMemoryPoolNodes(visit);
     SgInputOutputStatement::traverseMemoryPoolNodes(visit);
     SgOpenStatement::traverseMemoryPoolNodes(visit);
     SgCloseStatement::traverseMemoryPoolNodes(visit);
     SgInquireStatement::traverseMemoryPoolNodes(visit);
     SgIOFileControlStmt::traverseMemoryPoolNodes(visit);
     SgBlockDataStatement::traverseMemoryPoolNodes(visit);
     SgImplicitStatement::traverseMemoryPoolNodes(visit);
     SgStatementFunctionStatement::traverseMemoryPoolNodes(visit);
     SgWhereStatement::traverseMemoryPoolNodes(visit);
     SgNullifyStatement::traverseMemoryPoolNodes(visit);
     SgEquivalenceStatement::traverseMemoryPoolNodes(visit);
     SgDerivedTypeStatement::traverseMemoryPoolNodes(visit);
     SgAttributeSpecificationStatement::traverseMemoryPoolNodes(visit);
     SgAllocateStatement::traverseMemoryPoolNodes(visit);
     SgDeallocateStatement::traverseMemoryPoolNodes(visit);
     SgContainsStatement::traverseMemoryPoolNodes(visit);
     SgSequenceStatement::traverseMemoryPoolNodes(visit);
     SgElseWhereStatement::traverseMemoryPoolNodes(visit);
     SgArithmeticIfStatement::traverseMemoryPoolNodes(visit);
     SgAssignStatement::traverseMemoryPoolNodes(visit);
     SgComputedGotoStatement::traverseMemoryPoolNodes(visit);
     SgAssignedGotoStatement::traverseMemoryPoolNodes(visit);
     SgNamespaceDeclarationStatement::traverseMemoryPoolNodes(visit);
     SgNamespaceAliasDeclarationStatement::traverseMemoryPoolNodes(visit);
     SgNamespaceDefinitionStatement::traverseMemoryPoolNodes(visit);
     SgUsingDeclarationStatement::traverseMemoryPoolNodes(visit);
     SgUsingDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgTemplateInstantiationDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgIncludeDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgDefineDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgUndefDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgIfdefDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgIfndefDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgIfDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgDeadIfDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgElseDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgElseifDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgEndifDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgLineDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgWarningDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgErrorDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgEmptyDirectiveStatement::traverseMemoryPoolNodes(visit);
     SgClinkageStartStatement::traverseMemoryPoolNodes(visit);
     SgClinkageEndStatement::traverseMemoryPoolNodes(visit);
     SgVariableSymbol::traverseMemoryPoolNodes(visit);
     SgFunctionTypeSymbol::traverseMemoryPoolNodes(visit);
     SgClassSymbol::traverseMemoryPoolNodes(visit);
     SgTemplateSymbol::traverseMemoryPoolNodes(visit);
     SgEnumSymbol::traverseMemoryPoolNodes(visit);
     SgEnumFieldSymbol::traverseMemoryPoolNodes(visit);
     SgTypedefSymbol::traverseMemoryPoolNodes(visit);
     SgMemberFunctionSymbol::traverseMemoryPoolNodes(visit);
     SgLabelSymbol::traverseMemoryPoolNodes(visit);
     SgDefaultSymbol::traverseMemoryPoolNodes(visit);
     SgNamespaceSymbol::traverseMemoryPoolNodes(visit);
     SgIntrinsicSymbol::traverseMemoryPoolNodes(visit);
     SgModuleSymbol::traverseMemoryPoolNodes(visit);
     SgInterfaceSymbol::traverseMemoryPoolNodes(visit);
     SgCommonSymbol::traverseMemoryPoolNodes(visit);
     SgToken::traverseMemoryPoolNodes(visit);
   }



void traverseRepresentativeNodes ( ROSE_VisitTraversal & visit )
   {
     SgModifier::visitRepresentativeNode(visit);
     SgBitAttribute::visitRepresentativeNode(visit);
     SgAttribute::visitRepresentativeNode(visit);
     SgGraphNode::visitRepresentativeNode(visit);
     SgGraphEdge::visitRepresentativeNode(visit);
     SgGraph::visitRepresentativeNode(visit);
     SgSupport::visitRepresentativeNode(visit);
     SgPartialFunctionType::visitRepresentativeNode(visit);
     SgMemberFunctionType::visitRepresentativeNode(visit);
     SgFunctionType::visitRepresentativeNode(visit);
     SgPointerType::visitRepresentativeNode(visit);
     SgNamedType::visitRepresentativeNode(visit);
     SgType::visitRepresentativeNode(visit);
     SgInitializer::visitRepresentativeNode(visit);
     SgUnaryOp::visitRepresentativeNode(visit);
     SgBinaryOp::visitRepresentativeNode(visit);
     SgValueExp::visitRepresentativeNode(visit);
     SgExpression::visitRepresentativeNode(visit);
     SgFortranDo::visitRepresentativeNode(visit);
     SgIOControlStatement::visitRepresentativeNode(visit);
     SgClassDeclaration::visitRepresentativeNode(visit);
     SgClassDefinition::visitRepresentativeNode(visit);
     SgScopeStatement::visitRepresentativeNode(visit);
     SgMemberFunctionDeclaration::visitRepresentativeNode(visit);
     SgFunctionDeclaration::visitRepresentativeNode(visit);
     SgC_PreprocessorDirectiveStatement::visitRepresentativeNode(visit);
     SgClinkageDeclarationStatement::visitRepresentativeNode(visit);
     SgDeclarationStatement::visitRepresentativeNode(visit);
     SgStatement::visitRepresentativeNode(visit);
     SgFunctionSymbol::visitRepresentativeNode(visit);
     SgSymbol::visitRepresentativeNode(visit);
     SgLocatedNode::visitRepresentativeNode(visit);
     SgNode::visitRepresentativeNode(visit);
     SgSymbolTable::visitRepresentativeNode(visit);
     SgInitializedName::visitRepresentativeNode(visit);
     SgName::visitRepresentativeNode(visit);
     SgPragma::visitRepresentativeNode(visit);
     SgModifierNodes::visitRepresentativeNode(visit);
     SgConstVolatileModifier::visitRepresentativeNode(visit);
     SgStorageModifier::visitRepresentativeNode(visit);
     SgAccessModifier::visitRepresentativeNode(visit);
     SgFunctionModifier::visitRepresentativeNode(visit);
     SgUPC_AccessModifier::visitRepresentativeNode(visit);
     SgLinkageModifier::visitRepresentativeNode(visit);
     SgSpecialFunctionModifier::visitRepresentativeNode(visit);
     SgTypeModifier::visitRepresentativeNode(visit);
     SgElaboratedTypeModifier::visitRepresentativeNode(visit);
     SgBaseClassModifier::visitRepresentativeNode(visit);
     SgDeclarationModifier::visitRepresentativeNode(visit);
     Sg_File_Info::visitRepresentativeNode(visit);
     SgFile::visitRepresentativeNode(visit);
     SgFileList::visitRepresentativeNode(visit);
     SgDirectory::visitRepresentativeNode(visit);
     SgDirectoryList::visitRepresentativeNode(visit);
     SgProject::visitRepresentativeNode(visit);
     SgOptions::visitRepresentativeNode(visit);
     SgUnparse_Info::visitRepresentativeNode(visit);
     SgFuncDecl_attr::visitRepresentativeNode(visit);
     SgClassDecl_attr::visitRepresentativeNode(visit);
     SgTypedefSeq::visitRepresentativeNode(visit);
     SgFunctionParameterTypeList::visitRepresentativeNode(visit);
     SgTemplateParameter::visitRepresentativeNode(visit);
     SgTemplateArgument::visitRepresentativeNode(visit);
     SgTemplateParameterList::visitRepresentativeNode(visit);
     SgTemplateArgumentList::visitRepresentativeNode(visit);
     SgBaseClass::visitRepresentativeNode(visit);
     SgDirectedGraph::visitRepresentativeNode(visit);
     SgDirectedGraphNode::visitRepresentativeNode(visit);
     SgDirectedGraphEdge::visitRepresentativeNode(visit);
     SgQualifiedName::visitRepresentativeNode(visit);
     SgTypeUnknown::visitRepresentativeNode(visit);
     SgTypeChar::visitRepresentativeNode(visit);
     SgTypeSignedChar::visitRepresentativeNode(visit);
     SgTypeUnsignedChar::visitRepresentativeNode(visit);
     SgTypeShort::visitRepresentativeNode(visit);
     SgTypeSignedShort::visitRepresentativeNode(visit);
     SgTypeUnsignedShort::visitRepresentativeNode(visit);
     SgTypeInt::visitRepresentativeNode(visit);
     SgTypeSignedInt::visitRepresentativeNode(visit);
     SgTypeUnsignedInt::visitRepresentativeNode(visit);
     SgTypeLong::visitRepresentativeNode(visit);
     SgTypeSignedLong::visitRepresentativeNode(visit);
     SgTypeUnsignedLong::visitRepresentativeNode(visit);
     SgTypeVoid::visitRepresentativeNode(visit);
     SgTypeGlobalVoid::visitRepresentativeNode(visit);
     SgTypeWchar::visitRepresentativeNode(visit);
     SgTypeFloat::visitRepresentativeNode(visit);
     SgTypeDouble::visitRepresentativeNode(visit);
     SgTypeLongLong::visitRepresentativeNode(visit);
     SgTypeUnsignedLongLong::visitRepresentativeNode(visit);
     SgTypeLongDouble::visitRepresentativeNode(visit);
     SgTypeString::visitRepresentativeNode(visit);
     SgTypeBool::visitRepresentativeNode(visit);
     SgTypeComplex::visitRepresentativeNode(visit);
     SgTypeImaginary::visitRepresentativeNode(visit);
     SgTypeDefault::visitRepresentativeNode(visit);
     SgPointerMemberType::visitRepresentativeNode(visit);
     SgReferenceType::visitRepresentativeNode(visit);
     SgClassType::visitRepresentativeNode(visit);
     SgTemplateType::visitRepresentativeNode(visit);
     SgEnumType::visitRepresentativeNode(visit);
     SgTypedefType::visitRepresentativeNode(visit);
     SgModifierType::visitRepresentativeNode(visit);
     SgPartialFunctionModifierType::visitRepresentativeNode(visit);
     SgArrayType::visitRepresentativeNode(visit);
     SgTypeEllipse::visitRepresentativeNode(visit);
     SgUnknownMemberFunctionType::visitRepresentativeNode(visit);
     SgQualifiedNameType::visitRepresentativeNode(visit);
     SgExprListExp::visitRepresentativeNode(visit);
     SgVarRefExp::visitRepresentativeNode(visit);
     SgClassNameRefExp::visitRepresentativeNode(visit);
     SgFunctionRefExp::visitRepresentativeNode(visit);
     SgMemberFunctionRefExp::visitRepresentativeNode(visit);
     SgFunctionCallExp::visitRepresentativeNode(visit);
     SgSizeOfOp::visitRepresentativeNode(visit);
     SgVarArgStartOp::visitRepresentativeNode(visit);
     SgVarArgStartOneOperandOp::visitRepresentativeNode(visit);
     SgVarArgOp::visitRepresentativeNode(visit);
     SgVarArgEndOp::visitRepresentativeNode(visit);
     SgVarArgCopyOp::visitRepresentativeNode(visit);
     SgTypeIdOp::visitRepresentativeNode(visit);
     SgConditionalExp::visitRepresentativeNode(visit);
     SgNewExp::visitRepresentativeNode(visit);
     SgDeleteExp::visitRepresentativeNode(visit);
     SgThisExp::visitRepresentativeNode(visit);
     SgRefExp::visitRepresentativeNode(visit);
     SgAggregateInitializer::visitRepresentativeNode(visit);
     SgConstructorInitializer::visitRepresentativeNode(visit);
     SgAssignInitializer::visitRepresentativeNode(visit);
     SgExpressionRoot::visitRepresentativeNode(visit);
     SgMinusOp::visitRepresentativeNode(visit);
     SgUnaryAddOp::visitRepresentativeNode(visit);
     SgNotOp::visitRepresentativeNode(visit);
     SgPointerDerefExp::visitRepresentativeNode(visit);
     SgAddressOfOp::visitRepresentativeNode(visit);
     SgMinusMinusOp::visitRepresentativeNode(visit);
     SgPlusPlusOp::visitRepresentativeNode(visit);
     SgBitComplementOp::visitRepresentativeNode(visit);
     SgCastExp::visitRepresentativeNode(visit);
     SgThrowOp::visitRepresentativeNode(visit);
     SgArrowExp::visitRepresentativeNode(visit);
     SgDotExp::visitRepresentativeNode(visit);
     SgDotStarOp::visitRepresentativeNode(visit);
     SgArrowStarOp::visitRepresentativeNode(visit);
     SgEqualityOp::visitRepresentativeNode(visit);
     SgLessThanOp::visitRepresentativeNode(visit);
     SgGreaterThanOp::visitRepresentativeNode(visit);
     SgNotEqualOp::visitRepresentativeNode(visit);
     SgLessOrEqualOp::visitRepresentativeNode(visit);
     SgGreaterOrEqualOp::visitRepresentativeNode(visit);
     SgAddOp::visitRepresentativeNode(visit);
     SgSubtractOp::visitRepresentativeNode(visit);
     SgMultiplyOp::visitRepresentativeNode(visit);
     SgDivideOp::visitRepresentativeNode(visit);
     SgIntegerDivideOp::visitRepresentativeNode(visit);
     SgModOp::visitRepresentativeNode(visit);
     SgAndOp::visitRepresentativeNode(visit);
     SgOrOp::visitRepresentativeNode(visit);
     SgBitXorOp::visitRepresentativeNode(visit);
     SgBitAndOp::visitRepresentativeNode(visit);
     SgBitOrOp::visitRepresentativeNode(visit);
     SgCommaOpExp::visitRepresentativeNode(visit);
     SgLshiftOp::visitRepresentativeNode(visit);
     SgRshiftOp::visitRepresentativeNode(visit);
     SgPntrArrRefExp::visitRepresentativeNode(visit);
     SgScopeOp::visitRepresentativeNode(visit);
     SgAssignOp::visitRepresentativeNode(visit);
     SgPlusAssignOp::visitRepresentativeNode(visit);
     SgMinusAssignOp::visitRepresentativeNode(visit);
     SgAndAssignOp::visitRepresentativeNode(visit);
     SgIorAssignOp::visitRepresentativeNode(visit);
     SgMultAssignOp::visitRepresentativeNode(visit);
     SgDivAssignOp::visitRepresentativeNode(visit);
     SgModAssignOp::visitRepresentativeNode(visit);
     SgXorAssignOp::visitRepresentativeNode(visit);
     SgLshiftAssignOp::visitRepresentativeNode(visit);
     SgRshiftAssignOp::visitRepresentativeNode(visit);
     SgBoolValExp::visitRepresentativeNode(visit);
     SgStringVal::visitRepresentativeNode(visit);
     SgShortVal::visitRepresentativeNode(visit);
     SgCharVal::visitRepresentativeNode(visit);
     SgUnsignedCharVal::visitRepresentativeNode(visit);
     SgWcharVal::visitRepresentativeNode(visit);
     SgUnsignedShortVal::visitRepresentativeNode(visit);
     SgIntVal::visitRepresentativeNode(visit);
     SgEnumVal::visitRepresentativeNode(visit);
     SgUnsignedIntVal::visitRepresentativeNode(visit);
     SgLongIntVal::visitRepresentativeNode(visit);
     SgLongLongIntVal::visitRepresentativeNode(visit);
     SgUnsignedLongLongIntVal::visitRepresentativeNode(visit);
     SgUnsignedLongVal::visitRepresentativeNode(visit);
     SgFloatVal::visitRepresentativeNode(visit);
     SgDoubleVal::visitRepresentativeNode(visit);
     SgLongDoubleVal::visitRepresentativeNode(visit);
     SgComplexVal::visitRepresentativeNode(visit);
     SgNullExpression::visitRepresentativeNode(visit);
     SgVariantExpression::visitRepresentativeNode(visit);
     SgStatementExpression::visitRepresentativeNode(visit);
     SgAsmOp::visitRepresentativeNode(visit);
     SgIntrinsicFn::visitRepresentativeNode(visit);
     SgSubscriptExpression::visitRepresentativeNode(visit);
     SgSubscriptColon::visitRepresentativeNode(visit);
     SgColon::visitRepresentativeNode(visit);
     SgSubscriptAsterisk::visitRepresentativeNode(visit);
     SgUseOnlyExpression::visitRepresentativeNode(visit);
     SgUseRenameExpression::visitRepresentativeNode(visit);
     SgIOItemExpression::visitRepresentativeNode(visit);
     SgIOImpliedDo::visitRepresentativeNode(visit);
     SgExponentiationOp::visitRepresentativeNode(visit);
     SgForStatement::visitRepresentativeNode(visit);
     SgForInitStatement::visitRepresentativeNode(visit);
     SgCatchStatementSeq::visitRepresentativeNode(visit);
     SgFunctionParameterList::visitRepresentativeNode(visit);
     SgCtorInitializerList::visitRepresentativeNode(visit);
     SgBasicBlock::visitRepresentativeNode(visit);
     SgGlobal::visitRepresentativeNode(visit);
     SgIfStmt::visitRepresentativeNode(visit);
     SgFunctionDefinition::visitRepresentativeNode(visit);
     SgWhileStmt::visitRepresentativeNode(visit);
     SgDoWhileStmt::visitRepresentativeNode(visit);
     SgSwitchStatement::visitRepresentativeNode(visit);
     SgCatchOptionStmt::visitRepresentativeNode(visit);
     SgVariableDeclaration::visitRepresentativeNode(visit);
     SgVariableDefinition::visitRepresentativeNode(visit);
     SgEnumDeclaration::visitRepresentativeNode(visit);
     SgAsmStmt::visitRepresentativeNode(visit);
     SgTypedefDeclaration::visitRepresentativeNode(visit);
     SgFunctionTypeTable::visitRepresentativeNode(visit);
     SgExprStatement::visitRepresentativeNode(visit);
     SgLabelStatement::visitRepresentativeNode(visit);
     SgCaseOptionStmt::visitRepresentativeNode(visit);
     SgTryStmt::visitRepresentativeNode(visit);
     SgDefaultOptionStmt::visitRepresentativeNode(visit);
     SgBreakStmt::visitRepresentativeNode(visit);
     SgContinueStmt::visitRepresentativeNode(visit);
     SgReturnStmt::visitRepresentativeNode(visit);
     SgGotoStatement::visitRepresentativeNode(visit);
     SgSpawnStmt::visitRepresentativeNode(visit);
     SgNullStatement::visitRepresentativeNode(visit);
     SgVariantStatement::visitRepresentativeNode(visit);
     SgPragmaDeclaration::visitRepresentativeNode(visit);
     SgTemplateDeclaration::visitRepresentativeNode(visit);
     SgTemplateInstantiationDecl::visitRepresentativeNode(visit);
     SgTemplateInstantiationDefn::visitRepresentativeNode(visit);
     SgTemplateInstantiationFunctionDecl::visitRepresentativeNode(visit);
     SgTemplateInstantiationMemberFunctionDecl::visitRepresentativeNode(visit);
     SgProgramHeaderStatement::visitRepresentativeNode(visit);
     SgProcedureHeaderStatement::visitRepresentativeNode(visit);
     SgFortranNonblockedDo::visitRepresentativeNode(visit);
     SgInterfaceStatement::visitRepresentativeNode(visit);
     SgParameterStatement::visitRepresentativeNode(visit);
     SgCommonBlock::visitRepresentativeNode(visit);
     SgModuleStatement::visitRepresentativeNode(visit);
     SgUseStatement::visitRepresentativeNode(visit);
     SgStopOrPauseStatement::visitRepresentativeNode(visit);
     SgIOStatement::visitRepresentativeNode(visit);
     SgInputOutputStatement::visitRepresentativeNode(visit);
     SgOpenStatement::visitRepresentativeNode(visit);
     SgCloseStatement::visitRepresentativeNode(visit);
     SgInquireStatement::visitRepresentativeNode(visit);
     SgIOFileControlStmt::visitRepresentativeNode(visit);
     SgBlockDataStatement::visitRepresentativeNode(visit);
     SgImplicitStatement::visitRepresentativeNode(visit);
     SgStatementFunctionStatement::visitRepresentativeNode(visit);
     SgWhereStatement::visitRepresentativeNode(visit);
     SgNullifyStatement::visitRepresentativeNode(visit);
     SgEquivalenceStatement::visitRepresentativeNode(visit);
     SgDerivedTypeStatement::visitRepresentativeNode(visit);
     SgAttributeSpecificationStatement::visitRepresentativeNode(visit);
     SgAllocateStatement::visitRepresentativeNode(visit);
     SgDeallocateStatement::visitRepresentativeNode(visit);
     SgContainsStatement::visitRepresentativeNode(visit);
     SgSequenceStatement::visitRepresentativeNode(visit);
     SgElseWhereStatement::visitRepresentativeNode(visit);
     SgArithmeticIfStatement::visitRepresentativeNode(visit);
     SgAssignStatement::visitRepresentativeNode(visit);
     SgComputedGotoStatement::visitRepresentativeNode(visit);
     SgAssignedGotoStatement::visitRepresentativeNode(visit);
     SgNamespaceDeclarationStatement::visitRepresentativeNode(visit);
     SgNamespaceAliasDeclarationStatement::visitRepresentativeNode(visit);
     SgNamespaceDefinitionStatement::visitRepresentativeNode(visit);
     SgUsingDeclarationStatement::visitRepresentativeNode(visit);
     SgUsingDirectiveStatement::visitRepresentativeNode(visit);
     SgTemplateInstantiationDirectiveStatement::visitRepresentativeNode(visit);
     SgIncludeDirectiveStatement::visitRepresentativeNode(visit);
     SgDefineDirectiveStatement::visitRepresentativeNode(visit);
     SgUndefDirectiveStatement::visitRepresentativeNode(visit);
     SgIfdefDirectiveStatement::visitRepresentativeNode(visit);
     SgIfndefDirectiveStatement::visitRepresentativeNode(visit);
     SgIfDirectiveStatement::visitRepresentativeNode(visit);
     SgDeadIfDirectiveStatement::visitRepresentativeNode(visit);
     SgElseDirectiveStatement::visitRepresentativeNode(visit);
     SgElseifDirectiveStatement::visitRepresentativeNode(visit);
     SgEndifDirectiveStatement::visitRepresentativeNode(visit);
     SgLineDirectiveStatement::visitRepresentativeNode(visit);
     SgWarningDirectiveStatement::visitRepresentativeNode(visit);
     SgErrorDirectiveStatement::visitRepresentativeNode(visit);
     SgEmptyDirectiveStatement::visitRepresentativeNode(visit);
     SgClinkageStartStatement::visitRepresentativeNode(visit);
     SgClinkageEndStatement::visitRepresentativeNode(visit);
     SgVariableSymbol::visitRepresentativeNode(visit);
     SgFunctionTypeSymbol::visitRepresentativeNode(visit);
     SgClassSymbol::visitRepresentativeNode(visit);
     SgTemplateSymbol::visitRepresentativeNode(visit);
     SgEnumSymbol::visitRepresentativeNode(visit);
     SgEnumFieldSymbol::visitRepresentativeNode(visit);
     SgTypedefSymbol::visitRepresentativeNode(visit);
     SgMemberFunctionSymbol::visitRepresentativeNode(visit);
     SgLabelSymbol::visitRepresentativeNode(visit);
     SgDefaultSymbol::visitRepresentativeNode(visit);
     SgNamespaceSymbol::visitRepresentativeNode(visit);
     SgIntrinsicSymbol::visitRepresentativeNode(visit);
     SgModuleSymbol::visitRepresentativeNode(visit);
     SgInterfaceSymbol::visitRepresentativeNode(visit);
     SgCommonSymbol::visitRepresentativeNode(visit);
     SgToken::visitRepresentativeNode(visit);
   }



int memoryUsage ()
   {
     int count = 0; 

     count += SgModifier::memoryUsage();
     count += SgBitAttribute::memoryUsage();
     count += SgAttribute::memoryUsage();
     count += SgGraphNode::memoryUsage();
     count += SgGraphEdge::memoryUsage();
     count += SgGraph::memoryUsage();
     count += SgSupport::memoryUsage();
     count += SgPartialFunctionType::memoryUsage();
     count += SgMemberFunctionType::memoryUsage();
     count += SgFunctionType::memoryUsage();
     count += SgPointerType::memoryUsage();
     count += SgNamedType::memoryUsage();
     count += SgType::memoryUsage();
     count += SgInitializer::memoryUsage();
     count += SgUnaryOp::memoryUsage();
     count += SgBinaryOp::memoryUsage();
     count += SgValueExp::memoryUsage();
     count += SgExpression::memoryUsage();
     count += SgFortranDo::memoryUsage();
     count += SgIOControlStatement::memoryUsage();
     count += SgClassDeclaration::memoryUsage();
     count += SgClassDefinition::memoryUsage();
     count += SgScopeStatement::memoryUsage();
     count += SgMemberFunctionDeclaration::memoryUsage();
     count += SgFunctionDeclaration::memoryUsage();
     count += SgC_PreprocessorDirectiveStatement::memoryUsage();
     count += SgClinkageDeclarationStatement::memoryUsage();
     count += SgDeclarationStatement::memoryUsage();
     count += SgStatement::memoryUsage();
     count += SgFunctionSymbol::memoryUsage();
     count += SgSymbol::memoryUsage();
     count += SgLocatedNode::memoryUsage();
     count += SgNode::memoryUsage();
     count += SgSymbolTable::memoryUsage();
     count += SgInitializedName::memoryUsage();
     count += SgName::memoryUsage();
     count += SgPragma::memoryUsage();
     count += SgModifierNodes::memoryUsage();
     count += SgConstVolatileModifier::memoryUsage();
     count += SgStorageModifier::memoryUsage();
     count += SgAccessModifier::memoryUsage();
     count += SgFunctionModifier::memoryUsage();
     count += SgUPC_AccessModifier::memoryUsage();
     count += SgLinkageModifier::memoryUsage();
     count += SgSpecialFunctionModifier::memoryUsage();
     count += SgTypeModifier::memoryUsage();
     count += SgElaboratedTypeModifier::memoryUsage();
     count += SgBaseClassModifier::memoryUsage();
     count += SgDeclarationModifier::memoryUsage();
     count += Sg_File_Info::memoryUsage();
     count += SgFile::memoryUsage();
     count += SgFileList::memoryUsage();
     count += SgDirectory::memoryUsage();
     count += SgDirectoryList::memoryUsage();
     count += SgProject::memoryUsage();
     count += SgOptions::memoryUsage();
     count += SgUnparse_Info::memoryUsage();
     count += SgFuncDecl_attr::memoryUsage();
     count += SgClassDecl_attr::memoryUsage();
     count += SgTypedefSeq::memoryUsage();
     count += SgFunctionParameterTypeList::memoryUsage();
     count += SgTemplateParameter::memoryUsage();
     count += SgTemplateArgument::memoryUsage();
     count += SgTemplateParameterList::memoryUsage();
     count += SgTemplateArgumentList::memoryUsage();
     count += SgBaseClass::memoryUsage();
     count += SgDirectedGraph::memoryUsage();
     count += SgDirectedGraphNode::memoryUsage();
     count += SgDirectedGraphEdge::memoryUsage();
     count += SgQualifiedName::memoryUsage();
     count += SgTypeUnknown::memoryUsage();
     count += SgTypeChar::memoryUsage();
     count += SgTypeSignedChar::memoryUsage();
     count += SgTypeUnsignedChar::memoryUsage();
     count += SgTypeShort::memoryUsage();
     count += SgTypeSignedShort::memoryUsage();
     count += SgTypeUnsignedShort::memoryUsage();
     count += SgTypeInt::memoryUsage();
     count += SgTypeSignedInt::memoryUsage();
     count += SgTypeUnsignedInt::memoryUsage();
     count += SgTypeLong::memoryUsage();
     count += SgTypeSignedLong::memoryUsage();
     count += SgTypeUnsignedLong::memoryUsage();
     count += SgTypeVoid::memoryUsage();
     count += SgTypeGlobalVoid::memoryUsage();
     count += SgTypeWchar::memoryUsage();
     count += SgTypeFloat::memoryUsage();
     count += SgTypeDouble::memoryUsage();
     count += SgTypeLongLong::memoryUsage();
     count += SgTypeUnsignedLongLong::memoryUsage();
     count += SgTypeLongDouble::memoryUsage();
     count += SgTypeString::memoryUsage();
     count += SgTypeBool::memoryUsage();
     count += SgTypeComplex::memoryUsage();
     count += SgTypeImaginary::memoryUsage();
     count += SgTypeDefault::memoryUsage();
     count += SgPointerMemberType::memoryUsage();
     count += SgReferenceType::memoryUsage();
     count += SgClassType::memoryUsage();
     count += SgTemplateType::memoryUsage();
     count += SgEnumType::memoryUsage();
     count += SgTypedefType::memoryUsage();
     count += SgModifierType::memoryUsage();
     count += SgPartialFunctionModifierType::memoryUsage();
     count += SgArrayType::memoryUsage();
     count += SgTypeEllipse::memoryUsage();
     count += SgUnknownMemberFunctionType::memoryUsage();
     count += SgQualifiedNameType::memoryUsage();
     count += SgExprListExp::memoryUsage();
     count += SgVarRefExp::memoryUsage();
     count += SgClassNameRefExp::memoryUsage();
     count += SgFunctionRefExp::memoryUsage();
     count += SgMemberFunctionRefExp::memoryUsage();
     count += SgFunctionCallExp::memoryUsage();
     count += SgSizeOfOp::memoryUsage();
     count += SgVarArgStartOp::memoryUsage();
     count += SgVarArgStartOneOperandOp::memoryUsage();
     count += SgVarArgOp::memoryUsage();
     count += SgVarArgEndOp::memoryUsage();
     count += SgVarArgCopyOp::memoryUsage();
     count += SgTypeIdOp::memoryUsage();
     count += SgConditionalExp::memoryUsage();
     count += SgNewExp::memoryUsage();
     count += SgDeleteExp::memoryUsage();
     count += SgThisExp::memoryUsage();
     count += SgRefExp::memoryUsage();
     count += SgAggregateInitializer::memoryUsage();
     count += SgConstructorInitializer::memoryUsage();
     count += SgAssignInitializer::memoryUsage();
     count += SgExpressionRoot::memoryUsage();
     count += SgMinusOp::memoryUsage();
     count += SgUnaryAddOp::memoryUsage();
     count += SgNotOp::memoryUsage();
     count += SgPointerDerefExp::memoryUsage();
     count += SgAddressOfOp::memoryUsage();
     count += SgMinusMinusOp::memoryUsage();
     count += SgPlusPlusOp::memoryUsage();
     count += SgBitComplementOp::memoryUsage();
     count += SgCastExp::memoryUsage();
     count += SgThrowOp::memoryUsage();
     count += SgArrowExp::memoryUsage();
     count += SgDotExp::memoryUsage();
     count += SgDotStarOp::memoryUsage();
     count += SgArrowStarOp::memoryUsage();
     count += SgEqualityOp::memoryUsage();
     count += SgLessThanOp::memoryUsage();
     count += SgGreaterThanOp::memoryUsage();
     count += SgNotEqualOp::memoryUsage();
     count += SgLessOrEqualOp::memoryUsage();
     count += SgGreaterOrEqualOp::memoryUsage();
     count += SgAddOp::memoryUsage();
     count += SgSubtractOp::memoryUsage();
     count += SgMultiplyOp::memoryUsage();
     count += SgDivideOp::memoryUsage();
     count += SgIntegerDivideOp::memoryUsage();
     count += SgModOp::memoryUsage();
     count += SgAndOp::memoryUsage();
     count += SgOrOp::memoryUsage();
     count += SgBitXorOp::memoryUsage();
     count += SgBitAndOp::memoryUsage();
     count += SgBitOrOp::memoryUsage();
     count += SgCommaOpExp::memoryUsage();
     count += SgLshiftOp::memoryUsage();
     count += SgRshiftOp::memoryUsage();
     count += SgPntrArrRefExp::memoryUsage();
     count += SgScopeOp::memoryUsage();
     count += SgAssignOp::memoryUsage();
     count += SgPlusAssignOp::memoryUsage();
     count += SgMinusAssignOp::memoryUsage();
     count += SgAndAssignOp::memoryUsage();
     count += SgIorAssignOp::memoryUsage();
     count += SgMultAssignOp::memoryUsage();
     count += SgDivAssignOp::memoryUsage();
     count += SgModAssignOp::memoryUsage();
     count += SgXorAssignOp::memoryUsage();
     count += SgLshiftAssignOp::memoryUsage();
     count += SgRshiftAssignOp::memoryUsage();
     count += SgBoolValExp::memoryUsage();
     count += SgStringVal::memoryUsage();
     count += SgShortVal::memoryUsage();
     count += SgCharVal::memoryUsage();
     count += SgUnsignedCharVal::memoryUsage();
     count += SgWcharVal::memoryUsage();
     count += SgUnsignedShortVal::memoryUsage();
     count += SgIntVal::memoryUsage();
     count += SgEnumVal::memoryUsage();
     count += SgUnsignedIntVal::memoryUsage();
     count += SgLongIntVal::memoryUsage();
     count += SgLongLongIntVal::memoryUsage();
     count += SgUnsignedLongLongIntVal::memoryUsage();
     count += SgUnsignedLongVal::memoryUsage();
     count += SgFloatVal::memoryUsage();
     count += SgDoubleVal::memoryUsage();
     count += SgLongDoubleVal::memoryUsage();
     count += SgComplexVal::memoryUsage();
     count += SgNullExpression::memoryUsage();
     count += SgVariantExpression::memoryUsage();
     count += SgStatementExpression::memoryUsage();
     count += SgAsmOp::memoryUsage();
     count += SgIntrinsicFn::memoryUsage();
     count += SgSubscriptExpression::memoryUsage();
     count += SgSubscriptColon::memoryUsage();
     count += SgColon::memoryUsage();
     count += SgSubscriptAsterisk::memoryUsage();
     count += SgUseOnlyExpression::memoryUsage();
     count += SgUseRenameExpression::memoryUsage();
     count += SgIOItemExpression::memoryUsage();
     count += SgIOImpliedDo::memoryUsage();
     count += SgExponentiationOp::memoryUsage();
     count += SgForStatement::memoryUsage();
     count += SgForInitStatement::memoryUsage();
     count += SgCatchStatementSeq::memoryUsage();
     count += SgFunctionParameterList::memoryUsage();
     count += SgCtorInitializerList::memoryUsage();
     count += SgBasicBlock::memoryUsage();
     count += SgGlobal::memoryUsage();
     count += SgIfStmt::memoryUsage();
     count += SgFunctionDefinition::memoryUsage();
     count += SgWhileStmt::memoryUsage();
     count += SgDoWhileStmt::memoryUsage();
     count += SgSwitchStatement::memoryUsage();
     count += SgCatchOptionStmt::memoryUsage();
     count += SgVariableDeclaration::memoryUsage();
     count += SgVariableDefinition::memoryUsage();
     count += SgEnumDeclaration::memoryUsage();
     count += SgAsmStmt::memoryUsage();
     count += SgTypedefDeclaration::memoryUsage();
     count += SgFunctionTypeTable::memoryUsage();
     count += SgExprStatement::memoryUsage();
     count += SgLabelStatement::memoryUsage();
     count += SgCaseOptionStmt::memoryUsage();
     count += SgTryStmt::memoryUsage();
     count += SgDefaultOptionStmt::memoryUsage();
     count += SgBreakStmt::memoryUsage();
     count += SgContinueStmt::memoryUsage();
     count += SgReturnStmt::memoryUsage();
     count += SgGotoStatement::memoryUsage();
     count += SgSpawnStmt::memoryUsage();
     count += SgNullStatement::memoryUsage();
     count += SgVariantStatement::memoryUsage();
     count += SgPragmaDeclaration::memoryUsage();
     count += SgTemplateDeclaration::memoryUsage();
     count += SgTemplateInstantiationDecl::memoryUsage();
     count += SgTemplateInstantiationDefn::memoryUsage();
     count += SgTemplateInstantiationFunctionDecl::memoryUsage();
     count += SgTemplateInstantiationMemberFunctionDecl::memoryUsage();
     count += SgProgramHeaderStatement::memoryUsage();
     count += SgProcedureHeaderStatement::memoryUsage();
     count += SgFortranNonblockedDo::memoryUsage();
     count += SgInterfaceStatement::memoryUsage();
     count += SgParameterStatement::memoryUsage();
     count += SgCommonBlock::memoryUsage();
     count += SgModuleStatement::memoryUsage();
     count += SgUseStatement::memoryUsage();
     count += SgStopOrPauseStatement::memoryUsage();
     count += SgIOStatement::memoryUsage();
     count += SgInputOutputStatement::memoryUsage();
     count += SgOpenStatement::memoryUsage();
     count += SgCloseStatement::memoryUsage();
     count += SgInquireStatement::memoryUsage();
     count += SgIOFileControlStmt::memoryUsage();
     count += SgBlockDataStatement::memoryUsage();
     count += SgImplicitStatement::memoryUsage();
     count += SgStatementFunctionStatement::memoryUsage();
     count += SgWhereStatement::memoryUsage();
     count += SgNullifyStatement::memoryUsage();
     count += SgEquivalenceStatement::memoryUsage();
     count += SgDerivedTypeStatement::memoryUsage();
     count += SgAttributeSpecificationStatement::memoryUsage();
     count += SgAllocateStatement::memoryUsage();
     count += SgDeallocateStatement::memoryUsage();
     count += SgContainsStatement::memoryUsage();
     count += SgSequenceStatement::memoryUsage();
     count += SgElseWhereStatement::memoryUsage();
     count += SgArithmeticIfStatement::memoryUsage();
     count += SgAssignStatement::memoryUsage();
     count += SgComputedGotoStatement::memoryUsage();
     count += SgAssignedGotoStatement::memoryUsage();
     count += SgNamespaceDeclarationStatement::memoryUsage();
     count += SgNamespaceAliasDeclarationStatement::memoryUsage();
     count += SgNamespaceDefinitionStatement::memoryUsage();
     count += SgUsingDeclarationStatement::memoryUsage();
     count += SgUsingDirectiveStatement::memoryUsage();
     count += SgTemplateInstantiationDirectiveStatement::memoryUsage();
     count += SgIncludeDirectiveStatement::memoryUsage();
     count += SgDefineDirectiveStatement::memoryUsage();
     count += SgUndefDirectiveStatement::memoryUsage();
     count += SgIfdefDirectiveStatement::memoryUsage();
     count += SgIfndefDirectiveStatement::memoryUsage();
     count += SgIfDirectiveStatement::memoryUsage();
     count += SgDeadIfDirectiveStatement::memoryUsage();
     count += SgElseDirectiveStatement::memoryUsage();
     count += SgElseifDirectiveStatement::memoryUsage();
     count += SgEndifDirectiveStatement::memoryUsage();
     count += SgLineDirectiveStatement::memoryUsage();
     count += SgWarningDirectiveStatement::memoryUsage();
     count += SgErrorDirectiveStatement::memoryUsage();
     count += SgEmptyDirectiveStatement::memoryUsage();
     count += SgClinkageStartStatement::memoryUsage();
     count += SgClinkageEndStatement::memoryUsage();
     count += SgVariableSymbol::memoryUsage();
     count += SgFunctionTypeSymbol::memoryUsage();
     count += SgClassSymbol::memoryUsage();
     count += SgTemplateSymbol::memoryUsage();
     count += SgEnumSymbol::memoryUsage();
     count += SgEnumFieldSymbol::memoryUsage();
     count += SgTypedefSymbol::memoryUsage();
     count += SgMemberFunctionSymbol::memoryUsage();
     count += SgLabelSymbol::memoryUsage();
     count += SgDefaultSymbol::memoryUsage();
     count += SgNamespaceSymbol::memoryUsage();
     count += SgIntrinsicSymbol::memoryUsage();
     count += SgModuleSymbol::memoryUsage();
     count += SgInterfaceSymbol::memoryUsage();
     count += SgCommonSymbol::memoryUsage();
     count += SgToken::memoryUsage();


     return count;
   }


int numberOfNodes ()
   {
     int count = 0; 

     count += SgModifier::numberOfNodes();
     count += SgBitAttribute::numberOfNodes();
     count += SgAttribute::numberOfNodes();
     count += SgGraphNode::numberOfNodes();
     count += SgGraphEdge::numberOfNodes();
     count += SgGraph::numberOfNodes();
     count += SgSupport::numberOfNodes();
     count += SgPartialFunctionType::numberOfNodes();
     count += SgMemberFunctionType::numberOfNodes();
     count += SgFunctionType::numberOfNodes();
     count += SgPointerType::numberOfNodes();
     count += SgNamedType::numberOfNodes();
     count += SgType::numberOfNodes();
     count += SgInitializer::numberOfNodes();
     count += SgUnaryOp::numberOfNodes();
     count += SgBinaryOp::numberOfNodes();
     count += SgValueExp::numberOfNodes();
     count += SgExpression::numberOfNodes();
     count += SgFortranDo::numberOfNodes();
     count += SgIOControlStatement::numberOfNodes();
     count += SgClassDeclaration::numberOfNodes();
     count += SgClassDefinition::numberOfNodes();
     count += SgScopeStatement::numberOfNodes();
     count += SgMemberFunctionDeclaration::numberOfNodes();
     count += SgFunctionDeclaration::numberOfNodes();
     count += SgC_PreprocessorDirectiveStatement::numberOfNodes();
     count += SgClinkageDeclarationStatement::numberOfNodes();
     count += SgDeclarationStatement::numberOfNodes();
     count += SgStatement::numberOfNodes();
     count += SgFunctionSymbol::numberOfNodes();
     count += SgSymbol::numberOfNodes();
     count += SgLocatedNode::numberOfNodes();
     count += SgNode::numberOfNodes();
     count += SgSymbolTable::numberOfNodes();
     count += SgInitializedName::numberOfNodes();
     count += SgName::numberOfNodes();
     count += SgPragma::numberOfNodes();
     count += SgModifierNodes::numberOfNodes();
     count += SgConstVolatileModifier::numberOfNodes();
     count += SgStorageModifier::numberOfNodes();
     count += SgAccessModifier::numberOfNodes();
     count += SgFunctionModifier::numberOfNodes();
     count += SgUPC_AccessModifier::numberOfNodes();
     count += SgLinkageModifier::numberOfNodes();
     count += SgSpecialFunctionModifier::numberOfNodes();
     count += SgTypeModifier::numberOfNodes();
     count += SgElaboratedTypeModifier::numberOfNodes();
     count += SgBaseClassModifier::numberOfNodes();
     count += SgDeclarationModifier::numberOfNodes();
     count += Sg_File_Info::numberOfNodes();
     count += SgFile::numberOfNodes();
     count += SgFileList::numberOfNodes();
     count += SgDirectory::numberOfNodes();
     count += SgDirectoryList::numberOfNodes();
     count += SgProject::numberOfNodes();
     count += SgOptions::numberOfNodes();
     count += SgUnparse_Info::numberOfNodes();
     count += SgFuncDecl_attr::numberOfNodes();
     count += SgClassDecl_attr::numberOfNodes();
     count += SgTypedefSeq::numberOfNodes();
     count += SgFunctionParameterTypeList::numberOfNodes();
     count += SgTemplateParameter::numberOfNodes();
     count += SgTemplateArgument::numberOfNodes();
     count += SgTemplateParameterList::numberOfNodes();
     count += SgTemplateArgumentList::numberOfNodes();
     count += SgBaseClass::numberOfNodes();
     count += SgDirectedGraph::numberOfNodes();
     count += SgDirectedGraphNode::numberOfNodes();
     count += SgDirectedGraphEdge::numberOfNodes();
     count += SgQualifiedName::numberOfNodes();
     count += SgTypeUnknown::numberOfNodes();
     count += SgTypeChar::numberOfNodes();
     count += SgTypeSignedChar::numberOfNodes();
     count += SgTypeUnsignedChar::numberOfNodes();
     count += SgTypeShort::numberOfNodes();
     count += SgTypeSignedShort::numberOfNodes();
     count += SgTypeUnsignedShort::numberOfNodes();
     count += SgTypeInt::numberOfNodes();
     count += SgTypeSignedInt::numberOfNodes();
     count += SgTypeUnsignedInt::numberOfNodes();
     count += SgTypeLong::numberOfNodes();
     count += SgTypeSignedLong::numberOfNodes();
     count += SgTypeUnsignedLong::numberOfNodes();
     count += SgTypeVoid::numberOfNodes();
     count += SgTypeGlobalVoid::numberOfNodes();
     count += SgTypeWchar::numberOfNodes();
     count += SgTypeFloat::numberOfNodes();
     count += SgTypeDouble::numberOfNodes();
     count += SgTypeLongLong::numberOfNodes();
     count += SgTypeUnsignedLongLong::numberOfNodes();
     count += SgTypeLongDouble::numberOfNodes();
     count += SgTypeString::numberOfNodes();
     count += SgTypeBool::numberOfNodes();
     count += SgTypeComplex::numberOfNodes();
     count += SgTypeImaginary::numberOfNodes();
     count += SgTypeDefault::numberOfNodes();
     count += SgPointerMemberType::numberOfNodes();
     count += SgReferenceType::numberOfNodes();
     count += SgClassType::numberOfNodes();
     count += SgTemplateType::numberOfNodes();
     count += SgEnumType::numberOfNodes();
     count += SgTypedefType::numberOfNodes();
     count += SgModifierType::numberOfNodes();
     count += SgPartialFunctionModifierType::numberOfNodes();
     count += SgArrayType::numberOfNodes();
     count += SgTypeEllipse::numberOfNodes();
     count += SgUnknownMemberFunctionType::numberOfNodes();
     count += SgQualifiedNameType::numberOfNodes();
     count += SgExprListExp::numberOfNodes();
     count += SgVarRefExp::numberOfNodes();
     count += SgClassNameRefExp::numberOfNodes();
     count += SgFunctionRefExp::numberOfNodes();
     count += SgMemberFunctionRefExp::numberOfNodes();
     count += SgFunctionCallExp::numberOfNodes();
     count += SgSizeOfOp::numberOfNodes();
     count += SgVarArgStartOp::numberOfNodes();
     count += SgVarArgStartOneOperandOp::numberOfNodes();
     count += SgVarArgOp::numberOfNodes();
     count += SgVarArgEndOp::numberOfNodes();
     count += SgVarArgCopyOp::numberOfNodes();
     count += SgTypeIdOp::numberOfNodes();
     count += SgConditionalExp::numberOfNodes();
     count += SgNewExp::numberOfNodes();
     count += SgDeleteExp::numberOfNodes();
     count += SgThisExp::numberOfNodes();
     count += SgRefExp::numberOfNodes();
     count += SgAggregateInitializer::numberOfNodes();
     count += SgConstructorInitializer::numberOfNodes();
     count += SgAssignInitializer::numberOfNodes();
     count += SgExpressionRoot::numberOfNodes();
     count += SgMinusOp::numberOfNodes();
     count += SgUnaryAddOp::numberOfNodes();
     count += SgNotOp::numberOfNodes();
     count += SgPointerDerefExp::numberOfNodes();
     count += SgAddressOfOp::numberOfNodes();
     count += SgMinusMinusOp::numberOfNodes();
     count += SgPlusPlusOp::numberOfNodes();
     count += SgBitComplementOp::numberOfNodes();
     count += SgCastExp::numberOfNodes();
     count += SgThrowOp::numberOfNodes();
     count += SgArrowExp::numberOfNodes();
     count += SgDotExp::numberOfNodes();
     count += SgDotStarOp::numberOfNodes();
     count += SgArrowStarOp::numberOfNodes();
     count += SgEqualityOp::numberOfNodes();
     count += SgLessThanOp::numberOfNodes();
     count += SgGreaterThanOp::numberOfNodes();
     count += SgNotEqualOp::numberOfNodes();
     count += SgLessOrEqualOp::numberOfNodes();
     count += SgGreaterOrEqualOp::numberOfNodes();
     count += SgAddOp::numberOfNodes();
     count += SgSubtractOp::numberOfNodes();
     count += SgMultiplyOp::numberOfNodes();
     count += SgDivideOp::numberOfNodes();
     count += SgIntegerDivideOp::numberOfNodes();
     count += SgModOp::numberOfNodes();
     count += SgAndOp::numberOfNodes();
     count += SgOrOp::numberOfNodes();
     count += SgBitXorOp::numberOfNodes();
     count += SgBitAndOp::numberOfNodes();
     count += SgBitOrOp::numberOfNodes();
     count += SgCommaOpExp::numberOfNodes();
     count += SgLshiftOp::numberOfNodes();
     count += SgRshiftOp::numberOfNodes();
     count += SgPntrArrRefExp::numberOfNodes();
     count += SgScopeOp::numberOfNodes();
     count += SgAssignOp::numberOfNodes();
     count += SgPlusAssignOp::numberOfNodes();
     count += SgMinusAssignOp::numberOfNodes();
     count += SgAndAssignOp::numberOfNodes();
     count += SgIorAssignOp::numberOfNodes();
     count += SgMultAssignOp::numberOfNodes();
     count += SgDivAssignOp::numberOfNodes();
     count += SgModAssignOp::numberOfNodes();
     count += SgXorAssignOp::numberOfNodes();
     count += SgLshiftAssignOp::numberOfNodes();
     count += SgRshiftAssignOp::numberOfNodes();
     count += SgBoolValExp::numberOfNodes();
     count += SgStringVal::numberOfNodes();
     count += SgShortVal::numberOfNodes();
     count += SgCharVal::numberOfNodes();
     count += SgUnsignedCharVal::numberOfNodes();
     count += SgWcharVal::numberOfNodes();
     count += SgUnsignedShortVal::numberOfNodes();
     count += SgIntVal::numberOfNodes();
     count += SgEnumVal::numberOfNodes();
     count += SgUnsignedIntVal::numberOfNodes();
     count += SgLongIntVal::numberOfNodes();
     count += SgLongLongIntVal::numberOfNodes();
     count += SgUnsignedLongLongIntVal::numberOfNodes();
     count += SgUnsignedLongVal::numberOfNodes();
     count += SgFloatVal::numberOfNodes();
     count += SgDoubleVal::numberOfNodes();
     count += SgLongDoubleVal::numberOfNodes();
     count += SgComplexVal::numberOfNodes();
     count += SgNullExpression::numberOfNodes();
     count += SgVariantExpression::numberOfNodes();
     count += SgStatementExpression::numberOfNodes();
     count += SgAsmOp::numberOfNodes();
     count += SgIntrinsicFn::numberOfNodes();
     count += SgSubscriptExpression::numberOfNodes();
     count += SgSubscriptColon::numberOfNodes();
     count += SgColon::numberOfNodes();
     count += SgSubscriptAsterisk::numberOfNodes();
     count += SgUseOnlyExpression::numberOfNodes();
     count += SgUseRenameExpression::numberOfNodes();
     count += SgIOItemExpression::numberOfNodes();
     count += SgIOImpliedDo::numberOfNodes();
     count += SgExponentiationOp::numberOfNodes();
     count += SgForStatement::numberOfNodes();
     count += SgForInitStatement::numberOfNodes();
     count += SgCatchStatementSeq::numberOfNodes();
     count += SgFunctionParameterList::numberOfNodes();
     count += SgCtorInitializerList::numberOfNodes();
     count += SgBasicBlock::numberOfNodes();
     count += SgGlobal::numberOfNodes();
     count += SgIfStmt::numberOfNodes();
     count += SgFunctionDefinition::numberOfNodes();
     count += SgWhileStmt::numberOfNodes();
     count += SgDoWhileStmt::numberOfNodes();
     count += SgSwitchStatement::numberOfNodes();
     count += SgCatchOptionStmt::numberOfNodes();
     count += SgVariableDeclaration::numberOfNodes();
     count += SgVariableDefinition::numberOfNodes();
     count += SgEnumDeclaration::numberOfNodes();
     count += SgAsmStmt::numberOfNodes();
     count += SgTypedefDeclaration::numberOfNodes();
     count += SgFunctionTypeTable::numberOfNodes();
     count += SgExprStatement::numberOfNodes();
     count += SgLabelStatement::numberOfNodes();
     count += SgCaseOptionStmt::numberOfNodes();
     count += SgTryStmt::numberOfNodes();
     count += SgDefaultOptionStmt::numberOfNodes();
     count += SgBreakStmt::numberOfNodes();
     count += SgContinueStmt::numberOfNodes();
     count += SgReturnStmt::numberOfNodes();
     count += SgGotoStatement::numberOfNodes();
     count += SgSpawnStmt::numberOfNodes();
     count += SgNullStatement::numberOfNodes();
     count += SgVariantStatement::numberOfNodes();
     count += SgPragmaDeclaration::numberOfNodes();
     count += SgTemplateDeclaration::numberOfNodes();
     count += SgTemplateInstantiationDecl::numberOfNodes();
     count += SgTemplateInstantiationDefn::numberOfNodes();
     count += SgTemplateInstantiationFunctionDecl::numberOfNodes();
     count += SgTemplateInstantiationMemberFunctionDecl::numberOfNodes();
     count += SgProgramHeaderStatement::numberOfNodes();
     count += SgProcedureHeaderStatement::numberOfNodes();
     count += SgFortranNonblockedDo::numberOfNodes();
     count += SgInterfaceStatement::numberOfNodes();
     count += SgParameterStatement::numberOfNodes();
     count += SgCommonBlock::numberOfNodes();
     count += SgModuleStatement::numberOfNodes();
     count += SgUseStatement::numberOfNodes();
     count += SgStopOrPauseStatement::numberOfNodes();
     count += SgIOStatement::numberOfNodes();
     count += SgInputOutputStatement::numberOfNodes();
     count += SgOpenStatement::numberOfNodes();
     count += SgCloseStatement::numberOfNodes();
     count += SgInquireStatement::numberOfNodes();
     count += SgIOFileControlStmt::numberOfNodes();
     count += SgBlockDataStatement::numberOfNodes();
     count += SgImplicitStatement::numberOfNodes();
     count += SgStatementFunctionStatement::numberOfNodes();
     count += SgWhereStatement::numberOfNodes();
     count += SgNullifyStatement::numberOfNodes();
     count += SgEquivalenceStatement::numberOfNodes();
     count += SgDerivedTypeStatement::numberOfNodes();
     count += SgAttributeSpecificationStatement::numberOfNodes();
     count += SgAllocateStatement::numberOfNodes();
     count += SgDeallocateStatement::numberOfNodes();
     count += SgContainsStatement::numberOfNodes();
     count += SgSequenceStatement::numberOfNodes();
     count += SgElseWhereStatement::numberOfNodes();
     count += SgArithmeticIfStatement::numberOfNodes();
     count += SgAssignStatement::numberOfNodes();
     count += SgComputedGotoStatement::numberOfNodes();
     count += SgAssignedGotoStatement::numberOfNodes();
     count += SgNamespaceDeclarationStatement::numberOfNodes();
     count += SgNamespaceAliasDeclarationStatement::numberOfNodes();
     count += SgNamespaceDefinitionStatement::numberOfNodes();
     count += SgUsingDeclarationStatement::numberOfNodes();
     count += SgUsingDirectiveStatement::numberOfNodes();
     count += SgTemplateInstantiationDirectiveStatement::numberOfNodes();
     count += SgIncludeDirectiveStatement::numberOfNodes();
     count += SgDefineDirectiveStatement::numberOfNodes();
     count += SgUndefDirectiveStatement::numberOfNodes();
     count += SgIfdefDirectiveStatement::numberOfNodes();
     count += SgIfndefDirectiveStatement::numberOfNodes();
     count += SgIfDirectiveStatement::numberOfNodes();
     count += SgDeadIfDirectiveStatement::numberOfNodes();
     count += SgElseDirectiveStatement::numberOfNodes();
     count += SgElseifDirectiveStatement::numberOfNodes();
     count += SgEndifDirectiveStatement::numberOfNodes();
     count += SgLineDirectiveStatement::numberOfNodes();
     count += SgWarningDirectiveStatement::numberOfNodes();
     count += SgErrorDirectiveStatement::numberOfNodes();
     count += SgEmptyDirectiveStatement::numberOfNodes();
     count += SgClinkageStartStatement::numberOfNodes();
     count += SgClinkageEndStatement::numberOfNodes();
     count += SgVariableSymbol::numberOfNodes();
     count += SgFunctionTypeSymbol::numberOfNodes();
     count += SgClassSymbol::numberOfNodes();
     count += SgTemplateSymbol::numberOfNodes();
     count += SgEnumSymbol::numberOfNodes();
     count += SgEnumFieldSymbol::numberOfNodes();
     count += SgTypedefSymbol::numberOfNodes();
     count += SgMemberFunctionSymbol::numberOfNodes();
     count += SgLabelSymbol::numberOfNodes();
     count += SgDefaultSymbol::numberOfNodes();
     count += SgNamespaceSymbol::numberOfNodes();
     count += SgIntrinsicSymbol::numberOfNodes();
     count += SgModuleSymbol::numberOfNodes();
     count += SgInterfaceSymbol::numberOfNodes();
     count += SgCommonSymbol::numberOfNodes();
     count += SgToken::numberOfNodes();


     return count;
   }


#endif

