// Generates input groups.  Each input group contains a sequence of input values.  The input values are consumed by functions
// as they run.

#include "sage3basic.h"
#include "CloneDetectionLib.h"
#include "Combinatorics.h"
#include <cerrno>

using namespace CloneDetection;
std::string argv0;

static void
usage(int exit_status)
{
    std::cerr <<"usage: " <<argv0 <<" --ngroups=N [SWITCHES] [--] DATABASE GENERATORS_AND_FILTERS...\n"
              <<"  This command populates the specified database with input groups. Each input group contains the values\n"
              <<"  that will be consumed by a tested function whenever it needs an input value.\n"
              <<"\n"
              <<"    --ngroups=N\n"
              <<"            Generate N new input groups. Each input group contains a number of value queues from which\n"
              <<"            values are consumed as a function is tested.  The queues for each new group are initialized\n"
              <<"            by applying value generators in the order specified.\n"
              <<"    --collection[=ID]\n"
              <<"            This switch causes all input groups generated by this command to be placed in a single collection.\n"
              <<"            Without this switch, every input group is its own singleton collection.  When computing function\n"
              <<"            similarity, two output groups can be compared if they come from input groups that are part of the\n"
              <<"            same collection.  If no ID number is specified, then the ID of the first generated input group\n"
              <<"            serves as the ID number for the collection.\n"
              <<"    --default=QUEUE\n"
              <<"            All queues that are not defined initially redirect to the \"integer\" queue unless this switch\n"
              <<"            indicates some other queue.\n"
              <<"    --memhash=[MIN],[MAX],[SEED]\n"
              <<"            The \"memhash\" input value queue is usually used differently than the others: its first three\n"
              <<"            values are used to initialize all of virtual memory, and any attempt to consume values from the\n"
              <<"            queue instead returns the value from virtual memory.  The three-value queue can be initialized\n"
              <<"            with the generators and filters described below, but using the --memhash switch is more\n"
              <<"            convenient.  Any of its three values are optional, and trailing commas and equal can be omitted.\n"
              <<"            The full default form is just \"--memhash\", which is equivalent to \"memhash:reset=0,255\n"
              <<"            memhash:random=1\".\n"
              <<"\n"
              <<"  The following generators are understood. Each of these arguments is processed in the order it\n"
              <<"  occurs on the command line for each input group to be generated.\n"
              <<"    QUEUE:values=[V1,...]\n"
              <<"            The specified values are appended to the queue. Values can be specified in decimal, octal, or\n"
              <<"            hexadecimal using the usual C syntax.  Negative values are cast to 64-bit, 2's complement.\n"
              <<"    QUEUE:[re]set=[V1,...]\n"
              <<"            Same as the \"values\" generator except the queue is cleared first.\n"
              <<"    QUEUE:pad=N,VAL\n"
              <<"            Similar to the \"values\" generator, but appends N copies of VAL to the specified queue. If N is\n"
              <<"            the word \"infinite\" (or \"inf\") then an infinite number of values are added and subsequent\n"
              <<"            generators have no effect.\n"
              <<"    QUEUE:random=N,[MIN],[MAX],[SEED]\n"
              <<"            Generates N random values in the range MIN through MAX, inclusive, and appends them to specified\n"
              <<"            queue.  Each queue has its own random number generator whose seed is a function of the input\n"
              <<"            group ID and the queue ID. MIN and MAX are treated as unsigned values.\n"
              <<"    QUEUE:copy=[N],[IGROUP],[SRC_QUEUE]\n"
              <<"            Generates N values by copying them from the SRC_QUEUE of the specified input group.  If IGROUP\n"
              <<"            is not specified then the current input group is used; if IGROUP is negative it is an offset from\n"
              <<"            the current input group.  SRC_QUEUE defaults to QUEUE. If neither IGROUP nor SRC_QUEUE are\n"
              <<"            specified, then all current values of QUEUE in the current input group are appended again,\n"
              <<"            doubling the length of the queue.\n"
              <<"\n"
              <<"  The following arguments specify filters.  They act on the current input group in the order of specification\n"
              <<"  on the command line, even relative to the generators (i.e., it is possible to generate values, then filter\n"
              <<"  them, then generate more values).\n"
              <<"    QUEUE:permute=[N]\n"
              <<"            Permutes the first N values of the current input's specified queue. Permutations are numbered\n"
              <<"            from zero to N!-1; no attempt is made to remove permutations that are identical due to a\n"
              <<"            repeated value in the queue.  The permutation number is the input group ID modulo N!\n"
              <<"    QUEUE:shuffle=[N]\n"
              <<"            Randomly shuffles the first N values of the queue.\n"
              <<"    QUEUE:redirect=TO\n"
              <<"            Causes input requests for queue FROM to be redirected to queue TO.  This is different than\n"
              <<"            giving two queues the same values. Only one level of indirection is supported (i.e., it's possible\n"
              <<"            to swap two queues by redirecting each to the other, although I'm not sure of the utility).\n"
              <<"            The redirection occurs when a test is running, not when input groups are being generated.\n"
              <<"\n"
              <<"  In the descriptions above, optional arguments are indicated with square brackets and any combination of\n"
              <<"  optional arguments can be omitted as long as their position is indicated with the correct number of commas.\n"
              <<"  Trailing commas and equal sign can also be dropped (i.e., \"local:random=,,,\" can be written as\n"
              <<"  \"local:random\"). Unless noted otherwise in switch descriptions, the following defaults are used:\n"
              <<"    * N defaults to the number of values in the source queue, but not counting those that were added\n"
              <<"      with the pad generator with N=infinite.\n"
              <<"    * MIN defaults to zero.\n"
              <<"    * MAX defaults to 255.\n"
              <<"    * SEED defaults to a hash function whose input is the current group's ID number, the name of the\n"
              <<"      switch, and the number of previous switches with the same name.\n"
              <<"\n"
              <<"  The possible QUEUE names are (plural forms also allowed):\n"
              <<"    * \"local\" is used when a test needs a value for a local variable of the function being tested.  Local\n"
              <<"      variables are defined as those memory addresses that are on the stack but are less than the initial\n"
              <<"      stack pointer.\n"
              <<"    * \"argument\" is used when a test needs a value for an argument of the function being tested. Arguments\n"
              <<"      are defined as those memory addresses that are on the stack, but greater than or equal to the initial\n"
              <<"      stack pointer.\n"
              <<"    * \"global\" is used when a test needs a value for a global variable.  Global variables are defined as\n"
              <<"      those memory addresses that are mapped from the specimen or one of its dynamically linked libraries.\n"
              <<"    * \"function\" is used as the return value from functions that are treated as black boxes--those\n"
              <<"      functions that are skipped over instead of traversing into the function.\n"
              <<"    * \"pointer\" is used when a test needs a value for a variable for which none of the previous queues\n"
              <<"      apply and a pointer detection analysis has determined that the address stores a pointer.\n"
              <<"    * \"memhash\" is a special queue representing memory values that are a function of their address. This\n"
              <<"      queue is consulted if it was created created by the --memhash switch, and no previous queue applies,\n"
              <<"      and the address is one that is mapped from the specimen or its dynamic libraries.\n"
              <<"    * \"integer\" is the catch-all queue if no other queue applies.\n"
              <<"\n"
              <<" Example: To generate an infinite number of random pointer values where the first 100 have a 10% chance of\n"
              <<" being null pointers a 90% chance of being between 0x40000000 and 0x4000cffc, inclusive, and the remaining\n"
              <<" pointers are null, one would use the following generators and filters in this order:\n"
              <<"     --ngroups=1                               # Or however many you want\n"
              <<"     pointers:random=90,0x40000000,0x4000cffc  # The 90 non-null pointers\n"
              <<"     pointers:pad=10,0                         # The 10 null pointers\n"
              <<"     pointers:shuffle                          # shuffle all 100 of them\n"
              <<"     pointers:pad=infinite,0                   # add the infinite number of null pointers\n"
              <<" The two \"pad\" generators could have been combined and an N=100 supplied to the \"shuffle\" filter.\n"
              <<"\n"
              <<" Example: To generate all permutations of 5 integer inputs use the \"--ngroups=120\" switch (5! = 120) and\n"
              <<" the \"--collection\" switch and these generators and filters:\n"
              <<"     integers:random=5,,,12345                 # Generate 5 random values using a specific seed\n"
              <<"     integers:permute                          # Permutations; each is unique if the 5 values are unique.\n"
              <<"\n"
              <<"    DATABASE\n"
              <<"            The name of the database to which we are connecting.  For SQLite3 databases this is just a local\n"
              <<"            file name that will be created if it doesn't exist; for other database drivers this is a URL\n"
              <<"            containing the driver type and all necessary connection parameters.\n";
    exit(exit_status);
}

static SqlDatabase::TransactionPtr transaction;

InputQueueName parse_queuename(const std::string &name)
{
    if (0==name.compare("argument") || 0==name.compare("arguments")) {
        return IQ_ARGUMENT;
    } else if (0==name.compare("local") || 0==name.compare("locals")) {
        return IQ_LOCAL;
    } else if (0==name.compare("global") || 0==name.compare("globals")) {
        return IQ_GLOBAL;
    } else if (0==name.compare("function") || 0==name.compare("functions")) {
        return IQ_FUNCTION;
    } else if (0==name.compare("pointer") || 0==name.compare("pointers")) {
        return IQ_POINTER;
    } else if (0==name.compare("memhash")) {
        return IQ_MEMHASH;
    } else if (0==name.compare("integer") || 0==name.compare("integers")) {
        return IQ_INTEGER;
    } else {
        return IQ_NONE;
    }
}

typedef std::map<int/*igroup_id*/, InputGroup*> InputGroups;
static InputGroups igroup_cache;

// Return the input group with the specified ID, loading it from the database if necessary.
static InputGroup *
igroup(int igroup_id)
{
    InputGroups::iterator found = igroup_cache.find(igroup_id);
    if (found!=igroup_cache.end())
        return found->second;

    InputGroup *igroup = new InputGroup;
    if (!igroup->load(transaction, igroup_id)) {
        delete igroup;
        igroup_cache.insert(std::make_pair(igroup_id, (InputGroup*)0));
        return NULL;
    }

    igroup_cache.insert(std::make_pair(igroup_id, igroup));
    return igroup;
}

// Return the specified queue of the specified input group.
static InputQueue &
queue(int igroup_id, InputQueueName qn)
{
    InputGroup *ig = igroup(igroup_id);
    if (!ig)
        throw Exception("input group "+StringUtility::numberToString(igroup_id)+" does not exist");
    return ig->queue(qn);
}

// Parse a string as a 64-bit signed integer and cast to a 64-bit unsigned.
static uint64_t
parse_int(const std::string &str, bool allow_negative=true)
{
    const char *s=str.c_str();
    char *rest;
    errno = 0;
    uint64_t v = allow_negative ? (int64_t)strtoll(s, &rest, 0) : (int64_t)strtoull(s, &rest, 0);
    if (errno || rest==s)
        throw Exception("invalid queue value: "+str);
    while (isspace(*rest)) ++rest;
    if (*rest)
        throw Exception("invalid queue value: "+str);
    return v;
}

enum QueueModifierClass {
    VALUES_GENERATOR, RESET_GENERATOR, PADDING_GENERATOR, RANDOM_GENERATOR, COPY_GENERATOR,
    PERMUTE_FILTER, SHUFFLE_FILTER, REDIRECT_FILTER,
    N_MODIFIERS // must be last
};

static std::vector<size_t> instnum(N_MODIFIERS, 0);

// Base class for generators and filters
class QueueModifier {
public:
    QueueModifier(InputQueueName qn, QueueModifierClass class_seed)
        : queuename(qn), class_seed(class_seed), user_seed(0), user_seed_set(false) {
        assert((int)qn>=0 && (int)qn<N_MODIFIERS);
        instnum = ++::instnum[qn];
    }

    virtual ~QueueModifier() {}

    /** Restart the LCG. */
    void reseed(int igroup_id) {
        if (user_seed_set) {
            lcg.reseed(user_seed);
        } else {
            lcg.reseed(class_seed);
            lcg.reseed(lcg()+instnum);
            lcg.reseed(lcg()+igroup_id);
        }
    }

    /** Operate on the queue. */
    virtual void operator()(InputQueue &q, int igroup_id) = 0;

    InputQueueName queuename;                   // queue on which to operate
    LinearCongruentialGenerator lcg;            // source of random number sequences

    // These are inputs to the LCG seed value, not the seed itself
    uint64_t class_seed;                        // class number
    uint64_t instnum;                           // instance number within class
    uint64_t user_seed;                         // user-specified seed
    bool user_seed_set;
};

class ValuesGenerator: public QueueModifier {
public:
    ValuesGenerator(InputQueueName iq, const std::vector<std::string> args)
        : QueueModifier(iq, VALUES_GENERATOR) {
        for (size_t i=0; i<args.size(); ++i)
            values.push_back(parse_int(args[i]));
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        if (q.is_infinite())
            return;
        q.append_range(values.begin(), values.end());
    }

    std::vector<int64_t> values;
};

class ResetGenerator: public QueueModifier {
public:
    ResetGenerator(InputQueueName iq, const std::vector<std::string> args)
        : QueueModifier(iq, RESET_GENERATOR) {
        for (size_t i=0; i<args.size(); ++i)
            values.push_back(parse_int(args[i]));
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        InputQueueName dest = q.redirect();
        q.clear();
        q.redirect(dest);
        q.append_range(values.begin(), values.end());
    }

    std::vector<int64_t> values;
};

class PaddingGenerator: public QueueModifier {
public:
    PaddingGenerator(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, PADDING_GENERATOR), infinite(false), nvalues(0), value(0) {
        if (args.size()!=2)
            throw Exception("requires two arguments");
        if (0==args[0].compare("inf") || 0==args[0].compare("infinite") || 0==args[0].compare("infinity")) {
            infinite = true;
        } else {
            nvalues = parse_int(args[0], false);
        }
        value = parse_int(args[1]);
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        if (q.is_infinite())
            return;
        if (infinite) {
            q.pad(value);
        } else {
            q.append(value, nvalues);
        }
    }

    bool infinite;
    size_t nvalues;
    uint64_t value;
};

class RandomGenerator: public QueueModifier {
public:
    RandomGenerator(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, RANDOM_GENERATOR), nvalues(0), minval(0), maxval(255) {
        if (args.size()>4)
            throw Exception("too many arguments");
        if (args.size()<1)
            throw Exception("requires at least one argument");
        nvalues = parse_int(args[0], false);
        if (args.size()>=2 && !args[1].empty())
            minval = parse_int(args[1]);
        if (args.size()>=3 && !args[2].empty())
            maxval = parse_int(args[2]);
        if (args.size()>=4 && !args[3].empty()) {
            user_seed = parse_int(args[3]);
            user_seed_set = true;
        }
        if (minval>maxval)
            std::swap(minval, maxval);
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        if (q.is_infinite())
            return;
        assert(minval<=maxval);
        for (size_t i=0; i<nvalues; ++i) {
            int64_t val = minval + lcg() % (maxval+1-minval);
            q.append(val);
        }
    }

    size_t nvalues;
    uint64_t minval, maxval;
};

class CopyGenerator: public QueueModifier {
public:
    CopyGenerator(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, COPY_GENERATOR), src_igroup_id(-1), src_igroup_id_set(false), src_queuename(IQ_NONE),
          nvalues(0), nvalues_set(false) {
        if (args.size()>3)
            throw Exception("too many arguments");
        if (args.size()>=1 && !args[0].empty()) {
            nvalues = parse_int(args[0], false);
            nvalues_set = true;
        }
        if (args.size()>=2 && !args[1].empty()) {
            src_igroup_id = parse_int(args[1], false);
            src_igroup_id_set = true;
        }
        if (args.size()>=3 && !args[2].empty())
            src_queuename = parse_queuename(args[2]);
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        if (q.is_infinite())
            return;
        int src_igroup_id = src_igroup_id_set ?
                            (this->src_igroup_id<0 ? igroup_id+this->src_igroup_id : this->src_igroup_id) :
                            igroup_id;
        InputQueue &src = queue(src_igroup_id, src_queuename);
        size_t nvalues = nvalues_set ? this->nvalues : src.size();
        if (!src.has(nvalues))
            throw Exception("source queue does not have "+StringUtility::numberToString(nvalues)+" value"+(1==nvalues?"":"s"));
        for (size_t i=0; i<nvalues; ++i)
            q.append(src.get(i));
    }

    int src_igroup_id;
    bool src_igroup_id_set;
    InputQueueName src_queuename; // source and destination might be the same
    size_t nvalues;
    bool nvalues_set;
};

class PermuteFilter: public QueueModifier {
public:
    PermuteFilter(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, PERMUTE_FILTER), nvalues(0), nvalues_set(false) {
        if (args.size()>1)
            throw Exception("too many arguments");
        if (!args.empty()) {
            nvalues = parse_int(args[0], false);
            nvalues_set = true;
        }
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        size_t nvalues = nvalues_set ? this->nvalues : q.size();
        if (nvalues > q.size()) {
            if (q.is_infinite()) {
                q.extend(nvalues);
            } else {
                throw Exception("queue does not have "+StringUtility::numberToString(nvalues)+" value"+(1==nvalues?"":"s"));
            }
        }
        uint64_t pn = igroup_id % Combinatorics::factorial((uint64_t)nvalues);
        Combinatorics::permute(q.values(), pn, nvalues);
    }

    size_t nvalues;
    bool nvalues_set;
};

class ShuffleFilter: public QueueModifier {
public:
    ShuffleFilter(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, SHUFFLE_FILTER), nvalues(0), nvalues_set(false) {
        if (args.size()>1)
            throw Exception("too many arguments");
        if (!args.empty()) {
            nvalues = parse_int(args[0], false);
            nvalues_set = true;
        }
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        size_t nvalues = nvalues_set ? this->nvalues : q.size();
        if (nvalues > q.size()) {
            if (q.is_infinite()) {
                q.extend(nvalues);
            } else {
                throw Exception("queue does not have "+StringUtility::numberToString(nvalues)+" value"+(1==nvalues?"":"s"));
            }
        }
        for (size_t i=0; i<nvalues; ++i) {
            size_t j = lcg() % nvalues;
            std::swap(q.values()[i], q.values()[j]);
        }
    }

    size_t nvalues;
    bool nvalues_set;
};

class RedirectFilter: public QueueModifier {
public:
    RedirectFilter(InputQueueName qn, const std::vector<std::string> &args)
        : QueueModifier(qn, REDIRECT_FILTER), redirect_to(IQ_NONE) {
        if (1!=args.size())
            throw Exception("requires one argument");
        redirect_to = parse_queuename(args[0]);
    }

    virtual void operator()(InputQueue &q, int igroup_id) ROSE_OVERRIDE {
        if (redirect_to!=q.redirect() && q.redirect()!=queuename && q.redirect()!=IQ_NONE)
            throw Exception("queue is already redirected to "+InputGroup::queue_name(q.redirect()));
        q.redirect(redirect_to);
    }

    InputQueueName redirect_to;
};

typedef std::vector<QueueModifier*> QueueModifiers;

class Switches {
public:
    Switches()
        : ngroups(0), ngroups_set(false), collection_id(0), collection_id_set(false), single_collection(false),
          default_queue(IQ_INTEGER) {}
    size_t ngroups;
    bool ngroups_set;
    int collection_id;
    bool collection_id_set, single_collection;
    QueueModifiers queue_modifiers;
    InputQueueName default_queue;
};

int
main(int argc, char *argv[])
{
    std::ios::sync_with_stdio();
    argv0 = argv[0];
    {
        size_t slash = argv0.rfind('/');
        argv0 = slash==std::string::npos ? argv0 : argv0.substr(slash+1);
        if (0==argv0.substr(0, 3).compare("lt-"))
            argv0 = argv0.substr(3);
    }

    // Parse switches
    Switches opt;
    int argno = 1, ngenerators = 0;
    for (/*void*/; argno<argc && '-'==argv[argno][0]; ++argno) {
        if (!strcmp(argv[argno], "--")) {
            ++argno;
            break;
        } else if (!strcmp(argv[argno], "--help") || !strcmp(argv[argno], "-h")) {
            usage(0);
        } else if (!strncmp(argv[argno], "--ngroups=", 10)) {
            opt.ngroups = strtoul(argv[argno]+10, NULL, 0);
            opt.ngroups_set = true;
        } else if (!strcmp(argv[argno], "--collection")) {
            opt.single_collection = true;
        } else if (!strncmp(argv[argno], "--collection=", 13)) {
            opt.collection_id = strtoul(argv[argno]+13, NULL, 0);
            opt.collection_id_set = opt.single_collection = true;
        } else if (!strncmp(argv[argno], "--default=", 10)) {
            opt.default_queue = parse_queuename(argv[argno]+10);
        } else if (!strcmp(argv[argno], "--memhash") || !strncmp(argv[argno], "--memhash=", 10)) {
            std::string s;
            if (char *equal = strchr(argv[argno], '='))
                s = equal+1;
            std::vector<std::string> valargs = StringUtility::split(',', s, 3);
            valargs.resize(3);
            if (valargs[0].empty())
                valargs[0] = "0";
            if (valargs[1].empty())
                valargs[1] = "255";
            std::vector<std::string> randargs(1, "1");
            randargs.push_back(valargs[2]);
            valargs.pop_back();
            opt.queue_modifiers.push_back(new ValuesGenerator(IQ_MEMHASH, valargs));
            opt.queue_modifiers.push_back(new RandomGenerator(IQ_MEMHASH, randargs));
            ++ngenerators;
        } else {
            std::cerr <<argv0 <<": unrecognized switch: " <<argv[argno] <<"\n"
                      <<"see \"" <<argv0 <<" --help\" for usage info.\n";
            exit(1);
        }
    }
    if (!opt.ngroups_set) {
        std::cerr <<argv0 <<": missing --ngroups switch\n"
                  <<argv0 <<": see --help for more info\n";
        exit(1);
    }

    // Parse non-switch arguments (allow the database connection string to appear anywhere in this list since simplifies
    // the run-analysis.sh script.
    for (/*void*/; argno<argc; argno++) {
        std::vector<std::string> colon_parts = StringUtility::split(':', argv[argno], 2);
        InputQueueName qn = parse_queuename(colon_parts[0]);
        if (IQ_NONE!=qn && 2==colon_parts.size()) {
            std::vector<std::string> equal_parts = StringUtility::split('=', colon_parts[1], 2);
            std::string gname = equal_parts[0];
            std::vector<std::string> args;
            try {
                if (2==equal_parts.size())
                    args = StringUtility::split(',', equal_parts[1], (size_t)-1, true);
                if (0==gname.compare("values")) {
                    opt.queue_modifiers.push_back(new ValuesGenerator(qn, args));
                } else if (0==gname.compare("set") || 0==gname.compare("reset")) {
                    opt.queue_modifiers.push_back(new ResetGenerator(qn, args));
                } else if (0==gname.compare("pad")) {
                    opt.queue_modifiers.push_back(new PaddingGenerator(qn, args));
                    ++ngenerators;
                } else if (0==gname.compare("random")) {
                    opt.queue_modifiers.push_back(new RandomGenerator(qn, args));
                    ++ngenerators;
                } else if (0==gname.compare("copy")) {
                    opt.queue_modifiers.push_back(new CopyGenerator(qn, args));
                    ++ngenerators;
                } else if (0==gname.compare("permute")) {
                    opt.queue_modifiers.push_back(new PermuteFilter(qn, args));
                } else if (0==gname.compare("shuffle")) {
                    opt.queue_modifiers.push_back(new ShuffleFilter(qn, args));
                } else if (0==gname.compare("redirect")) {
                    opt.queue_modifiers.push_back(new RedirectFilter(qn, args));
                } else {
                    std::cerr <<argv0 <<": unknown generator or filter name: " <<gname <<"\n";
                    exit(1);
                }
            } catch (const Exception &e) {
                std::cerr <<argv0 <<": " <<argv[argno] <<": " <<e <<"\n";
                exit(1);
            }
        } else if (transaction==NULL) {
            transaction = SqlDatabase::Connection::create(argv[argno])->transaction();
        } else {
            std::cerr <<argv0 <<": unknown generator or filter: " <<argv[argno] <<"\n";
            exit(1);
        }
    }
    if (transaction==NULL) {
        std::cerr <<argv0 <<": missing database URL\n"
                  <<argv0 <<": see --help for more info\n";
        exit(1);
    }
    if (opt.queue_modifiers.empty()) {
        if (opt.ngroups>0) {
            std::cerr <<argv0 <<": no generators specified; all input groups would be empty\n";
            exit(1);
        } else {
            exit(0);
        }
    }

    // Get the list of queues that are affected.
    std::vector<int> queue_modified(IQ_NQUEUES, 0);
    for (size_t i=0; i<opt.queue_modifiers.size(); ++i)
        queue_modified[opt.queue_modifiers[i]->queuename] = 1;

    // Generate the inputs
    int64_t cmd_id = start_command(transaction, argc, argv, "generating input groups");
    int first_id = transaction->statement("select coalesce(max(igroup_id),-1)+1 from semantic_inputvalues")->execute_int();
    if (!opt.collection_id_set)
        opt.collection_id = first_id;
    Progress progress(opt.ngroups);
    for (size_t gi=0; gi<opt.ngroups; ++gi) {
        ++progress;
        int igroup_id = first_id + gi;
        InputGroup igroup;
        igroup.set_collection_id(opt.single_collection ? opt.collection_id : igroup_id);

        // All queues initialize redirect to the default queue.  If any generator or filter is applied, then
        // we don't do the default redirect.
        for (size_t qi=0; qi<IQ_NQUEUES; ++qi) {
            if (!queue_modified[qi])
                igroup.queue((InputQueueName)qi).redirect(opt.default_queue);
        }

        // Build the queues
        for (size_t qmi=0; qmi<opt.queue_modifiers.size(); ++qmi) {
            QueueModifier *qm = opt.queue_modifiers[qmi];
            qm->reseed(igroup_id);
            InputQueue &q = igroup.queue(qm->queuename);
            qm->operator()(q, igroup_id);
        }

        // Save all queues
        igroup.save(transaction, igroup_id, cmd_id);
    }
    progress.clear();

    std::string desc = "generated "+StringUtility::numberToString(opt.ngroups)+" input group"+(1==opt.ngroups?"":"s")+
                       " starting at "+StringUtility::numberToString(first_id);
    if (opt.ngroups>0) {
        finish_command(transaction, cmd_id, desc);
        transaction->commit();
    }

    std::cerr <<argv0 <<": " <<desc <<"\n";
    return 0;
}
